// Generated from ValkyrieAntlr.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use super::{valkyrieantlrlistener::*, valkyrieantlrvisitor::*};
use antlr_rust::{
    atn::{ATN, INVALID_ALT},
    atn_deserializer::ATNDeserializer,
    dfa::DFA,
    error_strategy::{DefaultErrorStrategy, ErrorStrategy},
    errors::*,
    int_stream::EOF,
    parser::{BaseParser, Parser, ParserNodeType, ParserRecog},
    parser_atn_simulator::ParserATNSimulator,
    parser_rule_context::{cast, cast_mut, BaseParserRuleContext, ParserRuleContext},
    recognizer::{Actions, Recognizer},
    rule_context::{BaseRuleContext, CustomRuleContext, RuleContext},
    token::{OwningToken, Token, TOKEN_EOF},
    token_factory::{CommonTokenFactory, TokenAware, TokenFactory},
    token_stream::TokenStream,
    tree::*,
    vocabulary::{Vocabulary, VocabularyImpl},
    PredictionContextCache, TokenSource,
};

use antlr_rust::{lazy_static, TidAble, TidExt};

use std::{
    any::{Any, TypeId},
    borrow::{Borrow, BorrowMut},
    cell::RefCell,
    convert::TryFrom,
    marker::PhantomData,
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::Arc,
};

pub const DOT: isize = 1;
pub const COMMA: isize = 2;
pub const SEMICOLON: isize = 3;
pub const FAKE_COLON: isize = 4;
pub const OP_PROPORTION: isize = 5;
pub const COLON: isize = 6;
pub const PARENTHESES_L: isize = 7;
pub const PARENTHESES_R: isize = 8;
pub const BRACKET_L: isize = 9;
pub const BRACKET_R: isize = 10;
pub const BRACE_L: isize = 11;
pub const BRACE_R: isize = 12;
pub const GENERIC_L: isize = 13;
pub const GENERIC_R: isize = 14;
pub const OFFSET_L: isize = 15;
pub const OFFSET_R: isize = 16;
pub const RANGE_L: isize = 17;
pub const RANGE_R: isize = 18;
pub const CEILING_L: isize = 19;
pub const CEILING_R: isize = 20;
pub const FLOOR_L: isize = 21;
pub const FLOOR_R: isize = 22;
pub const COLLECTION_L: isize = 23;
pub const COLLECTION_R: isize = 24;
pub const OP_ADD: isize = 25;
pub const OP_INC: isize = 26;
pub const OP_SUB: isize = 27;
pub const OP_DEC: isize = 28;
pub const OP_MUL: isize = 29;
pub const OP_DIV: isize = 30;
pub const OP_DIV_REM: isize = 31;
pub const OP_EQ: isize = 32;
pub const OP_NE: isize = 33;
pub const OP_NEE: isize = 34;
pub const OP_EEE: isize = 35;
pub const OP_LEQ: isize = 36;
pub const OP_LLE: isize = 37;
pub const OP_LLL: isize = 38;
pub const OP_LL: isize = 39;
pub const OP_LT: isize = 40;
pub const OP_GEQ: isize = 41;
pub const OP_GGE: isize = 42;
pub const OP_GGG: isize = 43;
pub const OP_GG: isize = 44;
pub const OP_GT: isize = 45;
pub const OP_LEFT: isize = 46;
pub const OP_ARROW: isize = 47;
pub const OP_ARROW2: isize = 48;
pub const OP_ASSIGN: isize = 49;
pub const OP_BIND: isize = 50;
pub const OP_MAY_ASSIGN: isize = 51;
pub const OP_ADD_ASSIGN: isize = 52;
pub const OP_SUB_ASSIGN: isize = 53;
pub const OP_MUL_ASSIGN: isize = 54;
pub const OP_DIV_ASSIGN: isize = 55;
pub const LOGIC_NOT: isize = 56;
pub const LOGIC_AND: isize = 57;
pub const LOGIC_XAND: isize = 58;
pub const LOGIC_NAND: isize = 59;
pub const LOGIC_OR: isize = 60;
pub const LOGIC_XOR: isize = 61;
pub const LOGIC_NOR: isize = 62;
pub const SET_INTERSECTION: isize = 63;
pub const SET_UNION: isize = 64;
pub const OP_AND: isize = 65;
pub const OP_OR: isize = 66;
pub const OP_XOR: isize = 67;
pub const OP_IMPL: isize = 68;
pub const OP_IFF: isize = 69;
pub const OP_AT: isize = 70;
pub const OP_HASH: isize = 71;
pub const LAMBDA_SLOT: isize = 72;
pub const MACRO_SLOT: isize = 73;
pub const OP_UNIMPLEMENTED: isize = 74;
pub const OP_OR_ELSE: isize = 75;
pub const OP_THROW: isize = 76;
pub const OP_NOT: isize = 77;
pub const KW_NOT: isize = 78;
pub const OP_IN: isize = 79;
pub const KW_IN: isize = 80;
pub const OP_NOT_IN: isize = 81;
pub const OP_CONTINUES: isize = 82;
pub const KW_IS: isize = 83;
pub const OP_IS: isize = 84;
pub const OP_IS_NOT: isize = 85;
pub const KW_AS: isize = 86;
pub const OP_DECONSTRUCT: isize = 87;
pub const OP_UNTIL: isize = 88;
pub const OP_POW: isize = 89;
pub const OP_INVERSE: isize = 90;
pub const OP_ROOTS: isize = 91;
pub const OP_TEMPERATURE: isize = 92;
pub const OP_TRANSPOSE: isize = 93;
pub const OP_PERCENT: isize = 94;
pub const OP_REFERENCE: isize = 95;
pub const OP_LABEL: isize = 96;
pub const KW_NAMESPACE: isize = 97;
pub const KW_IMPORT: isize = 98;
pub const KW_EXTENSION: isize = 99;
pub const KW_CLASS: isize = 100;
pub const KW_TRAIT: isize = 101;
pub const KW_UNION: isize = 102;
pub const KW_BITFLAGS: isize = 103;
pub const KW_TYPE: isize = 104;
pub const KW_TEMPLATE: isize = 105;
pub const KW_EXTENDS: isize = 106;
pub const KW_IMPLEMENTS: isize = 107;
pub const KW_WHERE: isize = 108;
pub const KW_WHILE: isize = 109;
pub const KW_FOR: isize = 110;
pub const KW_LET: isize = 111;
pub const KW_WITCH: isize = 112;
pub const KW_NEW: isize = 113;
pub const KW_OBJECT: isize = 114;
pub const KW_LAMBDA: isize = 115;
pub const KW_FUNCTION: isize = 116;
pub const KW_TRY: isize = 117;
pub const KW_MATCH: isize = 118;
pub const KW_CATCH: isize = 119;
pub const KW_WITH: isize = 120;
pub const KW_CASE: isize = 121;
pub const KW_WHEN: isize = 122;
pub const INTEGER: isize = 123;
pub const DECIMAL: isize = 124;
pub const STRING_SINGLE: isize = 125;
pub const STRING_DOUBLE: isize = 126;
pub const STRING_BLOCK: isize = 127;
pub const KW_IF: isize = 128;
pub const KW_ELSE: isize = 129;
pub const KW_OTHERWISE: isize = 130;
pub const RETURN: isize = 131;
pub const RESUME: isize = 132;
pub const YIELD: isize = 133;
pub const BREAK: isize = 134;
pub const CONTINUE: isize = 135;
pub const RAISE: isize = 136;
pub const SPECIAL: isize = 137;
pub const RAW_ID: isize = 138;
pub const UNICODE_ID: isize = 139;
pub const LINE_COMMENT: isize = 140;
pub const BLOCK_COMMENT: isize = 141;
pub const WHITE_SPACE: isize = 142;
pub const ERROR_CHARACTAR: isize = 143;
pub const RULE_program: usize = 0;
pub const RULE_top_statement: usize = 1;
pub const RULE_eos: usize = 2;
pub const RULE_eos_free: usize = 3;
pub const RULE_define_namespace: usize = 4;
pub const RULE_import_statement: usize = 5;
pub const RULE_import_as: usize = 6;
pub const RULE_import_term: usize = 7;
pub const RULE_import_name: usize = 8;
pub const RULE_import_block: usize = 9;
pub const RULE_define_extension: usize = 10;
pub const RULE_define_class: usize = 11;
pub const RULE_class_block: usize = 12;
pub const RULE_class_inherit: usize = 13;
pub const RULE_class_inherit_item: usize = 14;
pub const RULE_class_field: usize = 15;
pub const RULE_class_method: usize = 16;
pub const RULE_class_dsl: usize = 17;
pub const RULE_define_trait: usize = 18;
pub const RULE_trait_block: usize = 19;
pub const RULE_define_trait_type: usize = 20;
pub const RULE_define_extends: usize = 21;
pub const RULE_with_implements: usize = 22;
pub const RULE_define_union: usize = 23;
pub const RULE_base_layout: usize = 24;
pub const RULE_union_block: usize = 25;
pub const RULE_define_variant: usize = 26;
pub const RULE_variant_block: usize = 27;
pub const RULE_define_bitflags: usize = 28;
pub const RULE_bitflags_block: usize = 29;
pub const RULE_bitflags_item: usize = 30;
pub const RULE_define_function: usize = 31;
pub const RULE_function_parameters: usize = 32;
pub const RULE_parameter_item: usize = 33;
pub const RULE_parameter_default: usize = 34;
pub const RULE_function_call: usize = 35;
pub const RULE_dot_call: usize = 36;
pub const RULE_tuple_call_body: usize = 37;
pub const RULE_tuple_call_item: usize = 38;
pub const RULE_define_lambda: usize = 39;
pub const RULE_lambda_call: usize = 40;
pub const RULE_function_block: usize = 41;
pub const RULE_function_statement: usize = 42;
pub const RULE_let_binding: usize = 43;
pub const RULE_let_pattern: usize = 44;
pub const RULE_let_pattern_plain: usize = 45;
pub const RULE_let_pattern_tuple: usize = 46;
pub const RULE_let_pattern_item: usize = 47;
pub const RULE_define_type: usize = 48;
pub const RULE_type_hint: usize = 49;
pub const RULE_effect_hint: usize = 50;
pub const RULE_if_statement: usize = 51;
pub const RULE_if_let_statement: usize = 52;
pub const RULE_else_if_statement: usize = 53;
pub const RULE_loop_statement: usize = 54;
pub const RULE_if_guard: usize = 55;
pub const RULE_expression_root: usize = 56;
pub const RULE_expression: usize = 57;
pub const RULE_term_with_follow: usize = 58;
pub const RULE_inline_expression: usize = 59;
pub const RULE_type_expression: usize = 60;
pub const RULE_atomic: usize = 61;
pub const RULE_op_prefix: usize = 62;
pub const RULE_op_suffix: usize = 63;
pub const RULE_control_expression: usize = 64;
pub const RULE_op_compare: usize = 65;
pub const RULE_op_pattern: usize = 66;
pub const RULE_infix_arrows: usize = 67;
pub const RULE_op_multiple: usize = 68;
pub const RULE_op_plus: usize = 69;
pub const RULE_op_logic: usize = 70;
pub const RULE_op_pipeline: usize = 71;
pub const RULE_op_assign: usize = 72;
pub const RULE_infix_is: usize = 73;
pub const RULE_infix_in: usize = 74;
pub const RULE_define_generic: usize = 75;
pub const RULE_generic_item: usize = 76;
pub const RULE_generic_call: usize = 77;
pub const RULE_generic_call_in_type: usize = 78;
pub const RULE_generic_pair: usize = 79;
pub const RULE_define_label: usize = 80;
pub const RULE_offset_call: usize = 81;
pub const RULE_template_call: usize = 82;
pub const RULE_template_block: usize = 83;
pub const RULE_template_statements: usize = 84;
pub const RULE_where_block: usize = 85;
pub const RULE_where_bound: usize = 86;
pub const RULE_macro_call: usize = 87;
pub const RULE_annotation: usize = 88;
pub const RULE_annotation_call_item: usize = 89;
pub const RULE_try_statement: usize = 90;
pub const RULE_match_statement: usize = 91;
pub const RULE_match_call: usize = 92;
pub const RULE_match_block: usize = 93;
pub const RULE_match_terms: usize = 94;
pub const RULE_match_case_block: usize = 95;
pub const RULE_case_pattern: usize = 96;
pub const RULE_case_pattern_item: usize = 97;
pub const RULE_case_pattern_tuple: usize = 98;
pub const RULE_object_statement: usize = 99;
pub const RULE_new_statement: usize = 100;
pub const RULE_new_body: usize = 101;
pub const RULE_new_block: usize = 102;
pub const RULE_tuple_literal: usize = 103;
pub const RULE_collection_pair: usize = 104;
pub const RULE_slice_call: usize = 105;
pub const RULE_range_literal: usize = 106;
pub const RULE_range_axis: usize = 107;
pub const RULE_range_start: usize = 108;
pub const RULE_range_end: usize = 109;
pub const RULE_range_step: usize = 110;
pub const RULE_modifiers: usize = 111;
pub const RULE_modified_identifier: usize = 112;
pub const RULE_modified_namepath: usize = 113;
pub const RULE_lambda_name: usize = 114;
pub const RULE_function_name: usize = 115;
pub const RULE_namepath_free: usize = 116;
pub const RULE_namepath: usize = 117;
pub const RULE_identifier: usize = 118;
pub const RULE_number: usize = 119;
pub const RULE_number_literal: usize = 120;
pub const RULE_string: usize = 121;
pub const RULE_string_literal: usize = 122;
pub const ruleNames: [&'static str; 123] = [
    "program",
    "top_statement",
    "eos",
    "eos_free",
    "define_namespace",
    "import_statement",
    "import_as",
    "import_term",
    "import_name",
    "import_block",
    "define_extension",
    "define_class",
    "class_block",
    "class_inherit",
    "class_inherit_item",
    "class_field",
    "class_method",
    "class_dsl",
    "define_trait",
    "trait_block",
    "define_trait_type",
    "define_extends",
    "with_implements",
    "define_union",
    "base_layout",
    "union_block",
    "define_variant",
    "variant_block",
    "define_bitflags",
    "bitflags_block",
    "bitflags_item",
    "define_function",
    "function_parameters",
    "parameter_item",
    "parameter_default",
    "function_call",
    "dot_call",
    "tuple_call_body",
    "tuple_call_item",
    "define_lambda",
    "lambda_call",
    "function_block",
    "function_statement",
    "let_binding",
    "let_pattern",
    "let_pattern_plain",
    "let_pattern_tuple",
    "let_pattern_item",
    "define_type",
    "type_hint",
    "effect_hint",
    "if_statement",
    "if_let_statement",
    "else_if_statement",
    "loop_statement",
    "if_guard",
    "expression_root",
    "expression",
    "term_with_follow",
    "inline_expression",
    "type_expression",
    "atomic",
    "op_prefix",
    "op_suffix",
    "control_expression",
    "op_compare",
    "op_pattern",
    "infix_arrows",
    "op_multiple",
    "op_plus",
    "op_logic",
    "op_pipeline",
    "op_assign",
    "infix_is",
    "infix_in",
    "define_generic",
    "generic_item",
    "generic_call",
    "generic_call_in_type",
    "generic_pair",
    "define_label",
    "offset_call",
    "template_call",
    "template_block",
    "template_statements",
    "where_block",
    "where_bound",
    "macro_call",
    "annotation",
    "annotation_call_item",
    "try_statement",
    "match_statement",
    "match_call",
    "match_block",
    "match_terms",
    "match_case_block",
    "case_pattern",
    "case_pattern_item",
    "case_pattern_tuple",
    "object_statement",
    "new_statement",
    "new_body",
    "new_block",
    "tuple_literal",
    "collection_pair",
    "slice_call",
    "range_literal",
    "range_axis",
    "range_start",
    "range_end",
    "range_step",
    "modifiers",
    "modified_identifier",
    "modified_namepath",
    "lambda_name",
    "function_name",
    "namepath_free",
    "namepath",
    "identifier",
    "number",
    "number_literal",
    "string",
    "string_literal",
];

pub const _LITERAL_NAMES: [Option<&'static str>; 137] = [
    None,
    Some("'.'"),
    None,
    Some("';'"),
    None,
    None,
    None,
    Some("'('"),
    Some("')'"),
    Some("'['"),
    Some("']'"),
    Some("'{'"),
    Some("'}'"),
    Some("'\u{27E8}'"),
    Some("'\u{27E9}'"),
    Some("'\u{2045}'"),
    Some("'\u{2046}'"),
    Some("'\u{27E6}'"),
    Some("'\u{27E7}'"),
    Some("'\u{2308}'"),
    Some("'\u{2309}'"),
    Some("'\u{230A}'"),
    Some("'\u{230B}'"),
    Some("'\u{2983}'"),
    Some("'\u{2984}'"),
    Some("'+'"),
    Some("'++'"),
    Some("'-'"),
    Some("'--'"),
    Some("'*'"),
    Some("'/'"),
    None,
    Some("'=='"),
    None,
    None,
    None,
    None,
    Some("'<<='"),
    None,
    None,
    Some("'<'"),
    None,
    Some("'>>='"),
    None,
    None,
    Some("'>'"),
    None,
    None,
    None,
    Some("'='"),
    None,
    Some("'?='"),
    Some("'+='"),
    Some("'-='"),
    Some("'*='"),
    Some("'/='"),
    Some("'\u{00AC}'"),
    None,
    Some("'\u{2A5F}'"),
    Some("'\u{22BC}'"),
    None,
    Some("'\u{22BB}'"),
    Some("'\u{22BD}'"),
    Some("'\u{2229}'"),
    Some("'\u{222A}'"),
    Some("'&'"),
    Some("'|'"),
    Some("'\u{2295}'"),
    Some("'\u{203D}'"),
    Some("'\u{21D4}'"),
    Some("'@'"),
    None,
    None,
    None,
    None,
    Some("'?:'"),
    Some("'?'"),
    Some("'!'"),
    Some("'not'"),
    None,
    Some("'in'"),
    Some("'\u{2209}'"),
    None,
    Some("'is'"),
    None,
    None,
    None,
    None,
    None,
    Some("'^'"),
    Some("'\u{215F}'"),
    None,
    None,
    None,
    None,
    Some("'\u{203B}'"),
    Some("'\u{00B6}'"),
    None,
    None,
    Some("'extension'"),
    None,
    None,
    Some("'union'"),
    Some("'flags'"),
    Some("'type'"),
    None,
    None,
    Some("'implement'"),
    Some("'where'"),
    None,
    Some("'for'"),
    Some("'let'"),
    Some("'which'"),
    Some("'new'"),
    Some("'object'"),
    Some("'lambda'"),
    None,
    Some("'try'"),
    Some("'match'"),
    Some("'catch'"),
    Some("'with'"),
    Some("'case'"),
    Some("'when'"),
    None,
    None,
    None,
    None,
    None,
    Some("'if'"),
    Some("'else'"),
    Some("'otherwise'"),
    Some("'return'"),
    Some("'resume'"),
    Some("'yield'"),
    Some("'break'"),
    Some("'continue'"),
    Some("'raise'"),
];
pub const _SYMBOLIC_NAMES: [Option<&'static str>; 144] = [
    None,
    Some("DOT"),
    Some("COMMA"),
    Some("SEMICOLON"),
    Some("FAKE_COLON"),
    Some("OP_PROPORTION"),
    Some("COLON"),
    Some("PARENTHESES_L"),
    Some("PARENTHESES_R"),
    Some("BRACKET_L"),
    Some("BRACKET_R"),
    Some("BRACE_L"),
    Some("BRACE_R"),
    Some("GENERIC_L"),
    Some("GENERIC_R"),
    Some("OFFSET_L"),
    Some("OFFSET_R"),
    Some("RANGE_L"),
    Some("RANGE_R"),
    Some("CEILING_L"),
    Some("CEILING_R"),
    Some("FLOOR_L"),
    Some("FLOOR_R"),
    Some("COLLECTION_L"),
    Some("COLLECTION_R"),
    Some("OP_ADD"),
    Some("OP_INC"),
    Some("OP_SUB"),
    Some("OP_DEC"),
    Some("OP_MUL"),
    Some("OP_DIV"),
    Some("OP_DIV_REM"),
    Some("OP_EQ"),
    Some("OP_NE"),
    Some("OP_NEE"),
    Some("OP_EEE"),
    Some("OP_LEQ"),
    Some("OP_LLE"),
    Some("OP_LLL"),
    Some("OP_LL"),
    Some("OP_LT"),
    Some("OP_GEQ"),
    Some("OP_GGE"),
    Some("OP_GGG"),
    Some("OP_GG"),
    Some("OP_GT"),
    Some("OP_LEFT"),
    Some("OP_ARROW"),
    Some("OP_ARROW2"),
    Some("OP_ASSIGN"),
    Some("OP_BIND"),
    Some("OP_MAY_ASSIGN"),
    Some("OP_ADD_ASSIGN"),
    Some("OP_SUB_ASSIGN"),
    Some("OP_MUL_ASSIGN"),
    Some("OP_DIV_ASSIGN"),
    Some("LOGIC_NOT"),
    Some("LOGIC_AND"),
    Some("LOGIC_XAND"),
    Some("LOGIC_NAND"),
    Some("LOGIC_OR"),
    Some("LOGIC_XOR"),
    Some("LOGIC_NOR"),
    Some("SET_INTERSECTION"),
    Some("SET_UNION"),
    Some("OP_AND"),
    Some("OP_OR"),
    Some("OP_XOR"),
    Some("OP_IMPL"),
    Some("OP_IFF"),
    Some("OP_AT"),
    Some("OP_HASH"),
    Some("LAMBDA_SLOT"),
    Some("MACRO_SLOT"),
    Some("OP_UNIMPLEMENTED"),
    Some("OP_OR_ELSE"),
    Some("OP_THROW"),
    Some("OP_NOT"),
    Some("KW_NOT"),
    Some("OP_IN"),
    Some("KW_IN"),
    Some("OP_NOT_IN"),
    Some("OP_CONTINUES"),
    Some("KW_IS"),
    Some("OP_IS"),
    Some("OP_IS_NOT"),
    Some("KW_AS"),
    Some("OP_DECONSTRUCT"),
    Some("OP_UNTIL"),
    Some("OP_POW"),
    Some("OP_INVERSE"),
    Some("OP_ROOTS"),
    Some("OP_TEMPERATURE"),
    Some("OP_TRANSPOSE"),
    Some("OP_PERCENT"),
    Some("OP_REFERENCE"),
    Some("OP_LABEL"),
    Some("KW_NAMESPACE"),
    Some("KW_IMPORT"),
    Some("KW_EXTENSION"),
    Some("KW_CLASS"),
    Some("KW_TRAIT"),
    Some("KW_UNION"),
    Some("KW_BITFLAGS"),
    Some("KW_TYPE"),
    Some("KW_TEMPLATE"),
    Some("KW_EXTENDS"),
    Some("KW_IMPLEMENTS"),
    Some("KW_WHERE"),
    Some("KW_WHILE"),
    Some("KW_FOR"),
    Some("KW_LET"),
    Some("KW_WITCH"),
    Some("KW_NEW"),
    Some("KW_OBJECT"),
    Some("KW_LAMBDA"),
    Some("KW_FUNCTION"),
    Some("KW_TRY"),
    Some("KW_MATCH"),
    Some("KW_CATCH"),
    Some("KW_WITH"),
    Some("KW_CASE"),
    Some("KW_WHEN"),
    Some("INTEGER"),
    Some("DECIMAL"),
    Some("STRING_SINGLE"),
    Some("STRING_DOUBLE"),
    Some("STRING_BLOCK"),
    Some("KW_IF"),
    Some("KW_ELSE"),
    Some("KW_OTHERWISE"),
    Some("RETURN"),
    Some("RESUME"),
    Some("YIELD"),
    Some("BREAK"),
    Some("CONTINUE"),
    Some("RAISE"),
    Some("SPECIAL"),
    Some("RAW_ID"),
    Some("UNICODE_ID"),
    Some("LINE_COMMENT"),
    Some("BLOCK_COMMENT"),
    Some("WHITE_SPACE"),
    Some("ERROR_CHARACTAR"),
];
lazy_static! {
    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
    static ref VOCABULARY: Box<dyn Vocabulary> =
        Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
}

type BaseParserType<'input, I> = BaseParser<
    'input,
    ValkyrieAntlrParserExt<'input>,
    I,
    ValkyrieAntlrParserContextType,
    dyn ValkyrieAntlrListener<'input> + 'input,
>;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type ValkyrieAntlrTreeWalker<'input, 'a> =
    ParseTreeWalker<'input, 'a, ValkyrieAntlrParserContextType, dyn ValkyrieAntlrListener<'input> + 'a>;

/// Parser for ValkyrieAntlr grammar
pub struct ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    base: BaseParserType<'input, I>,
    interpreter: Arc<ParserATNSimulator>,
    _shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn get_serialized_atn() -> &'static str {
        _serializedATN
    }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
        antlr_rust::recognizer::check_version("0", "3");
        let interpreter =
            Arc::new(ParserATNSimulator::new(_ATN.clone(), _decision_to_DFA.clone(), _shared_context_cache.clone()));
        Self {
            base: BaseParser::new_base_parser(
                input,
                Arc::clone(&interpreter),
                ValkyrieAntlrParserExt { _pd: Default::default() },
            ),
            interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }
}

type DynStrategy<'input, I> = Box<dyn ErrorStrategy<'input, BaseParserType<'input, I>> + 'input>;

impl<'input, I> ValkyrieAntlrParser<'input, I, DynStrategy<'input, I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self {
        Self::with_strategy(input, Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn new(input: I) -> Self {
        Self::with_strategy(input, DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for ValkyrieAntlrParser
pub trait ValkyrieAntlrParserContext<'input>:
    for<'x> Listenable<dyn ValkyrieAntlrListener<'input> + 'x>
    + for<'x> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'x>
    + ParserRuleContext<'input, TF = LocalTokenFactory<'input>, Ctx = ValkyrieAntlrParserContextType>
{
}

antlr_rust::coerce_from! { 'input : ValkyrieAntlrParserContext<'input> }

impl<'input, 'x, T> VisitableDyn<T> for dyn ValkyrieAntlrParserContext<'input> + 'input
where
    T: ValkyrieAntlrVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn ValkyrieAntlrVisitor<'input> + 'x))
    }
}

impl<'input> ValkyrieAntlrParserContext<'input> for TerminalNode<'input, ValkyrieAntlrParserContextType> {}
impl<'input> ValkyrieAntlrParserContext<'input> for ErrorNode<'input, ValkyrieAntlrParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrListener<'input> + 'input }

pub struct ValkyrieAntlrParserContextType;
antlr_rust::tid! {ValkyrieAntlrParserContextType}

impl<'input> ParserNodeType<'input> for ValkyrieAntlrParserContextType {
    type TF = LocalTokenFactory<'input>;
    type Type = dyn ValkyrieAntlrParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    type Target = BaseParserType<'input, I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct ValkyrieAntlrParserExt<'input> {
    _pd: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserExt<'input> {}
antlr_rust::tid! { ValkyrieAntlrParserExt<'a> }

impl<'input> TokenAware<'input> for ValkyrieAntlrParserExt<'input> {
    type TF = LocalTokenFactory<'input>;
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    ParserRecog<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    Actions<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
    fn get_grammar_file_name(&self) -> &str {
        "ValkyrieAntlr.g4"
    }

    fn get_rule_names(&self) -> &[&str] {
        &ruleNames
    }

    fn get_vocabulary(&self) -> &dyn Vocabulary {
        &**VOCABULARY
    }
    fn sempred(
        _localctx: Option<&(dyn ValkyrieAntlrParserContext<'input> + 'input)>,
        rule_index: isize,
        pred_index: isize,
        recog: &mut BaseParserType<'input, I>,
    ) -> bool {
        match rule_index {
            57 => ValkyrieAntlrParser::<'input, I, _>::expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            59 => ValkyrieAntlrParser::<'input, I, _>::inline_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            60 => ValkyrieAntlrParser::<'input, I, _>::type_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            96 => ValkyrieAntlrParser::<'input, I, _>::case_pattern_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            _ => true,
        }
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    fn expression_sempred(
        _localctx: Option<&ExpressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            0 => recog.precpred(None, 24),
            1 => recog.precpred(None, 23),
            2 => recog.precpred(None, 22),
            3 => recog.precpred(None, 21),
            4 => recog.precpred(None, 20),
            5 => recog.precpred(None, 19),
            6 => recog.precpred(None, 16),
            7 => recog.precpred(None, 18),
            8 => recog.precpred(None, 17),
            9 => recog.precpred(None, 15),
            10 => recog.precpred(None, 14),
            11 => recog.precpred(None, 13),
            12 => recog.precpred(None, 12),
            13 => recog.precpred(None, 11),
            14 => recog.precpred(None, 10),
            15 => recog.precpred(None, 9),
            16 => recog.precpred(None, 8),
            17 => recog.precpred(None, 7),
            18 => recog.precpred(None, 6),
            19 => recog.precpred(None, 5),
            _ => true,
        }
    }
    fn inline_expression_sempred(
        _localctx: Option<&Inline_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            20 => recog.precpred(None, 11),
            21 => recog.precpred(None, 10),
            22 => recog.precpred(None, 9),
            23 => recog.precpred(None, 8),
            24 => recog.precpred(None, 7),
            25 => recog.precpred(None, 6),
            26 => recog.precpred(None, 5),
            27 => recog.precpred(None, 4),
            28 => recog.precpred(None, 3),
            _ => true,
        }
    }
    fn type_expression_sempred(
        _localctx: Option<&Type_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            29 => recog.precpred(None, 6),
            30 => recog.precpred(None, 5),
            31 => recog.precpred(None, 4),
            32 => recog.precpred(None, 3),
            _ => true,
        }
    }
    fn case_pattern_sempred(
        _localctx: Option<&Case_patternContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            33 => recog.precpred(None, 3),
            34 => recog.precpred(None, 2),
            _ => true,
        }
    }
}
//------------------- program ----------------
pub type ProgramContextAll<'input> = ProgramContext<'input>;

pub type ProgramContext<'input> = BaseParserRuleContext<'input, ProgramContextExt<'input>>;

#[derive(Clone)]
pub struct ProgramContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ProgramContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ProgramContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_program(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_program(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ProgramContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_program(self);
    }
}

impl<'input> CustomRuleContext<'input> for ProgramContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_program
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_program }
}
antlr_rust::tid! {ProgramContextExt<'a>}

impl<'input> ProgramContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ProgramContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, ProgramContextExt { ph: PhantomData }))
    }
}

pub trait ProgramContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ProgramContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
    fn top_statement_all(&self) -> Vec<Rc<Top_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn top_statement(&self, i: usize) -> Option<Rc<Top_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_all(&self) -> Vec<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos(&self, i: usize) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ProgramContextAttrs<'input> for ProgramContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn program(&mut self) -> Result<Rc<ProgramContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ProgramContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_program);
        let mut _localctx: Rc<ProgramContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(250);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << SEMICOLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << OFFSET_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 65) & !0x3f) == 0
                        && ((1usize << (_la - 65))
                            & ((1usize << (OP_AND - 65))
                                | (1usize << (OP_AT - 65))
                                | (1usize << (OP_HASH - 65))
                                | (1usize << (LAMBDA_SLOT - 65))
                                | (1usize << (OP_THROW - 65))
                                | (1usize << (OP_NOT - 65))
                                | (1usize << (OP_DECONSTRUCT - 65))
                                | (1usize << (OP_INVERSE - 65))
                                | (1usize << (OP_ROOTS - 65))
                                | (1usize << (OP_REFERENCE - 65))
                                | (1usize << (OP_LABEL - 65))))
                            != 0)
                    || (((_la - 97) & !0x3f) == 0
                        && ((1usize << (_la - 97))
                            & ((1usize << (KW_NAMESPACE - 97))
                                | (1usize << (KW_IMPORT - 97))
                                | (1usize << (KW_EXTENSION - 97))
                                | (1usize << (KW_CLASS - 97))
                                | (1usize << (KW_TRAIT - 97))
                                | (1usize << (KW_UNION - 97))
                                | (1usize << (KW_BITFLAGS - 97))
                                | (1usize << (KW_TYPE - 97))
                                | (1usize << (KW_TEMPLATE - 97))
                                | (1usize << (KW_EXTENDS - 97))
                                | (1usize << (KW_WHILE - 97))
                                | (1usize << (KW_FOR - 97))
                                | (1usize << (KW_LET - 97))
                                | (1usize << (KW_NEW - 97))
                                | (1usize << (KW_OBJECT - 97))
                                | (1usize << (KW_LAMBDA - 97))
                                | (1usize << (KW_FUNCTION - 97))
                                | (1usize << (KW_TRY - 97))
                                | (1usize << (KW_MATCH - 97))
                                | (1usize << (KW_CATCH - 97))
                                | (1usize << (INTEGER - 97))
                                | (1usize << (DECIMAL - 97))
                                | (1usize << (STRING_SINGLE - 97))
                                | (1usize << (STRING_DOUBLE - 97))
                                | (1usize << (STRING_BLOCK - 97))
                                | (1usize << (KW_IF - 97))))
                            != 0)
                    || (((_la - 131) & !0x3f) == 0
                        && ((1usize << (_la - 131))
                            & ((1usize << (RETURN - 131))
                                | (1usize << (RESUME - 131))
                                | (1usize << (YIELD - 131))
                                | (1usize << (BREAK - 131))
                                | (1usize << (CONTINUE - 131))
                                | (1usize << (RAISE - 131))
                                | (1usize << (SPECIAL - 131))
                                | (1usize << (RAW_ID - 131))
                                | (1usize << (UNICODE_ID - 131))))
                            != 0)
                {
                    {
                        recog.base.set_state(248);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | OFFSET_L | OP_ADD | OP_SUB | OP_MUL | OP_AND | OP_AT | OP_HASH
                            | LAMBDA_SLOT | OP_THROW | OP_NOT | OP_DECONSTRUCT | OP_INVERSE | OP_ROOTS | OP_REFERENCE
                            | OP_LABEL | KW_NAMESPACE | KW_IMPORT | KW_EXTENSION | KW_CLASS | KW_TRAIT | KW_UNION
                            | KW_BITFLAGS | KW_TYPE | KW_TEMPLATE | KW_EXTENDS | KW_WHILE | KW_FOR | KW_LET | KW_NEW
                            | KW_OBJECT | KW_LAMBDA | KW_FUNCTION | KW_TRY | KW_MATCH | KW_CATCH | INTEGER | DECIMAL
                            | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK | KW_IF | RETURN | RESUME | YIELD | BREAK
                            | CONTINUE | RAISE | SPECIAL | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule top_statement */
                                    recog.base.set_state(246);
                                    recog.top_statement()?;
                                }
                            }

                            SEMICOLON => {
                                {
                                    /* InvokeRule eos */
                                    recog.base.set_state(247);
                                    recog.eos()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(252);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(253);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- top_statement ----------------
#[derive(Debug)]
pub enum Top_statementContextAll<'input> {
    SClassContext(SClassContext<'input>),
    SExtendsContext(SExtendsContext<'input>),
    SExtensionContext(SExtensionContext<'input>),
    SFunctionContext(SFunctionContext<'input>),
    SImportContext(SImportContext<'input>),
    SFlagsContext(SFlagsContext<'input>),
    STraitContext(STraitContext<'input>),
    SNamespaceContext(SNamespaceContext<'input>),
    S1Context(S1Context<'input>),
    SUnionContext(SUnionContext<'input>),
    Error(Top_statementContext<'input>),
}
antlr_rust::tid! {Top_statementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Top_statementContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Top_statementContextAll<'input> {}

impl<'input> Deref for Top_statementContextAll<'input> {
    type Target = dyn Top_statementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Top_statementContextAll::*;
        match self {
            SClassContext(inner) => inner,
            SExtendsContext(inner) => inner,
            SExtensionContext(inner) => inner,
            SFunctionContext(inner) => inner,
            SImportContext(inner) => inner,
            SFlagsContext(inner) => inner,
            STraitContext(inner) => inner,
            SNamespaceContext(inner) => inner,
            S1Context(inner) => inner,
            SUnionContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Top_statementContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Top_statementContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Top_statementContext<'input> = BaseParserRuleContext<'input, Top_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Top_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Top_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Top_statementContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Top_statementContext<'input> {}

impl<'input> CustomRuleContext<'input> for Top_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}
antlr_rust::tid! {Top_statementContextExt<'a>}

impl<'input> Top_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Top_statementContextExt { ph: PhantomData },
        )))
    }
}

pub trait Top_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Top_statementContextExt<'input>>
{
}

impl<'input> Top_statementContextAttrs<'input> for Top_statementContext<'input> {}

pub type SClassContext<'input> = BaseParserRuleContext<'input, SClassContextExt<'input>>;

pub trait SClassContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_class(&self) -> Option<Rc<Define_classContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SClassContextAttrs<'input> for SClassContext<'input> {}

pub struct SClassContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SClassContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SClassContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SClassContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SClass(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SClass(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SClassContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SClass(self);
    }
}

impl<'input> CustomRuleContext<'input> for SClassContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SClassContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SClassContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SClassContext<'input> {}

impl<'input> SClassContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SClassContext(BaseParserRuleContext::copy_from(
            ctx,
            SClassContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SExtendsContext<'input> = BaseParserRuleContext<'input, SExtendsContextExt<'input>>;

pub trait SExtendsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_extends(&self) -> Option<Rc<Define_extendsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SExtendsContextAttrs<'input> for SExtendsContext<'input> {}

pub struct SExtendsContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SExtendsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SExtendsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SExtendsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SExtends(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SExtends(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SExtendsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SExtends(self);
    }
}

impl<'input> CustomRuleContext<'input> for SExtendsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SExtendsContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SExtendsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SExtendsContext<'input> {}

impl<'input> SExtendsContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SExtendsContext(BaseParserRuleContext::copy_from(
            ctx,
            SExtendsContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SExtensionContext<'input> = BaseParserRuleContext<'input, SExtensionContextExt<'input>>;

pub trait SExtensionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_extension(&self) -> Option<Rc<Define_extensionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SExtensionContextAttrs<'input> for SExtensionContext<'input> {}

pub struct SExtensionContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SExtensionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SExtensionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SExtensionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SExtension(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SExtension(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SExtensionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SExtension(self);
    }
}

impl<'input> CustomRuleContext<'input> for SExtensionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SExtensionContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SExtensionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SExtensionContext<'input> {}

impl<'input> SExtensionContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SExtensionContext(BaseParserRuleContext::copy_from(
            ctx,
            SExtensionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SFunctionContext<'input> = BaseParserRuleContext<'input, SFunctionContextExt<'input>>;

pub trait SFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_function(&self) -> Option<Rc<Define_functionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SFunctionContextAttrs<'input> for SFunctionContext<'input> {}

pub struct SFunctionContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for SFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SFunctionContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SFunctionContext<'input> {}

impl<'input> SFunctionContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            SFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SImportContext<'input> = BaseParserRuleContext<'input, SImportContextExt<'input>>;

pub trait SImportContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn import_statement(&self) -> Option<Rc<Import_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SImportContextAttrs<'input> for SImportContext<'input> {}

pub struct SImportContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SImportContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SImportContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SImportContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SImport(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SImport(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SImportContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SImport(self);
    }
}

impl<'input> CustomRuleContext<'input> for SImportContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SImportContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SImportContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SImportContext<'input> {}

impl<'input> SImportContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SImportContext(BaseParserRuleContext::copy_from(
            ctx,
            SImportContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SFlagsContext<'input> = BaseParserRuleContext<'input, SFlagsContextExt<'input>>;

pub trait SFlagsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_bitflags(&self) -> Option<Rc<Define_bitflagsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SFlagsContextAttrs<'input> for SFlagsContext<'input> {}

pub struct SFlagsContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SFlagsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SFlagsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SFlagsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SFlags(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SFlags(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SFlagsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SFlags(self);
    }
}

impl<'input> CustomRuleContext<'input> for SFlagsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SFlagsContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SFlagsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SFlagsContext<'input> {}

impl<'input> SFlagsContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SFlagsContext(BaseParserRuleContext::copy_from(
            ctx,
            SFlagsContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type STraitContext<'input> = BaseParserRuleContext<'input, STraitContextExt<'input>>;

pub trait STraitContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_trait(&self) -> Option<Rc<Define_traitContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> STraitContextAttrs<'input> for STraitContext<'input> {}

pub struct STraitContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {STraitContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for STraitContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for STraitContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_STrait(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_STrait(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for STraitContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_STrait(self);
    }
}

impl<'input> CustomRuleContext<'input> for STraitContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for STraitContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for STraitContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for STraitContext<'input> {}

impl<'input> STraitContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::STraitContext(BaseParserRuleContext::copy_from(
            ctx,
            STraitContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SNamespaceContext<'input> = BaseParserRuleContext<'input, SNamespaceContextExt<'input>>;

pub trait SNamespaceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_namespace(&self) -> Option<Rc<Define_namespaceContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SNamespaceContextAttrs<'input> for SNamespaceContext<'input> {}

pub struct SNamespaceContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SNamespaceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SNamespaceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SNamespaceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SNamespace(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SNamespace(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SNamespaceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SNamespace(self);
    }
}

impl<'input> CustomRuleContext<'input> for SNamespaceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SNamespaceContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SNamespaceContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SNamespaceContext<'input> {}

impl<'input> SNamespaceContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SNamespaceContext(BaseParserRuleContext::copy_from(
            ctx,
            SNamespaceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type S1Context<'input> = BaseParserRuleContext<'input, S1ContextExt<'input>>;

pub trait S1ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn function_statement(&self) -> Option<Rc<Function_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> S1ContextAttrs<'input> for S1Context<'input> {}

pub struct S1ContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {S1ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for S1Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for S1Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_S1(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_S1(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for S1Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_S1(self);
    }
}

impl<'input> CustomRuleContext<'input> for S1ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for S1Context<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for S1Context<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for S1Context<'input> {}

impl<'input> S1ContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::S1Context(BaseParserRuleContext::copy_from(
            ctx,
            S1ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SUnionContext<'input> = BaseParserRuleContext<'input, SUnionContextExt<'input>>;

pub trait SUnionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_union(&self) -> Option<Rc<Define_unionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SUnionContextAttrs<'input> for SUnionContext<'input> {}

pub struct SUnionContextExt<'input> {
    base: Top_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SUnionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SUnionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SUnionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SUnion(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SUnion(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SUnionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SUnion(self);
    }
}

impl<'input> CustomRuleContext<'input> for SUnionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}

impl<'input> Borrow<Top_statementContextExt<'input>> for SUnionContext<'input> {
    fn borrow(&self) -> &Top_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Top_statementContextExt<'input>> for SUnionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Top_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Top_statementContextAttrs<'input> for SUnionContext<'input> {}

impl<'input> SUnionContextExt<'input> {
    fn new(ctx: &dyn Top_statementContextAttrs<'input>) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(Top_statementContextAll::SUnionContext(BaseParserRuleContext::copy_from(
            ctx,
            SUnionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn top_statement(&mut self) -> Result<Rc<Top_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Top_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_top_statement);
        let mut _localctx: Rc<Top_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(265);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(2, &mut recog.base)? {
                1 => {
                    let tmp = SNamespaceContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_namespace */
                        recog.base.set_state(255);
                        recog.define_namespace()?;
                    }
                }
                2 => {
                    let tmp = SImportContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /* InvokeRule import_statement */
                        recog.base.set_state(256);
                        recog.import_statement()?;
                    }
                }
                3 => {
                    let tmp = SExtensionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_extension */
                        recog.base.set_state(257);
                        recog.define_extension()?;
                    }
                }
                4 => {
                    let tmp = SClassContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_class */
                        recog.base.set_state(258);
                        recog.define_class()?;
                    }
                }
                5 => {
                    let tmp = SUnionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_union */
                        recog.base.set_state(259);
                        recog.define_union()?;
                    }
                }
                6 => {
                    let tmp = SFlagsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_bitflags */
                        recog.base.set_state(260);
                        recog.define_bitflags()?;
                    }
                }
                7 => {
                    let tmp = STraitContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_trait */
                        recog.base.set_state(261);
                        recog.define_trait()?;
                    }
                }
                8 => {
                    let tmp = SExtendsContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 8);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_extends */
                        recog.base.set_state(262);
                        recog.define_extends()?;
                    }
                }
                9 => {
                    let tmp = SFunctionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 9);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_function */
                        recog.base.set_state(263);
                        recog.define_function()?;
                    }
                }
                10 => {
                    let tmp = S1ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 10);
                    _localctx = tmp;
                    {
                        /* InvokeRule function_statement */
                        recog.base.set_state(264);
                        recog.function_statement()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos ----------------
pub type EosContextAll<'input> = EosContext<'input>;

pub type EosContext<'input> = BaseParserRuleContext<'input, EosContextExt<'input>>;

#[derive(Clone)]
pub struct EosContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for EosContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EosContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EosContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos(self);
    }
}

impl<'input> CustomRuleContext<'input> for EosContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos }
}
antlr_rust::tid! {EosContextExt<'a>}

impl<'input> EosContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<EosContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, EosContextExt { ph: PhantomData }))
    }
}

pub trait EosContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<EosContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
}

impl<'input> EosContextAttrs<'input> for EosContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos(&mut self) -> Result<Rc<EosContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = EosContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_eos);
        let mut _localctx: Rc<EosContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(267);
                recog.base.match_token(SEMICOLON, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos_free ----------------
pub type Eos_freeContextAll<'input> = Eos_freeContext<'input>;

pub type Eos_freeContext<'input> = BaseParserRuleContext<'input, Eos_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Eos_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Eos_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Eos_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Eos_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Eos_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos_free }
}
antlr_rust::tid! {Eos_freeContextExt<'a>}

impl<'input> Eos_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Eos_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Eos_freeContextExt { ph: PhantomData }))
    }
}

pub trait Eos_freeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Eos_freeContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
}

impl<'input> Eos_freeContextAttrs<'input> for Eos_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos_free(&mut self) -> Result<Rc<Eos_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Eos_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_eos_free);
        let mut _localctx: Rc<Eos_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(269);
                _la = recog.base.input.la(1);
                if { !(_la == COMMA || _la == SEMICOLON) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_namespace ----------------
pub type Define_namespaceContextAll<'input> = Define_namespaceContext<'input>;

pub type Define_namespaceContext<'input> = BaseParserRuleContext<'input, Define_namespaceContextExt<'input>>;

#[derive(Clone)]
pub struct Define_namespaceContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_namespaceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_namespaceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_namespace(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_namespace(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_namespaceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_namespace(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_namespaceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_namespace
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_namespace }
}
antlr_rust::tid! {Define_namespaceContextExt<'a>}

impl<'input> Define_namespaceContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_namespaceContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_namespaceContextExt { ph: PhantomData }))
    }
}

pub trait Define_namespaceContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_namespaceContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NAMESPACE
    /// Returns `None` if there is no child corresponding to token KW_NAMESPACE
    fn KW_NAMESPACE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NAMESPACE, 0)
    }
    fn namepath_free(&self) -> Option<Rc<Namepath_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_namespaceContextAttrs<'input> for Define_namespaceContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_namespace(&mut self) -> Result<Rc<Define_namespaceContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_namespaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_define_namespace);
        let mut _localctx: Rc<Define_namespaceContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(271);
                recog.base.match_token(KW_NAMESPACE, &mut recog.err_handler)?;

                /* InvokeRule namepath_free */
                recog.base.set_state(272);
                recog.namepath_free()?;

                recog.base.set_state(274);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(3, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(273);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_statement ----------------
pub type Import_statementContextAll<'input> = Import_statementContext<'input>;

pub type Import_statementContext<'input> = BaseParserRuleContext<'input, Import_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Import_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_statement }
}
antlr_rust::tid! {Import_statementContextExt<'a>}

impl<'input> Import_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_statementContextExt { ph: PhantomData }))
    }
}

pub trait Import_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IMPORT
    /// Returns `None` if there is no child corresponding to token KW_IMPORT
    fn KW_IMPORT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPORT, 0)
    }
    fn import_term(&self) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_statementContextAttrs<'input> for Import_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_statement(&mut self) -> Result<Rc<Import_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_import_statement);
        let mut _localctx: Rc<Import_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(276);
                recog.base.match_token(KW_IMPORT, &mut recog.err_handler)?;

                /* InvokeRule import_term */
                recog.base.set_state(277);
                recog.import_term()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_as ----------------
pub type Import_asContextAll<'input> = Import_asContext<'input>;

pub type Import_asContext<'input> = BaseParserRuleContext<'input, Import_asContextExt<'input>>;

#[derive(Clone)]
pub struct Import_asContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_asContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_asContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_as(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_as(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_asContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_as(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_asContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_as
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_as }
}
antlr_rust::tid! {Import_asContextExt<'a>}

impl<'input> Import_asContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_asContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_asContextExt { ph: PhantomData }))
    }
}

pub trait Import_asContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Import_asContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
}

impl<'input> Import_asContextAttrs<'input> for Import_asContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_as(&mut self) -> Result<Rc<Import_asContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_asContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_import_as);
        let mut _localctx: Rc<Import_asContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(279);
                recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                recog.base.set_state(281);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AT || _la == OP_HASH {
                    {
                        recog.base.set_state(280);
                        _la = recog.base.input.la(1);
                        if { !(_la == OP_AT || _la == OP_HASH) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                /* InvokeRule identifier */
                recog.base.set_state(283);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_term ----------------
pub type Import_termContextAll<'input> = Import_termContext<'input>;

pub type Import_termContext<'input> = BaseParserRuleContext<'input, Import_termContextExt<'input>>;

#[derive(Clone)]
pub struct Import_termContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_termContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_termContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_term(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_term(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_termContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_term(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_termContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_term
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_term }
}
antlr_rust::tid! {Import_termContextExt<'a>}

impl<'input> Import_termContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_termContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_termContextExt { ph: PhantomData }))
    }
}

pub trait Import_termContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_termContextExt<'input>>
{
    fn import_block(&self) -> Option<Rc<Import_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn import_name(&self) -> Option<Rc<Import_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn import_as(&self) -> Option<Rc<Import_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_termContextAttrs<'input> for Import_termContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_term(&mut self) -> Result<Rc<Import_termContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_termContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_import_term);
        let mut _localctx: Rc<Import_termContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(324);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(14, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule import_block */
                        recog.base.set_state(285);
                        recog.import_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(286);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(287);
                        recog.import_name()?;

                        recog.base.set_state(289);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(288);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(291);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(292);
                        recog.import_name()?;

                        recog.base.set_state(297);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(7, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(294);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(293);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(296);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(299);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(300);
                        recog.import_name()?;

                        recog.base.set_state(302);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(301);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(304);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(305);
                        recog.import_name()?;

                        recog.base.set_state(310);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(10, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(307);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(306);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(309);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(312);
                        recog.import_name()?;

                        recog.base.set_state(314);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(313);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(316);
                        recog.import_name()?;

                        recog.base.set_state(321);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(13, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(318);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(317);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(320);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(323);
                        recog.eos_free()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_name ----------------
pub type Import_nameContextAll<'input> = Import_nameContext<'input>;

pub type Import_nameContext<'input> = BaseParserRuleContext<'input, Import_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Import_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_name }
}
antlr_rust::tid! {Import_nameContextExt<'a>}

impl<'input> Import_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_nameContextExt { ph: PhantomData }))
    }
}

pub trait Import_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_nameContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Import_nameContextAttrs<'input> for Import_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_name(&mut self) -> Result<Rc<Import_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_import_name);
        let mut _localctx: Rc<Import_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(326);
                recog.identifier()?;

                recog.base.set_state(331);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(15, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(327);
                                _la = recog.base.input.la(1);
                                if { !(_la == DOT || _la == OP_PROPORTION) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                }
                                else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /* InvokeRule identifier */
                                recog.base.set_state(328);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(333);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(15, &mut recog.base)?;
                }
                {
                    recog.base.set_state(334);
                    _la = recog.base.input.la(1);
                    if { !(_la == DOT || _la == OP_PROPORTION) } {
                        recog.err_handler.recover_inline(&mut recog.base)?;
                    }
                    else {
                        if recog.base.input.la(1) == TOKEN_EOF {
                            recog.base.matched_eof = true
                        };
                        recog.err_handler.report_match(&mut recog.base);
                        recog.base.consume(&mut recog.err_handler);
                    }
                    {
                        recog.base.set_state(335);
                        recog.base.match_token(OP_MUL, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_block ----------------
pub type Import_blockContextAll<'input> = Import_blockContext<'input>;

pub type Import_blockContext<'input> = BaseParserRuleContext<'input, Import_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Import_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_block }
}
antlr_rust::tid! {Import_blockContextExt<'a>}

impl<'input> Import_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_blockContextExt { ph: PhantomData }))
    }
}

pub trait Import_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn import_term_all(&self) -> Vec<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn import_term(&self, i: usize) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Import_blockContextAttrs<'input> for Import_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_block(&mut self) -> Result<Rc<Import_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_import_block);
        let mut _localctx: Rc<Import_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(347);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(17, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(337);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(338);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(339);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(343);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << BRACE_L))) != 0)
                            || _la == OP_AT
                            || _la == OP_HASH
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                {
                                    /* InvokeRule import_term */
                                    recog.base.set_state(340);
                                    recog.import_term()?;
                                }
                            }
                            recog.base.set_state(345);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(346);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extension ----------------
pub type Define_extensionContextAll<'input> = Define_extensionContext<'input>;

pub type Define_extensionContext<'input> = BaseParserRuleContext<'input, Define_extensionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extensionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extensionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extensionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extension(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extension(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extensionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extension(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extensionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extension
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extension }
}
antlr_rust::tid! {Define_extensionContextExt<'a>}

impl<'input> Define_extensionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extensionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extensionContextExt { ph: PhantomData }))
    }
}

pub trait Define_extensionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extensionContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_EXTENSION
    /// Returns `None` if there is no child corresponding to token KW_EXTENSION
    fn KW_EXTENSION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENSION, 0)
    }
}

impl<'input> Define_extensionContextAttrs<'input> for Define_extensionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extension(&mut self) -> Result<Rc<Define_extensionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extensionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_define_extension);
        let mut _localctx: Rc<Define_extensionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(349);
                recog.base.match_token(KW_EXTENSION, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_class ----------------
pub type Define_classContextAll<'input> = Define_classContext<'input>;

pub type Define_classContext<'input> = BaseParserRuleContext<'input, Define_classContextExt<'input>>;

#[derive(Clone)]
pub struct Define_classContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_classContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_classContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_class(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_class(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_classContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_class(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_classContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_class
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_class }
}
antlr_rust::tid! {Define_classContextExt<'a>}

impl<'input> Define_classContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_classContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_classContextExt { ph: PhantomData }))
    }
}

pub trait Define_classContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_classContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CLASS
    /// Returns `None` if there is no child corresponding to token KW_CLASS
    fn KW_CLASS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CLASS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_classContextAttrs<'input> for Define_classContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_class(&mut self) -> Result<Rc<Define_classContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_classContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_define_class);
        let mut _localctx: Rc<Define_classContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(352);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(18, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(351);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(357);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(354);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(359);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(360);
                recog.modifiers()?;

                recog.base.set_state(361);
                recog.base.match_token(KW_CLASS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(362);
                recog.identifier()?;

                recog.base.set_state(364);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(363);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(367);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(366);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(370);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(369);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(372);
                recog.class_block()?;

                recog.base.set_state(374);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(23, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(373);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_block ----------------
pub type Class_blockContextAll<'input> = Class_blockContext<'input>;

pub type Class_blockContext<'input> = BaseParserRuleContext<'input, Class_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Class_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_block }
}
antlr_rust::tid! {Class_blockContextExt<'a>}

impl<'input> Class_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_blockContextExt { ph: PhantomData }))
    }
}

pub trait Class_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_dsl_all(&self) -> Vec<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_dsl(&self, i: usize) -> Option<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_blockContextAttrs<'input> for Class_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_block(&mut self) -> Result<Rc<Class_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_class_block);
        let mut _localctx: Rc<Class_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(376);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(383);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(381);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(24, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_dsl */
                                    recog.base.set_state(377);
                                    recog.class_dsl()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(378);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(379);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(380);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(385);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(386);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit ----------------
pub type Class_inheritContextAll<'input> = Class_inheritContext<'input>;

pub type Class_inheritContext<'input> = BaseParserRuleContext<'input, Class_inheritContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inheritContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inheritContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inheritContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inheritContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inheritContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit }
}
antlr_rust::tid! {Class_inheritContextExt<'a>}

impl<'input> Class_inheritContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inheritContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inheritContextExt { ph: PhantomData }))
    }
}

pub trait Class_inheritContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inheritContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn class_inherit_item_all(&self) -> Vec<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_inherit_item(&self, i: usize) -> Option<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Class_inheritContextAttrs<'input> for Class_inheritContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit(&mut self) -> Result<Rc<Class_inheritContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inheritContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_class_inherit);
        let mut _localctx: Rc<Class_inheritContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(404);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(28, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(388);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(389);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(390);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule class_inherit_item */
                        recog.base.set_state(391);
                        recog.class_inherit_item()?;

                        recog.base.set_state(396);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(26, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(392);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule class_inherit_item */
                                        recog.base.set_state(393);
                                        recog.class_inherit_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(398);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(26, &mut recog.base)?;
                        }
                        recog.base.set_state(400);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(399);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(402);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit_item ----------------
pub type Class_inherit_itemContextAll<'input> = Class_inherit_itemContext<'input>;

pub type Class_inherit_itemContext<'input> = BaseParserRuleContext<'input, Class_inherit_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inherit_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inherit_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inherit_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit_item }
}
antlr_rust::tid! {Class_inherit_itemContextExt<'a>}

impl<'input> Class_inherit_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inherit_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inherit_itemContextExt { ph: PhantomData }))
    }
}

pub trait Class_inherit_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inherit_itemContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_inherit_itemContextAttrs<'input> for Class_inherit_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit_item(&mut self) -> Result<Rc<Class_inherit_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inherit_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_class_inherit_item);
        let mut _localctx: Rc<Class_inherit_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_namepath */
                recog.base.set_state(406);
                recog.modified_namepath()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_field ----------------
pub type Class_fieldContextAll<'input> = Class_fieldContext<'input>;

pub type Class_fieldContext<'input> = BaseParserRuleContext<'input, Class_fieldContextExt<'input>>;

#[derive(Clone)]
pub struct Class_fieldContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_fieldContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_fieldContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_field(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_field(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_fieldContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_field(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_fieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_field
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_field }
}
antlr_rust::tid! {Class_fieldContextExt<'a>}

impl<'input> Class_fieldContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_fieldContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_fieldContextExt { ph: PhantomData }))
    }
}

pub trait Class_fieldContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_fieldContextExt<'input>>
{
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_fieldContextAttrs<'input> for Class_fieldContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_field(&mut self) -> Result<Rc<Class_fieldContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_fieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_class_field);
        let mut _localctx: Rc<Class_fieldContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(411);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(408);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(413);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(414);
                recog.modified_identifier()?;

                recog.base.set_state(416);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(415);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(419);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        /* InvokeRule parameter_default */
                        recog.base.set_state(418);
                        recog.parameter_default()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_method ----------------
pub type Class_methodContextAll<'input> = Class_methodContext<'input>;

pub type Class_methodContext<'input> = BaseParserRuleContext<'input, Class_methodContextExt<'input>>;

#[derive(Clone)]
pub struct Class_methodContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_methodContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_methodContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_method(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_method(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_methodContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_method(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_methodContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_method
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_method }
}
antlr_rust::tid! {Class_methodContextExt<'a>}

impl<'input> Class_methodContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_methodContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_methodContextExt { ph: PhantomData }))
    }
}

pub trait Class_methodContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_methodContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn effect_hint(&self) -> Option<Rc<Effect_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_methodContextAttrs<'input> for Class_methodContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_method(&mut self) -> Result<Rc<Class_methodContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_methodContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_class_method);
        let mut _localctx: Rc<Class_methodContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(424);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(421);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(426);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_namepath */
                recog.base.set_state(427);
                recog.modified_namepath()?;

                recog.base.set_state(429);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(428);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(431);
                recog.function_parameters()?;

                recog.base.set_state(433);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(432);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(436);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_DIV {
                    {
                        /* InvokeRule effect_hint */
                        recog.base.set_state(435);
                        recog.effect_hint()?;
                    }
                }

                recog.base.set_state(439);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule function_block */
                        recog.base.set_state(438);
                        recog.function_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_dsl ----------------
pub type Class_dslContextAll<'input> = Class_dslContext<'input>;

pub type Class_dslContext<'input> = BaseParserRuleContext<'input, Class_dslContextExt<'input>>;

#[derive(Clone)]
pub struct Class_dslContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_dslContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_dslContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_dsl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_dsl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_dslContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_dsl(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_dslContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_dsl
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_dsl }
}
antlr_rust::tid! {Class_dslContextExt<'a>}

impl<'input> Class_dslContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_dslContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_dslContextExt { ph: PhantomData }))
    }
}

pub trait Class_dslContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Class_dslContextExt<'input>> {
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_dslContextAttrs<'input> for Class_dslContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_dsl(&mut self) -> Result<Rc<Class_dslContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_dslContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_class_dsl);
        let mut _localctx: Rc<Class_dslContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(444);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(441);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(446);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(447);
                recog.modified_identifier()?;

                /* InvokeRule class_block */
                recog.base.set_state(448);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait ----------------
pub type Define_traitContextAll<'input> = Define_traitContext<'input>;

pub type Define_traitContext<'input> = BaseParserRuleContext<'input, Define_traitContextExt<'input>>;

#[derive(Clone)]
pub struct Define_traitContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_traitContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_traitContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_traitContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_traitContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait }
}
antlr_rust::tid! {Define_traitContextExt<'a>}

impl<'input> Define_traitContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_traitContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_traitContextExt { ph: PhantomData }))
    }
}

pub trait Define_traitContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_traitContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TRAIT
    /// Returns `None` if there is no child corresponding to token KW_TRAIT
    fn KW_TRAIT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRAIT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn trait_block(&self) -> Option<Rc<Trait_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn with_implements(&self) -> Option<Rc<With_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_traitContextAttrs<'input> for Define_traitContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait(&mut self) -> Result<Rc<Define_traitContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_traitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_define_trait);
        let mut _localctx: Rc<Define_traitContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(451);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(38, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(450);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(456);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(453);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(458);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(459);
                recog.modifiers()?;

                recog.base.set_state(460);
                recog.base.match_token(KW_TRAIT, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(461);
                recog.identifier()?;

                recog.base.set_state(463);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(462);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(466);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule with_implements */
                        recog.base.set_state(465);
                        recog.with_implements()?;
                    }
                }

                /* InvokeRule trait_block */
                recog.base.set_state(468);
                recog.trait_block()?;

                recog.base.set_state(470);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(42, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(469);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- trait_block ----------------
pub type Trait_blockContextAll<'input> = Trait_blockContext<'input>;

pub type Trait_blockContext<'input> = BaseParserRuleContext<'input, Trait_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Trait_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Trait_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Trait_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_trait_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_trait_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Trait_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_trait_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Trait_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_trait_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_trait_block }
}
antlr_rust::tid! {Trait_blockContextExt<'a>}

impl<'input> Trait_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Trait_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Trait_blockContextExt { ph: PhantomData }))
    }
}

pub trait Trait_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Trait_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_trait_type_all(&self) -> Vec<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait_type(&self, i: usize) -> Option<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Trait_blockContextAttrs<'input> for Trait_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn trait_block(&mut self) -> Result<Rc<Trait_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Trait_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_trait_block);
        let mut _localctx: Rc<Trait_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(472);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(479);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == KW_TYPE || _la == RAW_ID || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(477);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(43, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_trait_type */
                                    recog.base.set_state(473);
                                    recog.define_trait_type()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(474);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(475);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(476);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(481);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(482);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait_type ----------------
pub type Define_trait_typeContextAll<'input> = Define_trait_typeContext<'input>;

pub type Define_trait_typeContext<'input> = BaseParserRuleContext<'input, Define_trait_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_trait_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_trait_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_trait_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_trait_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_trait_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait_type }
}
antlr_rust::tid! {Define_trait_typeContextExt<'a>}

impl<'input> Define_trait_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_trait_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_trait_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_trait_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_trait_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_trait_typeContextAttrs<'input> for Define_trait_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait_type(&mut self) -> Result<Rc<Define_trait_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_trait_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_define_trait_type);
        let mut _localctx: Rc<Define_trait_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(484);
                recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(485);
                recog.identifier()?;

                recog.base.set_state(488);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(486);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(487);
                        recog.type_expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extends ----------------
pub type Define_extendsContextAll<'input> = Define_extendsContext<'input>;

pub type Define_extendsContext<'input> = BaseParserRuleContext<'input, Define_extendsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extendsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extendsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extendsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extends(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extends(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extendsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extends(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extendsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extends
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extends }
}
antlr_rust::tid! {Define_extendsContextExt<'a>}

impl<'input> Define_extendsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extendsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extendsContextExt { ph: PhantomData }))
    }
}

pub trait Define_extendsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extendsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_EXTENDS
    /// Returns `None` if there is no child corresponding to token KW_EXTENDS
    fn KW_EXTENDS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENDS, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn trait_block(&self) -> Option<Rc<Trait_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn with_implements(&self) -> Option<Rc<With_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_extendsContextAttrs<'input> for Define_extendsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extends(&mut self) -> Result<Rc<Define_extendsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extendsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_define_extends);
        let mut _localctx: Rc<Define_extendsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(491);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(46, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(490);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(496);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(493);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(498);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(499);
                recog.modifiers()?;

                recog.base.set_state(500);
                recog.base.match_token(KW_EXTENDS, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(501);
                recog.namepath()?;

                recog.base.set_state(503);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(502);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(506);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule with_implements */
                        recog.base.set_state(505);
                        recog.with_implements()?;
                    }
                }

                /* InvokeRule trait_block */
                recog.base.set_state(508);
                recog.trait_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- with_implements ----------------
pub type With_implementsContextAll<'input> = With_implementsContext<'input>;

pub type With_implementsContext<'input> = BaseParserRuleContext<'input, With_implementsContextExt<'input>>;

#[derive(Clone)]
pub struct With_implementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for With_implementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for With_implementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_with_implements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_with_implements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for With_implementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_with_implements(self);
    }
}

impl<'input> CustomRuleContext<'input> for With_implementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_with_implements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_with_implements }
}
antlr_rust::tid! {With_implementsContextExt<'a>}

impl<'input> With_implementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<With_implementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, With_implementsContextExt { ph: PhantomData }))
    }
}

pub trait With_implementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<With_implementsContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IMPLEMENTS
    /// Returns `None` if there is no child corresponding to token KW_IMPLEMENTS
    fn KW_IMPLEMENTS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPLEMENTS, 0)
    }
}

impl<'input> With_implementsContextAttrs<'input> for With_implementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn with_implements(&mut self) -> Result<Rc<With_implementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = With_implementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_with_implements);
        let mut _localctx: Rc<With_implementsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(510);
                _la = recog.base.input.la(1);
                if { !(_la == COLON || _la == KW_IMPLEMENTS) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                /* InvokeRule type_expression */
                recog.base.set_state(511);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_union ----------------
pub type Define_unionContextAll<'input> = Define_unionContext<'input>;

pub type Define_unionContext<'input> = BaseParserRuleContext<'input, Define_unionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_unionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_unionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_unionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_union(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_union(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_unionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_union(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_unionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_union
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_union }
}
antlr_rust::tid! {Define_unionContextExt<'a>}

impl<'input> Define_unionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_unionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_unionContextExt { ph: PhantomData }))
    }
}

pub trait Define_unionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_unionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_UNION
    /// Returns `None` if there is no child corresponding to token KW_UNION
    fn KW_UNION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_UNION, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn union_block(&self) -> Option<Rc<Union_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_unionContextAttrs<'input> for Define_unionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_union(&mut self) -> Result<Rc<Define_unionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_unionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_define_union);
        let mut _localctx: Rc<Define_unionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(516);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(513);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(518);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(519);
                recog.modifiers()?;

                recog.base.set_state(520);
                recog.base.match_token(KW_UNION, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(521);
                recog.identifier()?;

                recog.base.set_state(523);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(522);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(526);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(525);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule union_block */
                recog.base.set_state(528);
                recog.union_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- base_layout ----------------
pub type Base_layoutContextAll<'input> = Base_layoutContext<'input>;

pub type Base_layoutContext<'input> = BaseParserRuleContext<'input, Base_layoutContextExt<'input>>;

#[derive(Clone)]
pub struct Base_layoutContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Base_layoutContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Base_layoutContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_base_layout(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_base_layout(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Base_layoutContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_base_layout(self);
    }
}

impl<'input> CustomRuleContext<'input> for Base_layoutContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_base_layout
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_base_layout }
}
antlr_rust::tid! {Base_layoutContextExt<'a>}

impl<'input> Base_layoutContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Base_layoutContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Base_layoutContextExt { ph: PhantomData }))
    }
}

pub trait Base_layoutContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Base_layoutContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Base_layoutContextAttrs<'input> for Base_layoutContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn base_layout(&mut self) -> Result<Rc<Base_layoutContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Base_layoutContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_base_layout);
        let mut _localctx: Rc<Base_layoutContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(530);
                recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                recog.base.set_state(532);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L
                    || _la == LAMBDA_SLOT
                    || (((_la - 123) & !0x3f) == 0
                        && ((1usize << (_la - 123))
                            & ((1usize << (INTEGER - 123))
                                | (1usize << (DECIMAL - 123))
                                | (1usize << (STRING_SINGLE - 123))
                                | (1usize << (STRING_DOUBLE - 123))
                                | (1usize << (STRING_BLOCK - 123))
                                | (1usize << (SPECIAL - 123))
                                | (1usize << (RAW_ID - 123))
                                | (1usize << (UNICODE_ID - 123))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(531);
                        recog.type_expression_rec(0)?;
                    }
                }

                recog.base.set_state(534);
                recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- union_block ----------------
pub type Union_blockContextAll<'input> = Union_blockContext<'input>;

pub type Union_blockContext<'input> = BaseParserRuleContext<'input, Union_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Union_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Union_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Union_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_union_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_union_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Union_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_union_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Union_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_union_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_union_block }
}
antlr_rust::tid! {Union_blockContextExt<'a>}

impl<'input> Union_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Union_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Union_blockContextExt { ph: PhantomData }))
    }
}

pub trait Union_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Union_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_variant_all(&self) -> Vec<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_variant(&self, i: usize) -> Option<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Union_blockContextAttrs<'input> for Union_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn union_block(&mut self) -> Result<Rc<Union_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Union_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_union_block);
        let mut _localctx: Rc<Union_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(536);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(542);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(540);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(54, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(537);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule define_variant */
                                    recog.base.set_state(538);
                                    recog.define_variant()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(539);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(544);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(545);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_variant ----------------
pub type Define_variantContextAll<'input> = Define_variantContext<'input>;

pub type Define_variantContext<'input> = BaseParserRuleContext<'input, Define_variantContextExt<'input>>;

#[derive(Clone)]
pub struct Define_variantContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_variantContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_variantContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_variant(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_variant(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_variantContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_variant(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_variantContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_variant
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_variant }
}
antlr_rust::tid! {Define_variantContextExt<'a>}

impl<'input> Define_variantContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_variantContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_variantContextExt { ph: PhantomData }))
    }
}

pub trait Define_variantContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_variantContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn variant_block(&self) -> Option<Rc<Variant_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_variantContextAttrs<'input> for Define_variantContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_variant(&mut self) -> Result<Rc<Define_variantContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_variantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_define_variant);
        let mut _localctx: Rc<Define_variantContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(547);
                recog.identifier()?;

                recog.base.set_state(549);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule variant_block */
                        recog.base.set_state(548);
                        recog.variant_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- variant_block ----------------
pub type Variant_blockContextAll<'input> = Variant_blockContext<'input>;

pub type Variant_blockContext<'input> = BaseParserRuleContext<'input, Variant_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Variant_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Variant_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Variant_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_variant_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_variant_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Variant_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_variant_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Variant_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_variant_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_variant_block }
}
antlr_rust::tid! {Variant_blockContextExt<'a>}

impl<'input> Variant_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Variant_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Variant_blockContextExt { ph: PhantomData }))
    }
}

pub trait Variant_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Variant_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Variant_blockContextAttrs<'input> for Variant_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn variant_block(&mut self) -> Result<Rc<Variant_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Variant_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_variant_block);
        let mut _localctx: Rc<Variant_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(551);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(556);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(554);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_HASH | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(552);
                                    recog.class_field()?;
                                }
                            }

                            COMMA | SEMICOLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(553);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(558);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(559);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_bitflags ----------------
pub type Define_bitflagsContextAll<'input> = Define_bitflagsContext<'input>;

pub type Define_bitflagsContext<'input> = BaseParserRuleContext<'input, Define_bitflagsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_bitflagsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_bitflagsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_bitflagsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_bitflags(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_bitflags(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_bitflagsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_bitflags(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_bitflagsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_bitflags
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_bitflags }
}
antlr_rust::tid! {Define_bitflagsContextExt<'a>}

impl<'input> Define_bitflagsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_bitflagsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_bitflagsContextExt { ph: PhantomData }))
    }
}

pub trait Define_bitflagsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_bitflagsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_BITFLAGS
    /// Returns `None` if there is no child corresponding to token KW_BITFLAGS
    fn KW_BITFLAGS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_BITFLAGS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn bitflags_block(&self) -> Option<Rc<Bitflags_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_bitflagsContextAttrs<'input> for Define_bitflagsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_bitflags(&mut self) -> Result<Rc<Define_bitflagsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_bitflagsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_define_bitflags);
        let mut _localctx: Rc<Define_bitflagsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(564);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(561);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(566);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(567);
                recog.modifiers()?;

                recog.base.set_state(568);
                recog.base.match_token(KW_BITFLAGS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(569);
                recog.identifier()?;

                recog.base.set_state(571);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(570);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(574);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(573);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule bitflags_block */
                recog.base.set_state(576);
                recog.bitflags_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_block ----------------
pub type Bitflags_blockContextAll<'input> = Bitflags_blockContext<'input>;

pub type Bitflags_blockContext<'input> = BaseParserRuleContext<'input, Bitflags_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_block }
}
antlr_rust::tid! {Bitflags_blockContextExt<'a>}

impl<'input> Bitflags_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_blockContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn bitflags_item_all(&self) -> Vec<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn bitflags_item(&self, i: usize) -> Option<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Bitflags_blockContextAttrs<'input> for Bitflags_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_block(&mut self) -> Result<Rc<Bitflags_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_bitflags_block);
        let mut _localctx: Rc<Bitflags_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(578);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(584);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(582);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(62, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(579);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule bitflags_item */
                                    recog.base.set_state(580);
                                    recog.bitflags_item()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(581);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(586);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(587);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_item ----------------
pub type Bitflags_itemContextAll<'input> = Bitflags_itemContext<'input>;

pub type Bitflags_itemContext<'input> = BaseParserRuleContext<'input, Bitflags_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_item }
}
antlr_rust::tid! {Bitflags_itemContextExt<'a>}

impl<'input> Bitflags_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_itemContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_itemContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Bitflags_itemContextAttrs<'input> for Bitflags_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_item(&mut self) -> Result<Rc<Bitflags_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_bitflags_item);
        let mut _localctx: Rc<Bitflags_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(592);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(589);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(594);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule identifier */
                recog.base.set_state(595);
                recog.identifier()?;

                recog.base.set_state(598);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(596);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(597);
                        recog.expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_function ----------------
pub type Define_functionContextAll<'input> = Define_functionContext<'input>;

pub type Define_functionContext<'input> = BaseParserRuleContext<'input, Define_functionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_functionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_functionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_functionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_function(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_function(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_functionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_function(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_functionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_function
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_function }
}
antlr_rust::tid! {Define_functionContextExt<'a>}

impl<'input> Define_functionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_functionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_functionContextExt { ph: PhantomData }))
    }
}

pub trait Define_functionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_functionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_FUNCTION
    /// Returns `None` if there is no child corresponding to token KW_FUNCTION
    fn KW_FUNCTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FUNCTION, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn effect_hint(&self) -> Option<Rc<Effect_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_functionContextAttrs<'input> for Define_functionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_function(&mut self) -> Result<Rc<Define_functionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_functionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_define_function);
        let mut _localctx: Rc<Define_functionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(601);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(66, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(600);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(606);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(603);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(608);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(609);
                recog.modifiers()?;

                recog.base.set_state(610);
                recog.base.match_token(KW_FUNCTION, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(611);
                recog.namepath()?;

                recog.base.set_state(613);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(612);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(615);
                recog.function_parameters()?;

                recog.base.set_state(617);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(616);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(620);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_DIV {
                    {
                        /* InvokeRule effect_hint */
                        recog.base.set_state(619);
                        recog.effect_hint()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(622);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_parameters ----------------
pub type Function_parametersContextAll<'input> = Function_parametersContext<'input>;

pub type Function_parametersContext<'input> = BaseParserRuleContext<'input, Function_parametersContextExt<'input>>;

#[derive(Clone)]
pub struct Function_parametersContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_parametersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_parametersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_parameters(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_parameters(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_parametersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_parameters(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_parametersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_parameters
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_parameters }
}
antlr_rust::tid! {Function_parametersContextExt<'a>}

impl<'input> Function_parametersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_parametersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Function_parametersContextExt { ph: PhantomData },
        ))
    }
}

pub trait Function_parametersContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_parametersContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn parameter_item_all(&self) -> Vec<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn parameter_item(&self, i: usize) -> Option<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Function_parametersContextAttrs<'input> for Function_parametersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_parameters(&mut self) -> Result<Rc<Function_parametersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_parametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_function_parameters);
        let mut _localctx: Rc<Function_parametersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(637);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(72, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(624);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(625);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(626);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule parameter_item */
                        recog.base.set_state(627);
                        recog.parameter_item()?;

                        recog.base.set_state(632);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(628);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule parameter_item */
                                    recog.base.set_state(629);
                                    recog.parameter_item()?;
                                }
                            }
                            recog.base.set_state(634);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(635);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_item ----------------
pub type Parameter_itemContextAll<'input> = Parameter_itemContext<'input>;

pub type Parameter_itemContext<'input> = BaseParserRuleContext<'input, Parameter_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_item }
}
antlr_rust::tid! {Parameter_itemContextExt<'a>}

impl<'input> Parameter_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Parameter_itemContextExt { ph: PhantomData }))
    }
}

pub trait Parameter_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_itemContextExt<'input>>
{
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Parameter_itemContextAttrs<'input> for Parameter_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_item(&mut self) -> Result<Rc<Parameter_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_parameter_item);
        let mut _localctx: Rc<Parameter_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(642);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(639);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(644);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(645);
                recog.modified_identifier()?;

                recog.base.set_state(647);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(646);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(650);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        /* InvokeRule parameter_default */
                        recog.base.set_state(649);
                        recog.parameter_default()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_default ----------------
pub type Parameter_defaultContextAll<'input> = Parameter_defaultContext<'input>;

pub type Parameter_defaultContext<'input> = BaseParserRuleContext<'input, Parameter_defaultContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_defaultContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_defaultContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_defaultContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_default(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_default(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_defaultContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_default(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_defaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_default
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_default }
}
antlr_rust::tid! {Parameter_defaultContextExt<'a>}

impl<'input> Parameter_defaultContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_defaultContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Parameter_defaultContextExt { ph: PhantomData }))
    }
}

pub trait Parameter_defaultContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_defaultContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Parameter_defaultContextAttrs<'input> for Parameter_defaultContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_default(&mut self) -> Result<Rc<Parameter_defaultContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_defaultContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_parameter_default);
        let mut _localctx: Rc<Parameter_defaultContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(652);
                recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                /* InvokeRule expression */
                recog.base.set_state(653);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_call ----------------
pub type Function_callContextAll<'input> = Function_callContext<'input>;

pub type Function_callContext<'input> = BaseParserRuleContext<'input, Function_callContextExt<'input>>;

#[derive(Clone)]
pub struct Function_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_call }
}
antlr_rust::tid! {Function_callContextExt<'a>}

impl<'input> Function_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_callContextExt { ph: PhantomData }))
    }
}

pub trait Function_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_callContextExt<'input>>
{
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
}

impl<'input> Function_callContextAttrs<'input> for Function_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_call(&mut self) -> Result<Rc<Function_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_function_call);
        let mut _localctx: Rc<Function_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(656);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(655);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule tuple_call_body */
                recog.base.set_state(658);
                recog.tuple_call_body()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- dot_call ----------------
pub type Dot_callContextAll<'input> = Dot_callContext<'input>;

pub type Dot_callContext<'input> = BaseParserRuleContext<'input, Dot_callContextExt<'input>>;

#[derive(Clone)]
pub struct Dot_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Dot_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Dot_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dot_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_dot_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Dot_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_dot_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Dot_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_dot_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_dot_call }
}
antlr_rust::tid! {Dot_callContextExt<'a>}

impl<'input> Dot_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Dot_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Dot_callContextExt { ph: PhantomData }))
    }
}

pub trait Dot_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Dot_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
}

impl<'input> Dot_callContextAttrs<'input> for Dot_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn dot_call(&mut self) -> Result<Rc<Dot_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Dot_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_dot_call);
        let mut _localctx: Rc<Dot_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(679);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(82, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(661);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_THROW {
                            {
                                recog.base.set_state(660);
                                recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(663);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        /* InvokeRule namepath */
                        recog.base.set_state(664);
                        recog.namepath()?;

                        recog.base.set_state(666);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(78, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(665);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(669);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_THROW {
                            {
                                recog.base.set_state(668);
                                recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(671);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(673);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AT {
                            {
                                recog.base.set_state(672);
                                recog.base.match_token(OP_AT, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule namepath */
                        recog.base.set_state(675);
                        recog.namepath()?;

                        recog.base.set_state(677);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(81, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(676);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_body ----------------
pub type Tuple_call_bodyContextAll<'input> = Tuple_call_bodyContext<'input>;

pub type Tuple_call_bodyContext<'input> = BaseParserRuleContext<'input, Tuple_call_bodyContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_bodyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_body(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_body(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_body(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_bodyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_body
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_body }
}
antlr_rust::tid! {Tuple_call_bodyContextExt<'a>}

impl<'input> Tuple_call_bodyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_bodyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_call_bodyContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_call_bodyContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_bodyContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn tuple_call_item_all(&self) -> Vec<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tuple_call_item(&self, i: usize) -> Option<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Tuple_call_bodyContextAttrs<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_body(&mut self) -> Result<Rc<Tuple_call_bodyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_bodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_tuple_call_body);
        let mut _localctx: Rc<Tuple_call_bodyContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(697);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(85, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(681);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(682);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(683);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule tuple_call_item */
                        recog.base.set_state(684);
                        recog.tuple_call_item()?;

                        recog.base.set_state(689);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(83, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(685);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule tuple_call_item */
                                        recog.base.set_state(686);
                                        recog.tuple_call_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(691);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(83, &mut recog.base)?;
                        }
                        recog.base.set_state(693);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(692);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(695);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_item ----------------
pub type Tuple_call_itemContextAll<'input> = Tuple_call_itemContext<'input>;

pub type Tuple_call_itemContext<'input> = BaseParserRuleContext<'input, Tuple_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_item }
}
antlr_rust::tid! {Tuple_call_itemContextExt<'a>}

impl<'input> Tuple_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_call_itemContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_itemContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Tuple_call_itemContextAttrs<'input> for Tuple_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_item(&mut self) -> Result<Rc<Tuple_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_tuple_call_item);
        let mut _localctx: Rc<Tuple_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(704);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(86, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(699);
                        recog.identifier()?;

                        recog.base.set_state(700);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(701);
                        recog.expression_rec(0)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(703);
                        recog.expression_rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_lambda ----------------
pub type Define_lambdaContextAll<'input> = Define_lambdaContext<'input>;

pub type Define_lambdaContext<'input> = BaseParserRuleContext<'input, Define_lambdaContextExt<'input>>;

#[derive(Clone)]
pub struct Define_lambdaContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_lambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_lambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_lambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_lambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_lambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_lambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_lambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_lambda
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_lambda }
}
antlr_rust::tid! {Define_lambdaContextExt<'a>}

impl<'input> Define_lambdaContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_lambdaContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_lambdaContextExt { ph: PhantomData }))
    }
}

pub trait Define_lambdaContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_lambdaContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LAMBDA
    /// Returns `None` if there is no child corresponding to token KW_LAMBDA
    fn KW_LAMBDA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LAMBDA, 0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_lambdaContextAttrs<'input> for Define_lambdaContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_lambda(&mut self) -> Result<Rc<Define_lambdaContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_lambdaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_define_lambda);
        let mut _localctx: Rc<Define_lambdaContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(709);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(706);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(711);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(712);
                recog.base.match_token(KW_LAMBDA, &mut recog.err_handler)?;

                /* InvokeRule function_parameters */
                recog.base.set_state(713);
                recog.function_parameters()?;

                recog.base.set_state(715);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(714);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(717);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- lambda_call ----------------
pub type Lambda_callContextAll<'input> = Lambda_callContext<'input>;

pub type Lambda_callContext<'input> = BaseParserRuleContext<'input, Lambda_callContextExt<'input>>;

#[derive(Clone)]
pub struct Lambda_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Lambda_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Lambda_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lambda_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_lambda_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Lambda_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_lambda_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Lambda_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_lambda_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_lambda_call }
}
antlr_rust::tid! {Lambda_callContextExt<'a>}

impl<'input> Lambda_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Lambda_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Lambda_callContextExt { ph: PhantomData }))
    }
}

pub trait Lambda_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Lambda_callContextExt<'input>>
{
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
}

impl<'input> Lambda_callContextAttrs<'input> for Lambda_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn lambda_call(&mut self) -> Result<Rc<Lambda_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Lambda_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_lambda_call);
        let mut _localctx: Rc<Lambda_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(720);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(719);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(722);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_block ----------------
pub type Function_blockContextAll<'input> = Function_blockContext<'input>;

pub type Function_blockContext<'input> = BaseParserRuleContext<'input, Function_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Function_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_block }
}
antlr_rust::tid! {Function_blockContextExt<'a>}

impl<'input> Function_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_blockContextExt { ph: PhantomData }))
    }
}

pub trait Function_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn function_statement_all(&self) -> Vec<Rc<Function_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn function_statement(&self, i: usize) -> Option<Rc<Function_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_all(&self) -> Vec<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos(&self, i: usize) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Function_blockContextAttrs<'input> for Function_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_block(&mut self) -> Result<Rc<Function_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_function_block);
        let mut _localctx: Rc<Function_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(724);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(729);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << SEMICOLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << OFFSET_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 65) & !0x3f) == 0
                        && ((1usize << (_la - 65))
                            & ((1usize << (OP_AND - 65))
                                | (1usize << (OP_AT - 65))
                                | (1usize << (OP_HASH - 65))
                                | (1usize << (LAMBDA_SLOT - 65))
                                | (1usize << (OP_THROW - 65))
                                | (1usize << (OP_NOT - 65))
                                | (1usize << (OP_DECONSTRUCT - 65))
                                | (1usize << (OP_INVERSE - 65))
                                | (1usize << (OP_ROOTS - 65))
                                | (1usize << (OP_REFERENCE - 65))
                                | (1usize << (OP_LABEL - 65))))
                            != 0)
                    || (((_la - 104) & !0x3f) == 0
                        && ((1usize << (_la - 104))
                            & ((1usize << (KW_TYPE - 104))
                                | (1usize << (KW_WHILE - 104))
                                | (1usize << (KW_FOR - 104))
                                | (1usize << (KW_LET - 104))
                                | (1usize << (KW_NEW - 104))
                                | (1usize << (KW_OBJECT - 104))
                                | (1usize << (KW_LAMBDA - 104))
                                | (1usize << (KW_TRY - 104))
                                | (1usize << (KW_MATCH - 104))
                                | (1usize << (KW_CATCH - 104))
                                | (1usize << (INTEGER - 104))
                                | (1usize << (DECIMAL - 104))
                                | (1usize << (STRING_SINGLE - 104))
                                | (1usize << (STRING_DOUBLE - 104))
                                | (1usize << (STRING_BLOCK - 104))
                                | (1usize << (KW_IF - 104))
                                | (1usize << (RETURN - 104))
                                | (1usize << (RESUME - 104))
                                | (1usize << (YIELD - 104))
                                | (1usize << (BREAK - 104))
                                | (1usize << (CONTINUE - 104))))
                            != 0)
                    || (((_la - 136) & !0x3f) == 0
                        && ((1usize << (_la - 136))
                            & ((1usize << (RAISE - 136))
                                | (1usize << (SPECIAL - 136))
                                | (1usize << (RAW_ID - 136))
                                | (1usize << (UNICODE_ID - 136))))
                            != 0)
                {
                    {
                        recog.base.set_state(727);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | OFFSET_L | OP_ADD | OP_SUB | OP_MUL | OP_AND | OP_AT | OP_HASH
                            | LAMBDA_SLOT | OP_THROW | OP_NOT | OP_DECONSTRUCT | OP_INVERSE | OP_ROOTS | OP_REFERENCE
                            | OP_LABEL | KW_TYPE | KW_WHILE | KW_FOR | KW_LET | KW_NEW | KW_OBJECT | KW_LAMBDA | KW_TRY
                            | KW_MATCH | KW_CATCH | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK
                            | KW_IF | RETURN | RESUME | YIELD | BREAK | CONTINUE | RAISE | SPECIAL | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule function_statement */
                                    recog.base.set_state(725);
                                    recog.function_statement()?;
                                }
                            }

                            SEMICOLON => {
                                {
                                    /* InvokeRule eos */
                                    recog.base.set_state(726);
                                    recog.eos()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(731);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(732);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_statement ----------------
#[derive(Debug)]
pub enum Function_statementContextAll<'input> {
    SlambdaContext(SlambdaContext<'input>),
    SLoopContext(SLoopContext<'input>),
    STypeContext(STypeContext<'input>),
    SIfLetContext(SIfLetContext<'input>),
    SLetContext(SLetContext<'input>),
    S2Context(S2Context<'input>),
    Error(Function_statementContext<'input>),
}
antlr_rust::tid! {Function_statementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Function_statementContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_statementContextAll<'input> {}

impl<'input> Deref for Function_statementContextAll<'input> {
    type Target = dyn Function_statementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Function_statementContextAll::*;
        match self {
            SlambdaContext(inner) => inner,
            SLoopContext(inner) => inner,
            STypeContext(inner) => inner,
            SIfLetContext(inner) => inner,
            SLetContext(inner) => inner,
            S2Context(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_statementContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_statementContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Function_statementContext<'input> = BaseParserRuleContext<'input, Function_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Function_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_statementContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_statementContext<'input> {}

impl<'input> CustomRuleContext<'input> for Function_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statement }
}
antlr_rust::tid! {Function_statementContextExt<'a>}

impl<'input> Function_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_statementContextAll<'input>> {
        Rc::new(Function_statementContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Function_statementContextExt { ph: PhantomData },
        )))
    }
}

pub trait Function_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_statementContextExt<'input>>
{
}

impl<'input> Function_statementContextAttrs<'input> for Function_statementContext<'input> {}

pub type SlambdaContext<'input> = BaseParserRuleContext<'input, SlambdaContextExt<'input>>;

pub trait SlambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_lambda(&self) -> Option<Rc<Define_lambdaContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SlambdaContextAttrs<'input> for SlambdaContext<'input> {}

pub struct SlambdaContextExt<'input> {
    base: Function_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SlambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SlambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SlambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_Slambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_Slambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SlambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_Slambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for SlambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statement }
}

impl<'input> Borrow<Function_statementContextExt<'input>> for SlambdaContext<'input> {
    fn borrow(&self) -> &Function_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Function_statementContextExt<'input>> for SlambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut Function_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Function_statementContextAttrs<'input> for SlambdaContext<'input> {}

impl<'input> SlambdaContextExt<'input> {
    fn new(ctx: &dyn Function_statementContextAttrs<'input>) -> Rc<Function_statementContextAll<'input>> {
        Rc::new(Function_statementContextAll::SlambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            SlambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SLoopContext<'input> = BaseParserRuleContext<'input, SLoopContextExt<'input>>;

pub trait SLoopContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn loop_statement(&self) -> Option<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SLoopContextAttrs<'input> for SLoopContext<'input> {}

pub struct SLoopContextExt<'input> {
    base: Function_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SLoopContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SLoopContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SLoopContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SLoop(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SLoop(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SLoopContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SLoop(self);
    }
}

impl<'input> CustomRuleContext<'input> for SLoopContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statement }
}

impl<'input> Borrow<Function_statementContextExt<'input>> for SLoopContext<'input> {
    fn borrow(&self) -> &Function_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Function_statementContextExt<'input>> for SLoopContext<'input> {
    fn borrow_mut(&mut self) -> &mut Function_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Function_statementContextAttrs<'input> for SLoopContext<'input> {}

impl<'input> SLoopContextExt<'input> {
    fn new(ctx: &dyn Function_statementContextAttrs<'input>) -> Rc<Function_statementContextAll<'input>> {
        Rc::new(Function_statementContextAll::SLoopContext(BaseParserRuleContext::copy_from(
            ctx,
            SLoopContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type STypeContext<'input> = BaseParserRuleContext<'input, STypeContextExt<'input>>;

pub trait STypeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_type(&self) -> Option<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> STypeContextAttrs<'input> for STypeContext<'input> {}

pub struct STypeContextExt<'input> {
    base: Function_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {STypeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for STypeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for STypeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SType(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for STypeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SType(self);
    }
}

impl<'input> CustomRuleContext<'input> for STypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statement }
}

impl<'input> Borrow<Function_statementContextExt<'input>> for STypeContext<'input> {
    fn borrow(&self) -> &Function_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Function_statementContextExt<'input>> for STypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Function_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Function_statementContextAttrs<'input> for STypeContext<'input> {}

impl<'input> STypeContextExt<'input> {
    fn new(ctx: &dyn Function_statementContextAttrs<'input>) -> Rc<Function_statementContextAll<'input>> {
        Rc::new(Function_statementContextAll::STypeContext(BaseParserRuleContext::copy_from(
            ctx,
            STypeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SIfLetContext<'input> = BaseParserRuleContext<'input, SIfLetContextExt<'input>>;

pub trait SIfLetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn if_let_statement(&self) -> Option<Rc<If_let_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SIfLetContextAttrs<'input> for SIfLetContext<'input> {}

pub struct SIfLetContextExt<'input> {
    base: Function_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SIfLetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SIfLetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SIfLetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SIfLet(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SIfLet(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SIfLetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SIfLet(self);
    }
}

impl<'input> CustomRuleContext<'input> for SIfLetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statement }
}

impl<'input> Borrow<Function_statementContextExt<'input>> for SIfLetContext<'input> {
    fn borrow(&self) -> &Function_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Function_statementContextExt<'input>> for SIfLetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Function_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Function_statementContextAttrs<'input> for SIfLetContext<'input> {}

impl<'input> SIfLetContextExt<'input> {
    fn new(ctx: &dyn Function_statementContextAttrs<'input>) -> Rc<Function_statementContextAll<'input>> {
        Rc::new(Function_statementContextAll::SIfLetContext(BaseParserRuleContext::copy_from(
            ctx,
            SIfLetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type SLetContext<'input> = BaseParserRuleContext<'input, SLetContextExt<'input>>;

pub trait SLetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn let_binding(&self) -> Option<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SLetContextAttrs<'input> for SLetContext<'input> {}

pub struct SLetContextExt<'input> {
    base: Function_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SLetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SLetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SLetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SLet(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SLet(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SLetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SLet(self);
    }
}

impl<'input> CustomRuleContext<'input> for SLetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statement }
}

impl<'input> Borrow<Function_statementContextExt<'input>> for SLetContext<'input> {
    fn borrow(&self) -> &Function_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Function_statementContextExt<'input>> for SLetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Function_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Function_statementContextAttrs<'input> for SLetContext<'input> {}

impl<'input> SLetContextExt<'input> {
    fn new(ctx: &dyn Function_statementContextAttrs<'input>) -> Rc<Function_statementContextAll<'input>> {
        Rc::new(Function_statementContextAll::SLetContext(BaseParserRuleContext::copy_from(
            ctx,
            SLetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type S2Context<'input> = BaseParserRuleContext<'input, S2ContextExt<'input>>;

pub trait S2ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression_root(&self) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> S2ContextAttrs<'input> for S2Context<'input> {}

pub struct S2ContextExt<'input> {
    base: Function_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {S2ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for S2Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for S2Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_S2(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_S2(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for S2Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_S2(self);
    }
}

impl<'input> CustomRuleContext<'input> for S2ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statement }
}

impl<'input> Borrow<Function_statementContextExt<'input>> for S2Context<'input> {
    fn borrow(&self) -> &Function_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Function_statementContextExt<'input>> for S2Context<'input> {
    fn borrow_mut(&mut self) -> &mut Function_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Function_statementContextAttrs<'input> for S2Context<'input> {}

impl<'input> S2ContextExt<'input> {
    fn new(ctx: &dyn Function_statementContextAttrs<'input>) -> Rc<Function_statementContextAll<'input>> {
        Rc::new(Function_statementContextAll::S2Context(BaseParserRuleContext::copy_from(
            ctx,
            S2ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_statement(&mut self) -> Result<Rc<Function_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_function_statement);
        let mut _localctx: Rc<Function_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(740);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(92, &mut recog.base)? {
                1 => {
                    let tmp = STypeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_type */
                        recog.base.set_state(734);
                        recog.define_type()?;
                    }
                }
                2 => {
                    let tmp = SlambdaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_lambda */
                        recog.base.set_state(735);
                        recog.define_lambda()?;
                    }
                }
                3 => {
                    let tmp = SLetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule let_binding */
                        recog.base.set_state(736);
                        recog.let_binding()?;
                    }
                }
                4 => {
                    let tmp = SLoopContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /* InvokeRule loop_statement */
                        recog.base.set_state(737);
                        recog.loop_statement()?;
                    }
                }
                5 => {
                    let tmp = SIfLetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        /* InvokeRule if_let_statement */
                        recog.base.set_state(738);
                        recog.if_let_statement()?;
                    }
                }
                6 => {
                    let tmp = S2ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        /* InvokeRule expression_root */
                        recog.base.set_state(739);
                        recog.expression_root()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_binding ----------------
pub type Let_bindingContextAll<'input> = Let_bindingContext<'input>;

pub type Let_bindingContext<'input> = BaseParserRuleContext<'input, Let_bindingContextExt<'input>>;

#[derive(Clone)]
pub struct Let_bindingContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_bindingContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_bindingContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_binding(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_binding(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_bindingContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_binding(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_bindingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_binding
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_binding }
}
antlr_rust::tid! {Let_bindingContextExt<'a>}

impl<'input> Let_bindingContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_bindingContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_bindingContextExt { ph: PhantomData }))
    }
}

pub trait Let_bindingContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_bindingContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Let_bindingContextAttrs<'input> for Let_bindingContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_binding(&mut self) -> Result<Rc<Let_bindingContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_bindingContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_let_binding);
        let mut _localctx: Rc<Let_bindingContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(742);
                recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                /* InvokeRule let_pattern */
                recog.base.set_state(743);
                recog.let_pattern()?;

                recog.base.set_state(745);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(744);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(749);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(747);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(748);
                        recog.expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern ----------------
pub type Let_patternContextAll<'input> = Let_patternContext<'input>;

pub type Let_patternContext<'input> = BaseParserRuleContext<'input, Let_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Let_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern }
}
antlr_rust::tid! {Let_patternContextExt<'a>}

impl<'input> Let_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_patternContextExt { ph: PhantomData }))
    }
}

pub trait Let_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_patternContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_plain(&self) -> Option<Rc<Let_pattern_plainContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Let_patternContextAttrs<'input> for Let_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern(&mut self) -> Result<Rc<Let_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_let_pattern);
        let mut _localctx: Rc<Let_patternContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(753);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(95, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(751);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule let_pattern_plain */
                        recog.base.set_state(752);
                        recog.let_pattern_plain()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_plain ----------------
pub type Let_pattern_plainContextAll<'input> = Let_pattern_plainContext<'input>;

pub type Let_pattern_plainContext<'input> = BaseParserRuleContext<'input, Let_pattern_plainContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_plainContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_plainContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_plain(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_plain(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_plain(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_plainContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_plain
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_plain }
}
antlr_rust::tid! {Let_pattern_plainContextExt<'a>}

impl<'input> Let_pattern_plainContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_plainContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_plainContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_plainContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_plainContextExt<'input>>
{
    fn modified_identifier_all(&self) -> Vec<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn modified_identifier(&self, i: usize) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Let_pattern_plainContextAttrs<'input> for Let_pattern_plainContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_plain(&mut self) -> Result<Rc<Let_pattern_plainContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_plainContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_let_pattern_plain);
        let mut _localctx: Rc<Let_pattern_plainContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_identifier */
                recog.base.set_state(755);
                recog.modified_identifier()?;

                recog.base.set_state(760);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(96, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(756);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                /* InvokeRule modified_identifier */
                                recog.base.set_state(757);
                                recog.modified_identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(762);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(96, &mut recog.base)?;
                }
                recog.base.set_state(764);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COMMA {
                    {
                        recog.base.set_state(763);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_tuple ----------------
pub type Let_pattern_tupleContextAll<'input> = Let_pattern_tupleContext<'input>;

pub type Let_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Let_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_tuple }
}
antlr_rust::tid! {Let_pattern_tupleContextExt<'a>}

impl<'input> Let_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn let_pattern_item_all(&self) -> Vec<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_pattern_item(&self, i: usize) -> Option<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
}

impl<'input> Let_pattern_tupleContextAttrs<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_tuple(&mut self) -> Result<Rc<Let_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_let_pattern_tuple);
        let mut _localctx: Rc<Let_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(836);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(112, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(766);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(780);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(100, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(767);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(768);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                }
                            }

                            x if x == 2 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(770);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(773);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = 1;
                                    loop {
                                        match _alt {
                                            x if x == 1 => {
                                                {
                                                    recog.base.set_state(771);
                                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                    /* InvokeRule let_pattern_item */
                                                    recog.base.set_state(772);
                                                    recog.let_pattern_item()?;
                                                }
                                            }

                                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                        }
                                        recog.base.set_state(775);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = recog.interpreter.adaptive_predict(98, &mut recog.base)?;
                                        if _alt == 2 || _alt == INVALID_ALT {
                                            break;
                                        }
                                    }
                                    recog.base.set_state(778);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == COMMA {
                                        {
                                            recog.base.set_state(777);
                                            recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                        }
                                    }
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(782);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(783);
                        recog.namepath()?;

                        recog.base.set_state(784);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(796);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DECONSTRUCT
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(785);
                                recog.let_pattern_item()?;

                                recog.base.set_state(790);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(101, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(786);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(787);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(792);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(101, &mut recog.base)?;
                                }
                                recog.base.set_state(794);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(793);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(798);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(801);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(800);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(803);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(815);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DECONSTRUCT
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(804);
                                recog.let_pattern_item()?;

                                recog.base.set_state(809);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(105, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(805);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(806);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(811);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(105, &mut recog.base)?;
                                }
                                recog.base.set_state(813);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(812);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(817);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(819);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(818);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(821);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(833);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DECONSTRUCT
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(822);
                                recog.let_pattern_item()?;

                                recog.base.set_state(827);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(109, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(823);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(824);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(829);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(109, &mut recog.base)?;
                                }
                                recog.base.set_state(831);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(830);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(835);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_item ----------------
pub type Let_pattern_itemContextAll<'input> = Let_pattern_itemContext<'input>;

pub type Let_pattern_itemContext<'input> = BaseParserRuleContext<'input, Let_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_item }
}
antlr_rust::tid! {Let_pattern_itemContextExt<'a>}

impl<'input> Let_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Let_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Let_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_itemContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DECONSTRUCT
    /// Returns `None` if there is no child corresponding to token OP_DECONSTRUCT
    fn OP_DECONSTRUCT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DECONSTRUCT, 0)
    }
}

impl<'input> Let_pattern_itemContextAttrs<'input> for Let_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_item(&mut self) -> Result<Rc<Let_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_let_pattern_item);
        let mut _localctx: Rc<Let_pattern_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(868);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(119, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(841);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(113, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(838);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(839);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(846);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(114, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(843);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(844);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(848);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(852);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(115, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(849);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(850);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(857);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(116, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(854);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(855);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule identifier */
                        recog.base.set_state(859);
                        recog.identifier()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(861);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule modified_identifier */
                                recog.base.set_state(860);
                                recog.modified_identifier()?;
                            }
                        }

                        recog.base.set_state(863);
                        recog.base.match_token(OP_DECONSTRUCT, &mut recog.err_handler)?;

                        recog.base.set_state(865);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(864);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());
                            }
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(867);
                        recog.modified_identifier()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_type ----------------
pub type Define_typeContextAll<'input> = Define_typeContext<'input>;

pub type Define_typeContext<'input> = BaseParserRuleContext<'input, Define_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_type }
}
antlr_rust::tid! {Define_typeContextExt<'a>}

impl<'input> Define_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
}

impl<'input> Define_typeContextAttrs<'input> for Define_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_type(&mut self) -> Result<Rc<Define_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_define_type);
        let mut _localctx: Rc<Define_typeContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(870);
                recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(871);
                recog.identifier()?;

                recog.base.set_state(872);
                recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(873);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- type_hint ----------------
pub type Type_hintContextAll<'input> = Type_hintContext<'input>;

pub type Type_hintContext<'input> = BaseParserRuleContext<'input, Type_hintContextExt<'input>>;

#[derive(Clone)]
pub struct Type_hintContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_hintContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_hintContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_type_hint(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_type_hint(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_hintContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_type_hint(self);
    }
}

impl<'input> CustomRuleContext<'input> for Type_hintContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_hint
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_hint }
}
antlr_rust::tid! {Type_hintContextExt<'a>}

impl<'input> Type_hintContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_hintContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Type_hintContextExt { ph: PhantomData }))
    }
}

pub trait Type_hintContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Type_hintContextExt<'input>> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
}

impl<'input> Type_hintContextAttrs<'input> for Type_hintContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_hint(&mut self) -> Result<Rc<Type_hintContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Type_hintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_type_hint);
        let mut _localctx: Rc<Type_hintContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(875);
                _la = recog.base.input.la(1);
                if { !(_la == COLON || _la == OP_ARROW) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                /* InvokeRule type_expression */
                recog.base.set_state(876);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- effect_hint ----------------
pub type Effect_hintContextAll<'input> = Effect_hintContext<'input>;

pub type Effect_hintContext<'input> = BaseParserRuleContext<'input, Effect_hintContextExt<'input>>;

#[derive(Clone)]
pub struct Effect_hintContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Effect_hintContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Effect_hintContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_effect_hint(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_effect_hint(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Effect_hintContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_effect_hint(self);
    }
}

impl<'input> CustomRuleContext<'input> for Effect_hintContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_effect_hint
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_effect_hint }
}
antlr_rust::tid! {Effect_hintContextExt<'a>}

impl<'input> Effect_hintContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Effect_hintContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Effect_hintContextExt { ph: PhantomData }))
    }
}

pub trait Effect_hintContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Effect_hintContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Effect_hintContextAttrs<'input> for Effect_hintContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn effect_hint(&mut self) -> Result<Rc<Effect_hintContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Effect_hintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_effect_hint);
        let mut _localctx: Rc<Effect_hintContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(878);
                recog.base.match_token(OP_DIV, &mut recog.err_handler)?;

                /* InvokeRule type_expression */
                recog.base.set_state(879);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_statement ----------------
pub type If_statementContextAll<'input> = If_statementContext<'input>;

pub type If_statementContext<'input> = BaseParserRuleContext<'input, If_statementContextExt<'input>>;

#[derive(Clone)]
pub struct If_statementContextExt<'input> {
    pub then_block: Option<Rc<Function_blockContextAll<'input>>>,
    pub else_block: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_statement }
}
antlr_rust::tid! {If_statementContextExt<'a>}

impl<'input> If_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            If_statementContextExt { then_block: None, else_block: None, ph: PhantomData },
        ))
    }
}

pub trait If_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<If_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block_all(&self) -> Vec<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn function_block(&self, i: usize) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn else_if_statement_all(&self) -> Vec<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn else_if_statement(&self, i: usize) -> Option<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
}

impl<'input> If_statementContextAttrs<'input> for If_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_statement(&mut self) -> Result<Rc<If_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_if_statement);
        let mut _localctx: Rc<If_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(884);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(881);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(886);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(887);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(888);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(889);
                let tmp = recog.function_block()?;
                cast_mut::<_, If_statementContext>(&mut _localctx).then_block = Some(tmp.clone());

                recog.base.set_state(893);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(121, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule else_if_statement */
                                recog.base.set_state(890);
                                recog.else_if_statement()?;
                            }
                        }
                    }
                    recog.base.set_state(895);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(121, &mut recog.base)?;
                }
                recog.base.set_state(898);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(122, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(896);
                            recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                            /* InvokeRule function_block */
                            recog.base.set_state(897);
                            let tmp = recog.function_block()?;
                            cast_mut::<_, If_statementContext>(&mut _localctx).else_block = Some(tmp.clone());
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_let_statement ----------------
pub type If_let_statementContextAll<'input> = If_let_statementContext<'input>;

pub type If_let_statementContext<'input> = BaseParserRuleContext<'input, If_let_statementContextExt<'input>>;

#[derive(Clone)]
pub struct If_let_statementContextExt<'input> {
    pub then: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_let_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_let_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_let_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_let_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_let_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_let_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_let_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_let_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_let_statement }
}
antlr_rust::tid! {If_let_statementContextExt<'a>}

impl<'input> If_let_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_let_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            If_let_statementContextExt { then: None, ph: PhantomData },
        ))
    }
}

pub trait If_let_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<If_let_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> If_let_statementContextAttrs<'input> for If_let_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_let_statement(&mut self) -> Result<Rc<If_let_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_let_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_if_let_statement);
        let mut _localctx: Rc<If_let_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(903);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(900);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(905);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(906);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                recog.base.set_state(907);
                _la = recog.base.input.la(1);
                if { !(_la == KW_NOT || _la == KW_LET) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(911);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(124, &mut recog.base)? {
                    1 => {
                        {
                            /* InvokeRule let_pattern_tuple */
                            recog.base.set_state(908);
                            recog.let_pattern_tuple()?;
                        }
                    }
                    2 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(909);
                            recog.identifier()?;
                        }
                    }
                    3 => {
                        recog.base.set_state(910);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }

                    _ => {}
                }
                recog.base.set_state(913);
                recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(914);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(915);
                let tmp = recog.function_block()?;
                cast_mut::<_, If_let_statementContext>(&mut _localctx).then = Some(tmp.clone());
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- else_if_statement ----------------
pub type Else_if_statementContextAll<'input> = Else_if_statementContext<'input>;

pub type Else_if_statementContext<'input> = BaseParserRuleContext<'input, Else_if_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Else_if_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Else_if_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Else_if_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_else_if_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_else_if_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Else_if_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_else_if_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Else_if_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_else_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_else_if_statement }
}
antlr_rust::tid! {Else_if_statementContextExt<'a>}

impl<'input> Else_if_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Else_if_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Else_if_statementContextExt { ph: PhantomData }))
    }
}

pub trait Else_if_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Else_if_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Else_if_statementContextAttrs<'input> for Else_if_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn else_if_statement(&mut self) -> Result<Rc<Else_if_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Else_if_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_else_if_statement);
        let mut _localctx: Rc<Else_if_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(917);
                recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                recog.base.set_state(918);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(919);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(920);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- loop_statement ----------------
#[derive(Debug)]
pub enum Loop_statementContextAll<'input> {
    ForLoopContext(ForLoopContext<'input>),
    WhileLetContext(WhileLetContext<'input>),
    WhileLoopContext(WhileLoopContext<'input>),
    Error(Loop_statementContext<'input>),
}
antlr_rust::tid! {Loop_statementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Loop_statementContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Loop_statementContextAll<'input> {}

impl<'input> Deref for Loop_statementContextAll<'input> {
    type Target = dyn Loop_statementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Loop_statementContextAll::*;
        match self {
            ForLoopContext(inner) => inner,
            WhileLetContext(inner) => inner,
            WhileLoopContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Loop_statementContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Loop_statementContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Loop_statementContext<'input> = BaseParserRuleContext<'input, Loop_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Loop_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Loop_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Loop_statementContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Loop_statementContext<'input> {}

impl<'input> CustomRuleContext<'input> for Loop_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}
antlr_rust::tid! {Loop_statementContextExt<'a>}

impl<'input> Loop_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Loop_statementContextExt { ph: PhantomData },
        )))
    }
}

pub trait Loop_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Loop_statementContextExt<'input>>
{
}

impl<'input> Loop_statementContextAttrs<'input> for Loop_statementContext<'input> {}

pub type ForLoopContext<'input> = BaseParserRuleContext<'input, ForLoopContextExt<'input>>;

pub trait ForLoopContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_FOR
    /// Returns `None` if there is no child corresponding to token KW_FOR
    fn KW_FOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FOR, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn infix_in(&self) -> Option<Rc<Infix_inContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn if_guard(&self) -> Option<Rc<If_guardContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ForLoopContextAttrs<'input> for ForLoopContext<'input> {}

pub struct ForLoopContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ForLoopContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ForLoopContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ForLoopContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ForLoop(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ForLoop(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ForLoopContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ForLoop(self);
    }
}

impl<'input> CustomRuleContext<'input> for ForLoopContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for ForLoopContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for ForLoopContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for ForLoopContext<'input> {}

impl<'input> ForLoopContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::ForLoopContext(BaseParserRuleContext::copy_from(
            ctx,
            ForLoopContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type WhileLetContext<'input> = BaseParserRuleContext<'input, WhileLetContextExt<'input>>;

pub trait WhileLetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileLetContextAttrs<'input> for WhileLetContext<'input> {}

pub struct WhileLetContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileLetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileLetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileLetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileLet(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileLet(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileLetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileLet(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileLetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for WhileLetContext<'input> {}

impl<'input> WhileLetContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::WhileLetContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileLetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type WhileLoopContext<'input> = BaseParserRuleContext<'input, WhileLoopContextExt<'input>>;

pub trait WhileLoopContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileLoopContextAttrs<'input> for WhileLoopContext<'input> {}

pub struct WhileLoopContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileLoopContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileLoopContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileLoopContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileLoop(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileLoop(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileLoopContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileLoop(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileLoopContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for WhileLoopContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for WhileLoopContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for WhileLoopContext<'input> {}

impl<'input> WhileLoopContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::WhileLoopContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileLoopContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn loop_statement(&mut self) -> Result<Rc<Loop_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Loop_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_loop_statement);
        let mut _localctx: Rc<Loop_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(960);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(129, &mut recog.base)? {
                1 => {
                    let tmp = WhileLoopContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(925);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(922);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(927);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(928);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(929);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(930);
                        recog.function_block()?;
                    }
                }
                2 => {
                    let tmp = WhileLetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(935);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(932);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(937);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(938);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        recog.base.set_state(939);
                        recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                        /* InvokeRule let_pattern */
                        recog.base.set_state(940);
                        recog.let_pattern()?;

                        recog.base.set_state(941);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(942);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(943);
                        recog.function_block()?;
                    }
                }
                3 => {
                    let tmp = ForLoopContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(948);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(945);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(950);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(951);
                        recog.base.match_token(KW_FOR, &mut recog.err_handler)?;

                        /* InvokeRule let_pattern */
                        recog.base.set_state(952);
                        recog.let_pattern()?;

                        /* InvokeRule infix_in */
                        recog.base.set_state(953);
                        recog.infix_in()?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(954);
                        recog.inline_expression_rec(0)?;

                        recog.base.set_state(956);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                /* InvokeRule if_guard */
                                recog.base.set_state(955);
                                recog.if_guard()?;
                            }
                        }

                        /* InvokeRule function_block */
                        recog.base.set_state(958);
                        recog.function_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_guard ----------------
pub type If_guardContextAll<'input> = If_guardContext<'input>;

pub type If_guardContext<'input> = BaseParserRuleContext<'input, If_guardContextExt<'input>>;

#[derive(Clone)]
pub struct If_guardContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_guardContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_guardContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_guard(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_guard(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_guardContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_guard(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_guardContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_guard
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_guard }
}
antlr_rust::tid! {If_guardContextExt<'a>}

impl<'input> If_guardContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_guardContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, If_guardContextExt { ph: PhantomData }))
    }
}

pub trait If_guardContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<If_guardContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> If_guardContextAttrs<'input> for If_guardContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_guard(&mut self) -> Result<Rc<If_guardContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_guardContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_if_guard);
        let mut _localctx: Rc<If_guardContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(962);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(963);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression_root ----------------
pub type Expression_rootContextAll<'input> = Expression_rootContext<'input>;

pub type Expression_rootContext<'input> = BaseParserRuleContext<'input, Expression_rootContextExt<'input>>;

#[derive(Clone)]
pub struct Expression_rootContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Expression_rootContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Expression_rootContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_expression_root(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_expression_root(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Expression_rootContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_expression_root(self);
    }
}

impl<'input> CustomRuleContext<'input> for Expression_rootContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression_root
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression_root }
}
antlr_rust::tid! {Expression_rootContextExt<'a>}

impl<'input> Expression_rootContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Expression_rootContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Expression_rootContextExt { ph: PhantomData }))
    }
}

pub trait Expression_rootContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Expression_rootContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Expression_rootContextAttrs<'input> for Expression_rootContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression_root(&mut self) -> Result<Rc<Expression_rootContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Expression_rootContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_expression_root);
        let mut _localctx: Rc<Expression_rootContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(968);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(130, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule annotation */
                                recog.base.set_state(965);
                                recog.annotation()?;
                            }
                        }
                    }
                    recog.base.set_state(970);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(130, &mut recog.base)?;
                }
                /* InvokeRule expression */
                recog.base.set_state(971);
                recog.expression_rec(0)?;

                recog.base.set_state(973);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(131, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(972);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression ----------------
#[derive(Debug)]
pub enum ExpressionContextAll<'input> {
    EPipeContext(EPipeContext<'input>),
    ELambdaContext(ELambdaContext<'input>),
    EDotContext(EDotContext<'input>),
    EOrElseContext(EOrElseContext<'input>),
    EGroupContext(EGroupContext<'input>),
    EUntilContext(EUntilContext<'input>),
    ESuffixContext(ESuffixContext<'input>),
    EInContext(EInContext<'input>),
    E1Context(E1Context<'input>),
    EPlusContext(EPlusContext<'input>),
    ESliceContext(ESliceContext<'input>),
    EPrefixContext(EPrefixContext<'input>),
    ECompareContext(ECompareContext<'input>),
    EGenericContext(EGenericContext<'input>),
    EIsAContext(EIsAContext<'input>),
    EOffsetContext(EOffsetContext<'input>),
    EPowContext(EPowContext<'input>),
    EDotMatchContext(EDotMatchContext<'input>),
    EAsContext(EAsContext<'input>),
    EAssignContext(EAssignContext<'input>),
    ELogicContext(ELogicContext<'input>),
    EControlContext(EControlContext<'input>),
    EDotFunctionContext(EDotFunctionContext<'input>),
    EMulContext(EMulContext<'input>),
    Error(ExpressionContext<'input>),
}
antlr_rust::tid! {ExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ExpressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContextAll<'input> {}

impl<'input> Deref for ExpressionContextAll<'input> {
    type Target = dyn ExpressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use ExpressionContextAll::*;
        match self {
            EPipeContext(inner) => inner,
            ELambdaContext(inner) => inner,
            EDotContext(inner) => inner,
            EOrElseContext(inner) => inner,
            EGroupContext(inner) => inner,
            EUntilContext(inner) => inner,
            ESuffixContext(inner) => inner,
            EInContext(inner) => inner,
            E1Context(inner) => inner,
            EPlusContext(inner) => inner,
            ESliceContext(inner) => inner,
            EPrefixContext(inner) => inner,
            ECompareContext(inner) => inner,
            EGenericContext(inner) => inner,
            EIsAContext(inner) => inner,
            EOffsetContext(inner) => inner,
            EPowContext(inner) => inner,
            EDotMatchContext(inner) => inner,
            EAsContext(inner) => inner,
            EAssignContext(inner) => inner,
            ELogicContext(inner) => inner,
            EControlContext(inner) => inner,
            EDotFunctionContext(inner) => inner,
            EMulContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type ExpressionContext<'input> = BaseParserRuleContext<'input, ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid! {ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ExpressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait ExpressionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ExpressionContextExt<'input>> {}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input> {}

pub type EPipeContext<'input> = BaseParserRuleContext<'input, EPipeContextExt<'input>>;

pub trait EPipeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_pipeline(&self) -> Option<Rc<Op_pipelineContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EPipeContextAttrs<'input> for EPipeContext<'input> {}

pub struct EPipeContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPipeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPipeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPipeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPipe(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPipe(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPipeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPipe(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPipeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPipeContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPipeContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPipeContext<'input> {}

impl<'input> EPipeContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPipeContext(BaseParserRuleContext::copy_from(
            ctx,
            EPipeContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELambdaContext<'input> = BaseParserRuleContext<'input, ELambdaContextExt<'input>>;

pub trait ELambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn lambda_call(&self) -> Option<Rc<Lambda_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ELambdaContextAttrs<'input> for ELambdaContext<'input> {}

pub struct ELambdaContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELambdaContext<'input> {}

impl<'input> ELambdaContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            ELambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDotContext<'input> = BaseParserRuleContext<'input, EDotContextExt<'input>>;

pub trait EDotContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn dot_call(&self) -> Option<Rc<Dot_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDotContextAttrs<'input> for EDotContext<'input> {}

pub struct EDotContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDotContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDotContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDotContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDot(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDot(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDotContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDot(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDotContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDotContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDotContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDotContext<'input> {}

impl<'input> EDotContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDotContext(BaseParserRuleContext::copy_from(
            ctx,
            EDotContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EOrElseContext<'input> = BaseParserRuleContext<'input, EOrElseContextExt<'input>>;

pub trait EOrElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_OR_ELSE
    /// Returns `None` if there is no child corresponding to token OP_OR_ELSE
    fn OP_OR_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR_ELSE, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EOrElseContextAttrs<'input> for EOrElseContext<'input> {}

pub struct EOrElseContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EOrElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EOrElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EOrElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EOrElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EOrElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EOrElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EOrElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for EOrElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EOrElseContext<'input> {}

impl<'input> EOrElseContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EOrElseContext(BaseParserRuleContext::copy_from(
            ctx,
            EOrElseContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EGroupContext<'input> = BaseParserRuleContext<'input, EGroupContextExt<'input>>;

pub trait EGroupContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
}

impl<'input> EGroupContextAttrs<'input> for EGroupContext<'input> {}

pub struct EGroupContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EGroupContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EGroupContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EGroupContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EGroup(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EGroup(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EGroupContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EGroup(self);
    }
}

impl<'input> CustomRuleContext<'input> for EGroupContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EGroupContext<'input> {}

impl<'input> EGroupContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EGroupContext(BaseParserRuleContext::copy_from(
            ctx,
            EGroupContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EUntilContext<'input> = BaseParserRuleContext<'input, EUntilContextExt<'input>>;

pub trait EUntilContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EUntilContextAttrs<'input> for EUntilContext<'input> {}

pub struct EUntilContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EUntilContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EUntilContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EUntilContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EUntil(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EUntil(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EUntilContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EUntil(self);
    }
}

impl<'input> CustomRuleContext<'input> for EUntilContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EUntilContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EUntilContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EUntilContext<'input> {}

impl<'input> EUntilContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EUntilContext(BaseParserRuleContext::copy_from(
            ctx,
            EUntilContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESuffixContext<'input> = BaseParserRuleContext<'input, ESuffixContextExt<'input>>;

pub trait ESuffixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn op_suffix(&self) -> Option<Rc<Op_suffixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ESuffixContextAttrs<'input> for ESuffixContext<'input> {}

pub struct ESuffixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESuffixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESuffixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESuffixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESuffix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESuffix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESuffixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESuffix(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESuffixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESuffixContext<'input> {}

impl<'input> ESuffixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESuffixContext(BaseParserRuleContext::copy_from(
            ctx,
            ESuffixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EInContext<'input> = BaseParserRuleContext<'input, EInContextExt<'input>>;

pub trait EInContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_in(&self) -> Option<Rc<Infix_inContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EInContextAttrs<'input> for EInContext<'input> {}

pub struct EInContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EInContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EInContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EInContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIn(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIn(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EInContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIn(self);
    }
}

impl<'input> CustomRuleContext<'input> for EInContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EInContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EInContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EInContext<'input> {}

impl<'input> EInContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EInContext(BaseParserRuleContext::copy_from(
            ctx,
            EInContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type E1Context<'input> = BaseParserRuleContext<'input, E1ContextExt<'input>>;

pub trait E1ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn term_with_follow(&self) -> Option<Rc<Term_with_followContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> E1ContextAttrs<'input> for E1Context<'input> {}

pub struct E1ContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {E1ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for E1Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for E1Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_E1(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_E1(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for E1Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_E1(self);
    }
}

impl<'input> CustomRuleContext<'input> for E1ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for E1Context<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for E1Context<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for E1Context<'input> {}

impl<'input> E1ContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::E1Context(BaseParserRuleContext::copy_from(
            ctx,
            E1ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPlusContext<'input> = BaseParserRuleContext<'input, EPlusContextExt<'input>>;

pub trait EPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPlusContextAttrs<'input> for EPlusContext<'input> {}

pub struct EPlusContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPlusContext<'input> {}

impl<'input> EPlusContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            EPlusContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESliceContext<'input> = BaseParserRuleContext<'input, ESliceContextExt<'input>>;

pub trait ESliceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ESliceContextAttrs<'input> for ESliceContext<'input> {}

pub struct ESliceContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESliceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESliceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESliceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESlice(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESlice(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESliceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESlice(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESliceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESliceContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESliceContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESliceContext<'input> {}

impl<'input> ESliceContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESliceContext(BaseParserRuleContext::copy_from(
            ctx,
            ESliceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPrefixContext<'input> = BaseParserRuleContext<'input, EPrefixContextExt<'input>>;

pub trait EPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EPrefixContextAttrs<'input> for EPrefixContext<'input> {}

pub struct EPrefixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPrefixContext<'input> {}

impl<'input> EPrefixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            EPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ECompareContext<'input> = BaseParserRuleContext<'input, ECompareContextExt<'input>>;

pub trait ECompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ECompareContextAttrs<'input> for ECompareContext<'input> {}

pub struct ECompareContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ECompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ECompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ECompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ECompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ECompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ECompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ECompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ECompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ECompareContext<'input> {}

impl<'input> ECompareContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ECompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ECompareContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EGenericContext<'input> = BaseParserRuleContext<'input, EGenericContextExt<'input>>;

pub trait EGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call(&self) -> Option<Rc<Generic_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EGenericContextAttrs<'input> for EGenericContext<'input> {}

pub struct EGenericContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for EGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EGenericContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EGenericContext<'input> {}

impl<'input> EGenericContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            EGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EIsAContext<'input> = BaseParserRuleContext<'input, EIsAContextExt<'input>>;

pub trait EIsAContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_is(&self) -> Option<Rc<Infix_isContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EIsAContextAttrs<'input> for EIsAContext<'input> {}

pub struct EIsAContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EIsAContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EIsAContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EIsAContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIsA(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIsA(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EIsAContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIsA(self);
    }
}

impl<'input> CustomRuleContext<'input> for EIsAContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EIsAContext<'input> {}

impl<'input> EIsAContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EIsAContext(BaseParserRuleContext::copy_from(
            ctx,
            EIsAContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EOffsetContext<'input> = BaseParserRuleContext<'input, EOffsetContextExt<'input>>;

pub trait EOffsetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn offset_call(&self) -> Option<Rc<Offset_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EOffsetContextAttrs<'input> for EOffsetContext<'input> {}

pub struct EOffsetContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EOffsetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EOffsetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EOffsetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EOffset(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EOffset(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EOffsetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EOffset(self);
    }
}

impl<'input> CustomRuleContext<'input> for EOffsetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EOffsetContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EOffsetContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EOffsetContext<'input> {}

impl<'input> EOffsetContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EOffsetContext(BaseParserRuleContext::copy_from(
            ctx,
            EOffsetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPowContext<'input> = BaseParserRuleContext<'input, EPowContextExt<'input>>;

pub trait EPowContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_POW
    /// Returns `None` if there is no child corresponding to token OP_POW
    fn OP_POW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_POW, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPowContextAttrs<'input> for EPowContext<'input> {}

pub struct EPowContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPowContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPowContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPowContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPow(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPow(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPowContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPow(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPowContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPowContext<'input> {}

impl<'input> EPowContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPowContext(BaseParserRuleContext::copy_from(
            ctx,
            EPowContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDotMatchContext<'input> = BaseParserRuleContext<'input, EDotMatchContextExt<'input>>;

pub trait EDotMatchContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_call(&self) -> Option<Rc<Match_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDotMatchContextAttrs<'input> for EDotMatchContext<'input> {}

pub struct EDotMatchContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDotMatchContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDotMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDotMatchContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDotMatch(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDotMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDotMatchContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDotMatch(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDotMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDotMatchContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDotMatchContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDotMatchContext<'input> {}

impl<'input> EDotMatchContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDotMatchContext(BaseParserRuleContext::copy_from(
            ctx,
            EDotMatchContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAsContext<'input> = BaseParserRuleContext<'input, EAsContextExt<'input>>;

pub trait EAsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EAsContextAttrs<'input> for EAsContext<'input> {}

pub struct EAsContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAs(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAsContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAsContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAsContext<'input> {}

impl<'input> EAsContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAsContext(BaseParserRuleContext::copy_from(
            ctx,
            EAsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAssignContext<'input> = BaseParserRuleContext<'input, EAssignContextExt<'input>>;

pub trait EAssignContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_assign(&self) -> Option<Rc<Op_assignContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EAssignContextAttrs<'input> for EAssignContext<'input> {}

pub struct EAssignContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAssignContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAssignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAssignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAssign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAssign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAssignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAssign(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAssignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAssignContext<'input> {}

impl<'input> EAssignContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAssignContext(BaseParserRuleContext::copy_from(
            ctx,
            EAssignContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELogicContext<'input> = BaseParserRuleContext<'input, ELogicContextExt<'input>>;

pub trait ELogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ELogicContextAttrs<'input> for ELogicContext<'input> {}

pub struct ELogicContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELogicContext<'input> {}

impl<'input> ELogicContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ELogicContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EControlContext<'input> = BaseParserRuleContext<'input, EControlContextExt<'input>>;

pub trait EControlContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn control_expression(&self) -> Option<Rc<Control_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EControlContextAttrs<'input> for EControlContext<'input> {}

pub struct EControlContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EControlContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EControlContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EControlContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EControl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EControl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EControlContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EControl(self);
    }
}

impl<'input> CustomRuleContext<'input> for EControlContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EControlContext<'input> {}

impl<'input> EControlContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EControlContext(BaseParserRuleContext::copy_from(
            ctx,
            EControlContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDotFunctionContext<'input> = BaseParserRuleContext<'input, EDotFunctionContextExt<'input>>;

pub trait EDotFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDotFunctionContextAttrs<'input> for EDotFunctionContext<'input> {}

pub struct EDotFunctionContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDotFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDotFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDotFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDotFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDotFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDotFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDotFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDotFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDotFunctionContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDotFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDotFunctionContext<'input> {}

impl<'input> EDotFunctionContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDotFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            EDotFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMulContext<'input> = BaseParserRuleContext<'input, EMulContextExt<'input>>;

pub trait EMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EMulContextAttrs<'input> for EMulContext<'input> {}

pub struct EMulContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMulContext<'input> {}

impl<'input> EMulContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMulContext(BaseParserRuleContext::copy_from(
            ctx,
            EMulContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression(&mut self) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        self.expression_rec(0)
    }

    fn expression_rec(&mut self, _p: isize) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 114, RULE_expression, _p);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 114;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(985);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(132, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = EPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(976);
                            recog.op_prefix()?;

                            /* InvokeRule expression */
                            recog.base.set_state(977);
                            recog.expression_rec(4)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = EGroupContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(979);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(980);
                            recog.expression_rec(0)?;

                            recog.base.set_state(981);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = EControlContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule control_expression */
                            recog.base.set_state(983);
                            recog.control_expression()?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = E1ContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule term_with_follow */
                            recog.base.set_state(984);
                            recog.term_with_follow()?;
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1049);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(134, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1047);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(133, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EPowContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EPowContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(987);
                                        if !({ recog.precpred(None, 24) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 24)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(988);
                                        recog.base.match_token(OP_POW, &mut recog.err_handler)?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(989);
                                        let tmp = recog.expression_rec(24)?;
                                        if let ExpressionContextAll::EPowContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EMulContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EMulContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(990);
                                        if !({ recog.precpred(None, 23) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 23)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(991);
                                        recog.op_multiple()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(992);
                                        let tmp = recog.expression_rec(24)?;
                                        if let ExpressionContextAll::EMulContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EPlusContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EPlusContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(994);
                                        if !({ recog.precpred(None, 22) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 22)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(995);
                                        recog.op_plus()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(996);
                                        let tmp = recog.expression_rec(23)?;
                                        if let ExpressionContextAll::EPlusContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ELogicContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::ELogicContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(998);
                                        if !({ recog.precpred(None, 21) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 21)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(999);
                                        recog.op_logic()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1000);
                                        let tmp = recog.expression_rec(22)?;
                                        if let ExpressionContextAll::ELogicContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ECompareContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::ECompareContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1002);
                                        if !({ recog.precpred(None, 20) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 20)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1003);
                                        recog.op_compare()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1004);
                                        let tmp = recog.expression_rec(21)?;
                                        if let ExpressionContextAll::ECompareContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EUntilContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EUntilContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1006);
                                        if !({ recog.precpred(None, 19) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 19)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1007);
                                        recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1008);
                                        let tmp = recog.expression_rec(20)?;
                                        if let ExpressionContextAll::EUntilContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EInContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EInContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1009);
                                        if !({ recog.precpred(None, 16) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 16)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_in */
                                        recog.base.set_state(1010);
                                        recog.infix_in()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1011);
                                        let tmp = recog.expression_rec(17)?;
                                        if let ExpressionContextAll::EInContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EIsAContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EIsAContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1013);
                                        if !({ recog.precpred(None, 18) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 18)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_is */
                                        recog.base.set_state(1014);
                                        recog.infix_is()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1015);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EIsAContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EAsContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EAsContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1017);
                                        if !({ recog.precpred(None, 17) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 17)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1018);
                                        recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1019);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EAsContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                10 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EAssignContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EAssignContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1020);
                                        if !({ recog.precpred(None, 15) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 15)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_assign */
                                        recog.base.set_state(1021);
                                        recog.op_assign()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1022);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EAssignContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                11 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EOrElseContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EOrElseContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1024);
                                        if !({ recog.precpred(None, 14) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 14)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1025);
                                        recog.base.match_token(OP_OR_ELSE, &mut recog.err_handler)?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1026);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EOrElseContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                12 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EPipeContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EPipeContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1027);
                                        if !({ recog.precpred(None, 13) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 13)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_pipeline */
                                        recog.base.set_state(1028);
                                        recog.op_pipeline()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1029);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EPipeContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                13 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ESuffixContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1031);
                                        if !({ recog.precpred(None, 12) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 12)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_suffix */
                                        recog.base.set_state(1032);
                                        recog.op_suffix()?;
                                    }
                                }
                                14 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ESliceContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1033);
                                        if !({ recog.precpred(None, 11) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 11)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule slice_call */
                                        recog.base.set_state(1034);
                                        recog.slice_call()?;
                                    }
                                }
                                15 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EOffsetContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1035);
                                        if !({ recog.precpred(None, 10) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 10)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule offset_call */
                                        recog.base.set_state(1036);
                                        recog.offset_call()?;
                                    }
                                }
                                16 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EGenericContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1037);
                                        if !({ recog.precpred(None, 9) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 9)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call */
                                        recog.base.set_state(1038);
                                        recog.generic_call()?;
                                    }
                                }
                                17 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ELambdaContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1039);
                                        if !({ recog.precpred(None, 8) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 8)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule lambda_call */
                                        recog.base.set_state(1040);
                                        recog.lambda_call()?;
                                    }
                                }
                                18 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EDotMatchContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1041);
                                        if !({ recog.precpred(None, 7) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 7)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule match_call */
                                        recog.base.set_state(1042);
                                        recog.match_call()?;
                                    }
                                }
                                19 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EDotFunctionContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1043);
                                        if !({ recog.precpred(None, 6) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 6)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule function_call */
                                        recog.base.set_state(1044);
                                        recog.function_call()?;
                                    }
                                }
                                20 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EDotContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1045);
                                        if !({ recog.precpred(None, 5) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 5)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule dot_call */
                                        recog.base.set_state(1046);
                                        recog.dot_call()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1051);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(134, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- term_with_follow ----------------
#[derive(Debug)]
pub enum Term_with_followContextAll<'input> {
    SIfContext(SIfContext<'input>),
    ETryContext(ETryContext<'input>),
    EFunctionContext(EFunctionContext<'input>),
    EDefineContext(EDefineContext<'input>),
    EObjectContext(EObjectContext<'input>),
    ETupleContext(ETupleContext<'input>),
    ERangeContext(ERangeContext<'input>),
    EMatchContext(EMatchContext<'input>),
    ENewContext(ENewContext<'input>),
    E2Context(E2Context<'input>),
    EMacroContext(EMacroContext<'input>),
    Error(Term_with_followContext<'input>),
}
antlr_rust::tid! {Term_with_followContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Term_with_followContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Term_with_followContextAll<'input> {}

impl<'input> Deref for Term_with_followContextAll<'input> {
    type Target = dyn Term_with_followContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Term_with_followContextAll::*;
        match self {
            SIfContext(inner) => inner,
            ETryContext(inner) => inner,
            EFunctionContext(inner) => inner,
            EDefineContext(inner) => inner,
            EObjectContext(inner) => inner,
            ETupleContext(inner) => inner,
            ERangeContext(inner) => inner,
            EMatchContext(inner) => inner,
            ENewContext(inner) => inner,
            E2Context(inner) => inner,
            EMacroContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Term_with_followContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Term_with_followContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Term_with_followContext<'input> = BaseParserRuleContext<'input, Term_with_followContextExt<'input>>;

#[derive(Clone)]
pub struct Term_with_followContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Term_with_followContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Term_with_followContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Term_with_followContext<'input> {}

impl<'input> CustomRuleContext<'input> for Term_with_followContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}
antlr_rust::tid! {Term_with_followContextExt<'a>}

impl<'input> Term_with_followContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Term_with_followContextExt { ph: PhantomData },
        )))
    }
}

pub trait Term_with_followContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Term_with_followContextExt<'input>>
{
}

impl<'input> Term_with_followContextAttrs<'input> for Term_with_followContext<'input> {}

pub type SIfContext<'input> = BaseParserRuleContext<'input, SIfContextExt<'input>>;

pub trait SIfContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn if_statement(&self) -> Option<Rc<If_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> SIfContextAttrs<'input> for SIfContext<'input> {}

pub struct SIfContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SIfContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SIfContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SIfContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SIf(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SIf(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SIfContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SIf(self);
    }
}

impl<'input> CustomRuleContext<'input> for SIfContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for SIfContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for SIfContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for SIfContext<'input> {}

impl<'input> SIfContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::SIfContext(BaseParserRuleContext::copy_from(
            ctx,
            SIfContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ETryContext<'input> = BaseParserRuleContext<'input, ETryContextExt<'input>>;

pub trait ETryContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn try_statement(&self) -> Option<Rc<Try_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ETryContextAttrs<'input> for ETryContext<'input> {}

pub struct ETryContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ETryContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ETryContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ETryContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ETry(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ETry(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ETryContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ETry(self);
    }
}

impl<'input> CustomRuleContext<'input> for ETryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for ETryContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for ETryContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for ETryContext<'input> {}

impl<'input> ETryContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::ETryContext(BaseParserRuleContext::copy_from(
            ctx,
            ETryContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EFunctionContext<'input> = BaseParserRuleContext<'input, EFunctionContextExt<'input>>;

pub trait EFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EFunctionContextAttrs<'input> for EFunctionContext<'input> {}

pub struct EFunctionContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for EFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for EFunctionContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for EFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for EFunctionContext<'input> {}

impl<'input> EFunctionContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::EFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            EFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDefineContext<'input> = BaseParserRuleContext<'input, EDefineContextExt<'input>>;

pub trait EDefineContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_label(&self) -> Option<Rc<Define_labelContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDefineContextAttrs<'input> for EDefineContext<'input> {}

pub struct EDefineContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDefineContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDefineContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDefineContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDefine(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDefine(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDefineContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDefine(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDefineContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for EDefineContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for EDefineContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for EDefineContext<'input> {}

impl<'input> EDefineContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::EDefineContext(BaseParserRuleContext::copy_from(
            ctx,
            EDefineContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EObjectContext<'input> = BaseParserRuleContext<'input, EObjectContextExt<'input>>;

pub trait EObjectContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn object_statement(&self) -> Option<Rc<Object_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EObjectContextAttrs<'input> for EObjectContext<'input> {}

pub struct EObjectContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EObjectContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EObjectContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EObjectContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EObject(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EObject(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EObjectContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EObject(self);
    }
}

impl<'input> CustomRuleContext<'input> for EObjectContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for EObjectContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for EObjectContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for EObjectContext<'input> {}

impl<'input> EObjectContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::EObjectContext(BaseParserRuleContext::copy_from(
            ctx,
            EObjectContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ETupleContext<'input> = BaseParserRuleContext<'input, ETupleContextExt<'input>>;

pub trait ETupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn tuple_literal(&self) -> Option<Rc<Tuple_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ETupleContextAttrs<'input> for ETupleContext<'input> {}

pub struct ETupleContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ETupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ETupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ETupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ETuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ETuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ETupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ETuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for ETupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for ETupleContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for ETupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for ETupleContext<'input> {}

impl<'input> ETupleContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::ETupleContext(BaseParserRuleContext::copy_from(
            ctx,
            ETupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ERangeContext<'input> = BaseParserRuleContext<'input, ERangeContextExt<'input>>;

pub trait ERangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ERangeContextAttrs<'input> for ERangeContext<'input> {}

pub struct ERangeContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ERangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ERangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ERangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ERange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ERange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ERangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ERange(self);
    }
}

impl<'input> CustomRuleContext<'input> for ERangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for ERangeContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for ERangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for ERangeContext<'input> {}

impl<'input> ERangeContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::ERangeContext(BaseParserRuleContext::copy_from(
            ctx,
            ERangeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMatchContext<'input> = BaseParserRuleContext<'input, EMatchContextExt<'input>>;

pub trait EMatchContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn match_statement(&self) -> Option<Rc<Match_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMatchContextAttrs<'input> for EMatchContext<'input> {}

pub struct EMatchContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMatchContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMatchContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMatch(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMatchContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMatch(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for EMatchContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for EMatchContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for EMatchContext<'input> {}

impl<'input> EMatchContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::EMatchContext(BaseParserRuleContext::copy_from(
            ctx,
            EMatchContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ENewContext<'input> = BaseParserRuleContext<'input, ENewContextExt<'input>>;

pub trait ENewContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn new_statement(&self) -> Option<Rc<New_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ENewContextAttrs<'input> for ENewContext<'input> {}

pub struct ENewContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ENewContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ENewContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ENewContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ENew(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ENew(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ENewContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ENew(self);
    }
}

impl<'input> CustomRuleContext<'input> for ENewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for ENewContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for ENewContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for ENewContext<'input> {}

impl<'input> ENewContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::ENewContext(BaseParserRuleContext::copy_from(
            ctx,
            ENewContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type E2Context<'input> = BaseParserRuleContext<'input, E2ContextExt<'input>>;

pub trait E2ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> E2ContextAttrs<'input> for E2Context<'input> {}

pub struct E2ContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {E2ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for E2Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for E2Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_E2(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_E2(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for E2Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_E2(self);
    }
}

impl<'input> CustomRuleContext<'input> for E2ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for E2Context<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for E2Context<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for E2Context<'input> {}

impl<'input> E2ContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::E2Context(BaseParserRuleContext::copy_from(
            ctx,
            E2ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMacroContext<'input> = BaseParserRuleContext<'input, EMacroContextExt<'input>>;

pub trait EMacroContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn macro_call(&self) -> Option<Rc<Macro_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMacroContextAttrs<'input> for EMacroContext<'input> {}

pub struct EMacroContextExt<'input> {
    base: Term_with_followContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMacroContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMacroContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMacroContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMacro(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMacro(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMacroContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMacro(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMacroContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_term_with_follow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_term_with_follow }
}

impl<'input> Borrow<Term_with_followContextExt<'input>> for EMacroContext<'input> {
    fn borrow(&self) -> &Term_with_followContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Term_with_followContextExt<'input>> for EMacroContext<'input> {
    fn borrow_mut(&mut self) -> &mut Term_with_followContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Term_with_followContextAttrs<'input> for EMacroContext<'input> {}

impl<'input> EMacroContextExt<'input> {
    fn new(ctx: &dyn Term_with_followContextAttrs<'input>) -> Rc<Term_with_followContextAll<'input>> {
        Rc::new(Term_with_followContextAll::EMacroContext(BaseParserRuleContext::copy_from(
            ctx,
            EMacroContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn term_with_follow(&mut self) -> Result<Rc<Term_with_followContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Term_with_followContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_term_with_follow);
        let mut _localctx: Rc<Term_with_followContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1063);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(135, &mut recog.base)? {
                1 => {
                    let tmp = SIfContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule if_statement */
                        recog.base.set_state(1052);
                        recog.if_statement()?;
                    }
                }
                2 => {
                    let tmp = ENewContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /* InvokeRule new_statement */
                        recog.base.set_state(1053);
                        recog.new_statement()?;
                    }
                }
                3 => {
                    let tmp = ETryContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule try_statement */
                        recog.base.set_state(1054);
                        recog.try_statement()?;
                    }
                }
                4 => {
                    let tmp = EMatchContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /* InvokeRule match_statement */
                        recog.base.set_state(1055);
                        recog.match_statement()?;
                    }
                }
                5 => {
                    let tmp = EObjectContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        /* InvokeRule object_statement */
                        recog.base.set_state(1056);
                        recog.object_statement()?;
                    }
                }
                6 => {
                    let tmp = EMacroContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        /* InvokeRule macro_call */
                        recog.base.set_state(1057);
                        recog.macro_call()?;
                    }
                }
                7 => {
                    let tmp = EFunctionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        /* InvokeRule function_call */
                        recog.base.set_state(1058);
                        recog.function_call()?;
                    }
                }
                8 => {
                    let tmp = EDefineContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 8);
                    _localctx = tmp;
                    {
                        /* InvokeRule define_label */
                        recog.base.set_state(1059);
                        recog.define_label()?;
                    }
                }
                9 => {
                    let tmp = ETupleContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 9);
                    _localctx = tmp;
                    {
                        /* InvokeRule tuple_literal */
                        recog.base.set_state(1060);
                        recog.tuple_literal()?;
                    }
                }
                10 => {
                    let tmp = ERangeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 10);
                    _localctx = tmp;
                    {
                        /* InvokeRule range_literal */
                        recog.base.set_state(1061);
                        recog.range_literal()?;
                    }
                }
                11 => {
                    let tmp = E2ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 11);
                    _localctx = tmp;
                    {
                        /* InvokeRule atomic */
                        recog.base.set_state(1062);
                        recog.atomic()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- inline_expression ----------------
#[derive(Debug)]
pub enum Inline_expressionContextAll<'input> {
    ILogicContext(ILogicContext<'input>),
    IDotContext(IDotContext<'input>),
    IRangeContext(IRangeContext<'input>),
    IMulContext(IMulContext<'input>),
    IPlusContext(IPlusContext<'input>),
    ICompareContext(ICompareContext<'input>),
    IAsContext(IAsContext<'input>),
    IPrefixContext(IPrefixContext<'input>),
    IIsAContext(IIsAContext<'input>),
    E3Context(E3Context<'input>),
    ISliceContext(ISliceContext<'input>),
    Error(Inline_expressionContext<'input>),
}
antlr_rust::tid! {Inline_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Inline_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContextAll<'input> {}

impl<'input> Deref for Inline_expressionContextAll<'input> {
    type Target = dyn Inline_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Inline_expressionContextAll::*;
        match self {
            ILogicContext(inner) => inner,
            IDotContext(inner) => inner,
            IRangeContext(inner) => inner,
            IMulContext(inner) => inner,
            IPlusContext(inner) => inner,
            ICompareContext(inner) => inner,
            IAsContext(inner) => inner,
            IPrefixContext(inner) => inner,
            IIsAContext(inner) => inner,
            E3Context(inner) => inner,
            ISliceContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Inline_expressionContext<'input> = BaseParserRuleContext<'input, Inline_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Inline_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Inline_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}
antlr_rust::tid! {Inline_expressionContextExt<'a>}

impl<'input> Inline_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Inline_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Inline_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Inline_expressionContextExt<'input>>
{
}

impl<'input> Inline_expressionContextAttrs<'input> for Inline_expressionContext<'input> {}

pub type ILogicContext<'input> = BaseParserRuleContext<'input, ILogicContextExt<'input>>;

pub trait ILogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ILogicContextAttrs<'input> for ILogicContext<'input> {}

pub struct ILogicContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ILogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ILogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ILogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ILogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ILogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ILogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ILogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ILogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ILogicContext<'input> {}

impl<'input> ILogicContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ILogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ILogicContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IDotContext<'input> = BaseParserRuleContext<'input, IDotContextExt<'input>>;

pub trait IDotContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn dot_call(&self) -> Option<Rc<Dot_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IDotContextAttrs<'input> for IDotContext<'input> {}

pub struct IDotContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IDotContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IDotContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IDotContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IDot(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IDot(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IDotContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IDot(self);
    }
}

impl<'input> CustomRuleContext<'input> for IDotContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IDotContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IDotContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IDotContext<'input> {}

impl<'input> IDotContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IDotContext(BaseParserRuleContext::copy_from(
            ctx,
            IDotContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IRangeContext<'input> = BaseParserRuleContext<'input, IRangeContextExt<'input>>;

pub trait IRangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IRangeContextAttrs<'input> for IRangeContext<'input> {}

pub struct IRangeContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IRangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IRangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IRangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IRange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IRange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IRangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IRange(self);
    }
}

impl<'input> CustomRuleContext<'input> for IRangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IRangeContext<'input> {}

impl<'input> IRangeContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IRangeContext(BaseParserRuleContext::copy_from(
            ctx,
            IRangeContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IMulContext<'input> = BaseParserRuleContext<'input, IMulContextExt<'input>>;

pub trait IMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IMulContextAttrs<'input> for IMulContext<'input> {}

pub struct IMulContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for IMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IMulContext<'input> {}

impl<'input> IMulContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IMulContext(BaseParserRuleContext::copy_from(
            ctx,
            IMulContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPlusContext<'input> = BaseParserRuleContext<'input, IPlusContextExt<'input>>;

pub trait IPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IPlusContextAttrs<'input> for IPlusContext<'input> {}

pub struct IPlusContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPlusContext<'input> {}

impl<'input> IPlusContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            IPlusContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ICompareContext<'input> = BaseParserRuleContext<'input, ICompareContextExt<'input>>;

pub trait ICompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ICompareContextAttrs<'input> for ICompareContext<'input> {}

pub struct ICompareContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ICompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ICompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ICompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ICompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ICompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ICompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ICompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ICompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ICompareContext<'input> {}

impl<'input> ICompareContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ICompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ICompareContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IAsContext<'input> = BaseParserRuleContext<'input, IAsContextExt<'input>>;

pub trait IAsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IAsContextAttrs<'input> for IAsContext<'input> {}

pub struct IAsContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IAsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IAsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IAsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IAs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IAs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IAsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IAs(self);
    }
}

impl<'input> CustomRuleContext<'input> for IAsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IAsContext<'input> {}

impl<'input> IAsContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IAsContext(BaseParserRuleContext::copy_from(
            ctx,
            IAsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPrefixContext<'input> = BaseParserRuleContext<'input, IPrefixContextExt<'input>>;

pub trait IPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IPrefixContextAttrs<'input> for IPrefixContext<'input> {}

pub struct IPrefixContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPrefixContext<'input> {}

impl<'input> IPrefixContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            IPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IIsAContext<'input> = BaseParserRuleContext<'input, IIsAContextExt<'input>>;

pub trait IIsAContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_is(&self) -> Option<Rc<Infix_isContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IIsAContextAttrs<'input> for IIsAContext<'input> {}

pub struct IIsAContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IIsAContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IIsAContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IIsAContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IIsA(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IIsA(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IIsAContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IIsA(self);
    }
}

impl<'input> CustomRuleContext<'input> for IIsAContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IIsAContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IIsAContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IIsAContext<'input> {}

impl<'input> IIsAContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IIsAContext(BaseParserRuleContext::copy_from(
            ctx,
            IIsAContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type E3Context<'input> = BaseParserRuleContext<'input, E3ContextExt<'input>>;

pub trait E3ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> E3ContextAttrs<'input> for E3Context<'input> {}

pub struct E3ContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {E3ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for E3Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for E3Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_E3(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_E3(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for E3Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_E3(self);
    }
}

impl<'input> CustomRuleContext<'input> for E3ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for E3Context<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for E3Context<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for E3Context<'input> {}

impl<'input> E3ContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::E3Context(BaseParserRuleContext::copy_from(
            ctx,
            E3ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ISliceContext<'input> = BaseParserRuleContext<'input, ISliceContextExt<'input>>;

pub trait ISliceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ISliceContextAttrs<'input> for ISliceContext<'input> {}

pub struct ISliceContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ISliceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ISliceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ISliceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ISlice(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ISlice(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ISliceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ISlice(self);
    }
}

impl<'input> CustomRuleContext<'input> for ISliceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ISliceContext<'input> {}

impl<'input> ISliceContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ISliceContext(BaseParserRuleContext::copy_from(
            ctx,
            ISliceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn inline_expression(&mut self) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        self.inline_expression_rec(0)
    }

    fn inline_expression_rec(&mut self, _p: isize) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Inline_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 118, RULE_inline_expression, _p);
        let mut _localctx: Rc<Inline_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 118;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1070);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    OP_ADD | OP_SUB | OP_MUL | OP_AND | OP_NOT | OP_DECONSTRUCT | OP_INVERSE | OP_ROOTS | OP_REFERENCE => {
                        {
                            let mut tmp = IPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(1066);
                            recog.op_prefix()?;

                            /* InvokeRule inline_expression */
                            recog.base.set_state(1067);
                            recog.inline_expression_rec(2)?;
                        }
                    }

                    LAMBDA_SLOT | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK | SPECIAL | RAW_ID
                    | UNICODE_ID => {
                        {
                            let mut tmp = E3ContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1069);
                            recog.atomic()?;
                        }
                    }

                    _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1104);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(138, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1102);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(137, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IMulContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IMulContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1072);
                                        if !({ recog.precpred(None, 11) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 11)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(1073);
                                        recog.op_multiple()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1074);
                                        let tmp = recog.inline_expression_rec(12)?;
                                        if let Inline_expressionContextAll::IMulContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IPlusContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IPlusContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1076);
                                        if !({ recog.precpred(None, 10) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 10)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(1077);
                                        recog.op_plus()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1078);
                                        let tmp = recog.inline_expression_rec(11)?;
                                        if let Inline_expressionContextAll::IPlusContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ILogicContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::ILogicContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1080);
                                        if !({ recog.precpred(None, 9) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 9)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(1081);
                                        recog.op_logic()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1082);
                                        let tmp = recog.inline_expression_rec(10)?;
                                        if let Inline_expressionContextAll::ILogicContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ICompareContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::ICompareContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1084);
                                        if !({ recog.precpred(None, 8) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 8)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1085);
                                        recog.op_compare()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1086);
                                        let tmp = recog.inline_expression_rec(9)?;
                                        if let Inline_expressionContextAll::ICompareContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IIsAContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IIsAContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1088);
                                        if !({ recog.precpred(None, 7) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 7)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_is */
                                        recog.base.set_state(1089);
                                        recog.infix_is()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1090);
                                        let tmp = recog.inline_expression_rec(8)?;
                                        if let Inline_expressionContextAll::IIsAContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IRangeContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IRangeContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1092);
                                        if !({ recog.precpred(None, 6) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 6)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1093);
                                        recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1094);
                                        let tmp = recog.inline_expression_rec(7)?;
                                        if let Inline_expressionContextAll::IRangeContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IAsContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IAsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1095);
                                        if !({ recog.precpred(None, 5) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 5)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1096);
                                        recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1097);
                                        let tmp = recog.inline_expression_rec(6)?;
                                        if let Inline_expressionContextAll::IAsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IDotContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1098);
                                        if !({ recog.precpred(None, 4) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 4)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule dot_call */
                                        recog.base.set_state(1099);
                                        recog.dot_call()?;
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ISliceContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1100);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule slice_call */
                                        recog.base.set_state(1101);
                                        recog.slice_call()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1106);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(138, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- type_expression ----------------
#[derive(Debug)]
pub enum Type_expressionContextAll<'input> {
    TGenericContext(TGenericContext<'input>),
    TPatternContext(TPatternContext<'input>),
    TTupleContext(TTupleContext<'input>),
    TAddContext(TAddContext<'input>),
    TArrowsContext(TArrowsContext<'input>),
    E4Context(E4Context<'input>),
    Error(Type_expressionContext<'input>),
}
antlr_rust::tid! {Type_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Type_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContextAll<'input> {}

impl<'input> Deref for Type_expressionContextAll<'input> {
    type Target = dyn Type_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Type_expressionContextAll::*;
        match self {
            TGenericContext(inner) => inner,
            TPatternContext(inner) => inner,
            TTupleContext(inner) => inner,
            TAddContext(inner) => inner,
            TArrowsContext(inner) => inner,
            E4Context(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Type_expressionContext<'input> = BaseParserRuleContext<'input, Type_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Type_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Type_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}
antlr_rust::tid! {Type_expressionContextExt<'a>}

impl<'input> Type_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Type_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Type_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Type_expressionContextExt<'input>>
{
}

impl<'input> Type_expressionContextAttrs<'input> for Type_expressionContext<'input> {}

pub type TGenericContext<'input> = BaseParserRuleContext<'input, TGenericContextExt<'input>>;

pub trait TGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TGenericContextAttrs<'input> for TGenericContext<'input> {}

pub struct TGenericContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for TGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TGenericContext<'input> {}

impl<'input> TGenericContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            TGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TPatternContext<'input> = BaseParserRuleContext<'input, TPatternContextExt<'input>>;

pub trait TPatternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_pattern(&self) -> Option<Rc<Op_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TPatternContextAttrs<'input> for TPatternContext<'input> {}

pub struct TPatternContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TPatternContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TPatternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TPattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TPattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TPatternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TPattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for TPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TPatternContext<'input> {}

impl<'input> TPatternContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TPatternContext(BaseParserRuleContext::copy_from(
            ctx,
            TPatternContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TTupleContext<'input> = BaseParserRuleContext<'input, TTupleContextExt<'input>>;

pub trait TTupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> TTupleContextAttrs<'input> for TTupleContext<'input> {}

pub struct TTupleContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TTupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TTupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TTupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TTuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TTuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TTupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TTuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for TTupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TTupleContext<'input> {}

impl<'input> TTupleContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TTupleContext(BaseParserRuleContext::copy_from(
            ctx,
            TTupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TAddContext<'input> = BaseParserRuleContext<'input, TAddContextExt<'input>>;

pub trait TAddContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> TAddContextAttrs<'input> for TAddContext<'input> {}

pub struct TAddContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TAddContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TAddContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TAddContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TAdd(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TAdd(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TAddContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TAdd(self);
    }
}

impl<'input> CustomRuleContext<'input> for TAddContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TAddContext<'input> {}

impl<'input> TAddContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TAddContext(BaseParserRuleContext::copy_from(
            ctx,
            TAddContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TArrowsContext<'input> = BaseParserRuleContext<'input, TArrowsContextExt<'input>>;

pub trait TArrowsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn infix_arrows(&self) -> Option<Rc<Infix_arrowsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TArrowsContextAttrs<'input> for TArrowsContext<'input> {}

pub struct TArrowsContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TArrowsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TArrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TArrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TArrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TArrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TArrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TArrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for TArrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TArrowsContext<'input> {}

impl<'input> TArrowsContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TArrowsContext(BaseParserRuleContext::copy_from(
            ctx,
            TArrowsContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type E4Context<'input> = BaseParserRuleContext<'input, E4ContextExt<'input>>;

pub trait E4ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> E4ContextAttrs<'input> for E4Context<'input> {}

pub struct E4ContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {E4ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for E4Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for E4Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_E4(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_E4(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for E4Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_E4(self);
    }
}

impl<'input> CustomRuleContext<'input> for E4ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for E4Context<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for E4Context<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for E4Context<'input> {}

impl<'input> E4ContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::E4Context(BaseParserRuleContext::copy_from(
            ctx,
            E4ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_expression(&mut self) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        self.type_expression_rec(0)
    }

    fn type_expression_rec(&mut self, _p: isize) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Type_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 120, RULE_type_expression, _p);
        let mut _localctx: Rc<Type_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 120;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1126);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    PARENTHESES_L => {
                        {
                            let mut tmp = TTupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            recog.base.set_state(1108);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            recog.base.set_state(1122);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(141, &mut recog.base)? {
                                x if x == 1 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1109);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1110);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }

                                x if x == 2 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1112);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1115);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = 1;
                                        loop {
                                            match _alt {
                                                x if x == 1 => {
                                                    {
                                                        recog.base.set_state(1113);
                                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                        /* InvokeRule type_expression */
                                                        recog.base.set_state(1114);
                                                        recog.type_expression_rec(0)?;
                                                    }
                                                }

                                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                            }
                                            recog.base.set_state(1117);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _alt = recog.interpreter.adaptive_predict(139, &mut recog.base)?;
                                            if _alt == 2 || _alt == INVALID_ALT {
                                                break;
                                            }
                                        }
                                        recog.base.set_state(1120);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == COMMA {
                                            {
                                                recog.base.set_state(1119);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                            }
                                        }
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(1124);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }

                    LAMBDA_SLOT | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK | SPECIAL | RAW_ID
                    | UNICODE_ID => {
                        {
                            let mut tmp = E4ContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1125);
                            recog.atomic()?;
                        }
                    }

                    _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1143);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(144, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1141);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(143, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TPatternContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1128);
                                        if !({ recog.precpred(None, 6) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 6)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_pattern */
                                        recog.base.set_state(1129);
                                        recog.op_pattern()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1130);
                                        recog.type_expression_rec(7)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TArrowsContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1132);
                                        if !({ recog.precpred(None, 5) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 5)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_arrows */
                                        recog.base.set_state(1133);
                                        recog.infix_arrows()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1134);
                                        recog.type_expression_rec(6)?;
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TAddContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1136);
                                        if !({ recog.precpred(None, 4) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 4)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1137);
                                        recog.base.match_token(OP_ADD, &mut recog.err_handler)?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1138);
                                        recog.type_expression_rec(5)?;
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TGenericContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1139);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call_in_type */
                                        recog.base.set_state(1140);
                                        recog.generic_call_in_type()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1145);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(144, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- atomic ----------------
#[derive(Debug)]
pub enum AtomicContextAll<'input> {
    ASpecialContext(ASpecialContext<'input>),
    ALambdaContext(ALambdaContext<'input>),
    ANumberContext(ANumberContext<'input>),
    AStringContext(AStringContext<'input>),
    ANamepathContext(ANamepathContext<'input>),
    Error(AtomicContext<'input>),
}
antlr_rust::tid! {AtomicContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for AtomicContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for AtomicContextAll<'input> {}

impl<'input> Deref for AtomicContextAll<'input> {
    type Target = dyn AtomicContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use AtomicContextAll::*;
        match self {
            ASpecialContext(inner) => inner,
            ALambdaContext(inner) => inner,
            ANumberContext(inner) => inner,
            AStringContext(inner) => inner,
            ANamepathContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AtomicContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AtomicContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type AtomicContext<'input> = BaseParserRuleContext<'input, AtomicContextExt<'input>>;

#[derive(Clone)]
pub struct AtomicContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for AtomicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AtomicContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AtomicContext<'input> {}

impl<'input> CustomRuleContext<'input> for AtomicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}
antlr_rust::tid! {AtomicContextExt<'a>}

impl<'input> AtomicContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            AtomicContextExt { ph: PhantomData },
        )))
    }
}

pub trait AtomicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<AtomicContextExt<'input>> {}

impl<'input> AtomicContextAttrs<'input> for AtomicContext<'input> {}

pub type ASpecialContext<'input> = BaseParserRuleContext<'input, ASpecialContextExt<'input>>;

pub trait ASpecialContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> ASpecialContextAttrs<'input> for ASpecialContext<'input> {}

pub struct ASpecialContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ASpecialContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ASpecialContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ASpecialContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ASpecial(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ASpecial(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ASpecialContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ASpecial(self);
    }
}

impl<'input> CustomRuleContext<'input> for ASpecialContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ASpecialContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ASpecialContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ASpecialContext<'input> {}

impl<'input> ASpecialContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ASpecialContext(BaseParserRuleContext::copy_from(
            ctx,
            ASpecialContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ALambdaContext<'input> = BaseParserRuleContext<'input, ALambdaContextExt<'input>>;

pub trait ALambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn lambda_name(&self) -> Option<Rc<Lambda_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ALambdaContextAttrs<'input> for ALambdaContext<'input> {}

pub struct ALambdaContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ALambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ALambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ALambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ALambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ALambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ALambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ALambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for ALambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ALambdaContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ALambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ALambdaContext<'input> {}

impl<'input> ALambdaContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ALambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            ALambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ANumberContext<'input> = BaseParserRuleContext<'input, ANumberContextExt<'input>>;

pub trait ANumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ANumberContextAttrs<'input> for ANumberContext<'input> {}

pub struct ANumberContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ANumberContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ANumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ANumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ANumber(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ANumber(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ANumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ANumber(self);
    }
}

impl<'input> CustomRuleContext<'input> for ANumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ANumberContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ANumberContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ANumberContext<'input> {}

impl<'input> ANumberContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ANumberContext(BaseParserRuleContext::copy_from(
            ctx,
            ANumberContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type AStringContext<'input> = BaseParserRuleContext<'input, AStringContextExt<'input>>;

pub trait AStringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AStringContextAttrs<'input> for AStringContext<'input> {}

pub struct AStringContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AStringContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for AStringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AStringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_AString(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_AString(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AStringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_AString(self);
    }
}

impl<'input> CustomRuleContext<'input> for AStringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for AStringContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for AStringContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for AStringContext<'input> {}

impl<'input> AStringContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::AStringContext(BaseParserRuleContext::copy_from(
            ctx,
            AStringContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ANamepathContext<'input> = BaseParserRuleContext<'input, ANamepathContextExt<'input>>;

pub trait ANamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ANamepathContextAttrs<'input> for ANamepathContext<'input> {}

pub struct ANamepathContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ANamepathContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ANamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ANamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ANamepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ANamepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ANamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ANamepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for ANamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ANamepathContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ANamepathContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ANamepathContext<'input> {}

impl<'input> ANamepathContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ANamepathContext(BaseParserRuleContext::copy_from(
            ctx,
            ANamepathContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn atomic(&mut self) -> Result<Rc<AtomicContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = AtomicContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_atomic);
        let mut _localctx: Rc<AtomicContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1151);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(145, &mut recog.base)? {
                1 => {
                    let tmp = AStringContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule string_literal */
                        recog.base.set_state(1146);
                        recog.string_literal()?;
                    }
                }
                2 => {
                    let tmp = ANumberContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /* InvokeRule number_literal */
                        recog.base.set_state(1147);
                        recog.number_literal()?;
                    }
                }
                3 => {
                    let tmp = ALambdaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule lambda_name */
                        recog.base.set_state(1148);
                        recog.lambda_name()?;
                    }
                }
                4 => {
                    let tmp = ANamepathContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1149);
                        recog.namepath()?;
                    }
                }
                5 => {
                    let tmp = ASpecialContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1150);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_prefix ----------------
pub type Op_prefixContextAll<'input> = Op_prefixContext<'input>;

pub type Op_prefixContext<'input> = BaseParserRuleContext<'input, Op_prefixContextExt<'input>>;

#[derive(Clone)]
pub struct Op_prefixContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_prefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_prefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_prefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_prefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_prefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_prefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_prefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_prefix
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_prefix }
}
antlr_rust::tid! {Op_prefixContextExt<'a>}

impl<'input> Op_prefixContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_prefixContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_prefixContextExt { ph: PhantomData }))
    }
}

pub trait Op_prefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_prefixContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_NOT
    /// Returns `None` if there is no child corresponding to token OP_NOT
    fn OP_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REFERENCE
    /// Returns `None` if there is no child corresponding to token OP_REFERENCE
    fn OP_REFERENCE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REFERENCE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DECONSTRUCT
    /// Returns `None` if there is no child corresponding to token OP_DECONSTRUCT
    fn OP_DECONSTRUCT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DECONSTRUCT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_INVERSE
    /// Returns `None` if there is no child corresponding to token OP_INVERSE
    fn OP_INVERSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_INVERSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOTS
    /// Returns `None` if there is no child corresponding to token OP_ROOTS
    fn OP_ROOTS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOTS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Op_prefixContextAttrs<'input> for Op_prefixContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_prefix(&mut self) -> Result<Rc<Op_prefixContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_prefixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_op_prefix);
        let mut _localctx: Rc<Op_prefixContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1153);
                _la = recog.base.input.la(1);
                if {
                    !((((_la) & !0x3f) == 0
                        && ((1usize << _la) & ((1usize << OP_ADD) | (1usize << OP_SUB) | (1usize << OP_MUL))) != 0)
                        || (((_la - 65) & !0x3f) == 0
                            && ((1usize << (_la - 65))
                                & ((1usize << (OP_AND - 65))
                                    | (1usize << (OP_NOT - 65))
                                    | (1usize << (OP_DECONSTRUCT - 65))
                                    | (1usize << (OP_INVERSE - 65))
                                    | (1usize << (OP_ROOTS - 65))
                                    | (1usize << (OP_REFERENCE - 65))))
                                != 0))
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_suffix ----------------
pub type Op_suffixContextAll<'input> = Op_suffixContext<'input>;

pub type Op_suffixContext<'input> = BaseParserRuleContext<'input, Op_suffixContextExt<'input>>;

#[derive(Clone)]
pub struct Op_suffixContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_suffixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_suffixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_suffix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_suffix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_suffixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_suffix(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_suffixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_suffix
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_suffix }
}
antlr_rust::tid! {Op_suffixContextExt<'a>}

impl<'input> Op_suffixContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_suffixContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_suffixContextExt { ph: PhantomData }))
    }
}

pub trait Op_suffixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_suffixContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_NOT
    /// Returns `None` if there is no child corresponding to token OP_NOT
    fn OP_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TEMPERATURE
    /// Returns `None` if there is no child corresponding to token OP_TEMPERATURE
    fn OP_TEMPERATURE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TEMPERATURE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TRANSPOSE
    /// Returns `None` if there is no child corresponding to token OP_TRANSPOSE
    fn OP_TRANSPOSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TRANSPOSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PERCENT
    /// Returns `None` if there is no child corresponding to token OP_PERCENT
    fn OP_PERCENT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PERCENT, 0)
    }
}

impl<'input> Op_suffixContextAttrs<'input> for Op_suffixContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_suffix(&mut self) -> Result<Rc<Op_suffixContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_suffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_op_suffix);
        let mut _localctx: Rc<Op_suffixContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1155);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 77) & !0x3f) == 0
                        && ((1usize << (_la - 77))
                            & ((1usize << (OP_NOT - 77))
                                | (1usize << (OP_TEMPERATURE - 77))
                                | (1usize << (OP_TRANSPOSE - 77))
                                | (1usize << (OP_PERCENT - 77))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- control_expression ----------------
#[derive(Debug)]
pub enum Control_expressionContextAll<'input> {
    CBreakContext(CBreakContext<'input>),
    CWithContext(CWithContext<'input>),
    CYieldContext(CYieldContext<'input>),
    CReturnContext(CReturnContext<'input>),
    CRaiseContext(CRaiseContext<'input>),
    CContinueContext(CContinueContext<'input>),
    Error(Control_expressionContext<'input>),
}
antlr_rust::tid! {Control_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Control_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Control_expressionContextAll<'input> {}

impl<'input> Deref for Control_expressionContextAll<'input> {
    type Target = dyn Control_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Control_expressionContextAll::*;
        match self {
            CBreakContext(inner) => inner,
            CWithContext(inner) => inner,
            CYieldContext(inner) => inner,
            CReturnContext(inner) => inner,
            CRaiseContext(inner) => inner,
            CContinueContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Control_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Control_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Control_expressionContext<'input> = BaseParserRuleContext<'input, Control_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Control_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Control_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Control_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Control_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Control_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}
antlr_rust::tid! {Control_expressionContextExt<'a>}

impl<'input> Control_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Control_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Control_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Control_expressionContextExt<'input>>
{
}

impl<'input> Control_expressionContextAttrs<'input> for Control_expressionContext<'input> {}

pub type CBreakContext<'input> = BaseParserRuleContext<'input, CBreakContextExt<'input>>;

pub trait CBreakContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BREAK
    /// Returns `None` if there is no child corresponding to token BREAK
    fn BREAK(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BREAK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
}

impl<'input> CBreakContextAttrs<'input> for CBreakContext<'input> {}

pub struct CBreakContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CBreakContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CBreakContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CBreakContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CBreak(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CBreak(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CBreakContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CBreak(self);
    }
}

impl<'input> CustomRuleContext<'input> for CBreakContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CBreakContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CBreakContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CBreakContext<'input> {}

impl<'input> CBreakContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CBreakContext(BaseParserRuleContext::copy_from(
            ctx,
            CBreakContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CWithContext<'input> = BaseParserRuleContext<'input, CWithContextExt<'input>>;

pub trait CWithContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CWithContextAttrs<'input> for CWithContext<'input> {}

pub struct CWithContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CWithContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CWithContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CWithContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CWith(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CWithContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CWith(self);
    }
}

impl<'input> CustomRuleContext<'input> for CWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CWithContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CWithContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CWithContext<'input> {}

impl<'input> CWithContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CWithContext(BaseParserRuleContext::copy_from(
            ctx,
            CWithContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CYieldContext<'input> = BaseParserRuleContext<'input, CYieldContextExt<'input>>;

pub trait CYieldContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CYieldContextAttrs<'input> for CYieldContext<'input> {}

pub struct CYieldContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CYieldContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CYieldContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CYieldContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CYield(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CYield(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CYieldContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CYield(self);
    }
}

impl<'input> CustomRuleContext<'input> for CYieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CYieldContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CYieldContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CYieldContext<'input> {}

impl<'input> CYieldContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CYieldContext(BaseParserRuleContext::copy_from(
            ctx,
            CYieldContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CReturnContext<'input> = BaseParserRuleContext<'input, CReturnContextExt<'input>>;

pub trait CReturnContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token RETURN
    /// Returns `None` if there is no child corresponding to token RETURN
    fn RETURN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESUME
    /// Returns `None` if there is no child corresponding to token RESUME
    fn RESUME(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESUME, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CReturnContextAttrs<'input> for CReturnContext<'input> {}

pub struct CReturnContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CReturnContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CReturnContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CReturnContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CReturn(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CReturn(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CReturnContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CReturn(self);
    }
}

impl<'input> CustomRuleContext<'input> for CReturnContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CReturnContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CReturnContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CReturnContext<'input> {}

impl<'input> CReturnContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CReturnContext(BaseParserRuleContext::copy_from(
            ctx,
            CReturnContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CRaiseContext<'input> = BaseParserRuleContext<'input, CRaiseContextExt<'input>>;

pub trait CRaiseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token RAISE
    /// Returns `None` if there is no child corresponding to token RAISE
    fn RAISE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAISE, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CRaiseContextAttrs<'input> for CRaiseContext<'input> {}

pub struct CRaiseContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CRaiseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CRaiseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CRaiseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CRaise(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CRaise(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CRaiseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CRaise(self);
    }
}

impl<'input> CustomRuleContext<'input> for CRaiseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CRaiseContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CRaiseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CRaiseContext<'input> {}

impl<'input> CRaiseContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CRaiseContext(BaseParserRuleContext::copy_from(
            ctx,
            CRaiseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CContinueContext<'input> = BaseParserRuleContext<'input, CContinueContextExt<'input>>;

pub trait CContinueContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CONTINUE
    /// Returns `None` if there is no child corresponding to token CONTINUE
    fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CONTINUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CContinueContextAttrs<'input> for CContinueContext<'input> {}

pub struct CContinueContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CContinueContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CContinueContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CContinueContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CContinue(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CContinue(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CContinueContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CContinue(self);
    }
}

impl<'input> CustomRuleContext<'input> for CContinueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CContinueContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CContinueContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CContinueContext<'input> {}

impl<'input> CContinueContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CContinueContext(BaseParserRuleContext::copy_from(
            ctx,
            CContinueContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn control_expression(&mut self) -> Result<Rc<Control_expressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Control_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_control_expression);
        let mut _localctx: Rc<Control_expressionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1189);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(152, &mut recog.base)? {
                1 => {
                    let tmp = CReturnContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1162);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            RETURN => {
                                recog.base.set_state(1157);
                                recog.base.match_token(RETURN, &mut recog.err_handler)?;
                            }

                            RESUME => {
                                {
                                    recog.base.set_state(1158);
                                    recog.base.match_token(RESUME, &mut recog.err_handler)?;

                                    recog.base.set_state(1160);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    match recog.interpreter.adaptive_predict(146, &mut recog.base)? {
                                        x if x == 1 => {
                                            {
                                                /* InvokeRule expression */
                                                recog.base.set_state(1159);
                                                recog.expression_rec(0)?;
                                            }
                                        }

                                        _ => {}
                                    }
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                2 => {
                    let tmp = CBreakContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1164);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;

                        recog.base.set_state(1167);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(148, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1165);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1166);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                3 => {
                    let tmp = CContinueContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1169);
                        recog.base.match_token(CONTINUE, &mut recog.err_handler)?;

                        recog.base.set_state(1172);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(149, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1170);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1171);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    let tmp = CRaiseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1174);
                        recog.base.match_token(RAISE, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1175);
                        recog.expression_rec(0)?;
                    }
                }
                5 => {
                    let tmp = CYieldContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1176);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1179);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(150, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1177);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1178);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(1182);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(151, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule expression */
                                    recog.base.set_state(1181);
                                    recog.expression_rec(0)?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                6 => {
                    let tmp = CBreakContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1184);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1185);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    let tmp = CWithContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1186);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1187);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1188);
                        recog.expression_rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_compare ----------------
pub type Op_compareContextAll<'input> = Op_compareContext<'input>;

pub type Op_compareContext<'input> = BaseParserRuleContext<'input, Op_compareContextExt<'input>>;

#[derive(Clone)]
pub struct Op_compareContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_compareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_compareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_compare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_compare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_compareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_compare(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_compareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_compare
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_compare }
}
antlr_rust::tid! {Op_compareContextExt<'a>}

impl<'input> Op_compareContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_compareContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_compareContextExt { ph: PhantomData }))
    }
}

pub trait Op_compareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_compareContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LEQ
    /// Returns `None` if there is no child corresponding to token OP_LEQ
    fn OP_LEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GEQ
    /// Returns `None` if there is no child corresponding to token OP_GEQ
    fn OP_GEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_EQ
    /// Returns `None` if there is no child corresponding to token OP_EQ
    fn OP_EQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_EQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NE
    /// Returns `None` if there is no child corresponding to token OP_NE
    fn OP_NE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_EEE
    /// Returns `None` if there is no child corresponding to token OP_EEE
    fn OP_EEE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_EEE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NEE
    /// Returns `None` if there is no child corresponding to token OP_NEE
    fn OP_NEE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NEE, 0)
    }
}

impl<'input> Op_compareContextAttrs<'input> for Op_compareContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_compare(&mut self) -> Result<Rc<Op_compareContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_compareContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_op_compare);
        let mut _localctx: Rc<Op_compareContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1191);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 32) & !0x3f) == 0
                        && ((1usize << (_la - 32))
                            & ((1usize << (OP_EQ - 32))
                                | (1usize << (OP_NE - 32))
                                | (1usize << (OP_NEE - 32))
                                | (1usize << (OP_EEE - 32))
                                | (1usize << (OP_LEQ - 32))
                                | (1usize << (OP_LT - 32))
                                | (1usize << (OP_GEQ - 32))
                                | (1usize << (OP_GT - 32))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_pattern ----------------
pub type Op_patternContextAll<'input> = Op_patternContext<'input>;

pub type Op_patternContext<'input> = BaseParserRuleContext<'input, Op_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Op_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_pattern }
}
antlr_rust::tid! {Op_patternContextExt<'a>}

impl<'input> Op_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_patternContextExt { ph: PhantomData }))
    }
}

pub trait Op_patternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_patternContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
}

impl<'input> Op_patternContextAttrs<'input> for Op_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_pattern(&mut self) -> Result<Rc<Op_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_op_pattern);
        let mut _localctx: Rc<Op_patternContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1193);
                _la = recog.base.input.la(1);
                if { !(_la == OP_AND || _la == OP_OR) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_arrows ----------------
pub type Infix_arrowsContextAll<'input> = Infix_arrowsContext<'input>;

pub type Infix_arrowsContext<'input> = BaseParserRuleContext<'input, Infix_arrowsContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_arrowsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_arrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_arrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_arrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_arrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_arrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_arrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_arrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_arrows
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_arrows }
}
antlr_rust::tid! {Infix_arrowsContextExt<'a>}

impl<'input> Infix_arrowsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_arrowsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_arrowsContextExt { ph: PhantomData }))
    }
}

pub trait Infix_arrowsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_arrowsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW2
    /// Returns `None` if there is no child corresponding to token OP_ARROW2
    fn OP_ARROW2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW2, 0)
    }
}

impl<'input> Infix_arrowsContextAttrs<'input> for Infix_arrowsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_arrows(&mut self) -> Result<Rc<Infix_arrowsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_arrowsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_infix_arrows);
        let mut _localctx: Rc<Infix_arrowsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1195);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ARROW || _la == OP_ARROW2) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_multiple ----------------
pub type Op_multipleContextAll<'input> = Op_multipleContext<'input>;

pub type Op_multipleContext<'input> = BaseParserRuleContext<'input, Op_multipleContextExt<'input>>;

#[derive(Clone)]
pub struct Op_multipleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_multipleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_multipleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_multiple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_multiple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_multipleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_multiple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_multipleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_multiple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_multiple }
}
antlr_rust::tid! {Op_multipleContextExt<'a>}

impl<'input> Op_multipleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_multipleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_multipleContextExt { ph: PhantomData }))
    }
}

pub trait Op_multipleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Op_multipleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV_REM
    /// Returns `None` if there is no child corresponding to token OP_DIV_REM
    fn OP_DIV_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV_REM, 0)
    }
}

impl<'input> Op_multipleContextAttrs<'input> for Op_multipleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_multiple(&mut self) -> Result<Rc<Op_multipleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_multipleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_op_multiple);
        let mut _localctx: Rc<Op_multipleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1197);
                _la = recog.base.input.la(1);
                if {
                    !(((_la) & !0x3f) == 0
                        && ((1usize << _la) & ((1usize << OP_MUL) | (1usize << OP_DIV) | (1usize << OP_DIV_REM))) != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_plus ----------------
pub type Op_plusContextAll<'input> = Op_plusContext<'input>;

pub type Op_plusContext<'input> = BaseParserRuleContext<'input, Op_plusContextExt<'input>>;

#[derive(Clone)]
pub struct Op_plusContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_plusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_plusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_plus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_plus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_plusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_plus(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_plusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_plus
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_plus }
}
antlr_rust::tid! {Op_plusContextExt<'a>}

impl<'input> Op_plusContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_plusContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_plusContextExt { ph: PhantomData }))
    }
}

pub trait Op_plusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_plusContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
}

impl<'input> Op_plusContextAttrs<'input> for Op_plusContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_plus(&mut self) -> Result<Rc<Op_plusContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_plusContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_op_plus);
        let mut _localctx: Rc<Op_plusContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1199);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ADD || _la == OP_SUB) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_logic ----------------
pub type Op_logicContextAll<'input> = Op_logicContext<'input>;

pub type Op_logicContext<'input> = BaseParserRuleContext<'input, Op_logicContextExt<'input>>;

#[derive(Clone)]
pub struct Op_logicContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_logicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_logicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_logic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_logic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_logicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_logic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_logicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_logic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_logic }
}
antlr_rust::tid! {Op_logicContextExt<'a>}

impl<'input> Op_logicContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_logicContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_logicContextExt { ph: PhantomData }))
    }
}

pub trait Op_logicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_logicContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token LOGIC_OR
    /// Returns `None` if there is no child corresponding to token LOGIC_OR
    fn LOGIC_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_AND
    /// Returns `None` if there is no child corresponding to token LOGIC_AND
    fn LOGIC_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_XOR
    /// Returns `None` if there is no child corresponding to token LOGIC_XOR
    fn LOGIC_XOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_XOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NOR
    /// Returns `None` if there is no child corresponding to token LOGIC_NOR
    fn LOGIC_NOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NAND
    /// Returns `None` if there is no child corresponding to token LOGIC_NAND
    fn LOGIC_NAND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NAND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_XAND
    /// Returns `None` if there is no child corresponding to token LOGIC_XAND
    fn LOGIC_XAND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_XAND, 0)
    }
}

impl<'input> Op_logicContextAttrs<'input> for Op_logicContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_logic(&mut self) -> Result<Rc<Op_logicContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_logicContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_op_logic);
        let mut _localctx: Rc<Op_logicContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1201);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 57) & !0x3f) == 0
                        && ((1usize << (_la - 57))
                            & ((1usize << (LOGIC_AND - 57))
                                | (1usize << (LOGIC_XAND - 57))
                                | (1usize << (LOGIC_NAND - 57))
                                | (1usize << (LOGIC_OR - 57))
                                | (1usize << (LOGIC_XOR - 57))
                                | (1usize << (LOGIC_NOR - 57))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_pipeline ----------------
pub type Op_pipelineContextAll<'input> = Op_pipelineContext<'input>;

pub type Op_pipelineContext<'input> = BaseParserRuleContext<'input, Op_pipelineContextExt<'input>>;

#[derive(Clone)]
pub struct Op_pipelineContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_pipelineContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_pipelineContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_pipeline(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_pipeline(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_pipelineContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_pipeline(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_pipelineContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_pipeline
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_pipeline }
}
antlr_rust::tid! {Op_pipelineContextExt<'a>}

impl<'input> Op_pipelineContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_pipelineContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_pipelineContextExt { ph: PhantomData }))
    }
}

pub trait Op_pipelineContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Op_pipelineContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LL
    /// Returns `None` if there is no child corresponding to token OP_LL
    fn OP_LL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LLE
    /// Returns `None` if there is no child corresponding to token OP_LLE
    fn OP_LLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LLL
    /// Returns `None` if there is no child corresponding to token OP_LLL
    fn OP_LLL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LLL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GG
    /// Returns `None` if there is no child corresponding to token OP_GG
    fn OP_GG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GGE
    /// Returns `None` if there is no child corresponding to token OP_GGE
    fn OP_GGE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GGE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GGG
    /// Returns `None` if there is no child corresponding to token OP_GGG
    fn OP_GGG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GGG, 0)
    }
}

impl<'input> Op_pipelineContextAttrs<'input> for Op_pipelineContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_pipeline(&mut self) -> Result<Rc<Op_pipelineContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_pipelineContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_op_pipeline);
        let mut _localctx: Rc<Op_pipelineContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1203);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 37) & !0x3f) == 0
                        && ((1usize << (_la - 37))
                            & ((1usize << (OP_LLE - 37))
                                | (1usize << (OP_LLL - 37))
                                | (1usize << (OP_LL - 37))
                                | (1usize << (OP_GGE - 37))
                                | (1usize << (OP_GGG - 37))
                                | (1usize << (OP_GG - 37))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_assign ----------------
pub type Op_assignContextAll<'input> = Op_assignContext<'input>;

pub type Op_assignContext<'input> = BaseParserRuleContext<'input, Op_assignContextExt<'input>>;

#[derive(Clone)]
pub struct Op_assignContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_assignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_assignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_assign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_assign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_assignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_assign(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_assignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_assign
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_assign }
}
antlr_rust::tid! {Op_assignContextExt<'a>}

impl<'input> Op_assignContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_assignContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_assignContextExt { ph: PhantomData }))
    }
}

pub trait Op_assignContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_assignContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ADD_ASSIGN
    fn OP_ADD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_SUB_ASSIGN
    fn OP_SUB_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MUL_ASSIGN
    fn OP_MUL_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_DIV_ASSIGN
    fn OP_DIV_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MAY_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MAY_ASSIGN
    fn OP_MAY_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MAY_ASSIGN, 0)
    }
}

impl<'input> Op_assignContextAttrs<'input> for Op_assignContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_assign(&mut self) -> Result<Rc<Op_assignContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_assignContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_op_assign);
        let mut _localctx: Rc<Op_assignContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1205);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 49) & !0x3f) == 0
                        && ((1usize << (_la - 49))
                            & ((1usize << (OP_ASSIGN - 49))
                                | (1usize << (OP_MAY_ASSIGN - 49))
                                | (1usize << (OP_ADD_ASSIGN - 49))
                                | (1usize << (OP_SUB_ASSIGN - 49))
                                | (1usize << (OP_MUL_ASSIGN - 49))
                                | (1usize << (OP_DIV_ASSIGN - 49))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_is ----------------
pub type Infix_isContextAll<'input> = Infix_isContext<'input>;

pub type Infix_isContext<'input> = BaseParserRuleContext<'input, Infix_isContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_isContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_isContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_isContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_is(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_is(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_isContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_is(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_isContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_is
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_is }
}
antlr_rust::tid! {Infix_isContextExt<'a>}

impl<'input> Infix_isContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_isContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_isContextExt { ph: PhantomData }))
    }
}

pub trait Infix_isContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_isContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IS
    /// Returns `None` if there is no child corresponding to token KW_IS
    fn KW_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IS
    /// Returns `None` if there is no child corresponding to token OP_IS
    fn OP_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IS_NOT
    /// Returns `None` if there is no child corresponding to token OP_IS_NOT
    fn OP_IS_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IS_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_CONTINUES
    /// Returns `None` if there is no child corresponding to token OP_CONTINUES
    fn OP_CONTINUES(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_CONTINUES, 0)
    }
}

impl<'input> Infix_isContextAttrs<'input> for Infix_isContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_is(&mut self) -> Result<Rc<Infix_isContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_isContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_infix_is);
        let mut _localctx: Rc<Infix_isContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1213);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(153, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1207);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1208);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;

                        recog.base.set_state(1209);
                        recog.base.match_token(KW_NOT, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1210);
                        recog.base.match_token(OP_IS, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1211);
                        recog.base.match_token(OP_IS_NOT, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1212);
                        recog.base.match_token(OP_CONTINUES, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_in ----------------
pub type Infix_inContextAll<'input> = Infix_inContext<'input>;

pub type Infix_inContext<'input> = BaseParserRuleContext<'input, Infix_inContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_inContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_inContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_inContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_in(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_in(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_inContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_in(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_inContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_in
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_in }
}
antlr_rust::tid! {Infix_inContextExt<'a>}

impl<'input> Infix_inContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_inContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_inContextExt { ph: PhantomData }))
    }
}

pub trait Infix_inContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_inContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IN
    /// Returns `None` if there is no child corresponding to token KW_IN
    fn KW_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IN
    /// Returns `None` if there is no child corresponding to token OP_IN
    fn OP_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NOT_IN
    /// Returns `None` if there is no child corresponding to token OP_NOT_IN
    fn OP_NOT_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT_IN, 0)
    }
}

impl<'input> Infix_inContextAttrs<'input> for Infix_inContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_in(&mut self) -> Result<Rc<Infix_inContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_inContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_infix_in);
        let mut _localctx: Rc<Infix_inContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1220);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                KW_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1215);
                        recog.base.match_token(KW_IN, &mut recog.err_handler)?;
                    }
                }

                KW_NOT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1216);
                        recog.base.match_token(KW_NOT, &mut recog.err_handler)?;

                        recog.base.set_state(1217);
                        recog.base.match_token(KW_IN, &mut recog.err_handler)?;
                    }
                }

                OP_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1218);
                        recog.base.match_token(OP_IN, &mut recog.err_handler)?;
                    }
                }

                OP_NOT_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1219);
                        recog.base.match_token(OP_NOT_IN, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_generic ----------------
pub type Define_genericContextAll<'input> = Define_genericContext<'input>;

pub type Define_genericContext<'input> = BaseParserRuleContext<'input, Define_genericContextExt<'input>>;

#[derive(Clone)]
pub struct Define_genericContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_genericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_genericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_generic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_generic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_genericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_generic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_genericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_generic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_generic }
}
antlr_rust::tid! {Define_genericContextExt<'a>}

impl<'input> Define_genericContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_genericContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_genericContextExt { ph: PhantomData }))
    }
}

pub trait Define_genericContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_genericContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
    fn generic_item_all(&self) -> Vec<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_item(&self, i: usize) -> Option<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
}

impl<'input> Define_genericContextAttrs<'input> for Define_genericContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_generic(&mut self) -> Result<Rc<Define_genericContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_genericContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_define_generic);
        let mut _localctx: Rc<Define_genericContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1260);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(161, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1222);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1223);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1224);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1225);
                        recog.generic_item()?;

                        recog.base.set_state(1230);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(155, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1226);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1227);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1232);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(155, &mut recog.base)?;
                        }
                        recog.base.set_state(1234);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1233);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1236);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1239);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1238);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1241);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1242);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1244);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1243);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1246);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1247);
                        recog.generic_item()?;

                        recog.base.set_state(1252);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(159, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1248);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1249);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1254);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(159, &mut recog.base)?;
                        }
                        recog.base.set_state(1256);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1255);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1258);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_item ----------------
pub type Generic_itemContextAll<'input> = Generic_itemContext<'input>;

pub type Generic_itemContext<'input> = BaseParserRuleContext<'input, Generic_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_item }
}
antlr_rust::tid! {Generic_itemContextExt<'a>}

impl<'input> Generic_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_itemContextExt { ph: PhantomData }))
    }
}

pub trait Generic_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_itemContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_itemContextAttrs<'input> for Generic_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_item(&mut self) -> Result<Rc<Generic_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_generic_item);
        let mut _localctx: Rc<Generic_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1265);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(162, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1262);
                            recog.identifier()?;

                            recog.base.set_state(1263);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1267);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call ----------------
pub type Generic_callContextAll<'input> = Generic_callContext<'input>;

pub type Generic_callContext<'input> = BaseParserRuleContext<'input, Generic_callContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call }
}
antlr_rust::tid! {Generic_callContextExt<'a>}

impl<'input> Generic_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_callContextExt { ph: PhantomData }))
    }
}

pub trait Generic_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_callContextAttrs<'input> for Generic_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call(&mut self) -> Result<Rc<Generic_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_generic_call);
        let mut _localctx: Rc<Generic_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1303);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(167, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1269);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1270);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1271);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1272);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1273);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1274);
                        recog.generic_pair()?;

                        recog.base.set_state(1279);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(163, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1275);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1276);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1281);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(163, &mut recog.base)?;
                        }
                        recog.base.set_state(1283);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1282);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1285);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1287);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1288);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1289);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1290);
                        recog.generic_pair()?;

                        recog.base.set_state(1295);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(165, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1291);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1292);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1297);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(165, &mut recog.base)?;
                        }
                        recog.base.set_state(1299);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1298);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1301);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call_in_type ----------------
pub type Generic_call_in_typeContextAll<'input> = Generic_call_in_typeContext<'input>;

pub type Generic_call_in_typeContext<'input> = BaseParserRuleContext<'input, Generic_call_in_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_call_in_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call_in_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call_in_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call_in_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_call_in_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call_in_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call_in_type }
}
antlr_rust::tid! {Generic_call_in_typeContextExt<'a>}

impl<'input> Generic_call_in_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_call_in_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Generic_call_in_typeContextExt { ph: PhantomData },
        ))
    }
}

pub trait Generic_call_in_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_call_in_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_call_in_typeContextAttrs<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call_in_type(&mut self) -> Result<Rc<Generic_call_in_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_call_in_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_generic_call_in_type);
        let mut _localctx: Rc<Generic_call_in_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1330);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_PROPORTION | OP_LT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1306);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1305);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1308);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1309);
                        recog.generic_pair()?;

                        recog.base.set_state(1314);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1310);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1311);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1316);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1317);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                GENERIC_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1319);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1320);
                        recog.generic_pair()?;

                        recog.base.set_state(1325);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1321);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1322);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1327);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1328);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_pair ----------------
pub type Generic_pairContextAll<'input> = Generic_pairContext<'input>;

pub type Generic_pairContext<'input> = BaseParserRuleContext<'input, Generic_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_pair }
}
antlr_rust::tid! {Generic_pairContextExt<'a>}

impl<'input> Generic_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_pairContextExt { ph: PhantomData }))
    }
}

pub trait Generic_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_pairContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_pairContextAttrs<'input> for Generic_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_pair(&mut self) -> Result<Rc<Generic_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_generic_pair);
        let mut _localctx: Rc<Generic_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1335);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(172, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1332);
                            recog.identifier()?;

                            recog.base.set_state(1333);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1337);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_label ----------------
pub type Define_labelContextAll<'input> = Define_labelContext<'input>;

pub type Define_labelContext<'input> = BaseParserRuleContext<'input, Define_labelContextExt<'input>>;

#[derive(Clone)]
pub struct Define_labelContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_labelContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_labelContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_label(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_label(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_labelContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_label(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_labelContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_label
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_label }
}
antlr_rust::tid! {Define_labelContextExt<'a>}

impl<'input> Define_labelContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_labelContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_labelContextExt { ph: PhantomData }))
    }
}

pub trait Define_labelContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_labelContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_labelContextAttrs<'input> for Define_labelContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_label(&mut self) -> Result<Rc<Define_labelContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_labelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_define_label);
        let mut _localctx: Rc<Define_labelContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1339);
                recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(1340);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- offset_call ----------------
pub type Offset_callContextAll<'input> = Offset_callContext<'input>;

pub type Offset_callContext<'input> = BaseParserRuleContext<'input, Offset_callContextExt<'input>>;

#[derive(Clone)]
pub struct Offset_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Offset_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Offset_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_offset_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_offset_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Offset_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_offset_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Offset_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_offset_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_offset_call }
}
antlr_rust::tid! {Offset_callContextExt<'a>}

impl<'input> Offset_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Offset_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Offset_callContextExt { ph: PhantomData }))
    }
}

pub trait Offset_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Offset_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_L
    /// Returns `None` if there is no child corresponding to token OFFSET_L
    fn OFFSET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_R
    /// Returns `None` if there is no child corresponding to token OFFSET_R
    fn OFFSET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_R, 0)
    }
}

impl<'input> Offset_callContextAttrs<'input> for Offset_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn offset_call(&mut self) -> Result<Rc<Offset_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Offset_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_offset_call);
        let mut _localctx: Rc<Offset_callContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1351);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_PROPORTION => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1342);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1343);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1344);
                        recog.expression_rec(0)?;

                        recog.base.set_state(1345);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                OFFSET_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1347);
                        recog.base.match_token(OFFSET_L, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1348);
                        recog.expression_rec(0)?;

                        recog.base.set_state(1349);
                        recog.base.match_token(OFFSET_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_call ----------------
pub type Template_callContextAll<'input> = Template_callContext<'input>;

pub type Template_callContext<'input> = BaseParserRuleContext<'input, Template_callContextExt<'input>>;

#[derive(Clone)]
pub struct Template_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_call }
}
antlr_rust::tid! {Template_callContextExt<'a>}

impl<'input> Template_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_callContextExt { ph: PhantomData }))
    }
}

pub trait Template_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_callContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TEMPLATE
    /// Returns `None` if there is no child corresponding to token KW_TEMPLATE
    fn KW_TEMPLATE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TEMPLATE, 0)
    }
    fn template_block(&self) -> Option<Rc<Template_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Template_callContextAttrs<'input> for Template_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_call(&mut self) -> Result<Rc<Template_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_template_call);
        let mut _localctx: Rc<Template_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1384);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(178, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1356);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1353);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1358);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1359);
                        recog.modifiers()?;

                        recog.base.set_state(1360);
                        recog.base.match_token(KW_TEMPLATE, &mut recog.err_handler)?;

                        /* InvokeRule template_block */
                        recog.base.set_state(1361);
                        recog.template_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1366);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1363);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1368);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1369);
                        recog.modifiers()?;

                        recog.base.set_state(1370);
                        recog.base.match_token(KW_TEMPLATE, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1371);
                        recog.identifier()?;

                        recog.base.set_state(1376);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(176, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1372);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule identifier */
                                        recog.base.set_state(1373);
                                        recog.identifier()?;
                                    }
                                }
                            }
                            recog.base.set_state(1378);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(176, &mut recog.base)?;
                        }
                        recog.base.set_state(1380);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1379);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule template_block */
                        recog.base.set_state(1382);
                        recog.template_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_block ----------------
pub type Template_blockContextAll<'input> = Template_blockContext<'input>;

pub type Template_blockContext<'input> = BaseParserRuleContext<'input, Template_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Template_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_block }
}
antlr_rust::tid! {Template_blockContextExt<'a>}

impl<'input> Template_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_blockContextExt { ph: PhantomData }))
    }
}

pub trait Template_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn template_statements_all(&self) -> Vec<Rc<Template_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn template_statements(&self, i: usize) -> Option<Rc<Template_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Template_blockContextAttrs<'input> for Template_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_block(&mut self) -> Result<Rc<Template_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_template_block);
        let mut _localctx: Rc<Template_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1386);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1391);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == KW_WHERE {
                    {
                        recog.base.set_state(1389);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            KW_WHERE => {
                                {
                                    /* InvokeRule template_statements */
                                    recog.base.set_state(1387);
                                    recog.template_statements()?;
                                }
                            }

                            COMMA | SEMICOLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1388);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1393);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1394);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_statements ----------------
pub type Template_statementsContextAll<'input> = Template_statementsContext<'input>;

pub type Template_statementsContext<'input> = BaseParserRuleContext<'input, Template_statementsContextExt<'input>>;

#[derive(Clone)]
pub struct Template_statementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_statementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_statementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_statements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_statements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_statementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_statements(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_statementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_statements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_statements }
}
antlr_rust::tid! {Template_statementsContextExt<'a>}

impl<'input> Template_statementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_statementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Template_statementsContextExt { ph: PhantomData },
        ))
    }
}

pub trait Template_statementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_statementsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_WHERE
    /// Returns `None` if there is no child corresponding to token KW_WHERE
    fn KW_WHERE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHERE, 0)
    }
    fn where_block(&self) -> Option<Rc<Where_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Template_statementsContextAttrs<'input> for Template_statementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_statements(&mut self) -> Result<Rc<Template_statementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_statementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_template_statements);
        let mut _localctx: Rc<Template_statementsContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1396);
                recog.base.match_token(KW_WHERE, &mut recog.err_handler)?;

                /* InvokeRule where_block */
                recog.base.set_state(1397);
                recog.where_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_block ----------------
pub type Where_blockContextAll<'input> = Where_blockContext<'input>;

pub type Where_blockContext<'input> = BaseParserRuleContext<'input, Where_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Where_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_block }
}
antlr_rust::tid! {Where_blockContextExt<'a>}

impl<'input> Where_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_blockContextExt { ph: PhantomData }))
    }
}

pub trait Where_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn where_bound_all(&self) -> Vec<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn where_bound(&self, i: usize) -> Option<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Where_blockContextAttrs<'input> for Where_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_block(&mut self) -> Result<Rc<Where_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_where_block);
        let mut _localctx: Rc<Where_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1399);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1403);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        {
                            /* InvokeRule where_bound */
                            recog.base.set_state(1400);
                            recog.where_bound()?;
                        }
                    }
                    recog.base.set_state(1405);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1406);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_bound ----------------
pub type Where_boundContextAll<'input> = Where_boundContext<'input>;

pub type Where_boundContext<'input> = BaseParserRuleContext<'input, Where_boundContextExt<'input>>;

#[derive(Clone)]
pub struct Where_boundContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_boundContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_boundContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_bound(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_bound(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_boundContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_bound(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_boundContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_bound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_bound }
}
antlr_rust::tid! {Where_boundContextExt<'a>}

impl<'input> Where_boundContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_boundContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_boundContextExt { ph: PhantomData }))
    }
}

pub trait Where_boundContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_boundContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Where_boundContextAttrs<'input> for Where_boundContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_bound(&mut self) -> Result<Rc<Where_boundContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_boundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_where_bound);
        let mut _localctx: Rc<Where_boundContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1413);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                RAW_ID | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1408);
                        recog.identifier()?;

                        recog.base.set_state(1409);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1410);
                        recog.type_expression_rec(0)?;
                    }
                }

                COMMA | SEMICOLON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(1412);
                        recog.eos_free()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- macro_call ----------------
pub type Macro_callContextAll<'input> = Macro_callContext<'input>;

pub type Macro_callContext<'input> = BaseParserRuleContext<'input, Macro_callContextExt<'input>>;

#[derive(Clone)]
pub struct Macro_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Macro_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Macro_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_macro_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_macro_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Macro_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_macro_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Macro_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_macro_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_macro_call }
}
antlr_rust::tid! {Macro_callContextExt<'a>}

impl<'input> Macro_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Macro_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Macro_callContextExt { ph: PhantomData }))
    }
}

pub trait Macro_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Macro_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn annotation_call_item_all(&self) -> Vec<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation_call_item(&self, i: usize) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Macro_callContextAttrs<'input> for Macro_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn macro_call(&mut self) -> Result<Rc<Macro_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Macro_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_macro_call);
        let mut _localctx: Rc<Macro_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1434);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(186, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1415);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1416);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1418);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(183, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1417);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1420);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        recog.base.set_state(1421);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1422);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1427);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1423);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule annotation_call_item */
                                    recog.base.set_state(1424);
                                    recog.annotation_call_item()?;
                                }
                            }
                            recog.base.set_state(1429);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1430);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;

                        recog.base.set_state(1432);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(185, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1431);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;

pub type AnnotationContext<'input> = BaseParserRuleContext<'input, AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for AnnotationContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AnnotationContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AnnotationContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation(self);
    }
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::tid! {AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AnnotationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, AnnotationContextExt { ph: PhantomData }))
    }
}

pub trait AnnotationContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<AnnotationContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn annotation_call_item_all(&self) -> Vec<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation_call_item(&self, i: usize) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation(&mut self) -> Result<Rc<AnnotationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1455);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(190, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1436);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1437);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1439);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == BRACE_L {
                            {
                                /* InvokeRule class_block */
                                recog.base.set_state(1438);
                                recog.class_block()?;
                            }
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1441);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        recog.base.set_state(1442);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1443);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1448);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1444);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule annotation_call_item */
                                    recog.base.set_state(1445);
                                    recog.annotation_call_item()?;
                                }
                            }
                            recog.base.set_state(1450);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1451);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;

                        recog.base.set_state(1453);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == BRACE_L {
                            {
                                /* InvokeRule class_block */
                                recog.base.set_state(1452);
                                recog.class_block()?;
                            }
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation_call_item ----------------
pub type Annotation_call_itemContextAll<'input> = Annotation_call_itemContext<'input>;

pub type Annotation_call_itemContext<'input> = BaseParserRuleContext<'input, Annotation_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Annotation_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Annotation_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Annotation_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation_call_item }
}
antlr_rust::tid! {Annotation_call_itemContextExt<'a>}

impl<'input> Annotation_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Annotation_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Annotation_call_itemContextExt { ph: PhantomData },
        ))
    }
}

pub trait Annotation_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Annotation_call_itemContextExt<'input>>
{
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Annotation_call_itemContextAttrs<'input> for Annotation_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation_call_item(&mut self) -> Result<Rc<Annotation_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Annotation_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_annotation_call_item);
        let mut _localctx: Rc<Annotation_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule namepath */
                recog.base.set_state(1457);
                recog.namepath()?;

                recog.base.set_state(1459);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(191, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule tuple_call_body */
                            recog.base.set_state(1458);
                            recog.tuple_call_body()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1462);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(192, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule class_block */
                            recog.base.set_state(1461);
                            recog.class_block()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- try_statement ----------------
pub type Try_statementContextAll<'input> = Try_statementContext<'input>;

pub type Try_statementContext<'input> = BaseParserRuleContext<'input, Try_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Try_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Try_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Try_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_try_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_try_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Try_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_try_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Try_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_try_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_try_statement }
}
antlr_rust::tid! {Try_statementContextExt<'a>}

impl<'input> Try_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Try_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Try_statementContextExt { ph: PhantomData }))
    }
}

pub trait Try_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Try_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TRY
    /// Returns `None` if there is no child corresponding to token KW_TRY
    fn KW_TRY(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRY, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Try_statementContextAttrs<'input> for Try_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn try_statement(&mut self) -> Result<Rc<Try_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Try_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_try_statement);
        let mut _localctx: Rc<Try_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1467);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1464);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1469);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1470);
                recog.base.match_token(KW_TRY, &mut recog.err_handler)?;

                recog.base.set_state(1472);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L
                    || _la == LAMBDA_SLOT
                    || (((_la - 123) & !0x3f) == 0
                        && ((1usize << (_la - 123))
                            & ((1usize << (INTEGER - 123))
                                | (1usize << (DECIMAL - 123))
                                | (1usize << (STRING_SINGLE - 123))
                                | (1usize << (STRING_DOUBLE - 123))
                                | (1usize << (STRING_BLOCK - 123))
                                | (1usize << (SPECIAL - 123))
                                | (1usize << (RAW_ID - 123))
                                | (1usize << (UNICODE_ID - 123))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(1471);
                        recog.type_expression_rec(0)?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(1474);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_statement ----------------
pub type Match_statementContextAll<'input> = Match_statementContext<'input>;

pub type Match_statementContext<'input> = BaseParserRuleContext<'input, Match_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Match_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_statement }
}
antlr_rust::tid! {Match_statementContextExt<'a>}

impl<'input> Match_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_statementContextExt { ph: PhantomData }))
    }
}

pub trait Match_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_statementContextExt<'input>>
{
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
}

impl<'input> Match_statementContextAttrs<'input> for Match_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_statement(&mut self) -> Result<Rc<Match_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_match_statement);
        let mut _localctx: Rc<Match_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1479);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1476);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1481);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1482);
                _la = recog.base.input.la(1);
                if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(1486);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(196, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1483);
                            recog.identifier()?;

                            recog.base.set_state(1484);
                            recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule inline_expression */
                recog.base.set_state(1488);
                recog.inline_expression_rec(0)?;

                /* InvokeRule match_block */
                recog.base.set_state(1489);
                recog.match_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_call ----------------
pub type Match_callContextAll<'input> = Match_callContext<'input>;

pub type Match_callContext<'input> = BaseParserRuleContext<'input, Match_callContextExt<'input>>;

#[derive(Clone)]
pub struct Match_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_call }
}
antlr_rust::tid! {Match_callContextExt<'a>}

impl<'input> Match_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_callContextExt { ph: PhantomData }))
    }
}

pub trait Match_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Match_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Match_callContextAttrs<'input> for Match_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_call(&mut self) -> Result<Rc<Match_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_match_call);
        let mut _localctx: Rc<Match_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1492);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(1491);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                recog.base.set_state(1494);
                recog.base.match_token(DOT, &mut recog.err_handler)?;

                recog.base.set_state(1495);
                _la = recog.base.input.la(1);
                if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(1501);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == KW_AS {
                    {
                        recog.base.set_state(1496);
                        recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1497);
                        recog.identifier()?;

                        recog.base.set_state(1499);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON || _la == OP_ARROW {
                            {
                                /* InvokeRule type_hint */
                                recog.base.set_state(1498);
                                recog.type_hint()?;
                            }
                        }
                    }
                }

                /* InvokeRule match_block */
                recog.base.set_state(1503);
                recog.match_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_block ----------------
pub type Match_blockContextAll<'input> = Match_blockContext<'input>;

pub type Match_blockContext<'input> = BaseParserRuleContext<'input, Match_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_block }
}
antlr_rust::tid! {Match_blockContextExt<'a>}

impl<'input> Match_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn match_terms_all(&self) -> Vec<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn match_terms(&self, i: usize) -> Option<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_blockContextAttrs<'input> for Match_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_block(&mut self) -> Result<Rc<Match_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_match_block);
        let mut _localctx: Rc<Match_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1505);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1510);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA
                    || _la == SEMICOLON
                    || _la == OP_HASH
                    || (((_la - 104) & !0x3f) == 0
                        && ((1usize << (_la - 104))
                            & ((1usize << (KW_TYPE - 104))
                                | (1usize << (KW_WITH - 104))
                                | (1usize << (KW_CASE - 104))
                                | (1usize << (KW_WHEN - 104))
                                | (1usize << (KW_ELSE - 104))))
                            != 0)
                {
                    {
                        recog.base.set_state(1508);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_HASH | KW_TYPE | KW_WITH | KW_CASE | KW_WHEN | KW_ELSE => {
                                {
                                    /* InvokeRule match_terms */
                                    recog.base.set_state(1506);
                                    recog.match_terms()?;
                                }
                            }

                            COMMA | SEMICOLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1507);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1512);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1513);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_terms ----------------
#[derive(Debug)]
pub enum Match_termsContextAll<'input> {
    MatchWhenContext(MatchWhenContext<'input>),
    MatchTypeContext(MatchTypeContext<'input>),
    MatchCaseContext(MatchCaseContext<'input>),
    MatchWithContext(MatchWithContext<'input>),
    MatchWithManyContext(MatchWithManyContext<'input>),
    MatchElseContext(MatchElseContext<'input>),
    Error(Match_termsContext<'input>),
}
antlr_rust::tid! {Match_termsContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Match_termsContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContextAll<'input> {}

impl<'input> Deref for Match_termsContextAll<'input> {
    type Target = dyn Match_termsContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Match_termsContextAll::*;
        match self {
            MatchWhenContext(inner) => inner,
            MatchTypeContext(inner) => inner,
            MatchCaseContext(inner) => inner,
            MatchWithContext(inner) => inner,
            MatchWithManyContext(inner) => inner,
            MatchElseContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Match_termsContext<'input> = BaseParserRuleContext<'input, Match_termsContextExt<'input>>;

#[derive(Clone)]
pub struct Match_termsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContext<'input> {}

impl<'input> CustomRuleContext<'input> for Match_termsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}
antlr_rust::tid! {Match_termsContextExt<'a>}

impl<'input> Match_termsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Match_termsContextExt { ph: PhantomData },
        )))
    }
}

pub trait Match_termsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_termsContextExt<'input>>
{
}

impl<'input> Match_termsContextAttrs<'input> for Match_termsContext<'input> {}

pub type MatchWhenContext<'input> = BaseParserRuleContext<'input, MatchWhenContextExt<'input>>;

pub trait MatchWhenContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHEN
    /// Returns `None` if there is no child corresponding to token KW_WHEN
    fn KW_WHEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHEN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWhenContextAttrs<'input> for MatchWhenContext<'input> {}

pub struct MatchWhenContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWhenContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWhenContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWhenContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWhen(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWhen(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWhenContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWhen(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWhenContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWhenContext<'input> {}

impl<'input> MatchWhenContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWhenContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWhenContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchTypeContext<'input> = BaseParserRuleContext<'input, MatchTypeContextExt<'input>>;

pub trait MatchTypeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchTypeContextAttrs<'input> for MatchTypeContext<'input> {}

pub struct MatchTypeContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchTypeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchTypeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchType(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchTypeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchType(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchTypeContext<'input> {}

impl<'input> MatchTypeContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchTypeContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchTypeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchCaseContext<'input> = BaseParserRuleContext<'input, MatchCaseContextExt<'input>>;

pub trait MatchCaseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_CASE
    /// Returns `None` if there is no child corresponding to token KW_CASE
    fn KW_CASE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CASE, 0)
    }
    fn case_pattern(&self) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchCaseContextAttrs<'input> for MatchCaseContext<'input> {}

pub struct MatchCaseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchCaseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchCaseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchCaseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchCase(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchCase(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchCaseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchCase(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchCaseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchCaseContext<'input> {}

impl<'input> MatchCaseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchCaseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchCaseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithContext<'input> = BaseParserRuleContext<'input, MatchWithContextExt<'input>>;

pub trait MatchWithContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWithContextAttrs<'input> for MatchWithContext<'input> {}

pub struct MatchWithContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWith(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWith(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithContext<'input> {}

impl<'input> MatchWithContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithManyContext<'input> = BaseParserRuleContext<'input, MatchWithManyContextExt<'input>>;

pub trait MatchWithManyContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> MatchWithManyContextAttrs<'input> for MatchWithManyContext<'input> {}

pub struct MatchWithManyContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithManyContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithManyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithManyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWithMany(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWithMany(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithManyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWithMany(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithManyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithManyContext<'input> {}

impl<'input> MatchWithManyContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithManyContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithManyContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchElseContext<'input> = BaseParserRuleContext<'input, MatchElseContextExt<'input>>;

pub trait MatchElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchElseContextAttrs<'input> for MatchElseContext<'input> {}

pub struct MatchElseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchElseContext<'input> {}

impl<'input> MatchElseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchElseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchElseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_terms(&mut self) -> Result<Rc<Match_termsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_termsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_match_terms);
        let mut _localctx: Rc<Match_termsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1591);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(213, &mut recog.base)? {
                1 => {
                    let tmp = MatchWithContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1518);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1515);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1520);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1521);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1522);
                        recog.identifier()?;
                    }
                }
                2 => {
                    let tmp = MatchWithManyContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1526);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1523);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1528);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1529);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        recog.base.set_state(1530);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1542);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1531);
                                recog.identifier()?;

                                recog.base.set_state(1536);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(204, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1532);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule identifier */
                                                recog.base.set_state(1533);
                                                recog.identifier()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1538);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(204, &mut recog.base)?;
                                }
                                recog.base.set_state(1540);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1539);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1544);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = MatchTypeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1548);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1545);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1550);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1551);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1552);
                        recog.type_expression_rec(0)?;

                        recog.base.set_state(1555);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1553);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1554);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1557);
                        recog.match_case_block()?;
                    }
                }
                4 => {
                    let tmp = MatchWhenContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1562);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1559);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1564);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1565);
                        recog.base.match_token(KW_WHEN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1566);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1567);
                        recog.match_case_block()?;
                    }
                }
                5 => {
                    let tmp = MatchElseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1572);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1569);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1574);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1575);
                        recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1576);
                        recog.match_case_block()?;
                    }
                }
                6 => {
                    let tmp = MatchCaseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1580);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1577);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1582);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1583);
                        recog.base.match_token(KW_CASE, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern */
                        recog.base.set_state(1584);
                        recog.case_pattern_rec(0)?;

                        recog.base.set_state(1587);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1585);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1586);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1589);
                        recog.match_case_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_case_block ----------------
pub type Match_case_blockContextAll<'input> = Match_case_blockContext<'input>;

pub type Match_case_blockContext<'input> = BaseParserRuleContext<'input, Match_case_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_case_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_case_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_case_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_case_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_case_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_case_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_case_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_case_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_case_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_case_block }
}
antlr_rust::tid! {Match_case_blockContextExt<'a>}

impl<'input> Match_case_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_case_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_case_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_case_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_case_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_case_blockContextAttrs<'input> for Match_case_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_case_block(&mut self) -> Result<Rc<Match_case_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_case_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_match_case_block);
        let mut _localctx: Rc<Match_case_blockContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1593);
                recog.base.match_token(COLON, &mut recog.err_handler)?;

                recog.base.set_state(1597);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(214, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule expression */
                                recog.base.set_state(1594);
                                recog.expression_rec(0)?;
                            }
                        }
                    }
                    recog.base.set_state(1599);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(214, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern ----------------
#[derive(Debug)]
pub enum Case_patternContextAll<'input> {
    CaseORContext(CaseORContext<'input>),
    CaseAtomContext(CaseAtomContext<'input>),
    CaseUntilContext(CaseUntilContext<'input>),
    Error(Case_patternContext<'input>),
}
antlr_rust::tid! {Case_patternContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Case_patternContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContextAll<'input> {}

impl<'input> Deref for Case_patternContextAll<'input> {
    type Target = dyn Case_patternContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Case_patternContextAll::*;
        match self {
            CaseORContext(inner) => inner,
            CaseAtomContext(inner) => inner,
            CaseUntilContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Case_patternContext<'input> = BaseParserRuleContext<'input, Case_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Case_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContext<'input> {}

impl<'input> CustomRuleContext<'input> for Case_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}
antlr_rust::tid! {Case_patternContextExt<'a>}

impl<'input> Case_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_patternContextExt { ph: PhantomData },
        )))
    }
}

pub trait Case_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_patternContextExt<'input>>
{
}

impl<'input> Case_patternContextAttrs<'input> for Case_patternContext<'input> {}

pub type CaseORContext<'input> = BaseParserRuleContext<'input, CaseORContextExt<'input>>;

pub trait CaseORContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> CaseORContextAttrs<'input> for CaseORContext<'input> {}

pub struct CaseORContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseORContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseORContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseORContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseOR(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseOR(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseORContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseOR(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseORContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseORContext<'input> {}

impl<'input> CaseORContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseORContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseORContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseAtomContext<'input> = BaseParserRuleContext<'input, CaseAtomContextExt<'input>>;

pub trait CaseAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CaseAtomContextAttrs<'input> for CaseAtomContext<'input> {}

pub struct CaseAtomContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseAtomContext<'input> {}

impl<'input> CaseAtomContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseUntilContext<'input> = BaseParserRuleContext<'input, CaseUntilContextExt<'input>>;

pub trait CaseUntilContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> CaseUntilContextAttrs<'input> for CaseUntilContext<'input> {}

pub struct CaseUntilContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseUntilContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseUntilContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseUntilContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseUntil(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseUntil(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseUntilContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseUntil(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseUntilContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseUntilContext<'input> {}

impl<'input> CaseUntilContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseUntilContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseUntilContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern(&mut self) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        self.case_pattern_rec(0)
    }

    fn case_pattern_rec(&mut self, _p: isize) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Case_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 192, RULE_case_pattern, _p);
        let mut _localctx: Rc<Case_patternContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 192;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                {
                    let mut tmp = CaseAtomContextExt::new(&**_localctx);
                    recog.ctx = Some(tmp.clone());
                    _localctx = tmp;
                    _prevctx = _localctx.clone();

                    /* InvokeRule case_pattern_item */
                    recog.base.set_state(1601);
                    recog.case_pattern_item()?;
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1611);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(216, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1609);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(215, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseORContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1603);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1604);
                                        _la = recog.base.input.la(1);
                                        if { !(_la == OP_ADD || _la == OP_OR) } {
                                            recog.err_handler.recover_inline(&mut recog.base)?;
                                        }
                                        else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog.err_handler.report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1605);
                                        recog.case_pattern_rec(4)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseUntilContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1606);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 2)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        {
                                            recog.base.set_state(1607);
                                            recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1608);
                                        recog.case_pattern_rec(3)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1613);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(216, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- case_pattern_item ----------------
pub type Case_pattern_itemContextAll<'input> = Case_pattern_itemContext<'input>;

pub type Case_pattern_itemContext<'input> = BaseParserRuleContext<'input, Case_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_item }
}
antlr_rust::tid! {Case_pattern_itemContextExt<'a>}

impl<'input> Case_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Case_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_itemContextExt<'input>>
{
    fn case_pattern_tuple(&self) -> Option<Rc<Case_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> Case_pattern_itemContextAttrs<'input> for Case_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_item(&mut self) -> Result<Rc<Case_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_case_pattern_item);
        let mut _localctx: Rc<Case_pattern_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1633);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(218, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule case_pattern_tuple */
                        recog.base.set_state(1614);
                        recog.case_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1615);
                        let tmp = recog.identifier()?;
                        cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                        recog.base.set_state(1616);
                        recog.base.match_token(OP_BIND, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1617);
                        recog.case_pattern_item()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1619);
                        recog.modified_identifier()?;

                        recog.base.set_state(1620);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        recog.base.set_state(1624);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(217, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(1621);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(1622);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1626);
                        recog.case_pattern_item()?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1628);
                        recog.modified_identifier()?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1629);
                        recog.namepath()?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule number_literal */
                        recog.base.set_state(1630);
                        recog.number_literal()?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule string_literal */
                        recog.base.set_state(1631);
                        recog.string_literal()?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1632);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern_tuple ----------------
pub type Case_pattern_tupleContextAll<'input> = Case_pattern_tupleContext<'input>;

pub type Case_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Case_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_tuple }
}
antlr_rust::tid! {Case_pattern_tupleContextExt<'a>}

impl<'input> Case_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Case_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Case_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn case_pattern_item_all(&self) -> Vec<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern_item(&self, i: usize) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Case_pattern_tupleContextAttrs<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_tuple(&mut self) -> Result<Rc<Case_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_case_pattern_tuple);
        let mut _localctx: Rc<Case_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1717);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(232, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1636);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1635);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1638);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(1639);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1641);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1640);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1643);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1644);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1646);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1645);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1648);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(1649);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1650);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1651);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1652);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(1653);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1655);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1656);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1659);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1657);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1658);
                                        recog.case_pattern_item()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(1661);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(222, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(1664);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1663);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1666);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1668);
                        recog.namepath()?;

                        recog.base.set_state(1669);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1670);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1675);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(224, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1671);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1672);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1677);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(224, &mut recog.base)?;
                        }
                        recog.base.set_state(1679);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1678);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1681);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        recog.base.set_state(1684);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1683);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1686);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1687);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1692);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(227, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1688);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1689);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1694);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(227, &mut recog.base)?;
                        }
                        recog.base.set_state(1696);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1695);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1698);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1701);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1700);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1703);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1704);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1709);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(230, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1705);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1706);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1711);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(230, &mut recog.base)?;
                        }
                        recog.base.set_state(1713);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1712);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1715);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- object_statement ----------------
pub type Object_statementContextAll<'input> = Object_statementContext<'input>;

pub type Object_statementContext<'input> = BaseParserRuleContext<'input, Object_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Object_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Object_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Object_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_object_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_object_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Object_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_object_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Object_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_object_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_object_statement }
}
antlr_rust::tid! {Object_statementContextExt<'a>}

impl<'input> Object_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Object_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Object_statementContextExt { ph: PhantomData }))
    }
}

pub trait Object_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Object_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_OBJECT
    /// Returns `None` if there is no child corresponding to token KW_OBJECT
    fn KW_OBJECT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_OBJECT, 0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Object_statementContextAttrs<'input> for Object_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn object_statement(&mut self) -> Result<Rc<Object_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Object_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_object_statement);
        let mut _localctx: Rc<Object_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1719);
                recog.base.match_token(KW_OBJECT, &mut recog.err_handler)?;

                recog.base.set_state(1721);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(1720);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(1724);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(1723);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(1727);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(1726);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(1729);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_statement ----------------
pub type New_statementContextAll<'input> = New_statementContext<'input>;

pub type New_statementContext<'input> = BaseParserRuleContext<'input, New_statementContextExt<'input>>;

#[derive(Clone)]
pub struct New_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_statement }
}
antlr_rust::tid! {New_statementContextExt<'a>}

impl<'input> New_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_statementContextExt { ph: PhantomData }))
    }
}

pub trait New_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<New_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NEW
    /// Returns `None` if there is no child corresponding to token KW_NEW
    fn KW_NEW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NEW, 0)
    }
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn new_block(&self) -> Option<Rc<New_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_statementContextAttrs<'input> for New_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_statement(&mut self) -> Result<Rc<New_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_new_statement);
        let mut _localctx: Rc<New_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1748);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(239, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1731);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(1732);
                        recog.modified_namepath()?;

                        recog.base.set_state(1734);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(1733);
                                recog.generic_call_in_type()?;
                            }
                        }

                        recog.base.set_state(1737);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == PARENTHESES_L {
                            {
                                /* InvokeRule tuple_call_body */
                                recog.base.set_state(1736);
                                recog.tuple_call_body()?;
                            }
                        }

                        /* InvokeRule new_block */
                        recog.base.set_state(1739);
                        recog.new_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1741);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(1742);
                        recog.modified_namepath()?;

                        recog.base.set_state(1744);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(1743);
                                recog.generic_call_in_type()?;
                            }
                        }

                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(1746);
                        recog.tuple_call_body()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_body ----------------
pub type New_bodyContextAll<'input> = New_bodyContext<'input>;

pub type New_bodyContext<'input> = BaseParserRuleContext<'input, New_bodyContextExt<'input>>;

#[derive(Clone)]
pub struct New_bodyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_bodyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_bodyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_body(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_body(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_bodyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_body(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_bodyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_body
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_body }
}
antlr_rust::tid! {New_bodyContextExt<'a>}

impl<'input> New_bodyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_bodyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_bodyContextExt { ph: PhantomData }))
    }
}

pub trait New_bodyContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<New_bodyContextExt<'input>> {
    fn new_block(&self) -> Option<Rc<New_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_bodyContextAttrs<'input> for New_bodyContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_body(&mut self) -> Result<Rc<New_bodyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_bodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_new_body);
        let mut _localctx: Rc<New_bodyContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1755);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(241, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1751);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == PARENTHESES_L {
                            {
                                /* InvokeRule tuple_call_body */
                                recog.base.set_state(1750);
                                recog.tuple_call_body()?;
                            }
                        }

                        /* InvokeRule new_block */
                        recog.base.set_state(1753);
                        recog.new_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(1754);
                        recog.tuple_call_body()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_block ----------------
pub type New_blockContextAll<'input> = New_blockContext<'input>;

pub type New_blockContext<'input> = BaseParserRuleContext<'input, New_blockContextExt<'input>>;

#[derive(Clone)]
pub struct New_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_block }
}
antlr_rust::tid! {New_blockContextExt<'a>}

impl<'input> New_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_blockContextExt { ph: PhantomData }))
    }
}

pub trait New_blockContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<New_blockContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn tuple_call_item_all(&self) -> Vec<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tuple_call_item(&self, i: usize) -> Option<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> New_blockContextAttrs<'input> for New_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_block(&mut self) -> Result<Rc<New_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_new_block);
        let mut _localctx: Rc<New_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1757);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1762);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << COMMA)
                            | (1usize << SEMICOLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << OFFSET_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 65) & !0x3f) == 0
                        && ((1usize << (_la - 65))
                            & ((1usize << (OP_AND - 65))
                                | (1usize << (OP_AT - 65))
                                | (1usize << (OP_HASH - 65))
                                | (1usize << (LAMBDA_SLOT - 65))
                                | (1usize << (OP_THROW - 65))
                                | (1usize << (OP_NOT - 65))
                                | (1usize << (OP_DECONSTRUCT - 65))
                                | (1usize << (OP_INVERSE - 65))
                                | (1usize << (OP_ROOTS - 65))
                                | (1usize << (OP_REFERENCE - 65))
                                | (1usize << (OP_LABEL - 65))))
                            != 0)
                    || (((_la - 113) & !0x3f) == 0
                        && ((1usize << (_la - 113))
                            & ((1usize << (KW_NEW - 113))
                                | (1usize << (KW_OBJECT - 113))
                                | (1usize << (KW_TRY - 113))
                                | (1usize << (KW_MATCH - 113))
                                | (1usize << (KW_CATCH - 113))
                                | (1usize << (INTEGER - 113))
                                | (1usize << (DECIMAL - 113))
                                | (1usize << (STRING_SINGLE - 113))
                                | (1usize << (STRING_DOUBLE - 113))
                                | (1usize << (STRING_BLOCK - 113))
                                | (1usize << (KW_IF - 113))
                                | (1usize << (RETURN - 113))
                                | (1usize << (RESUME - 113))
                                | (1usize << (YIELD - 113))
                                | (1usize << (BREAK - 113))
                                | (1usize << (CONTINUE - 113))
                                | (1usize << (RAISE - 113))
                                | (1usize << (SPECIAL - 113))
                                | (1usize << (RAW_ID - 113))
                                | (1usize << (UNICODE_ID - 113))))
                            != 0)
                {
                    {
                        recog.base.set_state(1760);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | OFFSET_L | OP_ADD | OP_SUB | OP_MUL | OP_AND | OP_AT | OP_HASH
                            | LAMBDA_SLOT | OP_THROW | OP_NOT | OP_DECONSTRUCT | OP_INVERSE | OP_ROOTS | OP_REFERENCE
                            | OP_LABEL | KW_NEW | KW_OBJECT | KW_TRY | KW_MATCH | KW_CATCH | INTEGER | DECIMAL
                            | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK | KW_IF | RETURN | RESUME | YIELD | BREAK
                            | CONTINUE | RAISE | SPECIAL | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule tuple_call_item */
                                    recog.base.set_state(1758);
                                    recog.tuple_call_item()?;
                                }
                            }

                            COMMA | SEMICOLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1759);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1764);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1765);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_literal ----------------
pub type Tuple_literalContextAll<'input> = Tuple_literalContext<'input>;

pub type Tuple_literalContext<'input> = BaseParserRuleContext<'input, Tuple_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_literal }
}
antlr_rust::tid! {Tuple_literalContextExt<'a>}

impl<'input> Tuple_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_literalContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn collection_pair_all(&self) -> Vec<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn collection_pair(&self, i: usize) -> Option<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Tuple_literalContextAttrs<'input> for Tuple_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_literal(&mut self) -> Result<Rc<Tuple_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_tuple_literal);
        let mut _localctx: Rc<Tuple_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1787);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(246, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1767);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(1768);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1769);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(1770);
                        recog.collection_pair()?;

                        recog.base.set_state(1773);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1771);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule collection_pair */
                                        recog.base.set_state(1772);
                                        recog.collection_pair()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(1775);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(244, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(1778);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1777);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1780);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1782);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(1783);
                        recog.collection_pair()?;

                        recog.base.set_state(1784);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(1785);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- collection_pair ----------------
pub type Collection_pairContextAll<'input> = Collection_pairContext<'input>;

pub type Collection_pairContext<'input> = BaseParserRuleContext<'input, Collection_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Collection_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Collection_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Collection_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_collection_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_collection_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Collection_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_collection_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Collection_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_pair }
}
antlr_rust::tid! {Collection_pairContextExt<'a>}

impl<'input> Collection_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Collection_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Collection_pairContextExt { ph: PhantomData }))
    }
}

pub trait Collection_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Collection_pairContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Collection_pairContextAttrs<'input> for Collection_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn collection_pair(&mut self) -> Result<Rc<Collection_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Collection_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_collection_pair);
        let mut _localctx: Rc<Collection_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1792);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(247, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1789);
                            recog.identifier()?;

                            recog.base.set_state(1790);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule expression */
                recog.base.set_state(1794);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- slice_call ----------------
pub type Slice_callContextAll<'input> = Slice_callContext<'input>;

pub type Slice_callContext<'input> = BaseParserRuleContext<'input, Slice_callContextExt<'input>>;

#[derive(Clone)]
pub struct Slice_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Slice_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Slice_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_slice_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_slice_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Slice_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_slice_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Slice_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_slice_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_slice_call }
}
antlr_rust::tid! {Slice_callContextExt<'a>}

impl<'input> Slice_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Slice_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Slice_callContextExt { ph: PhantomData }))
    }
}

pub trait Slice_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Slice_callContextExt<'input>> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
}

impl<'input> Slice_callContextAttrs<'input> for Slice_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn slice_call(&mut self) -> Result<Rc<Slice_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Slice_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_slice_call);
        let mut _localctx: Rc<Slice_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1797);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(1796);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule range_literal */
                recog.base.set_state(1799);
                recog.range_literal()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_literal ----------------
#[derive(Debug)]
pub enum Range_literalContextAll<'input> {
    OrdinalContext(OrdinalContext<'input>),
    OffsetContext(OffsetContext<'input>),
    Error(Range_literalContext<'input>),
}
antlr_rust::tid! {Range_literalContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Range_literalContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_literalContextAll<'input> {}

impl<'input> Deref for Range_literalContextAll<'input> {
    type Target = dyn Range_literalContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Range_literalContextAll::*;
        match self {
            OrdinalContext(inner) => inner,
            OffsetContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_literalContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_literalContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Range_literalContext<'input> = BaseParserRuleContext<'input, Range_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Range_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_literalContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_literalContext<'input> {}

impl<'input> CustomRuleContext<'input> for Range_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}
antlr_rust::tid! {Range_literalContextExt<'a>}

impl<'input> Range_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Range_literalContextExt { ph: PhantomData },
        )))
    }
}

pub trait Range_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Range_literalContextExt<'input>>
{
}

impl<'input> Range_literalContextAttrs<'input> for Range_literalContext<'input> {}

pub type OrdinalContext<'input> = BaseParserRuleContext<'input, OrdinalContextExt<'input>>;

pub trait OrdinalContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn range_axis_all(&self) -> Vec<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn range_axis(&self, i: usize) -> Option<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> OrdinalContextAttrs<'input> for OrdinalContext<'input> {}

pub struct OrdinalContextExt<'input> {
    base: Range_literalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OrdinalContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for OrdinalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for OrdinalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_Ordinal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_Ordinal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for OrdinalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_Ordinal(self);
    }
}

impl<'input> CustomRuleContext<'input> for OrdinalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}

impl<'input> Borrow<Range_literalContextExt<'input>> for OrdinalContext<'input> {
    fn borrow(&self) -> &Range_literalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Range_literalContextExt<'input>> for OrdinalContext<'input> {
    fn borrow_mut(&mut self) -> &mut Range_literalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Range_literalContextAttrs<'input> for OrdinalContext<'input> {}

impl<'input> OrdinalContextExt<'input> {
    fn new(ctx: &dyn Range_literalContextAttrs<'input>) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::OrdinalContext(BaseParserRuleContext::copy_from(
            ctx,
            OrdinalContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type OffsetContext<'input> = BaseParserRuleContext<'input, OffsetContextExt<'input>>;

pub trait OffsetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OFFSET_L
    /// Returns `None` if there is no child corresponding to token OFFSET_L
    fn OFFSET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_R
    /// Returns `None` if there is no child corresponding to token OFFSET_R
    fn OFFSET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_R, 0)
    }
    fn range_axis_all(&self) -> Vec<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn range_axis(&self, i: usize) -> Option<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> OffsetContextAttrs<'input> for OffsetContext<'input> {}

pub struct OffsetContextExt<'input> {
    base: Range_literalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OffsetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for OffsetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for OffsetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_Offset(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_Offset(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for OffsetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_Offset(self);
    }
}

impl<'input> CustomRuleContext<'input> for OffsetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}

impl<'input> Borrow<Range_literalContextExt<'input>> for OffsetContext<'input> {
    fn borrow(&self) -> &Range_literalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Range_literalContextExt<'input>> for OffsetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Range_literalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Range_literalContextAttrs<'input> for OffsetContext<'input> {}

impl<'input> OffsetContextExt<'input> {
    fn new(ctx: &dyn Range_literalContextAttrs<'input>) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::OffsetContext(BaseParserRuleContext::copy_from(
            ctx,
            OffsetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_literal(&mut self) -> Result<Rc<Range_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_range_literal);
        let mut _localctx: Rc<Range_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1831);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                BRACKET_L => {
                    let tmp = OrdinalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1801);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1813);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << OP_PROPORTION)
                                    | (1usize << COLON)
                                    | (1usize << OP_ADD)
                                    | (1usize << OP_SUB)
                                    | (1usize << OP_MUL)))
                                != 0)
                            || (((_la - 65) & !0x3f) == 0
                                && ((1usize << (_la - 65))
                                    & ((1usize << (OP_AND - 65))
                                        | (1usize << (LAMBDA_SLOT - 65))
                                        | (1usize << (OP_NOT - 65))
                                        | (1usize << (OP_DECONSTRUCT - 65))
                                        | (1usize << (OP_INVERSE - 65))
                                        | (1usize << (OP_ROOTS - 65))
                                        | (1usize << (OP_REFERENCE - 65))))
                                    != 0)
                            || (((_la - 123) & !0x3f) == 0
                                && ((1usize << (_la - 123))
                                    & ((1usize << (INTEGER - 123))
                                        | (1usize << (DECIMAL - 123))
                                        | (1usize << (STRING_SINGLE - 123))
                                        | (1usize << (STRING_DOUBLE - 123))
                                        | (1usize << (STRING_BLOCK - 123))
                                        | (1usize << (SPECIAL - 123))
                                        | (1usize << (RAW_ID - 123))
                                        | (1usize << (UNICODE_ID - 123))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(1802);
                                recog.range_axis()?;

                                recog.base.set_state(1807);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(249, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1803);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(1804);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1809);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(249, &mut recog.base)?;
                                }
                                recog.base.set_state(1811);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1810);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1815);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                OFFSET_L => {
                    let tmp = OffsetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1816);
                        recog.base.match_token(OFFSET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1828);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << OP_PROPORTION)
                                    | (1usize << COLON)
                                    | (1usize << OP_ADD)
                                    | (1usize << OP_SUB)
                                    | (1usize << OP_MUL)))
                                != 0)
                            || (((_la - 65) & !0x3f) == 0
                                && ((1usize << (_la - 65))
                                    & ((1usize << (OP_AND - 65))
                                        | (1usize << (LAMBDA_SLOT - 65))
                                        | (1usize << (OP_NOT - 65))
                                        | (1usize << (OP_DECONSTRUCT - 65))
                                        | (1usize << (OP_INVERSE - 65))
                                        | (1usize << (OP_ROOTS - 65))
                                        | (1usize << (OP_REFERENCE - 65))))
                                    != 0)
                            || (((_la - 123) & !0x3f) == 0
                                && ((1usize << (_la - 123))
                                    & ((1usize << (INTEGER - 123))
                                        | (1usize << (DECIMAL - 123))
                                        | (1usize << (STRING_SINGLE - 123))
                                        | (1usize << (STRING_DOUBLE - 123))
                                        | (1usize << (STRING_BLOCK - 123))
                                        | (1usize << (SPECIAL - 123))
                                        | (1usize << (RAW_ID - 123))
                                        | (1usize << (UNICODE_ID - 123))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(1817);
                                recog.range_axis()?;

                                recog.base.set_state(1822);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(252, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1818);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(1819);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1824);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(252, &mut recog.base)?;
                                }
                                recog.base.set_state(1826);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1825);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1830);
                        recog.base.match_token(OFFSET_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_axis ----------------
pub type Range_axisContextAll<'input> = Range_axisContext<'input>;

pub type Range_axisContext<'input> = BaseParserRuleContext<'input, Range_axisContextExt<'input>>;

#[derive(Clone)]
pub struct Range_axisContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_axisContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_axisContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_axis(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_axis(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_axisContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_axis(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_axisContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_axis
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_axis }
}
antlr_rust::tid! {Range_axisContextExt<'a>}

impl<'input> Range_axisContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_axisContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_axisContextExt { ph: PhantomData }))
    }
}

pub trait Range_axisContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_axisContextExt<'input>> {
    /// Retrieves all `TerminalNode`s corresponding to token COLON in current rule
    fn COLON_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COLON, starting from 0.
    /// Returns `None` if number of children corresponding to token COLON is less or equal than `i`.
    fn COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    fn range_start(&self) -> Option<Rc<Range_startContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn range_end(&self) -> Option<Rc<Range_endContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn range_step(&self) -> Option<Rc<Range_stepContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_axisContextAttrs<'input> for Range_axisContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_axis(&mut self) -> Result<Rc<Range_axisContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_axisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_range_axis);
        let mut _localctx: Rc<Range_axisContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1844);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                COLON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1833);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                OP_PROPORTION => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1834);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                    }
                }

                OP_ADD | OP_SUB | OP_MUL | OP_AND | LAMBDA_SLOT | OP_NOT | OP_DECONSTRUCT | OP_INVERSE | OP_ROOTS
                | OP_REFERENCE | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK | SPECIAL | RAW_ID
                | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule range_start */
                        recog.base.set_state(1835);
                        recog.range_start()?;

                        recog.base.set_state(1838);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(256, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1836);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;

                                    /* InvokeRule range_end */
                                    recog.base.set_state(1837);
                                    recog.range_end()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(1842);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON {
                            {
                                recog.base.set_state(1840);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                /* InvokeRule range_step */
                                recog.base.set_state(1841);
                                recog.range_step()?;
                            }
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_start ----------------
pub type Range_startContextAll<'input> = Range_startContext<'input>;

pub type Range_startContext<'input> = BaseParserRuleContext<'input, Range_startContextExt<'input>>;

#[derive(Clone)]
pub struct Range_startContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_startContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_startContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_start(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_start(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_startContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_start(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_startContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_start
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_start }
}
antlr_rust::tid! {Range_startContextExt<'a>}

impl<'input> Range_startContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_startContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_startContextExt { ph: PhantomData }))
    }
}

pub trait Range_startContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Range_startContextExt<'input>>
{
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_startContextAttrs<'input> for Range_startContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_start(&mut self) -> Result<Rc<Range_startContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_startContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_range_start);
        let mut _localctx: Rc<Range_startContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule inline_expression */
                recog.base.set_state(1846);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_end ----------------
pub type Range_endContextAll<'input> = Range_endContext<'input>;

pub type Range_endContext<'input> = BaseParserRuleContext<'input, Range_endContextExt<'input>>;

#[derive(Clone)]
pub struct Range_endContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_endContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_endContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_end(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_end(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_endContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_end(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_endContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_end
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_end }
}
antlr_rust::tid! {Range_endContextExt<'a>}

impl<'input> Range_endContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_endContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_endContextExt { ph: PhantomData }))
    }
}

pub trait Range_endContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_endContextExt<'input>> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_endContextAttrs<'input> for Range_endContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_end(&mut self) -> Result<Rc<Range_endContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_endContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_range_end);
        let mut _localctx: Rc<Range_endContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule inline_expression */
                recog.base.set_state(1848);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_step ----------------
pub type Range_stepContextAll<'input> = Range_stepContext<'input>;

pub type Range_stepContext<'input> = BaseParserRuleContext<'input, Range_stepContextExt<'input>>;

#[derive(Clone)]
pub struct Range_stepContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_stepContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_stepContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_step(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_step(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_stepContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_step(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_stepContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_step
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_step }
}
antlr_rust::tid! {Range_stepContextExt<'a>}

impl<'input> Range_stepContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_stepContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_stepContextExt { ph: PhantomData }))
    }
}

pub trait Range_stepContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_stepContextExt<'input>> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_stepContextAttrs<'input> for Range_stepContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_step(&mut self) -> Result<Rc<Range_stepContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_stepContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_range_step);
        let mut _localctx: Rc<Range_stepContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule inline_expression */
                recog.base.set_state(1850);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modifiers ----------------
pub type ModifiersContextAll<'input> = ModifiersContext<'input>;

pub type ModifiersContext<'input> = BaseParserRuleContext<'input, ModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ModifiersContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ModifiersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ModifiersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modifiers(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modifiers(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ModifiersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modifiers(self);
    }
}

impl<'input> CustomRuleContext<'input> for ModifiersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modifiers
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modifiers }
}
antlr_rust::tid! {ModifiersContextExt<'a>}

impl<'input> ModifiersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ModifiersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, ModifiersContextExt { ph: PhantomData }))
    }
}

pub trait ModifiersContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ModifiersContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ModifiersContextAttrs<'input> for ModifiersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modifiers(&mut self) -> Result<Rc<ModifiersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_modifiers);
        let mut _localctx: Rc<ModifiersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1855);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == RAW_ID || _la == UNICODE_ID {
                    {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1852);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(1857);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_identifier ----------------
pub type Modified_identifierContextAll<'input> = Modified_identifierContext<'input>;

pub type Modified_identifierContext<'input> = BaseParserRuleContext<'input, Modified_identifierContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_identifierContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub id: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_identifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_identifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_identifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_identifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_identifier }
}
antlr_rust::tid! {Modified_identifierContextExt<'a>}

impl<'input> Modified_identifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_identifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_identifierContextExt { identifier: None, id: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_identifierContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_identifierContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Modified_identifierContextAttrs<'input> for Modified_identifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_identifier(&mut self) -> Result<Rc<Modified_identifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_identifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_modified_identifier);
        let mut _localctx: Rc<Modified_identifierContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1861);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(260, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1858);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp =
                                    cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(1863);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(260, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(1864);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_identifierContext>(&mut _localctx).id = Some(tmp.clone());
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_namepath ----------------
pub type Modified_namepathContextAll<'input> = Modified_namepathContext<'input>;

pub type Modified_namepathContext<'input> = BaseParserRuleContext<'input, Modified_namepathContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_namepathContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub path: Vec<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_namepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_namepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_namepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_namepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_namepath }
}
antlr_rust::tid! {Modified_namepathContextExt<'a>}

impl<'input> Modified_namepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_namepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_namepathContextExt { identifier: None, mods: Vec::new(), path: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_namepathContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_namepathContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> Modified_namepathContextAttrs<'input> for Modified_namepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_namepath(&mut self) -> Result<Rc<Modified_namepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_namepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_modified_namepath);
        let mut _localctx: Rc<Modified_namepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1869);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(261, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1866);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(1871);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(261, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(1872);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);

                recog.base.set_state(1877);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(262, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(1873);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(1874);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(1879);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(262, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- lambda_name ----------------
pub type Lambda_nameContextAll<'input> = Lambda_nameContext<'input>;

pub type Lambda_nameContext<'input> = BaseParserRuleContext<'input, Lambda_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Lambda_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Lambda_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Lambda_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lambda_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_lambda_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Lambda_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_lambda_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Lambda_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_lambda_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_lambda_name }
}
antlr_rust::tid! {Lambda_nameContextExt<'a>}

impl<'input> Lambda_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Lambda_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Lambda_nameContextExt { ph: PhantomData }))
    }
}

pub trait Lambda_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Lambda_nameContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token LAMBDA_SLOT
    /// Returns `None` if there is no child corresponding to token LAMBDA_SLOT
    fn LAMBDA_SLOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LAMBDA_SLOT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Lambda_nameContextAttrs<'input> for Lambda_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn lambda_name(&mut self) -> Result<Rc<Lambda_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Lambda_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_lambda_name);
        let mut _localctx: Rc<Lambda_nameContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1880);
                recog.base.match_token(LAMBDA_SLOT, &mut recog.err_handler)?;

                recog.base.set_state(1883);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(263, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1881);
                            recog.identifier()?;
                        }
                    }

                    x if x == 2 => {
                        {
                            /* InvokeRule number */
                            recog.base.set_state(1882);
                            recog.number()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_name ----------------
pub type Function_nameContextAll<'input> = Function_nameContext<'input>;

pub type Function_nameContext<'input> = BaseParserRuleContext<'input, Function_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Function_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_name }
}
antlr_rust::tid! {Function_nameContextExt<'a>}

impl<'input> Function_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_nameContextExt { ph: PhantomData }))
    }
}

pub trait Function_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_nameContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
}

impl<'input> Function_nameContextAttrs<'input> for Function_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_name(&mut self) -> Result<Rc<Function_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_function_name);
        let mut _localctx: Rc<Function_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(1885);
                recog.identifier()?;

                recog.base.set_state(1890);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_PROPORTION {
                    {
                        {
                            recog.base.set_state(1886);
                            recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                            /* InvokeRule identifier */
                            recog.base.set_state(1887);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(1892);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1895);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == DOT {
                    {
                        recog.base.set_state(1893);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1894);
                        recog.identifier()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath_free ----------------
pub type Namepath_freeContextAll<'input> = Namepath_freeContext<'input>;

pub type Namepath_freeContext<'input> = BaseParserRuleContext<'input, Namepath_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Namepath_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Namepath_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Namepath_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Namepath_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Namepath_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath_free }
}
antlr_rust::tid! {Namepath_freeContextExt<'a>}

impl<'input> Namepath_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Namepath_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Namepath_freeContextExt { ph: PhantomData }))
    }
}

pub trait Namepath_freeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Namepath_freeContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
}

impl<'input> Namepath_freeContextAttrs<'input> for Namepath_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath_free(&mut self) -> Result<Rc<Namepath_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Namepath_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_namepath_free);
        let mut _localctx: Rc<Namepath_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(1897);
                recog.identifier()?;

                recog.base.set_state(1902);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == DOT || _la == OP_PROPORTION {
                    {
                        {
                            recog.base.set_state(1898);
                            _la = recog.base.input.la(1);
                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            }
                            else {
                                if recog.base.input.la(1) == TOKEN_EOF {
                                    recog.base.matched_eof = true
                                };
                                recog.err_handler.report_match(&mut recog.base);
                                recog.base.consume(&mut recog.err_handler);
                            }
                            /* InvokeRule identifier */
                            recog.base.set_state(1899);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(1904);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath ----------------
pub type NamepathContextAll<'input> = NamepathContext<'input>;

pub type NamepathContext<'input> = BaseParserRuleContext<'input, NamepathContextExt<'input>>;

#[derive(Clone)]
pub struct NamepathContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for NamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath }
}
antlr_rust::tid! {NamepathContextExt<'a>}

impl<'input> NamepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NamepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NamepathContextExt { ph: PhantomData }))
    }
}

pub trait NamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NamepathContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> NamepathContextAttrs<'input> for NamepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath(&mut self) -> Result<Rc<NamepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NamepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_namepath);
        let mut _localctx: Rc<NamepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(1905);
                recog.identifier()?;

                recog.base.set_state(1910);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(267, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(1906);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(1907);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(1912);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(267, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;

pub type IdentifierContext<'input> = BaseParserRuleContext<'input, IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for IdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IdentifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IdentifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid! {IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, IdentifierContextExt { ph: PhantomData }))
    }
}

pub trait IdentifierContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<IdentifierContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token UNICODE_ID
    /// Returns `None` if there is no child corresponding to token UNICODE_ID
    fn UNICODE_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNICODE_ID, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RAW_ID
    /// Returns `None` if there is no child corresponding to token RAW_ID
    fn RAW_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAW_ID, 0)
    }
}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn identifier(&mut self) -> Result<Rc<IdentifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1913);
                _la = recog.base.input.la(1);
                if { !(_la == RAW_ID || _la == UNICODE_ID) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number ----------------
pub type NumberContextAll<'input> = NumberContext<'input>;

pub type NumberContext<'input> = BaseParserRuleContext<'input, NumberContextExt<'input>>;

#[derive(Clone)]
pub struct NumberContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number(self);
    }
}

impl<'input> CustomRuleContext<'input> for NumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}
antlr_rust::tid! {NumberContextExt<'a>}

impl<'input> NumberContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NumberContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NumberContextExt { ph: PhantomData }))
    }
}

pub trait NumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NumberContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DECIMAL
    /// Returns `None` if there is no child corresponding to token DECIMAL
    fn DECIMAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DECIMAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
}

impl<'input> NumberContextAttrs<'input> for NumberContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number(&mut self) -> Result<Rc<NumberContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NumberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_number);
        let mut _localctx: Rc<NumberContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1915);
                _la = recog.base.input.la(1);
                if { !(_la == INTEGER || _la == DECIMAL) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number_literal ----------------
pub type Number_literalContextAll<'input> = Number_literalContext<'input>;

pub type Number_literalContext<'input> = BaseParserRuleContext<'input, Number_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Number_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Number_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Number_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Number_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Number_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number_literal }
}
antlr_rust::tid! {Number_literalContextExt<'a>}

impl<'input> Number_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Number_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Number_literalContextExt { ph: PhantomData }))
    }
}

pub trait Number_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Number_literalContextExt<'input>>
{
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Number_literalContextAttrs<'input> for Number_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number_literal(&mut self) -> Result<Rc<Number_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Number_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_number_literal);
        let mut _localctx: Rc<Number_literalContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule number */
                recog.base.set_state(1917);
                recog.number()?;

                recog.base.set_state(1919);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(268, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1918);
                            recog.identifier()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string ----------------
pub type StringContextAll<'input> = StringContext<'input>;

pub type StringContext<'input> = BaseParserRuleContext<'input, StringContextExt<'input>>;

#[derive(Clone)]
pub struct StringContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for StringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for StringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for StringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string(self);
    }
}

impl<'input> CustomRuleContext<'input> for StringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string }
}
antlr_rust::tid! {StringContextExt<'a>}

impl<'input> StringContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StringContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, StringContextExt { ph: PhantomData }))
    }
}

pub trait StringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<StringContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token STRING_SINGLE
    /// Returns `None` if there is no child corresponding to token STRING_SINGLE
    fn STRING_SINGLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_SINGLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_DOUBLE
    /// Returns `None` if there is no child corresponding to token STRING_DOUBLE
    fn STRING_DOUBLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_DOUBLE, 0)
    }
}

impl<'input> StringContextAttrs<'input> for StringContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string(&mut self) -> Result<Rc<StringContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = StringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_string);
        let mut _localctx: Rc<StringContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1921);
                _la = recog.base.input.la(1);
                if { !(_la == STRING_SINGLE || _la == STRING_DOUBLE) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string_literal ----------------
pub type String_literalContextAll<'input> = String_literalContext<'input>;

pub type String_literalContext<'input> = BaseParserRuleContext<'input, String_literalContextExt<'input>>;

#[derive(Clone)]
pub struct String_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for String_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for String_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for String_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for String_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string_literal }
}
antlr_rust::tid! {String_literalContextExt<'a>}

impl<'input> String_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<String_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, String_literalContextExt { ph: PhantomData }))
    }
}

pub trait String_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<String_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token STRING_SINGLE
    /// Returns `None` if there is no child corresponding to token STRING_SINGLE
    fn STRING_SINGLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_SINGLE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_DOUBLE
    /// Returns `None` if there is no child corresponding to token STRING_DOUBLE
    fn STRING_DOUBLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_DOUBLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_BLOCK
    /// Returns `None` if there is no child corresponding to token STRING_BLOCK
    fn STRING_BLOCK(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_BLOCK, 0)
    }
}

impl<'input> String_literalContextAttrs<'input> for String_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string_literal(&mut self) -> Result<Rc<String_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = String_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_string_literal);
        let mut _localctx: Rc<String_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1935);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(272, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1924);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1923);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(1926);
                        recog.base.match_token(STRING_SINGLE, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1928);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1927);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(1930);
                        recog.base.match_token(STRING_DOUBLE, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1932);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1931);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(1934);
                        recog.base.match_token(STRING_BLOCK, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}

lazy_static! {
    static ref _ATN: Arc<ATN> = Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(_ATN.clone(), _ATN.get_decision_state(i), i as isize).into())
        }
        Arc::new(dfa)
    };
}

const _serializedATN: &'static str = "\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{91}\u{794}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x03\x02\x03\x02\x07\x02\u{fb}\x0a\x02\
	\x0c\x02\x0e\x02\u{fe}\x0b\x02\x03\x02\x03\x02\x03\x03\x03\x03\x03\x03\x03\
	\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x05\x03\u{10c}\x0a\
	\x03\x03\x04\x03\x04\x03\x05\x03\x05\x03\x06\x03\x06\x03\x06\x05\x06\u{115}\
	\x0a\x06\x03\x07\x03\x07\x03\x07\x03\x08\x03\x08\x05\x08\u{11c}\x0a\x08\
	\x03\x08\x03\x08\x03\x09\x03\x09\x03\x09\x03\x09\x05\x09\u{124}\x0a\x09\
	\x03\x09\x03\x09\x03\x09\x05\x09\u{129}\x0a\x09\x03\x09\x05\x09\u{12c}\x0a\
	\x09\x03\x09\x03\x09\x03\x09\x05\x09\u{131}\x0a\x09\x03\x09\x03\x09\x03\
	\x09\x05\x09\u{136}\x0a\x09\x03\x09\x05\x09\u{139}\x0a\x09\x03\x09\x03\x09\
	\x05\x09\u{13d}\x0a\x09\x03\x09\x03\x09\x05\x09\u{141}\x0a\x09\x03\x09\x05\
	\x09\u{144}\x0a\x09\x03\x09\x05\x09\u{147}\x0a\x09\x03\x0a\x03\x0a\x03\x0a\
	\x07\x0a\u{14c}\x0a\x0a\x0c\x0a\x0e\x0a\u{14f}\x0b\x0a\x03\x0a\x03\x0a\x03\
	\x0a\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x07\x0b\u{158}\x0a\x0b\x0c\x0b\x0e\
	\x0b\u{15b}\x0b\x0b\x03\x0b\x05\x0b\u{15e}\x0a\x0b\x03\x0c\x03\x0c\x03\x0d\
	\x05\x0d\u{163}\x0a\x0d\x03\x0d\x07\x0d\u{166}\x0a\x0d\x0c\x0d\x0e\x0d\u{169}\
	\x0b\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x05\x0d\u{16f}\x0a\x0d\x03\x0d\
	\x05\x0d\u{172}\x0a\x0d\x03\x0d\x05\x0d\u{175}\x0a\x0d\x03\x0d\x03\x0d\x05\
	\x0d\u{179}\x0a\x0d\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x07\x0e\u{180}\
	\x0a\x0e\x0c\x0e\x0e\x0e\u{183}\x0b\x0e\x03\x0e\x03\x0e\x03\x0f\x03\x0f\
	\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x07\x0f\u{18d}\x0a\x0f\x0c\x0f\x0e\x0f\
	\u{190}\x0b\x0f\x03\x0f\x05\x0f\u{193}\x0a\x0f\x03\x0f\x03\x0f\x05\x0f\u{197}\
	\x0a\x0f\x03\x10\x03\x10\x03\x11\x07\x11\u{19c}\x0a\x11\x0c\x11\x0e\x11\
	\u{19f}\x0b\x11\x03\x11\x03\x11\x05\x11\u{1a3}\x0a\x11\x03\x11\x05\x11\u{1a6}\
	\x0a\x11\x03\x12\x07\x12\u{1a9}\x0a\x12\x0c\x12\x0e\x12\u{1ac}\x0b\x12\x03\
	\x12\x03\x12\x05\x12\u{1b0}\x0a\x12\x03\x12\x03\x12\x05\x12\u{1b4}\x0a\x12\
	\x03\x12\x05\x12\u{1b7}\x0a\x12\x03\x12\x05\x12\u{1ba}\x0a\x12\x03\x13\x07\
	\x13\u{1bd}\x0a\x13\x0c\x13\x0e\x13\u{1c0}\x0b\x13\x03\x13\x03\x13\x03\x13\
	\x03\x14\x05\x14\u{1c6}\x0a\x14\x03\x14\x07\x14\u{1c9}\x0a\x14\x0c\x14\x0e\
	\x14\u{1cc}\x0b\x14\x03\x14\x03\x14\x03\x14\x03\x14\x05\x14\u{1d2}\x0a\x14\
	\x03\x14\x05\x14\u{1d5}\x0a\x14\x03\x14\x03\x14\x05\x14\u{1d9}\x0a\x14\x03\
	\x15\x03\x15\x03\x15\x03\x15\x03\x15\x07\x15\u{1e0}\x0a\x15\x0c\x15\x0e\
	\x15\u{1e3}\x0b\x15\x03\x15\x03\x15\x03\x16\x03\x16\x03\x16\x03\x16\x05\
	\x16\u{1eb}\x0a\x16\x03\x17\x05\x17\u{1ee}\x0a\x17\x03\x17\x07\x17\u{1f1}\
	\x0a\x17\x0c\x17\x0e\x17\u{1f4}\x0b\x17\x03\x17\x03\x17\x03\x17\x03\x17\
	\x05\x17\u{1fa}\x0a\x17\x03\x17\x05\x17\u{1fd}\x0a\x17\x03\x17\x03\x17\x03\
	\x18\x03\x18\x03\x18\x03\x19\x07\x19\u{205}\x0a\x19\x0c\x19\x0e\x19\u{208}\
	\x0b\x19\x03\x19\x03\x19\x03\x19\x03\x19\x05\x19\u{20e}\x0a\x19\x03\x19\
	\x05\x19\u{211}\x0a\x19\x03\x19\x03\x19\x03\x1a\x03\x1a\x05\x1a\u{217}\x0a\
	\x1a\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x07\x1b\u{21f}\x0a\
	\x1b\x0c\x1b\x0e\x1b\u{222}\x0b\x1b\x03\x1b\x03\x1b\x03\x1c\x03\x1c\x05\
	\x1c\u{228}\x0a\x1c\x03\x1d\x03\x1d\x03\x1d\x07\x1d\u{22d}\x0a\x1d\x0c\x1d\
	\x0e\x1d\u{230}\x0b\x1d\x03\x1d\x03\x1d\x03\x1e\x07\x1e\u{235}\x0a\x1e\x0c\
	\x1e\x0e\x1e\u{238}\x0b\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x05\x1e\u{23e}\
	\x0a\x1e\x03\x1e\x05\x1e\u{241}\x0a\x1e\x03\x1e\x03\x1e\x03\x1f\x03\x1f\
	\x03\x1f\x03\x1f\x07\x1f\u{249}\x0a\x1f\x0c\x1f\x0e\x1f\u{24c}\x0b\x1f\x03\
	\x1f\x03\x1f\x03\x20\x07\x20\u{251}\x0a\x20\x0c\x20\x0e\x20\u{254}\x0b\x20\
	\x03\x20\x03\x20\x03\x20\x05\x20\u{259}\x0a\x20\x03\x21\x05\x21\u{25c}\x0a\
	\x21\x03\x21\x07\x21\u{25f}\x0a\x21\x0c\x21\x0e\x21\u{262}\x0b\x21\x03\x21\
	\x03\x21\x03\x21\x03\x21\x05\x21\u{268}\x0a\x21\x03\x21\x03\x21\x05\x21\
	\u{26c}\x0a\x21\x03\x21\x05\x21\u{26f}\x0a\x21\x03\x21\x03\x21\x03\x22\x03\
	\x22\x03\x22\x03\x22\x03\x22\x03\x22\x07\x22\u{279}\x0a\x22\x0c\x22\x0e\
	\x22\u{27c}\x0b\x22\x03\x22\x03\x22\x05\x22\u{280}\x0a\x22\x03\x23\x07\x23\
	\u{283}\x0a\x23\x0c\x23\x0e\x23\u{286}\x0b\x23\x03\x23\x03\x23\x05\x23\u{28a}\
	\x0a\x23\x03\x23\x05\x23\u{28d}\x0a\x23\x03\x24\x03\x24\x03\x24\x03\x25\
	\x05\x25\u{293}\x0a\x25\x03\x25\x03\x25\x03\x26\x05\x26\u{298}\x0a\x26\x03\
	\x26\x03\x26\x03\x26\x05\x26\u{29d}\x0a\x26\x03\x26\x05\x26\u{2a0}\x0a\x26\
	\x03\x26\x03\x26\x05\x26\u{2a4}\x0a\x26\x03\x26\x03\x26\x05\x26\u{2a8}\x0a\
	\x26\x05\x26\u{2aa}\x0a\x26\x03\x27\x03\x27\x03\x27\x03\x27\x03\x27\x03\
	\x27\x07\x27\u{2b2}\x0a\x27\x0c\x27\x0e\x27\u{2b5}\x0b\x27\x03\x27\x05\x27\
	\u{2b8}\x0a\x27\x03\x27\x03\x27\x05\x27\u{2bc}\x0a\x27\x03\x28\x03\x28\x03\
	\x28\x03\x28\x03\x28\x05\x28\u{2c3}\x0a\x28\x03\x29\x07\x29\u{2c6}\x0a\x29\
	\x0c\x29\x0e\x29\u{2c9}\x0b\x29\x03\x29\x03\x29\x03\x29\x05\x29\u{2ce}\x0a\
	\x29\x03\x29\x03\x29\x03\x2a\x05\x2a\u{2d3}\x0a\x2a\x03\x2a\x03\x2a\x03\
	\x2b\x03\x2b\x03\x2b\x07\x2b\u{2da}\x0a\x2b\x0c\x2b\x0e\x2b\u{2dd}\x0b\x2b\
	\x03\x2b\x03\x2b\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x05\x2c\
	\u{2e7}\x0a\x2c\x03\x2d\x03\x2d\x03\x2d\x05\x2d\u{2ec}\x0a\x2d\x03\x2d\x03\
	\x2d\x05\x2d\u{2f0}\x0a\x2d\x03\x2e\x03\x2e\x05\x2e\u{2f4}\x0a\x2e\x03\x2f\
	\x03\x2f\x03\x2f\x07\x2f\u{2f9}\x0a\x2f\x0c\x2f\x0e\x2f\u{2fc}\x0b\x2f\x03\
	\x2f\x05\x2f\u{2ff}\x0a\x2f\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\
	\x30\x03\x30\x06\x30\u{308}\x0a\x30\x0d\x30\x0e\x30\u{309}\x03\x30\x05\x30\
	\u{30d}\x0a\x30\x05\x30\u{30f}\x0a\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\
	\x30\x03\x30\x07\x30\u{317}\x0a\x30\x0c\x30\x0e\x30\u{31a}\x0b\x30\x03\x30\
	\x05\x30\u{31d}\x0a\x30\x05\x30\u{31f}\x0a\x30\x03\x30\x03\x30\x03\x30\x05\
	\x30\u{324}\x0a\x30\x03\x30\x03\x30\x03\x30\x03\x30\x07\x30\u{32a}\x0a\x30\
	\x0c\x30\x0e\x30\u{32d}\x0b\x30\x03\x30\x05\x30\u{330}\x0a\x30\x05\x30\u{332}\
	\x0a\x30\x03\x30\x03\x30\x05\x30\u{336}\x0a\x30\x03\x30\x03\x30\x03\x30\
	\x03\x30\x07\x30\u{33c}\x0a\x30\x0c\x30\x0e\x30\u{33f}\x0b\x30\x03\x30\x05\
	\x30\u{342}\x0a\x30\x05\x30\u{344}\x0a\x30\x03\x30\x05\x30\u{347}\x0a\x30\
	\x03\x31\x03\x31\x03\x31\x05\x31\u{34c}\x0a\x31\x03\x31\x03\x31\x03\x31\
	\x05\x31\u{351}\x0a\x31\x03\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{357}\x0a\
	\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{35c}\x0a\x31\x03\x31\x03\x31\x05\
	\x31\u{360}\x0a\x31\x03\x31\x03\x31\x05\x31\u{364}\x0a\x31\x03\x31\x05\x31\
	\u{367}\x0a\x31\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x33\x03\x33\
	\x03\x33\x03\x34\x03\x34\x03\x34\x03\x35\x07\x35\u{375}\x0a\x35\x0c\x35\
	\x0e\x35\u{378}\x0b\x35\x03\x35\x03\x35\x03\x35\x03\x35\x07\x35\u{37e}\x0a\
	\x35\x0c\x35\x0e\x35\u{381}\x0b\x35\x03\x35\x03\x35\x05\x35\u{385}\x0a\x35\
	\x03\x36\x07\x36\u{388}\x0a\x36\x0c\x36\x0e\x36\u{38b}\x0b\x36\x03\x36\x03\
	\x36\x03\x36\x03\x36\x03\x36\x05\x36\u{392}\x0a\x36\x03\x36\x03\x36\x03\
	\x36\x03\x36\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x38\x07\x38\u{39e}\
	\x0a\x38\x0c\x38\x0e\x38\u{3a1}\x0b\x38\x03\x38\x03\x38\x03\x38\x03\x38\
	\x03\x38\x07\x38\u{3a8}\x0a\x38\x0c\x38\x0e\x38\u{3ab}\x0b\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x07\x38\u{3b5}\x0a\
	\x38\x0c\x38\x0e\x38\u{3b8}\x0b\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x05\x38\u{3bf}\x0a\x38\x03\x38\x03\x38\x05\x38\u{3c3}\x0a\x38\x03\x39\
	\x03\x39\x03\x39\x03\x3a\x07\x3a\u{3c9}\x0a\x3a\x0c\x3a\x0e\x3a\u{3cc}\x0b\
	\x3a\x03\x3a\x03\x3a\x05\x3a\u{3d0}\x0a\x3a\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x05\x3b\u{3dc}\x0a\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x07\x3b\u{41a}\x0a\
	\x3b\x0c\x3b\x0e\x3b\u{41d}\x0b\x3b\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\
	\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{42a}\x0a\
	\x3c\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x05\x3d\u{431}\x0a\x3d\x03\
	\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\
	\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\
	\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\
	\x3d\x03\x3d\x03\x3d\x07\x3d\u{451}\x0a\x3d\x0c\x3d\x0e\x3d\u{454}\x0b\x3d\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x06\x3e\
	\u{45e}\x0a\x3e\x0d\x3e\x0e\x3e\u{45f}\x03\x3e\x05\x3e\u{463}\x0a\x3e\x05\
	\x3e\u{465}\x0a\x3e\x03\x3e\x03\x3e\x05\x3e\u{469}\x0a\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x03\x3e\x03\x3e\x07\x3e\u{478}\x0a\x3e\x0c\x3e\x0e\x3e\u{47b}\x0b\x3e\x03\
	\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x05\x3f\u{482}\x0a\x3f\x03\x40\x03\
	\x40\x03\x41\x03\x41\x03\x42\x03\x42\x03\x42\x05\x42\u{48b}\x0a\x42\x05\
	\x42\u{48d}\x0a\x42\x03\x42\x03\x42\x03\x42\x05\x42\u{492}\x0a\x42\x03\x42\
	\x03\x42\x03\x42\x05\x42\u{497}\x0a\x42\x03\x42\x03\x42\x03\x42\x03\x42\
	\x03\x42\x05\x42\u{49e}\x0a\x42\x03\x42\x05\x42\u{4a1}\x0a\x42\x03\x42\x03\
	\x42\x03\x42\x03\x42\x03\x42\x05\x42\u{4a8}\x0a\x42\x03\x43\x03\x43\x03\
	\x44\x03\x44\x03\x45\x03\x45\x03\x46\x03\x46\x03\x47\x03\x47\x03\x48\x03\
	\x48\x03\x49\x03\x49\x03\x4a\x03\x4a\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\
	\x4b\x03\x4b\x05\x4b\u{4c0}\x0a\x4b\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\
	\x4c\x05\x4c\u{4c7}\x0a\x4c\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\
	\x4d\x07\x4d\u{4cf}\x0a\x4d\x0c\x4d\x0e\x4d\u{4d2}\x0b\x4d\x03\x4d\x05\x4d\
	\u{4d5}\x0a\x4d\x03\x4d\x03\x4d\x03\x4d\x05\x4d\u{4da}\x0a\x4d\x03\x4d\x03\
	\x4d\x03\x4d\x05\x4d\u{4df}\x0a\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x07\
	\x4d\u{4e5}\x0a\x4d\x0c\x4d\x0e\x4d\u{4e8}\x0b\x4d\x03\x4d\x05\x4d\u{4eb}\
	\x0a\x4d\x03\x4d\x03\x4d\x05\x4d\u{4ef}\x0a\x4d\x03\x4e\x03\x4e\x03\x4e\
	\x05\x4e\u{4f4}\x0a\x4e\x03\x4e\x03\x4e\x03\x4f\x03\x4f\x03\x4f\x03\x4f\
	\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x07\x4f\u{500}\x0a\x4f\x0c\x4f\x0e\x4f\
	\u{503}\x0b\x4f\x03\x4f\x05\x4f\u{506}\x0a\x4f\x03\x4f\x03\x4f\x03\x4f\x03\
	\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x07\x4f\u{510}\x0a\x4f\x0c\x4f\x0e\
	\x4f\u{513}\x0b\x4f\x03\x4f\x05\x4f\u{516}\x0a\x4f\x03\x4f\x03\x4f\x05\x4f\
	\u{51a}\x0a\x4f\x03\x50\x05\x50\u{51d}\x0a\x50\x03\x50\x03\x50\x03\x50\x03\
	\x50\x07\x50\u{523}\x0a\x50\x0c\x50\x0e\x50\u{526}\x0b\x50\x03\x50\x03\x50\
	\x03\x50\x03\x50\x03\x50\x03\x50\x07\x50\u{52e}\x0a\x50\x0c\x50\x0e\x50\
	\u{531}\x0b\x50\x03\x50\x03\x50\x05\x50\u{535}\x0a\x50\x03\x51\x03\x51\x03\
	\x51\x05\x51\u{53a}\x0a\x51\x03\x51\x03\x51\x03\x52\x03\x52\x03\x52\x03\
	\x53\x03\x53\x03\x53\x03\x53\x03\x53\x03\x53\x03\x53\x03\x53\x03\x53\x05\
	\x53\u{54a}\x0a\x53\x03\x54\x07\x54\u{54d}\x0a\x54\x0c\x54\x0e\x54\u{550}\
	\x0b\x54\x03\x54\x03\x54\x03\x54\x03\x54\x03\x54\x07\x54\u{557}\x0a\x54\
	\x0c\x54\x0e\x54\u{55a}\x0b\x54\x03\x54\x03\x54\x03\x54\x03\x54\x03\x54\
	\x07\x54\u{561}\x0a\x54\x0c\x54\x0e\x54\u{564}\x0b\x54\x03\x54\x05\x54\u{567}\
	\x0a\x54\x03\x54\x03\x54\x05\x54\u{56b}\x0a\x54\x03\x55\x03\x55\x03\x55\
	\x07\x55\u{570}\x0a\x55\x0c\x55\x0e\x55\u{573}\x0b\x55\x03\x55\x03\x55\x03\
	\x56\x03\x56\x03\x56\x03\x57\x03\x57\x07\x57\u{57c}\x0a\x57\x0c\x57\x0e\
	\x57\u{57f}\x0b\x57\x03\x57\x03\x57\x03\x58\x03\x58\x03\x58\x03\x58\x03\
	\x58\x05\x58\u{588}\x0a\x58\x03\x59\x03\x59\x03\x59\x05\x59\u{58d}\x0a\x59\
	\x03\x59\x03\x59\x03\x59\x03\x59\x03\x59\x07\x59\u{594}\x0a\x59\x0c\x59\
	\x0e\x59\u{597}\x0b\x59\x03\x59\x03\x59\x05\x59\u{59b}\x0a\x59\x05\x59\u{59d}\
	\x0a\x59\x03\x5a\x03\x5a\x03\x5a\x05\x5a\u{5a2}\x0a\x5a\x03\x5a\x03\x5a\
	\x03\x5a\x03\x5a\x03\x5a\x07\x5a\u{5a9}\x0a\x5a\x0c\x5a\x0e\x5a\u{5ac}\x0b\
	\x5a\x03\x5a\x03\x5a\x05\x5a\u{5b0}\x0a\x5a\x05\x5a\u{5b2}\x0a\x5a\x03\x5b\
	\x03\x5b\x05\x5b\u{5b6}\x0a\x5b\x03\x5b\x05\x5b\u{5b9}\x0a\x5b\x03\x5c\x07\
	\x5c\u{5bc}\x0a\x5c\x0c\x5c\x0e\x5c\u{5bf}\x0b\x5c\x03\x5c\x03\x5c\x05\x5c\
	\u{5c3}\x0a\x5c\x03\x5c\x03\x5c\x03\x5d\x07\x5d\u{5c8}\x0a\x5d\x0c\x5d\x0e\
	\x5d\u{5cb}\x0b\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x05\x5d\u{5d1}\x0a\x5d\
	\x03\x5d\x03\x5d\x03\x5d\x03\x5e\x05\x5e\u{5d7}\x0a\x5e\x03\x5e\x03\x5e\
	\x03\x5e\x03\x5e\x03\x5e\x05\x5e\u{5de}\x0a\x5e\x05\x5e\u{5e0}\x0a\x5e\x03\
	\x5e\x03\x5e\x03\x5f\x03\x5f\x03\x5f\x07\x5f\u{5e7}\x0a\x5f\x0c\x5f\x0e\
	\x5f\u{5ea}\x0b\x5f\x03\x5f\x03\x5f\x03\x60\x07\x60\u{5ef}\x0a\x60\x0c\x60\
	\x0e\x60\u{5f2}\x0b\x60\x03\x60\x03\x60\x03\x60\x07\x60\u{5f7}\x0a\x60\x0c\
	\x60\x0e\x60\u{5fa}\x0b\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\x07\
	\x60\u{601}\x0a\x60\x0c\x60\x0e\x60\u{604}\x0b\x60\x03\x60\x05\x60\u{607}\
	\x0a\x60\x05\x60\u{609}\x0a\x60\x03\x60\x03\x60\x07\x60\u{60d}\x0a\x60\x0c\
	\x60\x0e\x60\u{610}\x0b\x60\x03\x60\x03\x60\x03\x60\x03\x60\x05\x60\u{616}\
	\x0a\x60\x03\x60\x03\x60\x03\x60\x07\x60\u{61b}\x0a\x60\x0c\x60\x0e\x60\
	\u{61e}\x0b\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\x07\x60\u{625}\x0a\
	\x60\x0c\x60\x0e\x60\u{628}\x0b\x60\x03\x60\x03\x60\x03\x60\x07\x60\u{62d}\
	\x0a\x60\x0c\x60\x0e\x60\u{630}\x0b\x60\x03\x60\x03\x60\x03\x60\x03\x60\
	\x05\x60\u{636}\x0a\x60\x03\x60\x03\x60\x05\x60\u{63a}\x0a\x60\x03\x61\x03\
	\x61\x07\x61\u{63e}\x0a\x61\x0c\x61\x0e\x61\u{641}\x0b\x61\x03\x62\x03\x62\
	\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x07\x62\u{64c}\
	\x0a\x62\x0c\x62\x0e\x62\u{64f}\x0b\x62\x03\x63\x03\x63\x03\x63\x03\x63\
	\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{65b}\x0a\x63\
	\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{664}\
	\x0a\x63\x03\x64\x05\x64\u{667}\x0a\x64\x03\x64\x03\x64\x03\x64\x05\x64\
	\u{66c}\x0a\x64\x03\x64\x03\x64\x03\x64\x05\x64\u{671}\x0a\x64\x03\x64\x03\
	\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\
	\x64\x06\x64\u{67e}\x0a\x64\x0d\x64\x0e\x64\u{67f}\x03\x64\x05\x64\u{683}\
	\x0a\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x07\x64\
	\u{68c}\x0a\x64\x0c\x64\x0e\x64\u{68f}\x0b\x64\x03\x64\x05\x64\u{692}\x0a\
	\x64\x03\x64\x03\x64\x03\x64\x05\x64\u{697}\x0a\x64\x03\x64\x03\x64\x03\
	\x64\x03\x64\x07\x64\u{69d}\x0a\x64\x0c\x64\x0e\x64\u{6a0}\x0b\x64\x03\x64\
	\x05\x64\u{6a3}\x0a\x64\x03\x64\x03\x64\x03\x64\x05\x64\u{6a8}\x0a\x64\x03\
	\x64\x03\x64\x03\x64\x03\x64\x07\x64\u{6ae}\x0a\x64\x0c\x64\x0e\x64\u{6b1}\
	\x0b\x64\x03\x64\x05\x64\u{6b4}\x0a\x64\x03\x64\x03\x64\x05\x64\u{6b8}\x0a\
	\x64\x03\x65\x03\x65\x05\x65\u{6bc}\x0a\x65\x03\x65\x05\x65\u{6bf}\x0a\x65\
	\x03\x65\x05\x65\u{6c2}\x0a\x65\x03\x65\x03\x65\x03\x66\x03\x66\x03\x66\
	\x05\x66\u{6c9}\x0a\x66\x03\x66\x05\x66\u{6cc}\x0a\x66\x03\x66\x03\x66\x03\
	\x66\x03\x66\x03\x66\x05\x66\u{6d3}\x0a\x66\x03\x66\x03\x66\x05\x66\u{6d7}\
	\x0a\x66\x03\x67\x05\x67\u{6da}\x0a\x67\x03\x67\x03\x67\x05\x67\u{6de}\x0a\
	\x67\x03\x68\x03\x68\x03\x68\x07\x68\u{6e3}\x0a\x68\x0c\x68\x0e\x68\u{6e6}\
	\x0b\x68\x03\x68\x03\x68\x03\x69\x03\x69\x03\x69\x03\x69\x03\x69\x03\x69\
	\x06\x69\u{6f0}\x0a\x69\x0d\x69\x0e\x69\u{6f1}\x03\x69\x05\x69\u{6f5}\x0a\
	\x69\x03\x69\x03\x69\x03\x69\x03\x69\x03\x69\x03\x69\x03\x69\x05\x69\u{6fe}\
	\x0a\x69\x03\x6a\x03\x6a\x03\x6a\x05\x6a\u{703}\x0a\x6a\x03\x6a\x03\x6a\
	\x03\x6b\x05\x6b\u{708}\x0a\x6b\x03\x6b\x03\x6b\x03\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x07\x6c\u{710}\x0a\x6c\x0c\x6c\x0e\x6c\u{713}\x0b\x6c\x03\x6c\x05\
	\x6c\u{716}\x0a\x6c\x05\x6c\u{718}\x0a\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x07\x6c\u{71f}\x0a\x6c\x0c\x6c\x0e\x6c\u{722}\x0b\x6c\x03\x6c\x05\
	\x6c\u{725}\x0a\x6c\x05\x6c\u{727}\x0a\x6c\x03\x6c\x05\x6c\u{72a}\x0a\x6c\
	\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x05\x6d\u{731}\x0a\x6d\x03\x6d\
	\x03\x6d\x05\x6d\u{735}\x0a\x6d\x05\x6d\u{737}\x0a\x6d\x03\x6e\x03\x6e\x03\
	\x6f\x03\x6f\x03\x70\x03\x70\x03\x71\x07\x71\u{740}\x0a\x71\x0c\x71\x0e\
	\x71\u{743}\x0b\x71\x03\x72\x07\x72\u{746}\x0a\x72\x0c\x72\x0e\x72\u{749}\
	\x0b\x72\x03\x72\x03\x72\x03\x73\x07\x73\u{74e}\x0a\x73\x0c\x73\x0e\x73\
	\u{751}\x0b\x73\x03\x73\x03\x73\x03\x73\x07\x73\u{756}\x0a\x73\x0c\x73\x0e\
	\x73\u{759}\x0b\x73\x03\x74\x03\x74\x03\x74\x05\x74\u{75e}\x0a\x74\x03\x75\
	\x03\x75\x03\x75\x07\x75\u{763}\x0a\x75\x0c\x75\x0e\x75\u{766}\x0b\x75\x03\
	\x75\x03\x75\x05\x75\u{76a}\x0a\x75\x03\x76\x03\x76\x03\x76\x07\x76\u{76f}\
	\x0a\x76\x0c\x76\x0e\x76\u{772}\x0b\x76\x03\x77\x03\x77\x03\x77\x07\x77\
	\u{777}\x0a\x77\x0c\x77\x0e\x77\u{77a}\x0b\x77\x03\x78\x03\x78\x03\x79\x03\
	\x79\x03\x7a\x03\x7a\x05\x7a\u{782}\x0a\x7a\x03\x7b\x03\x7b\x03\x7c\x05\
	\x7c\u{787}\x0a\x7c\x03\x7c\x03\x7c\x05\x7c\u{78b}\x0a\x7c\x03\x7c\x03\x7c\
	\x05\x7c\u{78f}\x0a\x7c\x03\x7c\x05\x7c\u{792}\x0a\x7c\x03\x7c\x02\x06\x74\
	\x78\x7a\u{c2}\x7d\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\
	\x1e\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\
	\x42\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\
	\x66\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\
	\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\
	\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\
	\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\
	\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\
	\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\x02\x17\x03\x02\x04\x05\
	\x03\x02\x48\x49\x04\x02\x03\x03\x07\x07\x04\x02\x08\x08\x6d\x6d\x04\x02\
	\x08\x08\x31\x31\x04\x02\x50\x50\x71\x71\x0a\x02\x1b\x1b\x1d\x1d\x1f\x1f\
	\x43\x43\x4f\x4f\x59\x59\x5c\x5d\x61\x61\x04\x02\x4f\x4f\x5e\x60\x05\x02\
	\x22\x26\x2a\x2b\x2f\x2f\x03\x02\x43\x44\x03\x02\x31\x32\x03\x02\x1f\x21\
	\x04\x02\x1b\x1b\x1d\x1d\x03\x02\x3b\x40\x04\x02\x27\x29\x2c\x2e\x04\x02\
	\x33\x33\x35\x39\x03\x02\x78\x79\x04\x02\x1b\x1b\x44\x44\x03\x02\u{8c}\u{8d}\
	\x03\x02\x7d\x7e\x03\x02\x7f\u{80}\x02\u{894}\x02\u{fc}\x03\x02\x02\x02\
	\x04\u{10b}\x03\x02\x02\x02\x06\u{10d}\x03\x02\x02\x02\x08\u{10f}\x03\x02\
	\x02\x02\x0a\u{111}\x03\x02\x02\x02\x0c\u{116}\x03\x02\x02\x02\x0e\u{119}\
	\x03\x02\x02\x02\x10\u{146}\x03\x02\x02\x02\x12\u{148}\x03\x02\x02\x02\x14\
	\u{15d}\x03\x02\x02\x02\x16\u{15f}\x03\x02\x02\x02\x18\u{162}\x03\x02\x02\
	\x02\x1a\u{17a}\x03\x02\x02\x02\x1c\u{196}\x03\x02\x02\x02\x1e\u{198}\x03\
	\x02\x02\x02\x20\u{19d}\x03\x02\x02\x02\x22\u{1aa}\x03\x02\x02\x02\x24\u{1be}\
	\x03\x02\x02\x02\x26\u{1c5}\x03\x02\x02\x02\x28\u{1da}\x03\x02\x02\x02\x2a\
	\u{1e6}\x03\x02\x02\x02\x2c\u{1ed}\x03\x02\x02\x02\x2e\u{200}\x03\x02\x02\
	\x02\x30\u{206}\x03\x02\x02\x02\x32\u{214}\x03\x02\x02\x02\x34\u{21a}\x03\
	\x02\x02\x02\x36\u{225}\x03\x02\x02\x02\x38\u{229}\x03\x02\x02\x02\x3a\u{236}\
	\x03\x02\x02\x02\x3c\u{244}\x03\x02\x02\x02\x3e\u{252}\x03\x02\x02\x02\x40\
	\u{25b}\x03\x02\x02\x02\x42\u{27f}\x03\x02\x02\x02\x44\u{284}\x03\x02\x02\
	\x02\x46\u{28e}\x03\x02\x02\x02\x48\u{292}\x03\x02\x02\x02\x4a\u{2a9}\x03\
	\x02\x02\x02\x4c\u{2bb}\x03\x02\x02\x02\x4e\u{2c2}\x03\x02\x02\x02\x50\u{2c7}\
	\x03\x02\x02\x02\x52\u{2d2}\x03\x02\x02\x02\x54\u{2d6}\x03\x02\x02\x02\x56\
	\u{2e6}\x03\x02\x02\x02\x58\u{2e8}\x03\x02\x02\x02\x5a\u{2f3}\x03\x02\x02\
	\x02\x5c\u{2f5}\x03\x02\x02\x02\x5e\u{346}\x03\x02\x02\x02\x60\u{366}\x03\
	\x02\x02\x02\x62\u{368}\x03\x02\x02\x02\x64\u{36d}\x03\x02\x02\x02\x66\u{370}\
	\x03\x02\x02\x02\x68\u{376}\x03\x02\x02\x02\x6a\u{389}\x03\x02\x02\x02\x6c\
	\u{397}\x03\x02\x02\x02\x6e\u{3c2}\x03\x02\x02\x02\x70\u{3c4}\x03\x02\x02\
	\x02\x72\u{3ca}\x03\x02\x02\x02\x74\u{3db}\x03\x02\x02\x02\x76\u{429}\x03\
	\x02\x02\x02\x78\u{430}\x03\x02\x02\x02\x7a\u{468}\x03\x02\x02\x02\x7c\u{481}\
	\x03\x02\x02\x02\x7e\u{483}\x03\x02\x02\x02\u{80}\u{485}\x03\x02\x02\x02\
	\u{82}\u{4a7}\x03\x02\x02\x02\u{84}\u{4a9}\x03\x02\x02\x02\u{86}\u{4ab}\
	\x03\x02\x02\x02\u{88}\u{4ad}\x03\x02\x02\x02\u{8a}\u{4af}\x03\x02\x02\x02\
	\u{8c}\u{4b1}\x03\x02\x02\x02\u{8e}\u{4b3}\x03\x02\x02\x02\u{90}\u{4b5}\
	\x03\x02\x02\x02\u{92}\u{4b7}\x03\x02\x02\x02\u{94}\u{4bf}\x03\x02\x02\x02\
	\u{96}\u{4c6}\x03\x02\x02\x02\u{98}\u{4ee}\x03\x02\x02\x02\u{9a}\u{4f3}\
	\x03\x02\x02\x02\u{9c}\u{519}\x03\x02\x02\x02\u{9e}\u{534}\x03\x02\x02\x02\
	\u{a0}\u{539}\x03\x02\x02\x02\u{a2}\u{53d}\x03\x02\x02\x02\u{a4}\u{549}\
	\x03\x02\x02\x02\u{a6}\u{56a}\x03\x02\x02\x02\u{a8}\u{56c}\x03\x02\x02\x02\
	\u{aa}\u{576}\x03\x02\x02\x02\u{ac}\u{579}\x03\x02\x02\x02\u{ae}\u{587}\
	\x03\x02\x02\x02\u{b0}\u{59c}\x03\x02\x02\x02\u{b2}\u{5b1}\x03\x02\x02\x02\
	\u{b4}\u{5b3}\x03\x02\x02\x02\u{b6}\u{5bd}\x03\x02\x02\x02\u{b8}\u{5c9}\
	\x03\x02\x02\x02\u{ba}\u{5d6}\x03\x02\x02\x02\u{bc}\u{5e3}\x03\x02\x02\x02\
	\u{be}\u{639}\x03\x02\x02\x02\u{c0}\u{63b}\x03\x02\x02\x02\u{c2}\u{642}\
	\x03\x02\x02\x02\u{c4}\u{663}\x03\x02\x02\x02\u{c6}\u{6b7}\x03\x02\x02\x02\
	\u{c8}\u{6b9}\x03\x02\x02\x02\u{ca}\u{6d6}\x03\x02\x02\x02\u{cc}\u{6dd}\
	\x03\x02\x02\x02\u{ce}\u{6df}\x03\x02\x02\x02\u{d0}\u{6fd}\x03\x02\x02\x02\
	\u{d2}\u{702}\x03\x02\x02\x02\u{d4}\u{707}\x03\x02\x02\x02\u{d6}\u{729}\
	\x03\x02\x02\x02\u{d8}\u{736}\x03\x02\x02\x02\u{da}\u{738}\x03\x02\x02\x02\
	\u{dc}\u{73a}\x03\x02\x02\x02\u{de}\u{73c}\x03\x02\x02\x02\u{e0}\u{741}\
	\x03\x02\x02\x02\u{e2}\u{747}\x03\x02\x02\x02\u{e4}\u{74f}\x03\x02\x02\x02\
	\u{e6}\u{75a}\x03\x02\x02\x02\u{e8}\u{75f}\x03\x02\x02\x02\u{ea}\u{76b}\
	\x03\x02\x02\x02\u{ec}\u{773}\x03\x02\x02\x02\u{ee}\u{77b}\x03\x02\x02\x02\
	\u{f0}\u{77d}\x03\x02\x02\x02\u{f2}\u{77f}\x03\x02\x02\x02\u{f4}\u{783}\
	\x03\x02\x02\x02\u{f6}\u{791}\x03\x02\x02\x02\u{f8}\u{fb}\x05\x04\x03\x02\
	\u{f9}\u{fb}\x05\x06\x04\x02\u{fa}\u{f8}\x03\x02\x02\x02\u{fa}\u{f9}\x03\
	\x02\x02\x02\u{fb}\u{fe}\x03\x02\x02\x02\u{fc}\u{fa}\x03\x02\x02\x02\u{fc}\
	\u{fd}\x03\x02\x02\x02\u{fd}\u{ff}\x03\x02\x02\x02\u{fe}\u{fc}\x03\x02\x02\
	\x02\u{ff}\u{100}\x07\x02\x02\x03\u{100}\x03\x03\x02\x02\x02\u{101}\u{10c}\
	\x05\x0a\x06\x02\u{102}\u{10c}\x05\x0c\x07\x02\u{103}\u{10c}\x05\x16\x0c\
	\x02\u{104}\u{10c}\x05\x18\x0d\x02\u{105}\u{10c}\x05\x30\x19\x02\u{106}\
	\u{10c}\x05\x3a\x1e\x02\u{107}\u{10c}\x05\x26\x14\x02\u{108}\u{10c}\x05\
	\x2c\x17\x02\u{109}\u{10c}\x05\x40\x21\x02\u{10a}\u{10c}\x05\x56\x2c\x02\
	\u{10b}\u{101}\x03\x02\x02\x02\u{10b}\u{102}\x03\x02\x02\x02\u{10b}\u{103}\
	\x03\x02\x02\x02\u{10b}\u{104}\x03\x02\x02\x02\u{10b}\u{105}\x03\x02\x02\
	\x02\u{10b}\u{106}\x03\x02\x02\x02\u{10b}\u{107}\x03\x02\x02\x02\u{10b}\
	\u{108}\x03\x02\x02\x02\u{10b}\u{109}\x03\x02\x02\x02\u{10b}\u{10a}\x03\
	\x02\x02\x02\u{10c}\x05\x03\x02\x02\x02\u{10d}\u{10e}\x07\x05\x02\x02\u{10e}\
	\x07\x03\x02\x02\x02\u{10f}\u{110}\x09\x02\x02\x02\u{110}\x09\x03\x02\x02\
	\x02\u{111}\u{112}\x07\x63\x02\x02\u{112}\u{114}\x05\u{ea}\x76\x02\u{113}\
	\u{115}\x05\x06\x04\x02\u{114}\u{113}\x03\x02\x02\x02\u{114}\u{115}\x03\
	\x02\x02\x02\u{115}\x0b\x03\x02\x02\x02\u{116}\u{117}\x07\x64\x02\x02\u{117}\
	\u{118}\x05\x10\x09\x02\u{118}\x0d\x03\x02\x02\x02\u{119}\u{11b}\x07\x58\
	\x02\x02\u{11a}\u{11c}\x09\x03\x02\x02\u{11b}\u{11a}\x03\x02\x02\x02\u{11b}\
	\u{11c}\x03\x02\x02\x02\u{11c}\u{11d}\x03\x02\x02\x02\u{11d}\u{11e}\x05\
	\u{ee}\x78\x02\u{11e}\x0f\x03\x02\x02\x02\u{11f}\u{147}\x05\x14\x0b\x02\
	\u{120}\u{121}\x07\x48\x02\x02\u{121}\u{123}\x05\x12\x0a\x02\u{122}\u{124}\
	\x05\x0e\x08\x02\u{123}\u{122}\x03\x02\x02\x02\u{123}\u{124}\x03\x02\x02\
	\x02\u{124}\u{147}\x03\x02\x02\x02\u{125}\u{126}\x07\x48\x02\x02\u{126}\
	\u{12b}\x05\x12\x0a\x02\u{127}\u{129}\x09\x04\x02\x02\u{128}\u{127}\x03\
	\x02\x02\x02\u{128}\u{129}\x03\x02\x02\x02\u{129}\u{12a}\x03\x02\x02\x02\
	\u{12a}\u{12c}\x05\x14\x0b\x02\u{12b}\u{128}\x03\x02\x02\x02\u{12b}\u{12c}\
	\x03\x02\x02\x02\u{12c}\u{147}\x03\x02\x02\x02\u{12d}\u{12e}\x07\x49\x02\
	\x02\u{12e}\u{130}\x05\x12\x0a\x02\u{12f}\u{131}\x05\x0e\x08\x02\u{130}\
	\u{12f}\x03\x02\x02\x02\u{130}\u{131}\x03\x02\x02\x02\u{131}\u{147}\x03\
	\x02\x02\x02\u{132}\u{133}\x07\x49\x02\x02\u{133}\u{138}\x05\x12\x0a\x02\
	\u{134}\u{136}\x09\x04\x02\x02\u{135}\u{134}\x03\x02\x02\x02\u{135}\u{136}\
	\x03\x02\x02\x02\u{136}\u{137}\x03\x02\x02\x02\u{137}\u{139}\x05\x14\x0b\
	\x02\u{138}\u{135}\x03\x02\x02\x02\u{138}\u{139}\x03\x02\x02\x02\u{139}\
	\u{147}\x03\x02\x02\x02\u{13a}\u{13c}\x05\x12\x0a\x02\u{13b}\u{13d}\x05\
	\x0e\x08\x02\u{13c}\u{13b}\x03\x02\x02\x02\u{13c}\u{13d}\x03\x02\x02\x02\
	\u{13d}\u{147}\x03\x02\x02\x02\u{13e}\u{143}\x05\x12\x0a\x02\u{13f}\u{141}\
	\x09\x04\x02\x02\u{140}\u{13f}\x03\x02\x02\x02\u{140}\u{141}\x03\x02\x02\
	\x02\u{141}\u{142}\x03\x02\x02\x02\u{142}\u{144}\x05\x14\x0b\x02\u{143}\
	\u{140}\x03\x02\x02\x02\u{143}\u{144}\x03\x02\x02\x02\u{144}\u{147}\x03\
	\x02\x02\x02\u{145}\u{147}\x05\x08\x05\x02\u{146}\u{11f}\x03\x02\x02\x02\
	\u{146}\u{120}\x03\x02\x02\x02\u{146}\u{125}\x03\x02\x02\x02\u{146}\u{12d}\
	\x03\x02\x02\x02\u{146}\u{132}\x03\x02\x02\x02\u{146}\u{13a}\x03\x02\x02\
	\x02\u{146}\u{13e}\x03\x02\x02\x02\u{146}\u{145}\x03\x02\x02\x02\u{147}\
	\x11\x03\x02\x02\x02\u{148}\u{14d}\x05\u{ee}\x78\x02\u{149}\u{14a}\x09\x04\
	\x02\x02\u{14a}\u{14c}\x05\u{ee}\x78\x02\u{14b}\u{149}\x03\x02\x02\x02\u{14c}\
	\u{14f}\x03\x02\x02\x02\u{14d}\u{14b}\x03\x02\x02\x02\u{14d}\u{14e}\x03\
	\x02\x02\x02\u{14e}\u{150}\x03\x02\x02\x02\u{14f}\u{14d}\x03\x02\x02\x02\
	\u{150}\u{151}\x09\x04\x02\x02\u{151}\u{152}\x07\x1f\x02\x02\u{152}\x13\
	\x03\x02\x02\x02\u{153}\u{154}\x07\x0d\x02\x02\u{154}\u{15e}\x07\x0e\x02\
	\x02\u{155}\u{159}\x07\x0d\x02\x02\u{156}\u{158}\x05\x10\x09\x02\u{157}\
	\u{156}\x03\x02\x02\x02\u{158}\u{15b}\x03\x02\x02\x02\u{159}\u{157}\x03\
	\x02\x02\x02\u{159}\u{15a}\x03\x02\x02\x02\u{15a}\u{15c}\x03\x02\x02\x02\
	\u{15b}\u{159}\x03\x02\x02\x02\u{15c}\u{15e}\x07\x0e\x02\x02\u{15d}\u{153}\
	\x03\x02\x02\x02\u{15d}\u{155}\x03\x02\x02\x02\u{15e}\x15\x03\x02\x02\x02\
	\u{15f}\u{160}\x07\x65\x02\x02\u{160}\x17\x03\x02\x02\x02\u{161}\u{163}\
	\x05\u{a6}\x54\x02\u{162}\u{161}\x03\x02\x02\x02\u{162}\u{163}\x03\x02\x02\
	\x02\u{163}\u{167}\x03\x02\x02\x02\u{164}\u{166}\x05\u{b2}\x5a\x02\u{165}\
	\u{164}\x03\x02\x02\x02\u{166}\u{169}\x03\x02\x02\x02\u{167}\u{165}\x03\
	\x02\x02\x02\u{167}\u{168}\x03\x02\x02\x02\u{168}\u{16a}\x03\x02\x02\x02\
	\u{169}\u{167}\x03\x02\x02\x02\u{16a}\u{16b}\x05\u{e0}\x71\x02\u{16b}\u{16c}\
	\x07\x66\x02\x02\u{16c}\u{16e}\x05\u{ee}\x78\x02\u{16d}\u{16f}\x05\u{98}\
	\x4d\x02\u{16e}\u{16d}\x03\x02\x02\x02\u{16e}\u{16f}\x03\x02\x02\x02\u{16f}\
	\u{171}\x03\x02\x02\x02\u{170}\u{172}\x05\x1c\x0f\x02\u{171}\u{170}\x03\
	\x02\x02\x02\u{171}\u{172}\x03\x02\x02\x02\u{172}\u{174}\x03\x02\x02\x02\
	\u{173}\u{175}\x05\x64\x33\x02\u{174}\u{173}\x03\x02\x02\x02\u{174}\u{175}\
	\x03\x02\x02\x02\u{175}\u{176}\x03\x02\x02\x02\u{176}\u{178}\x05\x1a\x0e\
	\x02\u{177}\u{179}\x05\x06\x04\x02\u{178}\u{177}\x03\x02\x02\x02\u{178}\
	\u{179}\x03\x02\x02\x02\u{179}\x19\x03\x02\x02\x02\u{17a}\u{181}\x07\x0d\
	\x02\x02\u{17b}\u{180}\x05\x24\x13\x02\u{17c}\u{180}\x05\x22\x12\x02\u{17d}\
	\u{180}\x05\x20\x11\x02\u{17e}\u{180}\x05\x08\x05\x02\u{17f}\u{17b}\x03\
	\x02\x02\x02\u{17f}\u{17c}\x03\x02\x02\x02\u{17f}\u{17d}\x03\x02\x02\x02\
	\u{17f}\u{17e}\x03\x02\x02\x02\u{180}\u{183}\x03\x02\x02\x02\u{181}\u{17f}\
	\x03\x02\x02\x02\u{181}\u{182}\x03\x02\x02\x02\u{182}\u{184}\x03\x02\x02\
	\x02\u{183}\u{181}\x03\x02\x02\x02\u{184}\u{185}\x07\x0e\x02\x02\u{185}\
	\x1b\x03\x02\x02\x02\u{186}\u{187}\x07\x09\x02\x02\u{187}\u{197}\x07\x0a\
	\x02\x02\u{188}\u{189}\x07\x09\x02\x02\u{189}\u{18e}\x05\x1e\x10\x02\u{18a}\
	\u{18b}\x07\x04\x02\x02\u{18b}\u{18d}\x05\x1e\x10\x02\u{18c}\u{18a}\x03\
	\x02\x02\x02\u{18d}\u{190}\x03\x02\x02\x02\u{18e}\u{18c}\x03\x02\x02\x02\
	\u{18e}\u{18f}\x03\x02\x02\x02\u{18f}\u{192}\x03\x02\x02\x02\u{190}\u{18e}\
	\x03\x02\x02\x02\u{191}\u{193}\x07\x04\x02\x02\u{192}\u{191}\x03\x02\x02\
	\x02\u{192}\u{193}\x03\x02\x02\x02\u{193}\u{194}\x03\x02\x02\x02\u{194}\
	\u{195}\x07\x0a\x02\x02\u{195}\u{197}\x03\x02\x02\x02\u{196}\u{186}\x03\
	\x02\x02\x02\u{196}\u{188}\x03\x02\x02\x02\u{197}\x1d\x03\x02\x02\x02\u{198}\
	\u{199}\x05\u{e4}\x73\x02\u{199}\x1f\x03\x02\x02\x02\u{19a}\u{19c}\x05\u{b2}\
	\x5a\x02\u{19b}\u{19a}\x03\x02\x02\x02\u{19c}\u{19f}\x03\x02\x02\x02\u{19d}\
	\u{19b}\x03\x02\x02\x02\u{19d}\u{19e}\x03\x02\x02\x02\u{19e}\u{1a0}\x03\
	\x02\x02\x02\u{19f}\u{19d}\x03\x02\x02\x02\u{1a0}\u{1a2}\x05\u{e2}\x72\x02\
	\u{1a1}\u{1a3}\x05\x64\x33\x02\u{1a2}\u{1a1}\x03\x02\x02\x02\u{1a2}\u{1a3}\
	\x03\x02\x02\x02\u{1a3}\u{1a5}\x03\x02\x02\x02\u{1a4}\u{1a6}\x05\x46\x24\
	\x02\u{1a5}\u{1a4}\x03\x02\x02\x02\u{1a5}\u{1a6}\x03\x02\x02\x02\u{1a6}\
	\x21\x03\x02\x02\x02\u{1a7}\u{1a9}\x05\u{b2}\x5a\x02\u{1a8}\u{1a7}\x03\x02\
	\x02\x02\u{1a9}\u{1ac}\x03\x02\x02\x02\u{1aa}\u{1a8}\x03\x02\x02\x02\u{1aa}\
	\u{1ab}\x03\x02\x02\x02\u{1ab}\u{1ad}\x03\x02\x02\x02\u{1ac}\u{1aa}\x03\
	\x02\x02\x02\u{1ad}\u{1af}\x05\u{e4}\x73\x02\u{1ae}\u{1b0}\x05\u{98}\x4d\
	\x02\u{1af}\u{1ae}\x03\x02\x02\x02\u{1af}\u{1b0}\x03\x02\x02\x02\u{1b0}\
	\u{1b1}\x03\x02\x02\x02\u{1b1}\u{1b3}\x05\x42\x22\x02\u{1b2}\u{1b4}\x05\
	\x64\x33\x02\u{1b3}\u{1b2}\x03\x02\x02\x02\u{1b3}\u{1b4}\x03\x02\x02\x02\
	\u{1b4}\u{1b6}\x03\x02\x02\x02\u{1b5}\u{1b7}\x05\x66\x34\x02\u{1b6}\u{1b5}\
	\x03\x02\x02\x02\u{1b6}\u{1b7}\x03\x02\x02\x02\u{1b7}\u{1b9}\x03\x02\x02\
	\x02\u{1b8}\u{1ba}\x05\x54\x2b\x02\u{1b9}\u{1b8}\x03\x02\x02\x02\u{1b9}\
	\u{1ba}\x03\x02\x02\x02\u{1ba}\x23\x03\x02\x02\x02\u{1bb}\u{1bd}\x05\u{b2}\
	\x5a\x02\u{1bc}\u{1bb}\x03\x02\x02\x02\u{1bd}\u{1c0}\x03\x02\x02\x02\u{1be}\
	\u{1bc}\x03\x02\x02\x02\u{1be}\u{1bf}\x03\x02\x02\x02\u{1bf}\u{1c1}\x03\
	\x02\x02\x02\u{1c0}\u{1be}\x03\x02\x02\x02\u{1c1}\u{1c2}\x05\u{e2}\x72\x02\
	\u{1c2}\u{1c3}\x05\x1a\x0e\x02\u{1c3}\x25\x03\x02\x02\x02\u{1c4}\u{1c6}\
	\x05\u{a6}\x54\x02\u{1c5}\u{1c4}\x03\x02\x02\x02\u{1c5}\u{1c6}\x03\x02\x02\
	\x02\u{1c6}\u{1ca}\x03\x02\x02\x02\u{1c7}\u{1c9}\x05\u{b2}\x5a\x02\u{1c8}\
	\u{1c7}\x03\x02\x02\x02\u{1c9}\u{1cc}\x03\x02\x02\x02\u{1ca}\u{1c8}\x03\
	\x02\x02\x02\u{1ca}\u{1cb}\x03\x02\x02\x02\u{1cb}\u{1cd}\x03\x02\x02\x02\
	\u{1cc}\u{1ca}\x03\x02\x02\x02\u{1cd}\u{1ce}\x05\u{e0}\x71\x02\u{1ce}\u{1cf}\
	\x07\x67\x02\x02\u{1cf}\u{1d1}\x05\u{ee}\x78\x02\u{1d0}\u{1d2}\x05\u{98}\
	\x4d\x02\u{1d1}\u{1d0}\x03\x02\x02\x02\u{1d1}\u{1d2}\x03\x02\x02\x02\u{1d2}\
	\u{1d4}\x03\x02\x02\x02\u{1d3}\u{1d5}\x05\x2e\x18\x02\u{1d4}\u{1d3}\x03\
	\x02\x02\x02\u{1d4}\u{1d5}\x03\x02\x02\x02\u{1d5}\u{1d6}\x03\x02\x02\x02\
	\u{1d6}\u{1d8}\x05\x28\x15\x02\u{1d7}\u{1d9}\x05\x06\x04\x02\u{1d8}\u{1d7}\
	\x03\x02\x02\x02\u{1d8}\u{1d9}\x03\x02\x02\x02\u{1d9}\x27\x03\x02\x02\x02\
	\u{1da}\u{1e1}\x07\x0d\x02\x02\u{1db}\u{1e0}\x05\x2a\x16\x02\u{1dc}\u{1e0}\
	\x05\x22\x12\x02\u{1dd}\u{1e0}\x05\x20\x11\x02\u{1de}\u{1e0}\x05\x08\x05\
	\x02\u{1df}\u{1db}\x03\x02\x02\x02\u{1df}\u{1dc}\x03\x02\x02\x02\u{1df}\
	\u{1dd}\x03\x02\x02\x02\u{1df}\u{1de}\x03\x02\x02\x02\u{1e0}\u{1e3}\x03\
	\x02\x02\x02\u{1e1}\u{1df}\x03\x02\x02\x02\u{1e1}\u{1e2}\x03\x02\x02\x02\
	\u{1e2}\u{1e4}\x03\x02\x02\x02\u{1e3}\u{1e1}\x03\x02\x02\x02\u{1e4}\u{1e5}\
	\x07\x0e\x02\x02\u{1e5}\x29\x03\x02\x02\x02\u{1e6}\u{1e7}\x07\x6a\x02\x02\
	\u{1e7}\u{1ea}\x05\u{ee}\x78\x02\u{1e8}\u{1e9}\x07\x33\x02\x02\u{1e9}\u{1eb}\
	\x05\x7a\x3e\x02\u{1ea}\u{1e8}\x03\x02\x02\x02\u{1ea}\u{1eb}\x03\x02\x02\
	\x02\u{1eb}\x2b\x03\x02\x02\x02\u{1ec}\u{1ee}\x05\u{a6}\x54\x02\u{1ed}\u{1ec}\
	\x03\x02\x02\x02\u{1ed}\u{1ee}\x03\x02\x02\x02\u{1ee}\u{1f2}\x03\x02\x02\
	\x02\u{1ef}\u{1f1}\x05\u{b2}\x5a\x02\u{1f0}\u{1ef}\x03\x02\x02\x02\u{1f1}\
	\u{1f4}\x03\x02\x02\x02\u{1f2}\u{1f0}\x03\x02\x02\x02\u{1f2}\u{1f3}\x03\
	\x02\x02\x02\u{1f3}\u{1f5}\x03\x02\x02\x02\u{1f4}\u{1f2}\x03\x02\x02\x02\
	\u{1f5}\u{1f6}\x05\u{e0}\x71\x02\u{1f6}\u{1f7}\x07\x6c\x02\x02\u{1f7}\u{1f9}\
	\x05\u{ec}\x77\x02\u{1f8}\u{1fa}\x05\u{98}\x4d\x02\u{1f9}\u{1f8}\x03\x02\
	\x02\x02\u{1f9}\u{1fa}\x03\x02\x02\x02\u{1fa}\u{1fc}\x03\x02\x02\x02\u{1fb}\
	\u{1fd}\x05\x2e\x18\x02\u{1fc}\u{1fb}\x03\x02\x02\x02\u{1fc}\u{1fd}\x03\
	\x02\x02\x02\u{1fd}\u{1fe}\x03\x02\x02\x02\u{1fe}\u{1ff}\x05\x28\x15\x02\
	\u{1ff}\x2d\x03\x02\x02\x02\u{200}\u{201}\x09\x05\x02\x02\u{201}\u{202}\
	\x05\x7a\x3e\x02\u{202}\x2f\x03\x02\x02\x02\u{203}\u{205}\x05\u{b2}\x5a\
	\x02\u{204}\u{203}\x03\x02\x02\x02\u{205}\u{208}\x03\x02\x02\x02\u{206}\
	\u{204}\x03\x02\x02\x02\u{206}\u{207}\x03\x02\x02\x02\u{207}\u{209}\x03\
	\x02\x02\x02\u{208}\u{206}\x03\x02\x02\x02\u{209}\u{20a}\x05\u{e0}\x71\x02\
	\u{20a}\u{20b}\x07\x68\x02\x02\u{20b}\u{20d}\x05\u{ee}\x78\x02\u{20c}\u{20e}\
	\x05\x32\x1a\x02\u{20d}\u{20c}\x03\x02\x02\x02\u{20d}\u{20e}\x03\x02\x02\
	\x02\u{20e}\u{210}\x03\x02\x02\x02\u{20f}\u{211}\x05\x64\x33\x02\u{210}\
	\u{20f}\x03\x02\x02\x02\u{210}\u{211}\x03\x02\x02\x02\u{211}\u{212}\x03\
	\x02\x02\x02\u{212}\u{213}\x05\x34\x1b\x02\u{213}\x31\x03\x02\x02\x02\u{214}\
	\u{216}\x07\x09\x02\x02\u{215}\u{217}\x05\x7a\x3e\x02\u{216}\u{215}\x03\
	\x02\x02\x02\u{216}\u{217}\x03\x02\x02\x02\u{217}\u{218}\x03\x02\x02\x02\
	\u{218}\u{219}\x07\x0a\x02\x02\u{219}\x33\x03\x02\x02\x02\u{21a}\u{220}\
	\x07\x0d\x02\x02\u{21b}\u{21f}\x05\x22\x12\x02\u{21c}\u{21f}\x05\x36\x1c\
	\x02\u{21d}\u{21f}\x05\x08\x05\x02\u{21e}\u{21b}\x03\x02\x02\x02\u{21e}\
	\u{21c}\x03\x02\x02\x02\u{21e}\u{21d}\x03\x02\x02\x02\u{21f}\u{222}\x03\
	\x02\x02\x02\u{220}\u{21e}\x03\x02\x02\x02\u{220}\u{221}\x03\x02\x02\x02\
	\u{221}\u{223}\x03\x02\x02\x02\u{222}\u{220}\x03\x02\x02\x02\u{223}\u{224}\
	\x07\x0e\x02\x02\u{224}\x35\x03\x02\x02\x02\u{225}\u{227}\x05\u{ee}\x78\
	\x02\u{226}\u{228}\x05\x38\x1d\x02\u{227}\u{226}\x03\x02\x02\x02\u{227}\
	\u{228}\x03\x02\x02\x02\u{228}\x37\x03\x02\x02\x02\u{229}\u{22e}\x07\x0d\
	\x02\x02\u{22a}\u{22d}\x05\x20\x11\x02\u{22b}\u{22d}\x05\x08\x05\x02\u{22c}\
	\u{22a}\x03\x02\x02\x02\u{22c}\u{22b}\x03\x02\x02\x02\u{22d}\u{230}\x03\
	\x02\x02\x02\u{22e}\u{22c}\x03\x02\x02\x02\u{22e}\u{22f}\x03\x02\x02\x02\
	\u{22f}\u{231}\x03\x02\x02\x02\u{230}\u{22e}\x03\x02\x02\x02\u{231}\u{232}\
	\x07\x0e\x02\x02\u{232}\x39\x03\x02\x02\x02\u{233}\u{235}\x05\u{b2}\x5a\
	\x02\u{234}\u{233}\x03\x02\x02\x02\u{235}\u{238}\x03\x02\x02\x02\u{236}\
	\u{234}\x03\x02\x02\x02\u{236}\u{237}\x03\x02\x02\x02\u{237}\u{239}\x03\
	\x02\x02\x02\u{238}\u{236}\x03\x02\x02\x02\u{239}\u{23a}\x05\u{e0}\x71\x02\
	\u{23a}\u{23b}\x07\x69\x02\x02\u{23b}\u{23d}\x05\u{ee}\x78\x02\u{23c}\u{23e}\
	\x05\x32\x1a\x02\u{23d}\u{23c}\x03\x02\x02\x02\u{23d}\u{23e}\x03\x02\x02\
	\x02\u{23e}\u{240}\x03\x02\x02\x02\u{23f}\u{241}\x05\x64\x33\x02\u{240}\
	\u{23f}\x03\x02\x02\x02\u{240}\u{241}\x03\x02\x02\x02\u{241}\u{242}\x03\
	\x02\x02\x02\u{242}\u{243}\x05\x3c\x1f\x02\u{243}\x3b\x03\x02\x02\x02\u{244}\
	\u{24a}\x07\x0d\x02\x02\u{245}\u{249}\x05\x22\x12\x02\u{246}\u{249}\x05\
	\x3e\x20\x02\u{247}\u{249}\x05\x08\x05\x02\u{248}\u{245}\x03\x02\x02\x02\
	\u{248}\u{246}\x03\x02\x02\x02\u{248}\u{247}\x03\x02\x02\x02\u{249}\u{24c}\
	\x03\x02\x02\x02\u{24a}\u{248}\x03\x02\x02\x02\u{24a}\u{24b}\x03\x02\x02\
	\x02\u{24b}\u{24d}\x03\x02\x02\x02\u{24c}\u{24a}\x03\x02\x02\x02\u{24d}\
	\u{24e}\x07\x0e\x02\x02\u{24e}\x3d\x03\x02\x02\x02\u{24f}\u{251}\x05\u{b2}\
	\x5a\x02\u{250}\u{24f}\x03\x02\x02\x02\u{251}\u{254}\x03\x02\x02\x02\u{252}\
	\u{250}\x03\x02\x02\x02\u{252}\u{253}\x03\x02\x02\x02\u{253}\u{255}\x03\
	\x02\x02\x02\u{254}\u{252}\x03\x02\x02\x02\u{255}\u{258}\x05\u{ee}\x78\x02\
	\u{256}\u{257}\x07\x33\x02\x02\u{257}\u{259}\x05\x74\x3b\x02\u{258}\u{256}\
	\x03\x02\x02\x02\u{258}\u{259}\x03\x02\x02\x02\u{259}\x3f\x03\x02\x02\x02\
	\u{25a}\u{25c}\x05\u{a6}\x54\x02\u{25b}\u{25a}\x03\x02\x02\x02\u{25b}\u{25c}\
	\x03\x02\x02\x02\u{25c}\u{260}\x03\x02\x02\x02\u{25d}\u{25f}\x05\u{b2}\x5a\
	\x02\u{25e}\u{25d}\x03\x02\x02\x02\u{25f}\u{262}\x03\x02\x02\x02\u{260}\
	\u{25e}\x03\x02\x02\x02\u{260}\u{261}\x03\x02\x02\x02\u{261}\u{263}\x03\
	\x02\x02\x02\u{262}\u{260}\x03\x02\x02\x02\u{263}\u{264}\x05\u{e0}\x71\x02\
	\u{264}\u{265}\x07\x76\x02\x02\u{265}\u{267}\x05\u{ec}\x77\x02\u{266}\u{268}\
	\x05\u{98}\x4d\x02\u{267}\u{266}\x03\x02\x02\x02\u{267}\u{268}\x03\x02\x02\
	\x02\u{268}\u{269}\x03\x02\x02\x02\u{269}\u{26b}\x05\x42\x22\x02\u{26a}\
	\u{26c}\x05\x64\x33\x02\u{26b}\u{26a}\x03\x02\x02\x02\u{26b}\u{26c}\x03\
	\x02\x02\x02\u{26c}\u{26e}\x03\x02\x02\x02\u{26d}\u{26f}\x05\x66\x34\x02\
	\u{26e}\u{26d}\x03\x02\x02\x02\u{26e}\u{26f}\x03\x02\x02\x02\u{26f}\u{270}\
	\x03\x02\x02\x02\u{270}\u{271}\x05\x54\x2b\x02\u{271}\x41\x03\x02\x02\x02\
	\u{272}\u{273}\x07\x09\x02\x02\u{273}\u{280}\x07\x0a\x02\x02\u{274}\u{275}\
	\x07\x09\x02\x02\u{275}\u{27a}\x05\x44\x23\x02\u{276}\u{277}\x07\x04\x02\
	\x02\u{277}\u{279}\x05\x44\x23\x02\u{278}\u{276}\x03\x02\x02\x02\u{279}\
	\u{27c}\x03\x02\x02\x02\u{27a}\u{278}\x03\x02\x02\x02\u{27a}\u{27b}\x03\
	\x02\x02\x02\u{27b}\u{27d}\x03\x02\x02\x02\u{27c}\u{27a}\x03\x02\x02\x02\
	\u{27d}\u{27e}\x07\x0a\x02\x02\u{27e}\u{280}\x03\x02\x02\x02\u{27f}\u{272}\
	\x03\x02\x02\x02\u{27f}\u{274}\x03\x02\x02\x02\u{280}\x43\x03\x02\x02\x02\
	\u{281}\u{283}\x05\u{b2}\x5a\x02\u{282}\u{281}\x03\x02\x02\x02\u{283}\u{286}\
	\x03\x02\x02\x02\u{284}\u{282}\x03\x02\x02\x02\u{284}\u{285}\x03\x02\x02\
	\x02\u{285}\u{287}\x03\x02\x02\x02\u{286}\u{284}\x03\x02\x02\x02\u{287}\
	\u{289}\x05\u{e2}\x72\x02\u{288}\u{28a}\x05\x64\x33\x02\u{289}\u{288}\x03\
	\x02\x02\x02\u{289}\u{28a}\x03\x02\x02\x02\u{28a}\u{28c}\x03\x02\x02\x02\
	\u{28b}\u{28d}\x05\x46\x24\x02\u{28c}\u{28b}\x03\x02\x02\x02\u{28c}\u{28d}\
	\x03\x02\x02\x02\u{28d}\x45\x03\x02\x02\x02\u{28e}\u{28f}\x07\x33\x02\x02\
	\u{28f}\u{290}\x05\x74\x3b\x02\u{290}\x47\x03\x02\x02\x02\u{291}\u{293}\
	\x07\x4e\x02\x02\u{292}\u{291}\x03\x02\x02\x02\u{292}\u{293}\x03\x02\x02\
	\x02\u{293}\u{294}\x03\x02\x02\x02\u{294}\u{295}\x05\x4c\x27\x02\u{295}\
	\x49\x03\x02\x02\x02\u{296}\u{298}\x07\x4e\x02\x02\u{297}\u{296}\x03\x02\
	\x02\x02\u{297}\u{298}\x03\x02\x02\x02\u{298}\u{299}\x03\x02\x02\x02\u{299}\
	\u{29a}\x07\x03\x02\x02\u{29a}\u{29c}\x05\u{ec}\x77\x02\u{29b}\u{29d}\x05\
	\x4c\x27\x02\u{29c}\u{29b}\x03\x02\x02\x02\u{29c}\u{29d}\x03\x02\x02\x02\
	\u{29d}\u{2aa}\x03\x02\x02\x02\u{29e}\u{2a0}\x07\x4e\x02\x02\u{29f}\u{29e}\
	\x03\x02\x02\x02\u{29f}\u{2a0}\x03\x02\x02\x02\u{2a0}\u{2a1}\x03\x02\x02\
	\x02\u{2a1}\u{2a3}\x07\x03\x02\x02\u{2a2}\u{2a4}\x07\x48\x02\x02\u{2a3}\
	\u{2a2}\x03\x02\x02\x02\u{2a3}\u{2a4}\x03\x02\x02\x02\u{2a4}\u{2a5}\x03\
	\x02\x02\x02\u{2a5}\u{2a7}\x05\u{ec}\x77\x02\u{2a6}\u{2a8}\x05\x4c\x27\x02\
	\u{2a7}\u{2a6}\x03\x02\x02\x02\u{2a7}\u{2a8}\x03\x02\x02\x02\u{2a8}\u{2aa}\
	\x03\x02\x02\x02\u{2a9}\u{297}\x03\x02\x02\x02\u{2a9}\u{29f}\x03\x02\x02\
	\x02\u{2aa}\x4b\x03\x02\x02\x02\u{2ab}\u{2ac}\x07\x09\x02\x02\u{2ac}\u{2bc}\
	\x07\x0a\x02\x02\u{2ad}\u{2ae}\x07\x09\x02\x02\u{2ae}\u{2b3}\x05\x4e\x28\
	\x02\u{2af}\u{2b0}\x07\x04\x02\x02\u{2b0}\u{2b2}\x05\x4e\x28\x02\u{2b1}\
	\u{2af}\x03\x02\x02\x02\u{2b2}\u{2b5}\x03\x02\x02\x02\u{2b3}\u{2b1}\x03\
	\x02\x02\x02\u{2b3}\u{2b4}\x03\x02\x02\x02\u{2b4}\u{2b7}\x03\x02\x02\x02\
	\u{2b5}\u{2b3}\x03\x02\x02\x02\u{2b6}\u{2b8}\x07\x04\x02\x02\u{2b7}\u{2b6}\
	\x03\x02\x02\x02\u{2b7}\u{2b8}\x03\x02\x02\x02\u{2b8}\u{2b9}\x03\x02\x02\
	\x02\u{2b9}\u{2ba}\x07\x0a\x02\x02\u{2ba}\u{2bc}\x03\x02\x02\x02\u{2bb}\
	\u{2ab}\x03\x02\x02\x02\u{2bb}\u{2ad}\x03\x02\x02\x02\u{2bc}\x4d\x03\x02\
	\x02\x02\u{2bd}\u{2be}\x05\u{ee}\x78\x02\u{2be}\u{2bf}\x07\x08\x02\x02\u{2bf}\
	\u{2c0}\x05\x74\x3b\x02\u{2c0}\u{2c3}\x03\x02\x02\x02\u{2c1}\u{2c3}\x05\
	\x74\x3b\x02\u{2c2}\u{2bd}\x03\x02\x02\x02\u{2c2}\u{2c1}\x03\x02\x02\x02\
	\u{2c3}\x4f\x03\x02\x02\x02\u{2c4}\u{2c6}\x05\u{b2}\x5a\x02\u{2c5}\u{2c4}\
	\x03\x02\x02\x02\u{2c6}\u{2c9}\x03\x02\x02\x02\u{2c7}\u{2c5}\x03\x02\x02\
	\x02\u{2c7}\u{2c8}\x03\x02\x02\x02\u{2c8}\u{2ca}\x03\x02\x02\x02\u{2c9}\
	\u{2c7}\x03\x02\x02\x02\u{2ca}\u{2cb}\x07\x75\x02\x02\u{2cb}\u{2cd}\x05\
	\x42\x22\x02\u{2cc}\u{2ce}\x05\x64\x33\x02\u{2cd}\u{2cc}\x03\x02\x02\x02\
	\u{2cd}\u{2ce}\x03\x02\x02\x02\u{2ce}\u{2cf}\x03\x02\x02\x02\u{2cf}\u{2d0}\
	\x05\x54\x2b\x02\u{2d0}\x51\x03\x02\x02\x02\u{2d1}\u{2d3}\x07\x4e\x02\x02\
	\u{2d2}\u{2d1}\x03\x02\x02\x02\u{2d2}\u{2d3}\x03\x02\x02\x02\u{2d3}\u{2d4}\
	\x03\x02\x02\x02\u{2d4}\u{2d5}\x05\x54\x2b\x02\u{2d5}\x53\x03\x02\x02\x02\
	\u{2d6}\u{2db}\x07\x0d\x02\x02\u{2d7}\u{2da}\x05\x56\x2c\x02\u{2d8}\u{2da}\
	\x05\x06\x04\x02\u{2d9}\u{2d7}\x03\x02\x02\x02\u{2d9}\u{2d8}\x03\x02\x02\
	\x02\u{2da}\u{2dd}\x03\x02\x02\x02\u{2db}\u{2d9}\x03\x02\x02\x02\u{2db}\
	\u{2dc}\x03\x02\x02\x02\u{2dc}\u{2de}\x03\x02\x02\x02\u{2dd}\u{2db}\x03\
	\x02\x02\x02\u{2de}\u{2df}\x07\x0e\x02\x02\u{2df}\x55\x03\x02\x02\x02\u{2e0}\
	\u{2e7}\x05\x62\x32\x02\u{2e1}\u{2e7}\x05\x50\x29\x02\u{2e2}\u{2e7}\x05\
	\x58\x2d\x02\u{2e3}\u{2e7}\x05\x6e\x38\x02\u{2e4}\u{2e7}\x05\x6a\x36\x02\
	\u{2e5}\u{2e7}\x05\x72\x3a\x02\u{2e6}\u{2e0}\x03\x02\x02\x02\u{2e6}\u{2e1}\
	\x03\x02\x02\x02\u{2e6}\u{2e2}\x03\x02\x02\x02\u{2e6}\u{2e3}\x03\x02\x02\
	\x02\u{2e6}\u{2e4}\x03\x02\x02\x02\u{2e6}\u{2e5}\x03\x02\x02\x02\u{2e7}\
	\x57\x03\x02\x02\x02\u{2e8}\u{2e9}\x07\x71\x02\x02\u{2e9}\u{2eb}\x05\x5a\
	\x2e\x02\u{2ea}\u{2ec}\x05\x64\x33\x02\u{2eb}\u{2ea}\x03\x02\x02\x02\u{2eb}\
	\u{2ec}\x03\x02\x02\x02\u{2ec}\u{2ef}\x03\x02\x02\x02\u{2ed}\u{2ee}\x07\
	\x33\x02\x02\u{2ee}\u{2f0}\x05\x74\x3b\x02\u{2ef}\u{2ed}\x03\x02\x02\x02\
	\u{2ef}\u{2f0}\x03\x02\x02\x02\u{2f0}\x59\x03\x02\x02\x02\u{2f1}\u{2f4}\
	\x05\x5e\x30\x02\u{2f2}\u{2f4}\x05\x5c\x2f\x02\u{2f3}\u{2f1}\x03\x02\x02\
	\x02\u{2f3}\u{2f2}\x03\x02\x02\x02\u{2f4}\x5b\x03\x02\x02\x02\u{2f5}\u{2fa}\
	\x05\u{e2}\x72\x02\u{2f6}\u{2f7}\x07\x04\x02\x02\u{2f7}\u{2f9}\x05\u{e2}\
	\x72\x02\u{2f8}\u{2f6}\x03\x02\x02\x02\u{2f9}\u{2fc}\x03\x02\x02\x02\u{2fa}\
	\u{2f8}\x03\x02\x02\x02\u{2fa}\u{2fb}\x03\x02\x02\x02\u{2fb}\u{2fe}\x03\
	\x02\x02\x02\u{2fc}\u{2fa}\x03\x02\x02\x02\u{2fd}\u{2ff}\x07\x04\x02\x02\
	\u{2fe}\u{2fd}\x03\x02\x02\x02\u{2fe}\u{2ff}\x03\x02\x02\x02\u{2ff}\x5d\
	\x03\x02\x02\x02\u{300}\u{30e}\x07\x09\x02\x02\u{301}\u{302}\x05\x60\x31\
	\x02\u{302}\u{303}\x07\x04\x02\x02\u{303}\u{30f}\x03\x02\x02\x02\u{304}\
	\u{307}\x05\x60\x31\x02\u{305}\u{306}\x07\x04\x02\x02\u{306}\u{308}\x05\
	\x60\x31\x02\u{307}\u{305}\x03\x02\x02\x02\u{308}\u{309}\x03\x02\x02\x02\
	\u{309}\u{307}\x03\x02\x02\x02\u{309}\u{30a}\x03\x02\x02\x02\u{30a}\u{30c}\
	\x03\x02\x02\x02\u{30b}\u{30d}\x07\x04\x02\x02\u{30c}\u{30b}\x03\x02\x02\
	\x02\u{30c}\u{30d}\x03\x02\x02\x02\u{30d}\u{30f}\x03\x02\x02\x02\u{30e}\
	\u{301}\x03\x02\x02\x02\u{30e}\u{304}\x03\x02\x02\x02\u{30e}\u{30f}\x03\
	\x02\x02\x02\u{30f}\u{310}\x03\x02\x02\x02\u{310}\u{347}\x07\x0a\x02\x02\
	\u{311}\u{312}\x05\u{ec}\x77\x02\u{312}\u{31e}\x07\x09\x02\x02\u{313}\u{318}\
	\x05\x60\x31\x02\u{314}\u{315}\x07\x04\x02\x02\u{315}\u{317}\x05\x60\x31\
	\x02\u{316}\u{314}\x03\x02\x02\x02\u{317}\u{31a}\x03\x02\x02\x02\u{318}\
	\u{316}\x03\x02\x02\x02\u{318}\u{319}\x03\x02\x02\x02\u{319}\u{31c}\x03\
	\x02\x02\x02\u{31a}\u{318}\x03\x02\x02\x02\u{31b}\u{31d}\x07\x04\x02\x02\
	\u{31c}\u{31b}\x03\x02\x02\x02\u{31c}\u{31d}\x03\x02\x02\x02\u{31d}\u{31f}\
	\x03\x02\x02\x02\u{31e}\u{313}\x03\x02\x02\x02\u{31e}\u{31f}\x03\x02\x02\
	\x02\u{31f}\u{320}\x03\x02\x02\x02\u{320}\u{321}\x07\x0a\x02\x02\u{321}\
	\u{347}\x03\x02\x02\x02\u{322}\u{324}\x05\u{ec}\x77\x02\u{323}\u{322}\x03\
	\x02\x02\x02\u{323}\u{324}\x03\x02\x02\x02\u{324}\u{325}\x03\x02\x02\x02\
	\u{325}\u{331}\x07\x0b\x02\x02\u{326}\u{32b}\x05\x60\x31\x02\u{327}\u{328}\
	\x07\x04\x02\x02\u{328}\u{32a}\x05\x60\x31\x02\u{329}\u{327}\x03\x02\x02\
	\x02\u{32a}\u{32d}\x03\x02\x02\x02\u{32b}\u{329}\x03\x02\x02\x02\u{32b}\
	\u{32c}\x03\x02\x02\x02\u{32c}\u{32f}\x03\x02\x02\x02\u{32d}\u{32b}\x03\
	\x02\x02\x02\u{32e}\u{330}\x07\x04\x02\x02\u{32f}\u{32e}\x03\x02\x02\x02\
	\u{32f}\u{330}\x03\x02\x02\x02\u{330}\u{332}\x03\x02\x02\x02\u{331}\u{326}\
	\x03\x02\x02\x02\u{331}\u{332}\x03\x02\x02\x02\u{332}\u{333}\x03\x02\x02\
	\x02\u{333}\u{347}\x07\x0c\x02\x02\u{334}\u{336}\x05\u{ec}\x77\x02\u{335}\
	\u{334}\x03\x02\x02\x02\u{335}\u{336}\x03\x02\x02\x02\u{336}\u{337}\x03\
	\x02\x02\x02\u{337}\u{343}\x07\x0d\x02\x02\u{338}\u{33d}\x05\x60\x31\x02\
	\u{339}\u{33a}\x07\x04\x02\x02\u{33a}\u{33c}\x05\x60\x31\x02\u{33b}\u{339}\
	\x03\x02\x02\x02\u{33c}\u{33f}\x03\x02\x02\x02\u{33d}\u{33b}\x03\x02\x02\
	\x02\u{33d}\u{33e}\x03\x02\x02\x02\u{33e}\u{341}\x03\x02\x02\x02\u{33f}\
	\u{33d}\x03\x02\x02\x02\u{340}\u{342}\x07\x04\x02\x02\u{341}\u{340}\x03\
	\x02\x02\x02\u{341}\u{342}\x03\x02\x02\x02\u{342}\u{344}\x03\x02\x02\x02\
	\u{343}\u{338}\x03\x02\x02\x02\u{343}\u{344}\x03\x02\x02\x02\u{344}\u{345}\
	\x03\x02\x02\x02\u{345}\u{347}\x07\x0e\x02\x02\u{346}\u{300}\x03\x02\x02\
	\x02\u{346}\u{311}\x03\x02\x02\x02\u{346}\u{323}\x03\x02\x02\x02\u{346}\
	\u{335}\x03\x02\x02\x02\u{347}\x5f\x03\x02\x02\x02\u{348}\u{349}\x05\u{e2}\
	\x72\x02\u{349}\u{34a}\x07\x08\x02\x02\u{34a}\u{34c}\x03\x02\x02\x02\u{34b}\
	\u{348}\x03\x02\x02\x02\u{34b}\u{34c}\x03\x02\x02\x02\u{34c}\u{350}\x03\
	\x02\x02\x02\u{34d}\u{34e}\x05\u{ee}\x78\x02\u{34e}\u{34f}\x07\x34\x02\x02\
	\u{34f}\u{351}\x03\x02\x02\x02\u{350}\u{34d}\x03\x02\x02\x02\u{350}\u{351}\
	\x03\x02\x02\x02\u{351}\u{352}\x03\x02\x02\x02\u{352}\u{367}\x05\x5e\x30\
	\x02\u{353}\u{354}\x05\u{e2}\x72\x02\u{354}\u{355}\x07\x08\x02\x02\u{355}\
	\u{357}\x03\x02\x02\x02\u{356}\u{353}\x03\x02\x02\x02\u{356}\u{357}\x03\
	\x02\x02\x02\u{357}\u{35b}\x03\x02\x02\x02\u{358}\u{359}\x05\u{ee}\x78\x02\
	\u{359}\u{35a}\x07\x34\x02\x02\u{35a}\u{35c}\x03\x02\x02\x02\u{35b}\u{358}\
	\x03\x02\x02\x02\u{35b}\u{35c}\x03\x02\x02\x02\u{35c}\u{35d}\x03\x02\x02\
	\x02\u{35d}\u{367}\x05\u{ee}\x78\x02\u{35e}\u{360}\x05\u{e2}\x72\x02\u{35f}\
	\u{35e}\x03\x02\x02\x02\u{35f}\u{360}\x03\x02\x02\x02\u{360}\u{361}\x03\
	\x02\x02\x02\u{361}\u{363}\x07\x59\x02\x02\u{362}\u{364}\x05\u{ee}\x78\x02\
	\u{363}\u{362}\x03\x02\x02\x02\u{363}\u{364}\x03\x02\x02\x02\u{364}\u{367}\
	\x03\x02\x02\x02\u{365}\u{367}\x05\u{e2}\x72\x02\u{366}\u{34b}\x03\x02\x02\
	\x02\u{366}\u{356}\x03\x02\x02\x02\u{366}\u{35f}\x03\x02\x02\x02\u{366}\
	\u{365}\x03\x02\x02\x02\u{367}\x61\x03\x02\x02\x02\u{368}\u{369}\x07\x6a\
	\x02\x02\u{369}\u{36a}\x05\u{ee}\x78\x02\u{36a}\u{36b}\x07\x33\x02\x02\u{36b}\
	\u{36c}\x05\u{ee}\x78\x02\u{36c}\x63\x03\x02\x02\x02\u{36d}\u{36e}\x09\x06\
	\x02\x02\u{36e}\u{36f}\x05\x7a\x3e\x02\u{36f}\x65\x03\x02\x02\x02\u{370}\
	\u{371}\x07\x20\x02\x02\u{371}\u{372}\x05\x7a\x3e\x02\u{372}\x67\x03\x02\
	\x02\x02\u{373}\u{375}\x05\u{b2}\x5a\x02\u{374}\u{373}\x03\x02\x02\x02\u{375}\
	\u{378}\x03\x02\x02\x02\u{376}\u{374}\x03\x02\x02\x02\u{376}\u{377}\x03\
	\x02\x02\x02\u{377}\u{379}\x03\x02\x02\x02\u{378}\u{376}\x03\x02\x02\x02\
	\u{379}\u{37a}\x07\u{82}\x02\x02\u{37a}\u{37b}\x05\x78\x3d\x02\u{37b}\u{37f}\
	\x05\x54\x2b\x02\u{37c}\u{37e}\x05\x6c\x37\x02\u{37d}\u{37c}\x03\x02\x02\
	\x02\u{37e}\u{381}\x03\x02\x02\x02\u{37f}\u{37d}\x03\x02\x02\x02\u{37f}\
	\u{380}\x03\x02\x02\x02\u{380}\u{384}\x03\x02\x02\x02\u{381}\u{37f}\x03\
	\x02\x02\x02\u{382}\u{383}\x07\u{83}\x02\x02\u{383}\u{385}\x05\x54\x2b\x02\
	\u{384}\u{382}\x03\x02\x02\x02\u{384}\u{385}\x03\x02\x02\x02\u{385}\x69\
	\x03\x02\x02\x02\u{386}\u{388}\x05\u{b2}\x5a\x02\u{387}\u{386}\x03\x02\x02\
	\x02\u{388}\u{38b}\x03\x02\x02\x02\u{389}\u{387}\x03\x02\x02\x02\u{389}\
	\u{38a}\x03\x02\x02\x02\u{38a}\u{38c}\x03\x02\x02\x02\u{38b}\u{389}\x03\
	\x02\x02\x02\u{38c}\u{38d}\x07\u{82}\x02\x02\u{38d}\u{391}\x09\x07\x02\x02\
	\u{38e}\u{392}\x05\x5e\x30\x02\u{38f}\u{392}\x05\u{ee}\x78\x02\u{390}\u{392}\
	\x07\u{8b}\x02\x02\u{391}\u{38e}\x03\x02\x02\x02\u{391}\u{38f}\x03\x02\x02\
	\x02\u{391}\u{390}\x03\x02\x02\x02\u{392}\u{393}\x03\x02\x02\x02\u{393}\
	\u{394}\x07\x33\x02\x02\u{394}\u{395}\x05\x78\x3d\x02\u{395}\u{396}\x05\
	\x54\x2b\x02\u{396}\x6b\x03\x02\x02\x02\u{397}\u{398}\x07\u{83}\x02\x02\
	\u{398}\u{399}\x07\u{82}\x02\x02\u{399}\u{39a}\x05\x78\x3d\x02\u{39a}\u{39b}\
	\x05\x54\x2b\x02\u{39b}\x6d\x03\x02\x02\x02\u{39c}\u{39e}\x05\u{b2}\x5a\
	\x02\u{39d}\u{39c}\x03\x02\x02\x02\u{39e}\u{3a1}\x03\x02\x02\x02\u{39f}\
	\u{39d}\x03\x02\x02\x02\u{39f}\u{3a0}\x03\x02\x02\x02\u{3a0}\u{3a2}\x03\
	\x02\x02\x02\u{3a1}\u{39f}\x03\x02\x02\x02\u{3a2}\u{3a3}\x07\x6f\x02\x02\
	\u{3a3}\u{3a4}\x05\x78\x3d\x02\u{3a4}\u{3a5}\x05\x54\x2b\x02\u{3a5}\u{3c3}\
	\x03\x02\x02\x02\u{3a6}\u{3a8}\x05\u{b2}\x5a\x02\u{3a7}\u{3a6}\x03\x02\x02\
	\x02\u{3a8}\u{3ab}\x03\x02\x02\x02\u{3a9}\u{3a7}\x03\x02\x02\x02\u{3a9}\
	\u{3aa}\x03\x02\x02\x02\u{3aa}\u{3ac}\x03\x02\x02\x02\u{3ab}\u{3a9}\x03\
	\x02\x02\x02\u{3ac}\u{3ad}\x07\x6f\x02\x02\u{3ad}\u{3ae}\x07\x71\x02\x02\
	\u{3ae}\u{3af}\x05\x5a\x2e\x02\u{3af}\u{3b0}\x07\x33\x02\x02\u{3b0}\u{3b1}\
	\x05\x78\x3d\x02\u{3b1}\u{3b2}\x05\x54\x2b\x02\u{3b2}\u{3c3}\x03\x02\x02\
	\x02\u{3b3}\u{3b5}\x05\u{b2}\x5a\x02\u{3b4}\u{3b3}\x03\x02\x02\x02\u{3b5}\
	\u{3b8}\x03\x02\x02\x02\u{3b6}\u{3b4}\x03\x02\x02\x02\u{3b6}\u{3b7}\x03\
	\x02\x02\x02\u{3b7}\u{3b9}\x03\x02\x02\x02\u{3b8}\u{3b6}\x03\x02\x02\x02\
	\u{3b9}\u{3ba}\x07\x70\x02\x02\u{3ba}\u{3bb}\x05\x5a\x2e\x02\u{3bb}\u{3bc}\
	\x05\u{96}\x4c\x02\u{3bc}\u{3be}\x05\x78\x3d\x02\u{3bd}\u{3bf}\x05\x70\x39\
	\x02\u{3be}\u{3bd}\x03\x02\x02\x02\u{3be}\u{3bf}\x03\x02\x02\x02\u{3bf}\
	\u{3c0}\x03\x02\x02\x02\u{3c0}\u{3c1}\x05\x54\x2b\x02\u{3c1}\u{3c3}\x03\
	\x02\x02\x02\u{3c2}\u{39f}\x03\x02\x02\x02\u{3c2}\u{3a9}\x03\x02\x02\x02\
	\u{3c2}\u{3b6}\x03\x02\x02\x02\u{3c3}\x6f\x03\x02\x02\x02\u{3c4}\u{3c5}\
	\x07\u{82}\x02\x02\u{3c5}\u{3c6}\x05\x78\x3d\x02\u{3c6}\x71\x03\x02\x02\
	\x02\u{3c7}\u{3c9}\x05\u{b2}\x5a\x02\u{3c8}\u{3c7}\x03\x02\x02\x02\u{3c9}\
	\u{3cc}\x03\x02\x02\x02\u{3ca}\u{3c8}\x03\x02\x02\x02\u{3ca}\u{3cb}\x03\
	\x02\x02\x02\u{3cb}\u{3cd}\x03\x02\x02\x02\u{3cc}\u{3ca}\x03\x02\x02\x02\
	\u{3cd}\u{3cf}\x05\x74\x3b\x02\u{3ce}\u{3d0}\x05\x06\x04\x02\u{3cf}\u{3ce}\
	\x03\x02\x02\x02\u{3cf}\u{3d0}\x03\x02\x02\x02\u{3d0}\x73\x03\x02\x02\x02\
	\u{3d1}\u{3d2}\x08\x3b\x01\x02\u{3d2}\u{3d3}\x05\x7e\x40\x02\u{3d3}\u{3d4}\
	\x05\x74\x3b\x06\u{3d4}\u{3dc}\x03\x02\x02\x02\u{3d5}\u{3d6}\x07\x09\x02\
	\x02\u{3d6}\u{3d7}\x05\x74\x3b\x02\u{3d7}\u{3d8}\x07\x0a\x02\x02\u{3d8}\
	\u{3dc}\x03\x02\x02\x02\u{3d9}\u{3dc}\x05\u{82}\x42\x02\u{3da}\u{3dc}\x05\
	\x76\x3c\x02\u{3db}\u{3d1}\x03\x02\x02\x02\u{3db}\u{3d5}\x03\x02\x02\x02\
	\u{3db}\u{3d9}\x03\x02\x02\x02\u{3db}\u{3da}\x03\x02\x02\x02\u{3dc}\u{41b}\
	\x03\x02\x02\x02\u{3dd}\u{3de}\x0c\x1a\x02\x02\u{3de}\u{3df}\x07\x5b\x02\
	\x02\u{3df}\u{41a}\x05\x74\x3b\x1a\u{3e0}\u{3e1}\x0c\x19\x02\x02\u{3e1}\
	\u{3e2}\x05\u{8a}\x46\x02\u{3e2}\u{3e3}\x05\x74\x3b\x1a\u{3e3}\u{41a}\x03\
	\x02\x02\x02\u{3e4}\u{3e5}\x0c\x18\x02\x02\u{3e5}\u{3e6}\x05\u{8c}\x47\x02\
	\u{3e6}\u{3e7}\x05\x74\x3b\x19\u{3e7}\u{41a}\x03\x02\x02\x02\u{3e8}\u{3e9}\
	\x0c\x17\x02\x02\u{3e9}\u{3ea}\x05\u{8e}\x48\x02\u{3ea}\u{3eb}\x05\x74\x3b\
	\x18\u{3eb}\u{41a}\x03\x02\x02\x02\u{3ec}\u{3ed}\x0c\x16\x02\x02\u{3ed}\
	\u{3ee}\x05\u{84}\x43\x02\u{3ee}\u{3ef}\x05\x74\x3b\x17\u{3ef}\u{41a}\x03\
	\x02\x02\x02\u{3f0}\u{3f1}\x0c\x15\x02\x02\u{3f1}\u{3f2}\x07\x5a\x02\x02\
	\u{3f2}\u{41a}\x05\x74\x3b\x16\u{3f3}\u{3f4}\x0c\x12\x02\x02\u{3f4}\u{3f5}\
	\x05\u{96}\x4c\x02\u{3f5}\u{3f6}\x05\x74\x3b\x13\u{3f6}\u{41a}\x03\x02\x02\
	\x02\u{3f7}\u{3f8}\x0c\x14\x02\x02\u{3f8}\u{3f9}\x05\u{94}\x4b\x02\u{3f9}\
	\u{3fa}\x05\x7a\x3e\x02\u{3fa}\u{41a}\x03\x02\x02\x02\u{3fb}\u{3fc}\x0c\
	\x13\x02\x02\u{3fc}\u{3fd}\x07\x58\x02\x02\u{3fd}\u{41a}\x05\x7a\x3e\x02\
	\u{3fe}\u{3ff}\x0c\x11\x02\x02\u{3ff}\u{400}\x05\u{92}\x4a\x02\u{400}\u{401}\
	\x05\x7a\x3e\x02\u{401}\u{41a}\x03\x02\x02\x02\u{402}\u{403}\x0c\x10\x02\
	\x02\u{403}\u{404}\x07\x4d\x02\x02\u{404}\u{41a}\x05\x7a\x3e\x02\u{405}\
	\u{406}\x0c\x0f\x02\x02\u{406}\u{407}\x05\u{90}\x49\x02\u{407}\u{408}\x05\
	\x7a\x3e\x02\u{408}\u{41a}\x03\x02\x02\x02\u{409}\u{40a}\x0c\x0e\x02\x02\
	\u{40a}\u{41a}\x05\u{80}\x41\x02\u{40b}\u{40c}\x0c\x0d\x02\x02\u{40c}\u{41a}\
	\x05\u{d4}\x6b\x02\u{40d}\u{40e}\x0c\x0c\x02\x02\u{40e}\u{41a}\x05\u{a4}\
	\x53\x02\u{40f}\u{410}\x0c\x0b\x02\x02\u{410}\u{41a}\x05\u{9c}\x4f\x02\u{411}\
	\u{412}\x0c\x0a\x02\x02\u{412}\u{41a}\x05\x52\x2a\x02\u{413}\u{414}\x0c\
	\x09\x02\x02\u{414}\u{41a}\x05\u{ba}\x5e\x02\u{415}\u{416}\x0c\x08\x02\x02\
	\u{416}\u{41a}\x05\x48\x25\x02\u{417}\u{418}\x0c\x07\x02\x02\u{418}\u{41a}\
	\x05\x4a\x26\x02\u{419}\u{3dd}\x03\x02\x02\x02\u{419}\u{3e0}\x03\x02\x02\
	\x02\u{419}\u{3e4}\x03\x02\x02\x02\u{419}\u{3e8}\x03\x02\x02\x02\u{419}\
	\u{3ec}\x03\x02\x02\x02\u{419}\u{3f0}\x03\x02\x02\x02\u{419}\u{3f3}\x03\
	\x02\x02\x02\u{419}\u{3f7}\x03\x02\x02\x02\u{419}\u{3fb}\x03\x02\x02\x02\
	\u{419}\u{3fe}\x03\x02\x02\x02\u{419}\u{402}\x03\x02\x02\x02\u{419}\u{405}\
	\x03\x02\x02\x02\u{419}\u{409}\x03\x02\x02\x02\u{419}\u{40b}\x03\x02\x02\
	\x02\u{419}\u{40d}\x03\x02\x02\x02\u{419}\u{40f}\x03\x02\x02\x02\u{419}\
	\u{411}\x03\x02\x02\x02\u{419}\u{413}\x03\x02\x02\x02\u{419}\u{415}\x03\
	\x02\x02\x02\u{419}\u{417}\x03\x02\x02\x02\u{41a}\u{41d}\x03\x02\x02\x02\
	\u{41b}\u{419}\x03\x02\x02\x02\u{41b}\u{41c}\x03\x02\x02\x02\u{41c}\x75\
	\x03\x02\x02\x02\u{41d}\u{41b}\x03\x02\x02\x02\u{41e}\u{42a}\x05\x68\x35\
	\x02\u{41f}\u{42a}\x05\u{ca}\x66\x02\u{420}\u{42a}\x05\u{b6}\x5c\x02\u{421}\
	\u{42a}\x05\u{b8}\x5d\x02\u{422}\u{42a}\x05\u{c8}\x65\x02\u{423}\u{42a}\
	\x05\u{b0}\x59\x02\u{424}\u{42a}\x05\x48\x25\x02\u{425}\u{42a}\x05\u{a2}\
	\x52\x02\u{426}\u{42a}\x05\u{d0}\x69\x02\u{427}\u{42a}\x05\u{d6}\x6c\x02\
	\u{428}\u{42a}\x05\x7c\x3f\x02\u{429}\u{41e}\x03\x02\x02\x02\u{429}\u{41f}\
	\x03\x02\x02\x02\u{429}\u{420}\x03\x02\x02\x02\u{429}\u{421}\x03\x02\x02\
	\x02\u{429}\u{422}\x03\x02\x02\x02\u{429}\u{423}\x03\x02\x02\x02\u{429}\
	\u{424}\x03\x02\x02\x02\u{429}\u{425}\x03\x02\x02\x02\u{429}\u{426}\x03\
	\x02\x02\x02\u{429}\u{427}\x03\x02\x02\x02\u{429}\u{428}\x03\x02\x02\x02\
	\u{42a}\x77\x03\x02\x02\x02\u{42b}\u{42c}\x08\x3d\x01\x02\u{42c}\u{42d}\
	\x05\x7e\x40\x02\u{42d}\u{42e}\x05\x78\x3d\x04\u{42e}\u{431}\x03\x02\x02\
	\x02\u{42f}\u{431}\x05\x7c\x3f\x02\u{430}\u{42b}\x03\x02\x02\x02\u{430}\
	\u{42f}\x03\x02\x02\x02\u{431}\u{452}\x03\x02\x02\x02\u{432}\u{433}\x0c\
	\x0d\x02\x02\u{433}\u{434}\x05\u{8a}\x46\x02\u{434}\u{435}\x05\x78\x3d\x0e\
	\u{435}\u{451}\x03\x02\x02\x02\u{436}\u{437}\x0c\x0c\x02\x02\u{437}\u{438}\
	\x05\u{8c}\x47\x02\u{438}\u{439}\x05\x78\x3d\x0d\u{439}\u{451}\x03\x02\x02\
	\x02\u{43a}\u{43b}\x0c\x0b\x02\x02\u{43b}\u{43c}\x05\u{8e}\x48\x02\u{43c}\
	\u{43d}\x05\x78\x3d\x0c\u{43d}\u{451}\x03\x02\x02\x02\u{43e}\u{43f}\x0c\
	\x0a\x02\x02\u{43f}\u{440}\x05\u{84}\x43\x02\u{440}\u{441}\x05\x78\x3d\x0b\
	\u{441}\u{451}\x03\x02\x02\x02\u{442}\u{443}\x0c\x09\x02\x02\u{443}\u{444}\
	\x05\u{94}\x4b\x02\u{444}\u{445}\x05\x78\x3d\x0a\u{445}\u{451}\x03\x02\x02\
	\x02\u{446}\u{447}\x0c\x08\x02\x02\u{447}\u{448}\x07\x5a\x02\x02\u{448}\
	\u{451}\x05\x78\x3d\x09\u{449}\u{44a}\x0c\x07\x02\x02\u{44a}\u{44b}\x07\
	\x58\x02\x02\u{44b}\u{451}\x05\x78\x3d\x08\u{44c}\u{44d}\x0c\x06\x02\x02\
	\u{44d}\u{451}\x05\x4a\x26\x02\u{44e}\u{44f}\x0c\x05\x02\x02\u{44f}\u{451}\
	\x05\u{d4}\x6b\x02\u{450}\u{432}\x03\x02\x02\x02\u{450}\u{436}\x03\x02\x02\
	\x02\u{450}\u{43a}\x03\x02\x02\x02\u{450}\u{43e}\x03\x02\x02\x02\u{450}\
	\u{442}\x03\x02\x02\x02\u{450}\u{446}\x03\x02\x02\x02\u{450}\u{449}\x03\
	\x02\x02\x02\u{450}\u{44c}\x03\x02\x02\x02\u{450}\u{44e}\x03\x02\x02\x02\
	\u{451}\u{454}\x03\x02\x02\x02\u{452}\u{450}\x03\x02\x02\x02\u{452}\u{453}\
	\x03\x02\x02\x02\u{453}\x79\x03\x02\x02\x02\u{454}\u{452}\x03\x02\x02\x02\
	\u{455}\u{456}\x08\x3e\x01\x02\u{456}\u{464}\x07\x09\x02\x02\u{457}\u{458}\
	\x05\x7a\x3e\x02\u{458}\u{459}\x07\x04\x02\x02\u{459}\u{465}\x03\x02\x02\
	\x02\u{45a}\u{45d}\x05\x7a\x3e\x02\u{45b}\u{45c}\x07\x04\x02\x02\u{45c}\
	\u{45e}\x05\x7a\x3e\x02\u{45d}\u{45b}\x03\x02\x02\x02\u{45e}\u{45f}\x03\
	\x02\x02\x02\u{45f}\u{45d}\x03\x02\x02\x02\u{45f}\u{460}\x03\x02\x02\x02\
	\u{460}\u{462}\x03\x02\x02\x02\u{461}\u{463}\x07\x04\x02\x02\u{462}\u{461}\
	\x03\x02\x02\x02\u{462}\u{463}\x03\x02\x02\x02\u{463}\u{465}\x03\x02\x02\
	\x02\u{464}\u{457}\x03\x02\x02\x02\u{464}\u{45a}\x03\x02\x02\x02\u{464}\
	\u{465}\x03\x02\x02\x02\u{465}\u{466}\x03\x02\x02\x02\u{466}\u{469}\x07\
	\x0a\x02\x02\u{467}\u{469}\x05\x7c\x3f\x02\u{468}\u{455}\x03\x02\x02\x02\
	\u{468}\u{467}\x03\x02\x02\x02\u{469}\u{479}\x03\x02\x02\x02\u{46a}\u{46b}\
	\x0c\x08\x02\x02\u{46b}\u{46c}\x05\u{86}\x44\x02\u{46c}\u{46d}\x05\x7a\x3e\
	\x09\u{46d}\u{478}\x03\x02\x02\x02\u{46e}\u{46f}\x0c\x07\x02\x02\u{46f}\
	\u{470}\x05\u{88}\x45\x02\u{470}\u{471}\x05\x7a\x3e\x08\u{471}\u{478}\x03\
	\x02\x02\x02\u{472}\u{473}\x0c\x06\x02\x02\u{473}\u{474}\x07\x1b\x02\x02\
	\u{474}\u{478}\x05\x7a\x3e\x07\u{475}\u{476}\x0c\x05\x02\x02\u{476}\u{478}\
	\x05\u{9e}\x50\x02\u{477}\u{46a}\x03\x02\x02\x02\u{477}\u{46e}\x03\x02\x02\
	\x02\u{477}\u{472}\x03\x02\x02\x02\u{477}\u{475}\x03\x02\x02\x02\u{478}\
	\u{47b}\x03\x02\x02\x02\u{479}\u{477}\x03\x02\x02\x02\u{479}\u{47a}\x03\
	\x02\x02\x02\u{47a}\x7b\x03\x02\x02\x02\u{47b}\u{479}\x03\x02\x02\x02\u{47c}\
	\u{482}\x05\u{f6}\x7c\x02\u{47d}\u{482}\x05\u{f2}\x7a\x02\u{47e}\u{482}\
	\x05\u{e6}\x74\x02\u{47f}\u{482}\x05\u{ec}\x77\x02\u{480}\u{482}\x07\u{8b}\
	\x02\x02\u{481}\u{47c}\x03\x02\x02\x02\u{481}\u{47d}\x03\x02\x02\x02\u{481}\
	\u{47e}\x03\x02\x02\x02\u{481}\u{47f}\x03\x02\x02\x02\u{481}\u{480}\x03\
	\x02\x02\x02\u{482}\x7d\x03\x02\x02\x02\u{483}\u{484}\x09\x08\x02\x02\u{484}\
	\x7f\x03\x02\x02\x02\u{485}\u{486}\x09\x09\x02\x02\u{486}\u{81}\x03\x02\
	\x02\x02\u{487}\u{48d}\x07\u{85}\x02\x02\u{488}\u{48a}\x07\u{86}\x02\x02\
	\u{489}\u{48b}\x05\x74\x3b\x02\u{48a}\u{489}\x03\x02\x02\x02\u{48a}\u{48b}\
	\x03\x02\x02\x02\u{48b}\u{48d}\x03\x02\x02\x02\u{48c}\u{487}\x03\x02\x02\
	\x02\u{48c}\u{488}\x03\x02\x02\x02\u{48d}\u{4a8}\x03\x02\x02\x02\u{48e}\
	\u{491}\x07\u{88}\x02\x02\u{48f}\u{490}\x07\x62\x02\x02\u{490}\u{492}\x05\
	\u{ee}\x78\x02\u{491}\u{48f}\x03\x02\x02\x02\u{491}\u{492}\x03\x02\x02\x02\
	\u{492}\u{4a8}\x03\x02\x02\x02\u{493}\u{496}\x07\u{89}\x02\x02\u{494}\u{495}\
	\x07\x62\x02\x02\u{495}\u{497}\x05\u{ee}\x78\x02\u{496}\u{494}\x03\x02\x02\
	\x02\u{496}\u{497}\x03\x02\x02\x02\u{497}\u{4a8}\x03\x02\x02\x02\u{498}\
	\u{499}\x07\u{8a}\x02\x02\u{499}\u{4a8}\x05\x74\x3b\x02\u{49a}\u{49d}\x07\
	\u{87}\x02\x02\u{49b}\u{49c}\x07\x62\x02\x02\u{49c}\u{49e}\x05\u{ee}\x78\
	\x02\u{49d}\u{49b}\x03\x02\x02\x02\u{49d}\u{49e}\x03\x02\x02\x02\u{49e}\
	\u{4a0}\x03\x02\x02\x02\u{49f}\u{4a1}\x05\x74\x3b\x02\u{4a0}\u{49f}\x03\
	\x02\x02\x02\u{4a0}\u{4a1}\x03\x02\x02\x02\u{4a1}\u{4a8}\x03\x02\x02\x02\
	\u{4a2}\u{4a3}\x07\u{87}\x02\x02\u{4a3}\u{4a8}\x07\u{88}\x02\x02\u{4a4}\
	\u{4a5}\x07\u{87}\x02\x02\u{4a5}\u{4a6}\x07\x7a\x02\x02\u{4a6}\u{4a8}\x05\
	\x74\x3b\x02\u{4a7}\u{48c}\x03\x02\x02\x02\u{4a7}\u{48e}\x03\x02\x02\x02\
	\u{4a7}\u{493}\x03\x02\x02\x02\u{4a7}\u{498}\x03\x02\x02\x02\u{4a7}\u{49a}\
	\x03\x02\x02\x02\u{4a7}\u{4a2}\x03\x02\x02\x02\u{4a7}\u{4a4}\x03\x02\x02\
	\x02\u{4a8}\u{83}\x03\x02\x02\x02\u{4a9}\u{4aa}\x09\x0a\x02\x02\u{4aa}\u{85}\
	\x03\x02\x02\x02\u{4ab}\u{4ac}\x09\x0b\x02\x02\u{4ac}\u{87}\x03\x02\x02\
	\x02\u{4ad}\u{4ae}\x09\x0c\x02\x02\u{4ae}\u{89}\x03\x02\x02\x02\u{4af}\u{4b0}\
	\x09\x0d\x02\x02\u{4b0}\u{8b}\x03\x02\x02\x02\u{4b1}\u{4b2}\x09\x0e\x02\
	\x02\u{4b2}\u{8d}\x03\x02\x02\x02\u{4b3}\u{4b4}\x09\x0f\x02\x02\u{4b4}\u{8f}\
	\x03\x02\x02\x02\u{4b5}\u{4b6}\x09\x10\x02\x02\u{4b6}\u{91}\x03\x02\x02\
	\x02\u{4b7}\u{4b8}\x09\x11\x02\x02\u{4b8}\u{93}\x03\x02\x02\x02\u{4b9}\u{4c0}\
	\x07\x55\x02\x02\u{4ba}\u{4bb}\x07\x55\x02\x02\u{4bb}\u{4c0}\x07\x50\x02\
	\x02\u{4bc}\u{4c0}\x07\x56\x02\x02\u{4bd}\u{4c0}\x07\x57\x02\x02\u{4be}\
	\u{4c0}\x07\x54\x02\x02\u{4bf}\u{4b9}\x03\x02\x02\x02\u{4bf}\u{4ba}\x03\
	\x02\x02\x02\u{4bf}\u{4bc}\x03\x02\x02\x02\u{4bf}\u{4bd}\x03\x02\x02\x02\
	\u{4bf}\u{4be}\x03\x02\x02\x02\u{4c0}\u{95}\x03\x02\x02\x02\u{4c1}\u{4c7}\
	\x07\x52\x02\x02\u{4c2}\u{4c3}\x07\x50\x02\x02\u{4c3}\u{4c7}\x07\x52\x02\
	\x02\u{4c4}\u{4c7}\x07\x51\x02\x02\u{4c5}\u{4c7}\x07\x53\x02\x02\u{4c6}\
	\u{4c1}\x03\x02\x02\x02\u{4c6}\u{4c2}\x03\x02\x02\x02\u{4c6}\u{4c4}\x03\
	\x02\x02\x02\u{4c6}\u{4c5}\x03\x02\x02\x02\u{4c7}\u{97}\x03\x02\x02\x02\
	\u{4c8}\u{4c9}\x07\x0f\x02\x02\u{4c9}\u{4ef}\x07\x10\x02\x02\u{4ca}\u{4cb}\
	\x07\x0f\x02\x02\u{4cb}\u{4d0}\x05\u{9a}\x4e\x02\u{4cc}\u{4cd}\x07\x04\x02\
	\x02\u{4cd}\u{4cf}\x05\u{9a}\x4e\x02\u{4ce}\u{4cc}\x03\x02\x02\x02\u{4cf}\
	\u{4d2}\x03\x02\x02\x02\u{4d0}\u{4ce}\x03\x02\x02\x02\u{4d0}\u{4d1}\x03\
	\x02\x02\x02\u{4d1}\u{4d4}\x03\x02\x02\x02\u{4d2}\u{4d0}\x03\x02\x02\x02\
	\u{4d3}\u{4d5}\x07\x04\x02\x02\u{4d4}\u{4d3}\x03\x02\x02\x02\u{4d4}\u{4d5}\
	\x03\x02\x02\x02\u{4d5}\u{4d6}\x03\x02\x02\x02\u{4d6}\u{4d7}\x07\x10\x02\
	\x02\u{4d7}\u{4ef}\x03\x02\x02\x02\u{4d8}\u{4da}\x07\x07\x02\x02\u{4d9}\
	\u{4d8}\x03\x02\x02\x02\u{4d9}\u{4da}\x03\x02\x02\x02\u{4da}\u{4db}\x03\
	\x02\x02\x02\u{4db}\u{4dc}\x07\x2a\x02\x02\u{4dc}\u{4ef}\x07\x2f\x02\x02\
	\u{4dd}\u{4df}\x07\x07\x02\x02\u{4de}\u{4dd}\x03\x02\x02\x02\u{4de}\u{4df}\
	\x03\x02\x02\x02\u{4df}\u{4e0}\x03\x02\x02\x02\u{4e0}\u{4e1}\x07\x2a\x02\
	\x02\u{4e1}\u{4e6}\x05\u{9a}\x4e\x02\u{4e2}\u{4e3}\x07\x04\x02\x02\u{4e3}\
	\u{4e5}\x05\u{9a}\x4e\x02\u{4e4}\u{4e2}\x03\x02\x02\x02\u{4e5}\u{4e8}\x03\
	\x02\x02\x02\u{4e6}\u{4e4}\x03\x02\x02\x02\u{4e6}\u{4e7}\x03\x02\x02\x02\
	\u{4e7}\u{4ea}\x03\x02\x02\x02\u{4e8}\u{4e6}\x03\x02\x02\x02\u{4e9}\u{4eb}\
	\x07\x04\x02\x02\u{4ea}\u{4e9}\x03\x02\x02\x02\u{4ea}\u{4eb}\x03\x02\x02\
	\x02\u{4eb}\u{4ec}\x03\x02\x02\x02\u{4ec}\u{4ed}\x07\x2f\x02\x02\u{4ed}\
	\u{4ef}\x03\x02\x02\x02\u{4ee}\u{4c8}\x03\x02\x02\x02\u{4ee}\u{4ca}\x03\
	\x02\x02\x02\u{4ee}\u{4d9}\x03\x02\x02\x02\u{4ee}\u{4de}\x03\x02\x02\x02\
	\u{4ef}\u{99}\x03\x02\x02\x02\u{4f0}\u{4f1}\x05\u{ee}\x78\x02\u{4f1}\u{4f2}\
	\x07\x08\x02\x02\u{4f2}\u{4f4}\x03\x02\x02\x02\u{4f3}\u{4f0}\x03\x02\x02\
	\x02\u{4f3}\u{4f4}\x03\x02\x02\x02\u{4f4}\u{4f5}\x03\x02\x02\x02\u{4f5}\
	\u{4f6}\x05\x7a\x3e\x02\u{4f6}\u{9b}\x03\x02\x02\x02\u{4f7}\u{4f8}\x07\x07\
	\x02\x02\u{4f8}\u{4f9}\x07\x2a\x02\x02\u{4f9}\u{51a}\x07\x2f\x02\x02\u{4fa}\
	\u{4fb}\x07\x07\x02\x02\u{4fb}\u{4fc}\x07\x2a\x02\x02\u{4fc}\u{501}\x05\
	\u{a0}\x51\x02\u{4fd}\u{4fe}\x07\x04\x02\x02\u{4fe}\u{500}\x05\u{a0}\x51\
	\x02\u{4ff}\u{4fd}\x03\x02\x02\x02\u{500}\u{503}\x03\x02\x02\x02\u{501}\
	\u{4ff}\x03\x02\x02\x02\u{501}\u{502}\x03\x02\x02\x02\u{502}\u{505}\x03\
	\x02\x02\x02\u{503}\u{501}\x03\x02\x02\x02\u{504}\u{506}\x07\x04\x02\x02\
	\u{505}\u{504}\x03\x02\x02\x02\u{505}\u{506}\x03\x02\x02\x02\u{506}\u{507}\
	\x03\x02\x02\x02\u{507}\u{508}\x07\x2f\x02\x02\u{508}\u{51a}\x03\x02\x02\
	\x02\u{509}\u{50a}\x07\x0f\x02\x02\u{50a}\u{51a}\x07\x10\x02\x02\u{50b}\
	\u{50c}\x07\x0f\x02\x02\u{50c}\u{511}\x05\u{a0}\x51\x02\u{50d}\u{50e}\x07\
	\x04\x02\x02\u{50e}\u{510}\x05\u{a0}\x51\x02\u{50f}\u{50d}\x03\x02\x02\x02\
	\u{510}\u{513}\x03\x02\x02\x02\u{511}\u{50f}\x03\x02\x02\x02\u{511}\u{512}\
	\x03\x02\x02\x02\u{512}\u{515}\x03\x02\x02\x02\u{513}\u{511}\x03\x02\x02\
	\x02\u{514}\u{516}\x07\x04\x02\x02\u{515}\u{514}\x03\x02\x02\x02\u{515}\
	\u{516}\x03\x02\x02\x02\u{516}\u{517}\x03\x02\x02\x02\u{517}\u{518}\x07\
	\x10\x02\x02\u{518}\u{51a}\x03\x02\x02\x02\u{519}\u{4f7}\x03\x02\x02\x02\
	\u{519}\u{4fa}\x03\x02\x02\x02\u{519}\u{509}\x03\x02\x02\x02\u{519}\u{50b}\
	\x03\x02\x02\x02\u{51a}\u{9d}\x03\x02\x02\x02\u{51b}\u{51d}\x07\x07\x02\
	\x02\u{51c}\u{51b}\x03\x02\x02\x02\u{51c}\u{51d}\x03\x02\x02\x02\u{51d}\
	\u{51e}\x03\x02\x02\x02\u{51e}\u{51f}\x07\x2a\x02\x02\u{51f}\u{524}\x05\
	\u{a0}\x51\x02\u{520}\u{521}\x07\x04\x02\x02\u{521}\u{523}\x05\u{a0}\x51\
	\x02\u{522}\u{520}\x03\x02\x02\x02\u{523}\u{526}\x03\x02\x02\x02\u{524}\
	\u{522}\x03\x02\x02\x02\u{524}\u{525}\x03\x02\x02\x02\u{525}\u{527}\x03\
	\x02\x02\x02\u{526}\u{524}\x03\x02\x02\x02\u{527}\u{528}\x07\x2f\x02\x02\
	\u{528}\u{535}\x03\x02\x02\x02\u{529}\u{52a}\x07\x0f\x02\x02\u{52a}\u{52f}\
	\x05\u{a0}\x51\x02\u{52b}\u{52c}\x07\x04\x02\x02\u{52c}\u{52e}\x05\u{a0}\
	\x51\x02\u{52d}\u{52b}\x03\x02\x02\x02\u{52e}\u{531}\x03\x02\x02\x02\u{52f}\
	\u{52d}\x03\x02\x02\x02\u{52f}\u{530}\x03\x02\x02\x02\u{530}\u{532}\x03\
	\x02\x02\x02\u{531}\u{52f}\x03\x02\x02\x02\u{532}\u{533}\x07\x10\x02\x02\
	\u{533}\u{535}\x03\x02\x02\x02\u{534}\u{51c}\x03\x02\x02\x02\u{534}\u{529}\
	\x03\x02\x02\x02\u{535}\u{9f}\x03\x02\x02\x02\u{536}\u{537}\x05\u{ee}\x78\
	\x02\u{537}\u{538}\x07\x08\x02\x02\u{538}\u{53a}\x03\x02\x02\x02\u{539}\
	\u{536}\x03\x02\x02\x02\u{539}\u{53a}\x03\x02\x02\x02\u{53a}\u{53b}\x03\
	\x02\x02\x02\u{53b}\u{53c}\x05\x7a\x3e\x02\u{53c}\u{a1}\x03\x02\x02\x02\
	\u{53d}\u{53e}\x07\x62\x02\x02\u{53e}\u{53f}\x05\u{ee}\x78\x02\u{53f}\u{a3}\
	\x03\x02\x02\x02\u{540}\u{541}\x07\x07\x02\x02\u{541}\u{542}\x07\x0b\x02\
	\x02\u{542}\u{543}\x05\x74\x3b\x02\u{543}\u{544}\x07\x0c\x02\x02\u{544}\
	\u{54a}\x03\x02\x02\x02\u{545}\u{546}\x07\x11\x02\x02\u{546}\u{547}\x05\
	\x74\x3b\x02\u{547}\u{548}\x07\x12\x02\x02\u{548}\u{54a}\x03\x02\x02\x02\
	\u{549}\u{540}\x03\x02\x02\x02\u{549}\u{545}\x03\x02\x02\x02\u{54a}\u{a5}\
	\x03\x02\x02\x02\u{54b}\u{54d}\x05\u{b2}\x5a\x02\u{54c}\u{54b}\x03\x02\x02\
	\x02\u{54d}\u{550}\x03\x02\x02\x02\u{54e}\u{54c}\x03\x02\x02\x02\u{54e}\
	\u{54f}\x03\x02\x02\x02\u{54f}\u{551}\x03\x02\x02\x02\u{550}\u{54e}\x03\
	\x02\x02\x02\u{551}\u{552}\x05\u{e0}\x71\x02\u{552}\u{553}\x07\x6b\x02\x02\
	\u{553}\u{554}\x05\u{a8}\x55\x02\u{554}\u{56b}\x03\x02\x02\x02\u{555}\u{557}\
	\x05\u{b2}\x5a\x02\u{556}\u{555}\x03\x02\x02\x02\u{557}\u{55a}\x03\x02\x02\
	\x02\u{558}\u{556}\x03\x02\x02\x02\u{558}\u{559}\x03\x02\x02\x02\u{559}\
	\u{55b}\x03\x02\x02\x02\u{55a}\u{558}\x03\x02\x02\x02\u{55b}\u{55c}\x05\
	\u{e0}\x71\x02\u{55c}\u{55d}\x07\x6b\x02\x02\u{55d}\u{562}\x05\u{ee}\x78\
	\x02\u{55e}\u{55f}\x07\x04\x02\x02\u{55f}\u{561}\x05\u{ee}\x78\x02\u{560}\
	\u{55e}\x03\x02\x02\x02\u{561}\u{564}\x03\x02\x02\x02\u{562}\u{560}\x03\
	\x02\x02\x02\u{562}\u{563}\x03\x02\x02\x02\u{563}\u{566}\x03\x02\x02\x02\
	\u{564}\u{562}\x03\x02\x02\x02\u{565}\u{567}\x07\x04\x02\x02\u{566}\u{565}\
	\x03\x02\x02\x02\u{566}\u{567}\x03\x02\x02\x02\u{567}\u{568}\x03\x02\x02\
	\x02\u{568}\u{569}\x05\u{a8}\x55\x02\u{569}\u{56b}\x03\x02\x02\x02\u{56a}\
	\u{54e}\x03\x02\x02\x02\u{56a}\u{558}\x03\x02\x02\x02\u{56b}\u{a7}\x03\x02\
	\x02\x02\u{56c}\u{571}\x07\x0d\x02\x02\u{56d}\u{570}\x05\u{aa}\x56\x02\u{56e}\
	\u{570}\x05\x08\x05\x02\u{56f}\u{56d}\x03\x02\x02\x02\u{56f}\u{56e}\x03\
	\x02\x02\x02\u{570}\u{573}\x03\x02\x02\x02\u{571}\u{56f}\x03\x02\x02\x02\
	\u{571}\u{572}\x03\x02\x02\x02\u{572}\u{574}\x03\x02\x02\x02\u{573}\u{571}\
	\x03\x02\x02\x02\u{574}\u{575}\x07\x0e\x02\x02\u{575}\u{a9}\x03\x02\x02\
	\x02\u{576}\u{577}\x07\x6e\x02\x02\u{577}\u{578}\x05\u{ac}\x57\x02\u{578}\
	\u{ab}\x03\x02\x02\x02\u{579}\u{57d}\x07\x0d\x02\x02\u{57a}\u{57c}\x05\u{ae}\
	\x58\x02\u{57b}\u{57a}\x03\x02\x02\x02\u{57c}\u{57f}\x03\x02\x02\x02\u{57d}\
	\u{57b}\x03\x02\x02\x02\u{57d}\u{57e}\x03\x02\x02\x02\u{57e}\u{580}\x03\
	\x02\x02\x02\u{57f}\u{57d}\x03\x02\x02\x02\u{580}\u{581}\x07\x0e\x02\x02\
	\u{581}\u{ad}\x03\x02\x02\x02\u{582}\u{583}\x05\u{ee}\x78\x02\u{583}\u{584}\
	\x07\x08\x02\x02\u{584}\u{585}\x05\x7a\x3e\x02\u{585}\u{588}\x03\x02\x02\
	\x02\u{586}\u{588}\x05\x08\x05\x02\u{587}\u{582}\x03\x02\x02\x02\u{587}\
	\u{586}\x03\x02\x02\x02\u{588}\u{af}\x03\x02\x02\x02\u{589}\u{58a}\x07\x48\
	\x02\x02\u{58a}\u{58c}\x05\u{b4}\x5b\x02\u{58b}\u{58d}\x05\x1a\x0e\x02\u{58c}\
	\u{58b}\x03\x02\x02\x02\u{58c}\u{58d}\x03\x02\x02\x02\u{58d}\u{59d}\x03\
	\x02\x02\x02\u{58e}\u{58f}\x07\x48\x02\x02\u{58f}\u{590}\x07\x0b\x02\x02\
	\u{590}\u{595}\x05\u{b4}\x5b\x02\u{591}\u{592}\x07\x04\x02\x02\u{592}\u{594}\
	\x05\u{b4}\x5b\x02\u{593}\u{591}\x03\x02\x02\x02\u{594}\u{597}\x03\x02\x02\
	\x02\u{595}\u{593}\x03\x02\x02\x02\u{595}\u{596}\x03\x02\x02\x02\u{596}\
	\u{598}\x03\x02\x02\x02\u{597}\u{595}\x03\x02\x02\x02\u{598}\u{59a}\x07\
	\x0c\x02\x02\u{599}\u{59b}\x05\x1a\x0e\x02\u{59a}\u{599}\x03\x02\x02\x02\
	\u{59a}\u{59b}\x03\x02\x02\x02\u{59b}\u{59d}\x03\x02\x02\x02\u{59c}\u{589}\
	\x03\x02\x02\x02\u{59c}\u{58e}\x03\x02\x02\x02\u{59d}\u{b1}\x03\x02\x02\
	\x02\u{59e}\u{59f}\x07\x49\x02\x02\u{59f}\u{5a1}\x05\u{b4}\x5b\x02\u{5a0}\
	\u{5a2}\x05\x1a\x0e\x02\u{5a1}\u{5a0}\x03\x02\x02\x02\u{5a1}\u{5a2}\x03\
	\x02\x02\x02\u{5a2}\u{5b2}\x03\x02\x02\x02\u{5a3}\u{5a4}\x07\x49\x02\x02\
	\u{5a4}\u{5a5}\x07\x0b\x02\x02\u{5a5}\u{5aa}\x05\u{b4}\x5b\x02\u{5a6}\u{5a7}\
	\x07\x04\x02\x02\u{5a7}\u{5a9}\x05\u{b4}\x5b\x02\u{5a8}\u{5a6}\x03\x02\x02\
	\x02\u{5a9}\u{5ac}\x03\x02\x02\x02\u{5aa}\u{5a8}\x03\x02\x02\x02\u{5aa}\
	\u{5ab}\x03\x02\x02\x02\u{5ab}\u{5ad}\x03\x02\x02\x02\u{5ac}\u{5aa}\x03\
	\x02\x02\x02\u{5ad}\u{5af}\x07\x0c\x02\x02\u{5ae}\u{5b0}\x05\x1a\x0e\x02\
	\u{5af}\u{5ae}\x03\x02\x02\x02\u{5af}\u{5b0}\x03\x02\x02\x02\u{5b0}\u{5b2}\
	\x03\x02\x02\x02\u{5b1}\u{59e}\x03\x02\x02\x02\u{5b1}\u{5a3}\x03\x02\x02\
	\x02\u{5b2}\u{b3}\x03\x02\x02\x02\u{5b3}\u{5b5}\x05\u{ec}\x77\x02\u{5b4}\
	\u{5b6}\x05\x4c\x27\x02\u{5b5}\u{5b4}\x03\x02\x02\x02\u{5b5}\u{5b6}\x03\
	\x02\x02\x02\u{5b6}\u{5b8}\x03\x02\x02\x02\u{5b7}\u{5b9}\x05\x1a\x0e\x02\
	\u{5b8}\u{5b7}\x03\x02\x02\x02\u{5b8}\u{5b9}\x03\x02\x02\x02\u{5b9}\u{b5}\
	\x03\x02\x02\x02\u{5ba}\u{5bc}\x05\u{b2}\x5a\x02\u{5bb}\u{5ba}\x03\x02\x02\
	\x02\u{5bc}\u{5bf}\x03\x02\x02\x02\u{5bd}\u{5bb}\x03\x02\x02\x02\u{5bd}\
	\u{5be}\x03\x02\x02\x02\u{5be}\u{5c0}\x03\x02\x02\x02\u{5bf}\u{5bd}\x03\
	\x02\x02\x02\u{5c0}\u{5c2}\x07\x77\x02\x02\u{5c1}\u{5c3}\x05\x7a\x3e\x02\
	\u{5c2}\u{5c1}\x03\x02\x02\x02\u{5c2}\u{5c3}\x03\x02\x02\x02\u{5c3}\u{5c4}\
	\x03\x02\x02\x02\u{5c4}\u{5c5}\x05\x54\x2b\x02\u{5c5}\u{b7}\x03\x02\x02\
	\x02\u{5c6}\u{5c8}\x05\u{b2}\x5a\x02\u{5c7}\u{5c6}\x03\x02\x02\x02\u{5c8}\
	\u{5cb}\x03\x02\x02\x02\u{5c9}\u{5c7}\x03\x02\x02\x02\u{5c9}\u{5ca}\x03\
	\x02\x02\x02\u{5ca}\u{5cc}\x03\x02\x02\x02\u{5cb}\u{5c9}\x03\x02\x02\x02\
	\u{5cc}\u{5d0}\x09\x12\x02\x02\u{5cd}\u{5ce}\x05\u{ee}\x78\x02\u{5ce}\u{5cf}\
	\x07\x34\x02\x02\u{5cf}\u{5d1}\x03\x02\x02\x02\u{5d0}\u{5cd}\x03\x02\x02\
	\x02\u{5d0}\u{5d1}\x03\x02\x02\x02\u{5d1}\u{5d2}\x03\x02\x02\x02\u{5d2}\
	\u{5d3}\x05\x78\x3d\x02\u{5d3}\u{5d4}\x05\u{bc}\x5f\x02\u{5d4}\u{b9}\x03\
	\x02\x02\x02\u{5d5}\u{5d7}\x07\x4e\x02\x02\u{5d6}\u{5d5}\x03\x02\x02\x02\
	\u{5d6}\u{5d7}\x03\x02\x02\x02\u{5d7}\u{5d8}\x03\x02\x02\x02\u{5d8}\u{5d9}\
	\x07\x03\x02\x02\u{5d9}\u{5df}\x09\x12\x02\x02\u{5da}\u{5db}\x07\x58\x02\
	\x02\u{5db}\u{5dd}\x05\u{ee}\x78\x02\u{5dc}\u{5de}\x05\x64\x33\x02\u{5dd}\
	\u{5dc}\x03\x02\x02\x02\u{5dd}\u{5de}\x03\x02\x02\x02\u{5de}\u{5e0}\x03\
	\x02\x02\x02\u{5df}\u{5da}\x03\x02\x02\x02\u{5df}\u{5e0}\x03\x02\x02\x02\
	\u{5e0}\u{5e1}\x03\x02\x02\x02\u{5e1}\u{5e2}\x05\u{bc}\x5f\x02\u{5e2}\u{bb}\
	\x03\x02\x02\x02\u{5e3}\u{5e8}\x07\x0d\x02\x02\u{5e4}\u{5e7}\x05\u{be}\x60\
	\x02\u{5e5}\u{5e7}\x05\x08\x05\x02\u{5e6}\u{5e4}\x03\x02\x02\x02\u{5e6}\
	\u{5e5}\x03\x02\x02\x02\u{5e7}\u{5ea}\x03\x02\x02\x02\u{5e8}\u{5e6}\x03\
	\x02\x02\x02\u{5e8}\u{5e9}\x03\x02\x02\x02\u{5e9}\u{5eb}\x03\x02\x02\x02\
	\u{5ea}\u{5e8}\x03\x02\x02\x02\u{5eb}\u{5ec}\x07\x0e\x02\x02\u{5ec}\u{bd}\
	\x03\x02\x02\x02\u{5ed}\u{5ef}\x05\u{b2}\x5a\x02\u{5ee}\u{5ed}\x03\x02\x02\
	\x02\u{5ef}\u{5f2}\x03\x02\x02\x02\u{5f0}\u{5ee}\x03\x02\x02\x02\u{5f0}\
	\u{5f1}\x03\x02\x02\x02\u{5f1}\u{5f3}\x03\x02\x02\x02\u{5f2}\u{5f0}\x03\
	\x02\x02\x02\u{5f3}\u{5f4}\x07\x7a\x02\x02\u{5f4}\u{63a}\x05\u{ee}\x78\x02\
	\u{5f5}\u{5f7}\x05\u{b2}\x5a\x02\u{5f6}\u{5f5}\x03\x02\x02\x02\u{5f7}\u{5fa}\
	\x03\x02\x02\x02\u{5f8}\u{5f6}\x03\x02\x02\x02\u{5f8}\u{5f9}\x03\x02\x02\
	\x02\u{5f9}\u{5fb}\x03\x02\x02\x02\u{5fa}\u{5f8}\x03\x02\x02\x02\u{5fb}\
	\u{5fc}\x07\x7a\x02\x02\u{5fc}\u{608}\x07\x0b\x02\x02\u{5fd}\u{602}\x05\
	\u{ee}\x78\x02\u{5fe}\u{5ff}\x07\x04\x02\x02\u{5ff}\u{601}\x05\u{ee}\x78\
	\x02\u{600}\u{5fe}\x03\x02\x02\x02\u{601}\u{604}\x03\x02\x02\x02\u{602}\
	\u{600}\x03\x02\x02\x02\u{602}\u{603}\x03\x02\x02\x02\u{603}\u{606}\x03\
	\x02\x02\x02\u{604}\u{602}\x03\x02\x02\x02\u{605}\u{607}\x07\x04\x02\x02\
	\u{606}\u{605}\x03\x02\x02\x02\u{606}\u{607}\x03\x02\x02\x02\u{607}\u{609}\
	\x03\x02\x02\x02\u{608}\u{5fd}\x03\x02\x02\x02\u{608}\u{609}\x03\x02\x02\
	\x02\u{609}\u{60a}\x03\x02\x02\x02\u{60a}\u{63a}\x07\x0c\x02\x02\u{60b}\
	\u{60d}\x05\u{b2}\x5a\x02\u{60c}\u{60b}\x03\x02\x02\x02\u{60d}\u{610}\x03\
	\x02\x02\x02\u{60e}\u{60c}\x03\x02\x02\x02\u{60e}\u{60f}\x03\x02\x02\x02\
	\u{60f}\u{611}\x03\x02\x02\x02\u{610}\u{60e}\x03\x02\x02\x02\u{611}\u{612}\
	\x07\x6a\x02\x02\u{612}\u{615}\x05\x7a\x3e\x02\u{613}\u{614}\x07\u{82}\x02\
	\x02\u{614}\u{616}\x05\x78\x3d\x02\u{615}\u{613}\x03\x02\x02\x02\u{615}\
	\u{616}\x03\x02\x02\x02\u{616}\u{617}\x03\x02\x02\x02\u{617}\u{618}\x05\
	\u{c0}\x61\x02\u{618}\u{63a}\x03\x02\x02\x02\u{619}\u{61b}\x05\u{b2}\x5a\
	\x02\u{61a}\u{619}\x03\x02\x02\x02\u{61b}\u{61e}\x03\x02\x02\x02\u{61c}\
	\u{61a}\x03\x02\x02\x02\u{61c}\u{61d}\x03\x02\x02\x02\u{61d}\u{61f}\x03\
	\x02\x02\x02\u{61e}\u{61c}\x03\x02\x02\x02\u{61f}\u{620}\x07\x7c\x02\x02\
	\u{620}\u{621}\x05\x78\x3d\x02\u{621}\u{622}\x05\u{c0}\x61\x02\u{622}\u{63a}\
	\x03\x02\x02\x02\u{623}\u{625}\x05\u{b2}\x5a\x02\u{624}\u{623}\x03\x02\x02\
	\x02\u{625}\u{628}\x03\x02\x02\x02\u{626}\u{624}\x03\x02\x02\x02\u{626}\
	\u{627}\x03\x02\x02\x02\u{627}\u{629}\x03\x02\x02\x02\u{628}\u{626}\x03\
	\x02\x02\x02\u{629}\u{62a}\x07\u{83}\x02\x02\u{62a}\u{63a}\x05\u{c0}\x61\
	\x02\u{62b}\u{62d}\x05\u{b2}\x5a\x02\u{62c}\u{62b}\x03\x02\x02\x02\u{62d}\
	\u{630}\x03\x02\x02\x02\u{62e}\u{62c}\x03\x02\x02\x02\u{62e}\u{62f}\x03\
	\x02\x02\x02\u{62f}\u{631}\x03\x02\x02\x02\u{630}\u{62e}\x03\x02\x02\x02\
	\u{631}\u{632}\x07\x7b\x02\x02\u{632}\u{635}\x05\u{c2}\x62\x02\u{633}\u{634}\
	\x07\u{82}\x02\x02\u{634}\u{636}\x05\x78\x3d\x02\u{635}\u{633}\x03\x02\x02\
	\x02\u{635}\u{636}\x03\x02\x02\x02\u{636}\u{637}\x03\x02\x02\x02\u{637}\
	\u{638}\x05\u{c0}\x61\x02\u{638}\u{63a}\x03\x02\x02\x02\u{639}\u{5f0}\x03\
	\x02\x02\x02\u{639}\u{5f8}\x03\x02\x02\x02\u{639}\u{60e}\x03\x02\x02\x02\
	\u{639}\u{61c}\x03\x02\x02\x02\u{639}\u{626}\x03\x02\x02\x02\u{639}\u{62e}\
	\x03\x02\x02\x02\u{63a}\u{bf}\x03\x02\x02\x02\u{63b}\u{63f}\x07\x08\x02\
	\x02\u{63c}\u{63e}\x05\x74\x3b\x02\u{63d}\u{63c}\x03\x02\x02\x02\u{63e}\
	\u{641}\x03\x02\x02\x02\u{63f}\u{63d}\x03\x02\x02\x02\u{63f}\u{640}\x03\
	\x02\x02\x02\u{640}\u{c1}\x03\x02\x02\x02\u{641}\u{63f}\x03\x02\x02\x02\
	\u{642}\u{643}\x08\x62\x01\x02\u{643}\u{644}\x05\u{c4}\x63\x02\u{644}\u{64d}\
	\x03\x02\x02\x02\u{645}\u{646}\x0c\x05\x02\x02\u{646}\u{647}\x09\x13\x02\
	\x02\u{647}\u{64c}\x05\u{c2}\x62\x06\u{648}\u{649}\x0c\x04\x02\x02\u{649}\
	\u{64a}\x07\x5a\x02\x02\u{64a}\u{64c}\x05\u{c2}\x62\x05\u{64b}\u{645}\x03\
	\x02\x02\x02\u{64b}\u{648}\x03\x02\x02\x02\u{64c}\u{64f}\x03\x02\x02\x02\
	\u{64d}\u{64b}\x03\x02\x02\x02\u{64d}\u{64e}\x03\x02\x02\x02\u{64e}\u{c3}\
	\x03\x02\x02\x02\u{64f}\u{64d}\x03\x02\x02\x02\u{650}\u{664}\x05\u{c6}\x64\
	\x02\u{651}\u{652}\x05\u{ee}\x78\x02\u{652}\u{653}\x07\x34\x02\x02\u{653}\
	\u{654}\x05\u{c4}\x63\x02\u{654}\u{664}\x03\x02\x02\x02\u{655}\u{656}\x05\
	\u{e2}\x72\x02\u{656}\u{65a}\x07\x08\x02\x02\u{657}\u{658}\x05\u{ee}\x78\
	\x02\u{658}\u{659}\x07\x34\x02\x02\u{659}\u{65b}\x03\x02\x02\x02\u{65a}\
	\u{657}\x03\x02\x02\x02\u{65a}\u{65b}\x03\x02\x02\x02\u{65b}\u{65c}\x03\
	\x02\x02\x02\u{65c}\u{65d}\x05\u{c4}\x63\x02\u{65d}\u{664}\x03\x02\x02\x02\
	\u{65e}\u{664}\x05\u{e2}\x72\x02\u{65f}\u{664}\x05\u{ec}\x77\x02\u{660}\
	\u{664}\x05\u{f2}\x7a\x02\u{661}\u{664}\x05\u{f6}\x7c\x02\u{662}\u{664}\
	\x07\u{8b}\x02\x02\u{663}\u{650}\x03\x02\x02\x02\u{663}\u{651}\x03\x02\x02\
	\x02\u{663}\u{655}\x03\x02\x02\x02\u{663}\u{65e}\x03\x02\x02\x02\u{663}\
	\u{65f}\x03\x02\x02\x02\u{663}\u{660}\x03\x02\x02\x02\u{663}\u{661}\x03\
	\x02\x02\x02\u{663}\u{662}\x03\x02\x02\x02\u{664}\u{c5}\x03\x02\x02\x02\
	\u{665}\u{667}\x05\u{ec}\x77\x02\u{666}\u{665}\x03\x02\x02\x02\u{666}\u{667}\
	\x03\x02\x02\x02\u{667}\u{668}\x03\x02\x02\x02\u{668}\u{669}\x07\x09\x02\
	\x02\u{669}\u{6b8}\x07\x0a\x02\x02\u{66a}\u{66c}\x05\u{ec}\x77\x02\u{66b}\
	\u{66a}\x03\x02\x02\x02\u{66b}\u{66c}\x03\x02\x02\x02\u{66c}\u{66d}\x03\
	\x02\x02\x02\u{66d}\u{66e}\x07\x0b\x02\x02\u{66e}\u{6b8}\x07\x0c\x02\x02\
	\u{66f}\u{671}\x05\u{ec}\x77\x02\u{670}\u{66f}\x03\x02\x02\x02\u{670}\u{671}\
	\x03\x02\x02\x02\u{671}\u{672}\x03\x02\x02\x02\u{672}\u{673}\x07\x0d\x02\
	\x02\u{673}\u{6b8}\x07\x0e\x02\x02\u{674}\u{675}\x07\x09\x02\x02\u{675}\
	\u{676}\x05\u{c4}\x63\x02\u{676}\u{677}\x07\x04\x02\x02\u{677}\u{678}\x07\
	\x0a\x02\x02\u{678}\u{6b8}\x03\x02\x02\x02\u{679}\u{67a}\x07\x09\x02\x02\
	\u{67a}\u{67d}\x05\u{c4}\x63\x02\u{67b}\u{67c}\x07\x04\x02\x02\u{67c}\u{67e}\
	\x05\u{c4}\x63\x02\u{67d}\u{67b}\x03\x02\x02\x02\u{67e}\u{67f}\x03\x02\x02\
	\x02\u{67f}\u{67d}\x03\x02\x02\x02\u{67f}\u{680}\x03\x02\x02\x02\u{680}\
	\u{682}\x03\x02\x02\x02\u{681}\u{683}\x07\x04\x02\x02\u{682}\u{681}\x03\
	\x02\x02\x02\u{682}\u{683}\x03\x02\x02\x02\u{683}\u{684}\x03\x02\x02\x02\
	\u{684}\u{685}\x07\x0a\x02\x02\u{685}\u{6b8}\x03\x02\x02\x02\u{686}\u{687}\
	\x05\u{ec}\x77\x02\u{687}\u{688}\x07\x09\x02\x02\u{688}\u{68d}\x05\u{c4}\
	\x63\x02\u{689}\u{68a}\x07\x04\x02\x02\u{68a}\u{68c}\x05\u{c4}\x63\x02\u{68b}\
	\u{689}\x03\x02\x02\x02\u{68c}\u{68f}\x03\x02\x02\x02\u{68d}\u{68b}\x03\
	\x02\x02\x02\u{68d}\u{68e}\x03\x02\x02\x02\u{68e}\u{691}\x03\x02\x02\x02\
	\u{68f}\u{68d}\x03\x02\x02\x02\u{690}\u{692}\x07\x04\x02\x02\u{691}\u{690}\
	\x03\x02\x02\x02\u{691}\u{692}\x03\x02\x02\x02\u{692}\u{693}\x03\x02\x02\
	\x02\u{693}\u{694}\x07\x0a\x02\x02\u{694}\u{6b8}\x03\x02\x02\x02\u{695}\
	\u{697}\x05\u{ec}\x77\x02\u{696}\u{695}\x03\x02\x02\x02\u{696}\u{697}\x03\
	\x02\x02\x02\u{697}\u{698}\x03\x02\x02\x02\u{698}\u{699}\x07\x0b\x02\x02\
	\u{699}\u{69e}\x05\u{c4}\x63\x02\u{69a}\u{69b}\x07\x04\x02\x02\u{69b}\u{69d}\
	\x05\u{c4}\x63\x02\u{69c}\u{69a}\x03\x02\x02\x02\u{69d}\u{6a0}\x03\x02\x02\
	\x02\u{69e}\u{69c}\x03\x02\x02\x02\u{69e}\u{69f}\x03\x02\x02\x02\u{69f}\
	\u{6a2}\x03\x02\x02\x02\u{6a0}\u{69e}\x03\x02\x02\x02\u{6a1}\u{6a3}\x07\
	\x04\x02\x02\u{6a2}\u{6a1}\x03\x02\x02\x02\u{6a2}\u{6a3}\x03\x02\x02\x02\
	\u{6a3}\u{6a4}\x03\x02\x02\x02\u{6a4}\u{6a5}\x07\x0c\x02\x02\u{6a5}\u{6b8}\
	\x03\x02\x02\x02\u{6a6}\u{6a8}\x05\u{ec}\x77\x02\u{6a7}\u{6a6}\x03\x02\x02\
	\x02\u{6a7}\u{6a8}\x03\x02\x02\x02\u{6a8}\u{6a9}\x03\x02\x02\x02\u{6a9}\
	\u{6aa}\x07\x0d\x02\x02\u{6aa}\u{6af}\x05\u{c4}\x63\x02\u{6ab}\u{6ac}\x07\
	\x04\x02\x02\u{6ac}\u{6ae}\x05\u{c4}\x63\x02\u{6ad}\u{6ab}\x03\x02\x02\x02\
	\u{6ae}\u{6b1}\x03\x02\x02\x02\u{6af}\u{6ad}\x03\x02\x02\x02\u{6af}\u{6b0}\
	\x03\x02\x02\x02\u{6b0}\u{6b3}\x03\x02\x02\x02\u{6b1}\u{6af}\x03\x02\x02\
	\x02\u{6b2}\u{6b4}\x07\x04\x02\x02\u{6b3}\u{6b2}\x03\x02\x02\x02\u{6b3}\
	\u{6b4}\x03\x02\x02\x02\u{6b4}\u{6b5}\x03\x02\x02\x02\u{6b5}\u{6b6}\x07\
	\x0e\x02\x02\u{6b6}\u{6b8}\x03\x02\x02\x02\u{6b7}\u{666}\x03\x02\x02\x02\
	\u{6b7}\u{66b}\x03\x02\x02\x02\u{6b7}\u{670}\x03\x02\x02\x02\u{6b7}\u{674}\
	\x03\x02\x02\x02\u{6b7}\u{679}\x03\x02\x02\x02\u{6b7}\u{686}\x03\x02\x02\
	\x02\u{6b7}\u{696}\x03\x02\x02\x02\u{6b7}\u{6a7}\x03\x02\x02\x02\u{6b8}\
	\u{c7}\x03\x02\x02\x02\u{6b9}\u{6bb}\x07\x74\x02\x02\u{6ba}\u{6bc}\x05\u{98}\
	\x4d\x02\u{6bb}\u{6ba}\x03\x02\x02\x02\u{6bb}\u{6bc}\x03\x02\x02\x02\u{6bc}\
	\u{6be}\x03\x02\x02\x02\u{6bd}\u{6bf}\x05\x1c\x0f\x02\u{6be}\u{6bd}\x03\
	\x02\x02\x02\u{6be}\u{6bf}\x03\x02\x02\x02\u{6bf}\u{6c1}\x03\x02\x02\x02\
	\u{6c0}\u{6c2}\x05\x64\x33\x02\u{6c1}\u{6c0}\x03\x02\x02\x02\u{6c1}\u{6c2}\
	\x03\x02\x02\x02\u{6c2}\u{6c3}\x03\x02\x02\x02\u{6c3}\u{6c4}\x05\x1a\x0e\
	\x02\u{6c4}\u{c9}\x03\x02\x02\x02\u{6c5}\u{6c6}\x07\x73\x02\x02\u{6c6}\u{6c8}\
	\x05\u{e4}\x73\x02\u{6c7}\u{6c9}\x05\u{9e}\x50\x02\u{6c8}\u{6c7}\x03\x02\
	\x02\x02\u{6c8}\u{6c9}\x03\x02\x02\x02\u{6c9}\u{6cb}\x03\x02\x02\x02\u{6ca}\
	\u{6cc}\x05\x4c\x27\x02\u{6cb}\u{6ca}\x03\x02\x02\x02\u{6cb}\u{6cc}\x03\
	\x02\x02\x02\u{6cc}\u{6cd}\x03\x02\x02\x02\u{6cd}\u{6ce}\x05\u{ce}\x68\x02\
	\u{6ce}\u{6d7}\x03\x02\x02\x02\u{6cf}\u{6d0}\x07\x73\x02\x02\u{6d0}\u{6d2}\
	\x05\u{e4}\x73\x02\u{6d1}\u{6d3}\x05\u{9e}\x50\x02\u{6d2}\u{6d1}\x03\x02\
	\x02\x02\u{6d2}\u{6d3}\x03\x02\x02\x02\u{6d3}\u{6d4}\x03\x02\x02\x02\u{6d4}\
	\u{6d5}\x05\x4c\x27\x02\u{6d5}\u{6d7}\x03\x02\x02\x02\u{6d6}\u{6c5}\x03\
	\x02\x02\x02\u{6d6}\u{6cf}\x03\x02\x02\x02\u{6d7}\u{cb}\x03\x02\x02\x02\
	\u{6d8}\u{6da}\x05\x4c\x27\x02\u{6d9}\u{6d8}\x03\x02\x02\x02\u{6d9}\u{6da}\
	\x03\x02\x02\x02\u{6da}\u{6db}\x03\x02\x02\x02\u{6db}\u{6de}\x05\u{ce}\x68\
	\x02\u{6dc}\u{6de}\x05\x4c\x27\x02\u{6dd}\u{6d9}\x03\x02\x02\x02\u{6dd}\
	\u{6dc}\x03\x02\x02\x02\u{6de}\u{cd}\x03\x02\x02\x02\u{6df}\u{6e4}\x07\x0d\
	\x02\x02\u{6e0}\u{6e3}\x05\x4e\x28\x02\u{6e1}\u{6e3}\x05\x08\x05\x02\u{6e2}\
	\u{6e0}\x03\x02\x02\x02\u{6e2}\u{6e1}\x03\x02\x02\x02\u{6e3}\u{6e6}\x03\
	\x02\x02\x02\u{6e4}\u{6e2}\x03\x02\x02\x02\u{6e4}\u{6e5}\x03\x02\x02\x02\
	\u{6e5}\u{6e7}\x03\x02\x02\x02\u{6e6}\u{6e4}\x03\x02\x02\x02\u{6e7}\u{6e8}\
	\x07\x0e\x02\x02\u{6e8}\u{cf}\x03\x02\x02\x02\u{6e9}\u{6ea}\x07\x09\x02\
	\x02\u{6ea}\u{6fe}\x07\x0a\x02\x02\u{6eb}\u{6ec}\x07\x09\x02\x02\u{6ec}\
	\u{6ef}\x05\u{d2}\x6a\x02\u{6ed}\u{6ee}\x07\x04\x02\x02\u{6ee}\u{6f0}\x05\
	\u{d2}\x6a\x02\u{6ef}\u{6ed}\x03\x02\x02\x02\u{6f0}\u{6f1}\x03\x02\x02\x02\
	\u{6f1}\u{6ef}\x03\x02\x02\x02\u{6f1}\u{6f2}\x03\x02\x02\x02\u{6f2}\u{6f4}\
	\x03\x02\x02\x02\u{6f3}\u{6f5}\x07\x04\x02\x02\u{6f4}\u{6f3}\x03\x02\x02\
	\x02\u{6f4}\u{6f5}\x03\x02\x02\x02\u{6f5}\u{6f6}\x03\x02\x02\x02\u{6f6}\
	\u{6f7}\x07\x0a\x02\x02\u{6f7}\u{6fe}\x03\x02\x02\x02\u{6f8}\u{6f9}\x07\
	\x09\x02\x02\u{6f9}\u{6fa}\x05\u{d2}\x6a\x02\u{6fa}\u{6fb}\x07\x04\x02\x02\
	\u{6fb}\u{6fc}\x07\x0a\x02\x02\u{6fc}\u{6fe}\x03\x02\x02\x02\u{6fd}\u{6e9}\
	\x03\x02\x02\x02\u{6fd}\u{6eb}\x03\x02\x02\x02\u{6fd}\u{6f8}\x03\x02\x02\
	\x02\u{6fe}\u{d1}\x03\x02\x02\x02\u{6ff}\u{700}\x05\u{ee}\x78\x02\u{700}\
	\u{701}\x07\x08\x02\x02\u{701}\u{703}\x03\x02\x02\x02\u{702}\u{6ff}\x03\
	\x02\x02\x02\u{702}\u{703}\x03\x02\x02\x02\u{703}\u{704}\x03\x02\x02\x02\
	\u{704}\u{705}\x05\x74\x3b\x02\u{705}\u{d3}\x03\x02\x02\x02\u{706}\u{708}\
	\x07\x4e\x02\x02\u{707}\u{706}\x03\x02\x02\x02\u{707}\u{708}\x03\x02\x02\
	\x02\u{708}\u{709}\x03\x02\x02\x02\u{709}\u{70a}\x05\u{d6}\x6c\x02\u{70a}\
	\u{d5}\x03\x02\x02\x02\u{70b}\u{717}\x07\x0b\x02\x02\u{70c}\u{711}\x05\u{d8}\
	\x6d\x02\u{70d}\u{70e}\x07\x04\x02\x02\u{70e}\u{710}\x05\u{d8}\x6d\x02\u{70f}\
	\u{70d}\x03\x02\x02\x02\u{710}\u{713}\x03\x02\x02\x02\u{711}\u{70f}\x03\
	\x02\x02\x02\u{711}\u{712}\x03\x02\x02\x02\u{712}\u{715}\x03\x02\x02\x02\
	\u{713}\u{711}\x03\x02\x02\x02\u{714}\u{716}\x07\x04\x02\x02\u{715}\u{714}\
	\x03\x02\x02\x02\u{715}\u{716}\x03\x02\x02\x02\u{716}\u{718}\x03\x02\x02\
	\x02\u{717}\u{70c}\x03\x02\x02\x02\u{717}\u{718}\x03\x02\x02\x02\u{718}\
	\u{719}\x03\x02\x02\x02\u{719}\u{72a}\x07\x0c\x02\x02\u{71a}\u{726}\x07\
	\x11\x02\x02\u{71b}\u{720}\x05\u{d8}\x6d\x02\u{71c}\u{71d}\x07\x04\x02\x02\
	\u{71d}\u{71f}\x05\u{d8}\x6d\x02\u{71e}\u{71c}\x03\x02\x02\x02\u{71f}\u{722}\
	\x03\x02\x02\x02\u{720}\u{71e}\x03\x02\x02\x02\u{720}\u{721}\x03\x02\x02\
	\x02\u{721}\u{724}\x03\x02\x02\x02\u{722}\u{720}\x03\x02\x02\x02\u{723}\
	\u{725}\x07\x04\x02\x02\u{724}\u{723}\x03\x02\x02\x02\u{724}\u{725}\x03\
	\x02\x02\x02\u{725}\u{727}\x03\x02\x02\x02\u{726}\u{71b}\x03\x02\x02\x02\
	\u{726}\u{727}\x03\x02\x02\x02\u{727}\u{728}\x03\x02\x02\x02\u{728}\u{72a}\
	\x07\x12\x02\x02\u{729}\u{70b}\x03\x02\x02\x02\u{729}\u{71a}\x03\x02\x02\
	\x02\u{72a}\u{d7}\x03\x02\x02\x02\u{72b}\u{737}\x07\x08\x02\x02\u{72c}\u{737}\
	\x07\x07\x02\x02\u{72d}\u{730}\x05\u{da}\x6e\x02\u{72e}\u{72f}\x07\x08\x02\
	\x02\u{72f}\u{731}\x05\u{dc}\x6f\x02\u{730}\u{72e}\x03\x02\x02\x02\u{730}\
	\u{731}\x03\x02\x02\x02\u{731}\u{734}\x03\x02\x02\x02\u{732}\u{733}\x07\
	\x08\x02\x02\u{733}\u{735}\x05\u{de}\x70\x02\u{734}\u{732}\x03\x02\x02\x02\
	\u{734}\u{735}\x03\x02\x02\x02\u{735}\u{737}\x03\x02\x02\x02\u{736}\u{72b}\
	\x03\x02\x02\x02\u{736}\u{72c}\x03\x02\x02\x02\u{736}\u{72d}\x03\x02\x02\
	\x02\u{737}\u{d9}\x03\x02\x02\x02\u{738}\u{739}\x05\x78\x3d\x02\u{739}\u{db}\
	\x03\x02\x02\x02\u{73a}\u{73b}\x05\x78\x3d\x02\u{73b}\u{dd}\x03\x02\x02\
	\x02\u{73c}\u{73d}\x05\x78\x3d\x02\u{73d}\u{df}\x03\x02\x02\x02\u{73e}\u{740}\
	\x05\u{ee}\x78\x02\u{73f}\u{73e}\x03\x02\x02\x02\u{740}\u{743}\x03\x02\x02\
	\x02\u{741}\u{73f}\x03\x02\x02\x02\u{741}\u{742}\x03\x02\x02\x02\u{742}\
	\u{e1}\x03\x02\x02\x02\u{743}\u{741}\x03\x02\x02\x02\u{744}\u{746}\x05\u{ee}\
	\x78\x02\u{745}\u{744}\x03\x02\x02\x02\u{746}\u{749}\x03\x02\x02\x02\u{747}\
	\u{745}\x03\x02\x02\x02\u{747}\u{748}\x03\x02\x02\x02\u{748}\u{74a}\x03\
	\x02\x02\x02\u{749}\u{747}\x03\x02\x02\x02\u{74a}\u{74b}\x05\u{ee}\x78\x02\
	\u{74b}\u{e3}\x03\x02\x02\x02\u{74c}\u{74e}\x05\u{ee}\x78\x02\u{74d}\u{74c}\
	\x03\x02\x02\x02\u{74e}\u{751}\x03\x02\x02\x02\u{74f}\u{74d}\x03\x02\x02\
	\x02\u{74f}\u{750}\x03\x02\x02\x02\u{750}\u{752}\x03\x02\x02\x02\u{751}\
	\u{74f}\x03\x02\x02\x02\u{752}\u{757}\x05\u{ee}\x78\x02\u{753}\u{754}\x07\
	\x07\x02\x02\u{754}\u{756}\x05\u{ee}\x78\x02\u{755}\u{753}\x03\x02\x02\x02\
	\u{756}\u{759}\x03\x02\x02\x02\u{757}\u{755}\x03\x02\x02\x02\u{757}\u{758}\
	\x03\x02\x02\x02\u{758}\u{e5}\x03\x02\x02\x02\u{759}\u{757}\x03\x02\x02\
	\x02\u{75a}\u{75d}\x07\x4a\x02\x02\u{75b}\u{75e}\x05\u{ee}\x78\x02\u{75c}\
	\u{75e}\x05\u{f0}\x79\x02\u{75d}\u{75b}\x03\x02\x02\x02\u{75d}\u{75c}\x03\
	\x02\x02\x02\u{75d}\u{75e}\x03\x02\x02\x02\u{75e}\u{e7}\x03\x02\x02\x02\
	\u{75f}\u{764}\x05\u{ee}\x78\x02\u{760}\u{761}\x07\x07\x02\x02\u{761}\u{763}\
	\x05\u{ee}\x78\x02\u{762}\u{760}\x03\x02\x02\x02\u{763}\u{766}\x03\x02\x02\
	\x02\u{764}\u{762}\x03\x02\x02\x02\u{764}\u{765}\x03\x02\x02\x02\u{765}\
	\u{769}\x03\x02\x02\x02\u{766}\u{764}\x03\x02\x02\x02\u{767}\u{768}\x07\
	\x03\x02\x02\u{768}\u{76a}\x05\u{ee}\x78\x02\u{769}\u{767}\x03\x02\x02\x02\
	\u{769}\u{76a}\x03\x02\x02\x02\u{76a}\u{e9}\x03\x02\x02\x02\u{76b}\u{770}\
	\x05\u{ee}\x78\x02\u{76c}\u{76d}\x09\x04\x02\x02\u{76d}\u{76f}\x05\u{ee}\
	\x78\x02\u{76e}\u{76c}\x03\x02\x02\x02\u{76f}\u{772}\x03\x02\x02\x02\u{770}\
	\u{76e}\x03\x02\x02\x02\u{770}\u{771}\x03\x02\x02\x02\u{771}\u{eb}\x03\x02\
	\x02\x02\u{772}\u{770}\x03\x02\x02\x02\u{773}\u{778}\x05\u{ee}\x78\x02\u{774}\
	\u{775}\x07\x07\x02\x02\u{775}\u{777}\x05\u{ee}\x78\x02\u{776}\u{774}\x03\
	\x02\x02\x02\u{777}\u{77a}\x03\x02\x02\x02\u{778}\u{776}\x03\x02\x02\x02\
	\u{778}\u{779}\x03\x02\x02\x02\u{779}\u{ed}\x03\x02\x02\x02\u{77a}\u{778}\
	\x03\x02\x02\x02\u{77b}\u{77c}\x09\x14\x02\x02\u{77c}\u{ef}\x03\x02\x02\
	\x02\u{77d}\u{77e}\x09\x15\x02\x02\u{77e}\u{f1}\x03\x02\x02\x02\u{77f}\u{781}\
	\x05\u{f0}\x79\x02\u{780}\u{782}\x05\u{ee}\x78\x02\u{781}\u{780}\x03\x02\
	\x02\x02\u{781}\u{782}\x03\x02\x02\x02\u{782}\u{f3}\x03\x02\x02\x02\u{783}\
	\u{784}\x09\x16\x02\x02\u{784}\u{f5}\x03\x02\x02\x02\u{785}\u{787}\x05\u{ee}\
	\x78\x02\u{786}\u{785}\x03\x02\x02\x02\u{786}\u{787}\x03\x02\x02\x02\u{787}\
	\u{788}\x03\x02\x02\x02\u{788}\u{792}\x07\x7f\x02\x02\u{789}\u{78b}\x05\
	\u{ee}\x78\x02\u{78a}\u{789}\x03\x02\x02\x02\u{78a}\u{78b}\x03\x02\x02\x02\
	\u{78b}\u{78c}\x03\x02\x02\x02\u{78c}\u{792}\x07\u{80}\x02\x02\u{78d}\u{78f}\
	\x05\u{ee}\x78\x02\u{78e}\u{78d}\x03\x02\x02\x02\u{78e}\u{78f}\x03\x02\x02\
	\x02\u{78f}\u{790}\x03\x02\x02\x02\u{790}\u{792}\x07\u{81}\x02\x02\u{791}\
	\u{786}\x03\x02\x02\x02\u{791}\u{78a}\x03\x02\x02\x02\u{791}\u{78e}\x03\
	\x02\x02\x02\u{792}\u{f7}\x03\x02\x02\x02\u{113}\u{fa}\u{fc}\u{10b}\u{114}\
	\u{11b}\u{123}\u{128}\u{12b}\u{130}\u{135}\u{138}\u{13c}\u{140}\u{143}\u{146}\
	\u{14d}\u{159}\u{15d}\u{162}\u{167}\u{16e}\u{171}\u{174}\u{178}\u{17f}\u{181}\
	\u{18e}\u{192}\u{196}\u{19d}\u{1a2}\u{1a5}\u{1aa}\u{1af}\u{1b3}\u{1b6}\u{1b9}\
	\u{1be}\u{1c5}\u{1ca}\u{1d1}\u{1d4}\u{1d8}\u{1df}\u{1e1}\u{1ea}\u{1ed}\u{1f2}\
	\u{1f9}\u{1fc}\u{206}\u{20d}\u{210}\u{216}\u{21e}\u{220}\u{227}\u{22c}\u{22e}\
	\u{236}\u{23d}\u{240}\u{248}\u{24a}\u{252}\u{258}\u{25b}\u{260}\u{267}\u{26b}\
	\u{26e}\u{27a}\u{27f}\u{284}\u{289}\u{28c}\u{292}\u{297}\u{29c}\u{29f}\u{2a3}\
	\u{2a7}\u{2a9}\u{2b3}\u{2b7}\u{2bb}\u{2c2}\u{2c7}\u{2cd}\u{2d2}\u{2d9}\u{2db}\
	\u{2e6}\u{2eb}\u{2ef}\u{2f3}\u{2fa}\u{2fe}\u{309}\u{30c}\u{30e}\u{318}\u{31c}\
	\u{31e}\u{323}\u{32b}\u{32f}\u{331}\u{335}\u{33d}\u{341}\u{343}\u{346}\u{34b}\
	\u{350}\u{356}\u{35b}\u{35f}\u{363}\u{366}\u{376}\u{37f}\u{384}\u{389}\u{391}\
	\u{39f}\u{3a9}\u{3b6}\u{3be}\u{3c2}\u{3ca}\u{3cf}\u{3db}\u{419}\u{41b}\u{429}\
	\u{430}\u{450}\u{452}\u{45f}\u{462}\u{464}\u{468}\u{477}\u{479}\u{481}\u{48a}\
	\u{48c}\u{491}\u{496}\u{49d}\u{4a0}\u{4a7}\u{4bf}\u{4c6}\u{4d0}\u{4d4}\u{4d9}\
	\u{4de}\u{4e6}\u{4ea}\u{4ee}\u{4f3}\u{501}\u{505}\u{511}\u{515}\u{519}\u{51c}\
	\u{524}\u{52f}\u{534}\u{539}\u{549}\u{54e}\u{558}\u{562}\u{566}\u{56a}\u{56f}\
	\u{571}\u{57d}\u{587}\u{58c}\u{595}\u{59a}\u{59c}\u{5a1}\u{5aa}\u{5af}\u{5b1}\
	\u{5b5}\u{5b8}\u{5bd}\u{5c2}\u{5c9}\u{5d0}\u{5d6}\u{5dd}\u{5df}\u{5e6}\u{5e8}\
	\u{5f0}\u{5f8}\u{602}\u{606}\u{608}\u{60e}\u{615}\u{61c}\u{626}\u{62e}\u{635}\
	\u{639}\u{63f}\u{64b}\u{64d}\u{65a}\u{663}\u{666}\u{66b}\u{670}\u{67f}\u{682}\
	\u{68d}\u{691}\u{696}\u{69e}\u{6a2}\u{6a7}\u{6af}\u{6b3}\u{6b7}\u{6bb}\u{6be}\
	\u{6c1}\u{6c8}\u{6cb}\u{6d2}\u{6d6}\u{6d9}\u{6dd}\u{6e2}\u{6e4}\u{6f1}\u{6f4}\
	\u{6fd}\u{702}\u{707}\u{711}\u{715}\u{717}\u{720}\u{724}\u{726}\u{729}\u{730}\
	\u{734}\u{736}\u{741}\u{747}\u{74f}\u{757}\u{75d}\u{764}\u{769}\u{770}\u{778}\
	\u{781}\u{786}\u{78a}\u{78e}\u{791}";
