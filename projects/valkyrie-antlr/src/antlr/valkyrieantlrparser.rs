// Generated from ValkyrieAntlr.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use super::{valkyrieantlrlistener::*, valkyrieantlrvisitor::*};
use antlr_rust::{
    atn::{ATN, INVALID_ALT},
    atn_deserializer::ATNDeserializer,
    dfa::DFA,
    error_strategy::{DefaultErrorStrategy, ErrorStrategy},
    errors::*,
    int_stream::EOF,
    parser::{BaseParser, Parser, ParserNodeType, ParserRecog},
    parser_atn_simulator::ParserATNSimulator,
    parser_rule_context::{cast, cast_mut, BaseParserRuleContext, ParserRuleContext},
    recognizer::{Actions, Recognizer},
    rule_context::{BaseRuleContext, CustomRuleContext, RuleContext},
    token::{OwningToken, Token, TOKEN_EOF},
    token_factory::{CommonTokenFactory, TokenAware, TokenFactory},
    token_stream::TokenStream,
    tree::*,
    vocabulary::{Vocabulary, VocabularyImpl},
    PredictionContextCache, TokenSource,
};

use antlr_rust::{lazy_static, TidAble, TidExt};

use std::{
    any::{Any, TypeId},
    borrow::{Borrow, BorrowMut},
    cell::RefCell,
    convert::TryFrom,
    marker::PhantomData,
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::Arc,
};

pub const DOT: isize = 1;
pub const COMMA: isize = 2;
pub const SEMICOLON: isize = 3;
pub const FAKE_COLON: isize = 4;
pub const OP_PROPORTION: isize = 5;
pub const COLON: isize = 6;
pub const PARENTHESES_L: isize = 7;
pub const PARENTHESES_R: isize = 8;
pub const BRACKET_L: isize = 9;
pub const BRACKET_R: isize = 10;
pub const BRACE_L: isize = 11;
pub const BRACE_R: isize = 12;
pub const GENERIC_L: isize = 13;
pub const GENERIC_R: isize = 14;
pub const OFFSET_L: isize = 15;
pub const OFFSET_R: isize = 16;
pub const RANGE_L: isize = 17;
pub const RANGE_R: isize = 18;
pub const CEILING_L: isize = 19;
pub const CEILING_R: isize = 20;
pub const FLOOR_L: isize = 21;
pub const FLOOR_R: isize = 22;
pub const COLLECTION_L: isize = 23;
pub const COLLECTION_R: isize = 24;
pub const OP_ADD: isize = 25;
pub const OP_INC: isize = 26;
pub const OP_SUB: isize = 27;
pub const OP_DEC: isize = 28;
pub const OP_MUL: isize = 29;
pub const OP_DIV: isize = 30;
pub const OP_EQ: isize = 31;
pub const OP_NE: isize = 32;
pub const OP_LEQ: isize = 33;
pub const OP_LLL: isize = 34;
pub const OP_LL: isize = 35;
pub const OP_LT: isize = 36;
pub const OP_GEQ: isize = 37;
pub const OP_GGG: isize = 38;
pub const OP_GG: isize = 39;
pub const OP_GT: isize = 40;
pub const OP_LEFT: isize = 41;
pub const OP_ARROW: isize = 42;
pub const OP_ARROW2: isize = 43;
pub const OP_ASSIGN: isize = 44;
pub const OP_BIND: isize = 45;
pub const OP_MAY_ASSIGN: isize = 46;
pub const OP_ADD_ASSIGN: isize = 47;
pub const OP_SUB_ASSIGN: isize = 48;
pub const OP_MUL_ASSIGN: isize = 49;
pub const OP_DIV_ASSIGN: isize = 50;
pub const LOGIC_NOT: isize = 51;
pub const LOGIC_AND: isize = 52;
pub const LOGIC_OR: isize = 53;
pub const LOGIC_XOR: isize = 54;
pub const LOGIC_NOR: isize = 55;
pub const LOGIC_NAND: isize = 56;
pub const OP_AND: isize = 57;
pub const OP_OR: isize = 58;
pub const OP_XOR: isize = 59;
pub const OP_EQV: isize = 60;
pub const OP_IMPL: isize = 61;
pub const OP_IFF: isize = 62;
pub const OP_AT: isize = 63;
pub const OP_HASH: isize = 64;
pub const LAMBDA_SLOT: isize = 65;
pub const MACRO_SLOT: isize = 66;
pub const OP_UNIMPLEMENTED: isize = 67;
pub const OP_OR_ELSE: isize = 68;
pub const OP_THROW: isize = 69;
pub const OP_NOT: isize = 70;
pub const KW_NOT: isize = 71;
pub const OP_IN: isize = 72;
pub const KW_IN: isize = 73;
pub const OP_NOT_IN: isize = 74;
pub const OP_CONTINUES: isize = 75;
pub const KW_IS: isize = 76;
pub const OP_IS: isize = 77;
pub const OP_IS_NOT: isize = 78;
pub const KW_AS: isize = 79;
pub const OP_DECONSTRUCT: isize = 80;
pub const OP_UNTIL: isize = 81;
pub const OP_POW: isize = 82;
pub const OP_INVERSE: isize = 83;
pub const OP_ROOTS: isize = 84;
pub const OP_TEMPERATURE: isize = 85;
pub const OP_TRANSPOSE: isize = 86;
pub const OP_PERCENT: isize = 87;
pub const OP_REFERENCE: isize = 88;
pub const OP_LABEL: isize = 89;
pub const KW_NAMESPACE: isize = 90;
pub const KW_IMPORT: isize = 91;
pub const KW_EXTENSION: isize = 92;
pub const KW_CLASS: isize = 93;
pub const KW_TRAIT: isize = 94;
pub const KW_UNION: isize = 95;
pub const KW_BITFLAGS: isize = 96;
pub const KW_TYPE: isize = 97;
pub const KW_TEMPLATE: isize = 98;
pub const KW_EXTENDS: isize = 99;
pub const KW_IMPLEMENTS: isize = 100;
pub const KW_WHERE: isize = 101;
pub const KW_WHILE: isize = 102;
pub const KW_FOR: isize = 103;
pub const KW_LET: isize = 104;
pub const KW_WITCH: isize = 105;
pub const KW_NEW: isize = 106;
pub const KW_OBJECT: isize = 107;
pub const KW_LAMBDA: isize = 108;
pub const KW_FUNCTION: isize = 109;
pub const KW_TRY: isize = 110;
pub const KW_MATCH: isize = 111;
pub const KW_CATCH: isize = 112;
pub const KW_WITH: isize = 113;
pub const KW_CASE: isize = 114;
pub const KW_WHEN: isize = 115;
pub const INTEGER: isize = 116;
pub const DECIMAL: isize = 117;
pub const STRING_SINGLE: isize = 118;
pub const STRING_DOUBLE: isize = 119;
pub const STRING_BLOCK: isize = 120;
pub const KW_IF: isize = 121;
pub const KW_ELSE: isize = 122;
pub const KW_OTHERWISE: isize = 123;
pub const RETURN: isize = 124;
pub const RESUME: isize = 125;
pub const YIELD: isize = 126;
pub const BREAK: isize = 127;
pub const CONTINUE: isize = 128;
pub const RAISE: isize = 129;
pub const SPECIAL: isize = 130;
pub const RAW_ID: isize = 131;
pub const UNICODE_ID: isize = 132;
pub const LINE_COMMENT: isize = 133;
pub const BLOCK_COMMENT: isize = 134;
pub const WHITE_SPACE: isize = 135;
pub const ERROR_CHARACTAR: isize = 136;
pub const RULE_program: usize = 0;
pub const RULE_top_statement: usize = 1;
pub const RULE_function_statements: usize = 2;
pub const RULE_eos: usize = 3;
pub const RULE_eos_free: usize = 4;
pub const RULE_define_namespace: usize = 5;
pub const RULE_import_statement: usize = 6;
pub const RULE_import_as: usize = 7;
pub const RULE_import_term: usize = 8;
pub const RULE_import_name: usize = 9;
pub const RULE_import_block: usize = 10;
pub const RULE_define_extension: usize = 11;
pub const RULE_define_class: usize = 12;
pub const RULE_class_block: usize = 13;
pub const RULE_class_inherit: usize = 14;
pub const RULE_class_inherit_item: usize = 15;
pub const RULE_class_field: usize = 16;
pub const RULE_class_method: usize = 17;
pub const RULE_class_dsl: usize = 18;
pub const RULE_define_trait: usize = 19;
pub const RULE_trait_block: usize = 20;
pub const RULE_define_trait_type: usize = 21;
pub const RULE_define_extends: usize = 22;
pub const RULE_impliments: usize = 23;
pub const RULE_define_union: usize = 24;
pub const RULE_base_layout: usize = 25;
pub const RULE_union_block: usize = 26;
pub const RULE_define_variant: usize = 27;
pub const RULE_variant_block: usize = 28;
pub const RULE_define_bitflags: usize = 29;
pub const RULE_bitflags_block: usize = 30;
pub const RULE_bitflags_item: usize = 31;
pub const RULE_define_function: usize = 32;
pub const RULE_function_parameters: usize = 33;
pub const RULE_parameter_item: usize = 34;
pub const RULE_parameter_default: usize = 35;
pub const RULE_function_call: usize = 36;
pub const RULE_dot_call: usize = 37;
pub const RULE_tuple_call_body: usize = 38;
pub const RULE_tuple_call_item: usize = 39;
pub const RULE_define_lambda: usize = 40;
pub const RULE_lambda_call: usize = 41;
pub const RULE_function_block: usize = 42;
pub const RULE_define_variale: usize = 43;
pub const RULE_let_pattern: usize = 44;
pub const RULE_let_pattern_plain: usize = 45;
pub const RULE_let_pattern_tuple: usize = 46;
pub const RULE_let_pattern_item: usize = 47;
pub const RULE_define_type: usize = 48;
pub const RULE_type_hint: usize = 49;
pub const RULE_effect_hint: usize = 50;
pub const RULE_if_statement: usize = 51;
pub const RULE_else_if_statement: usize = 52;
pub const RULE_while_statement: usize = 53;
pub const RULE_for_statement: usize = 54;
pub const RULE_if_guard: usize = 55;
pub const RULE_top_expression: usize = 56;
pub const RULE_expression: usize = 57;
pub const RULE_inline_expression: usize = 58;
pub const RULE_type_expression: usize = 59;
pub const RULE_prefix_call: usize = 60;
pub const RULE_suffix_call: usize = 61;
pub const RULE_control_expression: usize = 62;
pub const RULE_op_compare: usize = 63;
pub const RULE_op_pattern: usize = 64;
pub const RULE_infix_arrows: usize = 65;
pub const RULE_op_multiple: usize = 66;
pub const RULE_op_plus: usize = 67;
pub const RULE_op_logic: usize = 68;
pub const RULE_op_assign: usize = 69;
pub const RULE_infix_is: usize = 70;
pub const RULE_infix_in: usize = 71;
pub const RULE_define_generic: usize = 72;
pub const RULE_generic_item: usize = 73;
pub const RULE_generic_call: usize = 74;
pub const RULE_generic_call_in_type: usize = 75;
pub const RULE_generic_pair: usize = 76;
pub const RULE_define_label: usize = 77;
pub const RULE_offset_call: usize = 78;
pub const RULE_template_call: usize = 79;
pub const RULE_template_block: usize = 80;
pub const RULE_tempalte_terms: usize = 81;
pub const RULE_where_block: usize = 82;
pub const RULE_where_bound: usize = 83;
pub const RULE_macro_call: usize = 84;
pub const RULE_annotation: usize = 85;
pub const RULE_annotation_call_item: usize = 86;
pub const RULE_try_statement: usize = 87;
pub const RULE_match_statement: usize = 88;
pub const RULE_match_call: usize = 89;
pub const RULE_match_block: usize = 90;
pub const RULE_match_terms: usize = 91;
pub const RULE_match_case_block: usize = 92;
pub const RULE_case_pattern: usize = 93;
pub const RULE_case_pattern_item: usize = 94;
pub const RULE_case_pattern_tuple: usize = 95;
pub const RULE_object_statement: usize = 96;
pub const RULE_new_statement: usize = 97;
pub const RULE_new_body: usize = 98;
pub const RULE_new_block: usize = 99;
pub const RULE_collection_literal: usize = 100;
pub const RULE_collection_pair: usize = 101;
pub const RULE_slice_call: usize = 102;
pub const RULE_range_literal: usize = 103;
pub const RULE_range_axis: usize = 104;
pub const RULE_range_start: usize = 105;
pub const RULE_range_end: usize = 106;
pub const RULE_range_step: usize = 107;
pub const RULE_modifiers: usize = 108;
pub const RULE_modified_identifier: usize = 109;
pub const RULE_modified_namepath: usize = 110;
pub const RULE_lambda_name: usize = 111;
pub const RULE_function_name: usize = 112;
pub const RULE_namepath_free: usize = 113;
pub const RULE_namepath: usize = 114;
pub const RULE_identifier: usize = 115;
pub const RULE_number: usize = 116;
pub const RULE_number_literal: usize = 117;
pub const RULE_string: usize = 118;
pub const RULE_string_literal: usize = 119;
pub const ruleNames: [&'static str; 120] = [
    "program",
    "top_statement",
    "function_statements",
    "eos",
    "eos_free",
    "define_namespace",
    "import_statement",
    "import_as",
    "import_term",
    "import_name",
    "import_block",
    "define_extension",
    "define_class",
    "class_block",
    "class_inherit",
    "class_inherit_item",
    "class_field",
    "class_method",
    "class_dsl",
    "define_trait",
    "trait_block",
    "define_trait_type",
    "define_extends",
    "impliments",
    "define_union",
    "base_layout",
    "union_block",
    "define_variant",
    "variant_block",
    "define_bitflags",
    "bitflags_block",
    "bitflags_item",
    "define_function",
    "function_parameters",
    "parameter_item",
    "parameter_default",
    "function_call",
    "dot_call",
    "tuple_call_body",
    "tuple_call_item",
    "define_lambda",
    "lambda_call",
    "function_block",
    "define_variale",
    "let_pattern",
    "let_pattern_plain",
    "let_pattern_tuple",
    "let_pattern_item",
    "define_type",
    "type_hint",
    "effect_hint",
    "if_statement",
    "else_if_statement",
    "while_statement",
    "for_statement",
    "if_guard",
    "top_expression",
    "expression",
    "inline_expression",
    "type_expression",
    "prefix_call",
    "suffix_call",
    "control_expression",
    "op_compare",
    "op_pattern",
    "infix_arrows",
    "op_multiple",
    "op_plus",
    "op_logic",
    "op_assign",
    "infix_is",
    "infix_in",
    "define_generic",
    "generic_item",
    "generic_call",
    "generic_call_in_type",
    "generic_pair",
    "define_label",
    "offset_call",
    "template_call",
    "template_block",
    "tempalte_terms",
    "where_block",
    "where_bound",
    "macro_call",
    "annotation",
    "annotation_call_item",
    "try_statement",
    "match_statement",
    "match_call",
    "match_block",
    "match_terms",
    "match_case_block",
    "case_pattern",
    "case_pattern_item",
    "case_pattern_tuple",
    "object_statement",
    "new_statement",
    "new_body",
    "new_block",
    "collection_literal",
    "collection_pair",
    "slice_call",
    "range_literal",
    "range_axis",
    "range_start",
    "range_end",
    "range_step",
    "modifiers",
    "modified_identifier",
    "modified_namepath",
    "lambda_name",
    "function_name",
    "namepath_free",
    "namepath",
    "identifier",
    "number",
    "number_literal",
    "string",
    "string_literal",
];

pub const _LITERAL_NAMES: [Option<&'static str>; 130] = [
    None,
    Some("'.'"),
    None,
    Some("';'"),
    None,
    None,
    None,
    Some("'('"),
    Some("')'"),
    Some("'['"),
    Some("']'"),
    Some("'{'"),
    Some("'}'"),
    Some("'\u{27E8}'"),
    Some("'\u{27E9}'"),
    Some("'\u{2045}'"),
    Some("'\u{2046}'"),
    Some("'\u{27E6}'"),
    Some("'\u{27E7}'"),
    Some("'\u{2308}'"),
    Some("'\u{2309}'"),
    Some("'\u{230A}'"),
    Some("'\u{230B}'"),
    Some("'\u{2983}'"),
    Some("'\u{2984}'"),
    Some("'+'"),
    Some("'++'"),
    Some("'-'"),
    Some("'--'"),
    Some("'*'"),
    None,
    Some("'=='"),
    Some("'!='"),
    None,
    None,
    None,
    Some("'<'"),
    None,
    None,
    None,
    Some("'>'"),
    None,
    None,
    None,
    Some("'='"),
    None,
    Some("'?='"),
    Some("'+='"),
    Some("'-='"),
    Some("'*='"),
    Some("'/='"),
    Some("'\u{00AC}'"),
    None,
    None,
    Some("'\u{22BB}'"),
    Some("'\u{22BD}'"),
    Some("'\u{22BC}'"),
    Some("'&'"),
    Some("'|'"),
    Some("'\u{2295}'"),
    Some("'\u{2261}'"),
    Some("'\u{203D}'"),
    Some("'\u{21D4}'"),
    Some("'@'"),
    None,
    None,
    None,
    None,
    Some("'?:'"),
    Some("'?'"),
    Some("'!'"),
    Some("'not'"),
    None,
    Some("'in'"),
    Some("'\u{2209}'"),
    None,
    Some("'is'"),
    None,
    None,
    None,
    None,
    None,
    Some("'^'"),
    Some("'\u{215F}'"),
    None,
    None,
    None,
    None,
    Some("'\u{203B}'"),
    Some("'\u{00B6}'"),
    None,
    None,
    Some("'extension'"),
    None,
    None,
    Some("'union'"),
    Some("'flags'"),
    Some("'type'"),
    None,
    None,
    None,
    Some("'where'"),
    None,
    Some("'for'"),
    Some("'let'"),
    Some("'which'"),
    Some("'new'"),
    Some("'object'"),
    Some("'lambda'"),
    None,
    Some("'try'"),
    Some("'match'"),
    Some("'catch'"),
    Some("'with'"),
    Some("'case'"),
    Some("'when'"),
    None,
    None,
    None,
    None,
    None,
    Some("'if'"),
    Some("'else'"),
    Some("'otherwise'"),
    Some("'return'"),
    Some("'resume'"),
    Some("'yield'"),
    Some("'break'"),
    Some("'continue'"),
    Some("'raise'"),
];
pub const _SYMBOLIC_NAMES: [Option<&'static str>; 137] = [
    None,
    Some("DOT"),
    Some("COMMA"),
    Some("SEMICOLON"),
    Some("FAKE_COLON"),
    Some("OP_PROPORTION"),
    Some("COLON"),
    Some("PARENTHESES_L"),
    Some("PARENTHESES_R"),
    Some("BRACKET_L"),
    Some("BRACKET_R"),
    Some("BRACE_L"),
    Some("BRACE_R"),
    Some("GENERIC_L"),
    Some("GENERIC_R"),
    Some("OFFSET_L"),
    Some("OFFSET_R"),
    Some("RANGE_L"),
    Some("RANGE_R"),
    Some("CEILING_L"),
    Some("CEILING_R"),
    Some("FLOOR_L"),
    Some("FLOOR_R"),
    Some("COLLECTION_L"),
    Some("COLLECTION_R"),
    Some("OP_ADD"),
    Some("OP_INC"),
    Some("OP_SUB"),
    Some("OP_DEC"),
    Some("OP_MUL"),
    Some("OP_DIV"),
    Some("OP_EQ"),
    Some("OP_NE"),
    Some("OP_LEQ"),
    Some("OP_LLL"),
    Some("OP_LL"),
    Some("OP_LT"),
    Some("OP_GEQ"),
    Some("OP_GGG"),
    Some("OP_GG"),
    Some("OP_GT"),
    Some("OP_LEFT"),
    Some("OP_ARROW"),
    Some("OP_ARROW2"),
    Some("OP_ASSIGN"),
    Some("OP_BIND"),
    Some("OP_MAY_ASSIGN"),
    Some("OP_ADD_ASSIGN"),
    Some("OP_SUB_ASSIGN"),
    Some("OP_MUL_ASSIGN"),
    Some("OP_DIV_ASSIGN"),
    Some("LOGIC_NOT"),
    Some("LOGIC_AND"),
    Some("LOGIC_OR"),
    Some("LOGIC_XOR"),
    Some("LOGIC_NOR"),
    Some("LOGIC_NAND"),
    Some("OP_AND"),
    Some("OP_OR"),
    Some("OP_XOR"),
    Some("OP_EQV"),
    Some("OP_IMPL"),
    Some("OP_IFF"),
    Some("OP_AT"),
    Some("OP_HASH"),
    Some("LAMBDA_SLOT"),
    Some("MACRO_SLOT"),
    Some("OP_UNIMPLEMENTED"),
    Some("OP_OR_ELSE"),
    Some("OP_THROW"),
    Some("OP_NOT"),
    Some("KW_NOT"),
    Some("OP_IN"),
    Some("KW_IN"),
    Some("OP_NOT_IN"),
    Some("OP_CONTINUES"),
    Some("KW_IS"),
    Some("OP_IS"),
    Some("OP_IS_NOT"),
    Some("KW_AS"),
    Some("OP_DECONSTRUCT"),
    Some("OP_UNTIL"),
    Some("OP_POW"),
    Some("OP_INVERSE"),
    Some("OP_ROOTS"),
    Some("OP_TEMPERATURE"),
    Some("OP_TRANSPOSE"),
    Some("OP_PERCENT"),
    Some("OP_REFERENCE"),
    Some("OP_LABEL"),
    Some("KW_NAMESPACE"),
    Some("KW_IMPORT"),
    Some("KW_EXTENSION"),
    Some("KW_CLASS"),
    Some("KW_TRAIT"),
    Some("KW_UNION"),
    Some("KW_BITFLAGS"),
    Some("KW_TYPE"),
    Some("KW_TEMPLATE"),
    Some("KW_EXTENDS"),
    Some("KW_IMPLEMENTS"),
    Some("KW_WHERE"),
    Some("KW_WHILE"),
    Some("KW_FOR"),
    Some("KW_LET"),
    Some("KW_WITCH"),
    Some("KW_NEW"),
    Some("KW_OBJECT"),
    Some("KW_LAMBDA"),
    Some("KW_FUNCTION"),
    Some("KW_TRY"),
    Some("KW_MATCH"),
    Some("KW_CATCH"),
    Some("KW_WITH"),
    Some("KW_CASE"),
    Some("KW_WHEN"),
    Some("INTEGER"),
    Some("DECIMAL"),
    Some("STRING_SINGLE"),
    Some("STRING_DOUBLE"),
    Some("STRING_BLOCK"),
    Some("KW_IF"),
    Some("KW_ELSE"),
    Some("KW_OTHERWISE"),
    Some("RETURN"),
    Some("RESUME"),
    Some("YIELD"),
    Some("BREAK"),
    Some("CONTINUE"),
    Some("RAISE"),
    Some("SPECIAL"),
    Some("RAW_ID"),
    Some("UNICODE_ID"),
    Some("LINE_COMMENT"),
    Some("BLOCK_COMMENT"),
    Some("WHITE_SPACE"),
    Some("ERROR_CHARACTAR"),
];
lazy_static! {
    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
    static ref VOCABULARY: Box<dyn Vocabulary> =
        Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
}

type BaseParserType<'input, I> = BaseParser<
    'input,
    ValkyrieAntlrParserExt<'input>,
    I,
    ValkyrieAntlrParserContextType,
    dyn ValkyrieAntlrListener<'input> + 'input,
>;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type ValkyrieAntlrTreeWalker<'input, 'a> =
    ParseTreeWalker<'input, 'a, ValkyrieAntlrParserContextType, dyn ValkyrieAntlrListener<'input> + 'a>;

/// Parser for ValkyrieAntlr grammar
pub struct ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    base: BaseParserType<'input, I>,
    interpreter: Arc<ParserATNSimulator>,
    _shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn get_serialized_atn() -> &'static str {
        _serializedATN
    }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
        antlr_rust::recognizer::check_version("0", "3");
        let interpreter =
            Arc::new(ParserATNSimulator::new(_ATN.clone(), _decision_to_DFA.clone(), _shared_context_cache.clone()));
        Self {
            base: BaseParser::new_base_parser(
                input,
                Arc::clone(&interpreter),
                ValkyrieAntlrParserExt { _pd: Default::default() },
            ),
            interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }
}

type DynStrategy<'input, I> = Box<dyn ErrorStrategy<'input, BaseParserType<'input, I>> + 'input>;

impl<'input, I> ValkyrieAntlrParser<'input, I, DynStrategy<'input, I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self {
        Self::with_strategy(input, Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn new(input: I) -> Self {
        Self::with_strategy(input, DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for ValkyrieAntlrParser
pub trait ValkyrieAntlrParserContext<'input>:
    for<'x> Listenable<dyn ValkyrieAntlrListener<'input> + 'x>
    + for<'x> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'x>
    + ParserRuleContext<'input, TF = LocalTokenFactory<'input>, Ctx = ValkyrieAntlrParserContextType>
{
}

antlr_rust::coerce_from! { 'input : ValkyrieAntlrParserContext<'input> }

impl<'input, 'x, T> VisitableDyn<T> for dyn ValkyrieAntlrParserContext<'input> + 'input
where
    T: ValkyrieAntlrVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn ValkyrieAntlrVisitor<'input> + 'x))
    }
}

impl<'input> ValkyrieAntlrParserContext<'input> for TerminalNode<'input, ValkyrieAntlrParserContextType> {}
impl<'input> ValkyrieAntlrParserContext<'input> for ErrorNode<'input, ValkyrieAntlrParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrListener<'input> + 'input }

pub struct ValkyrieAntlrParserContextType;
antlr_rust::tid! {ValkyrieAntlrParserContextType}

impl<'input> ParserNodeType<'input> for ValkyrieAntlrParserContextType {
    type TF = LocalTokenFactory<'input>;
    type Type = dyn ValkyrieAntlrParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    type Target = BaseParserType<'input, I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct ValkyrieAntlrParserExt<'input> {
    _pd: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserExt<'input> {}
antlr_rust::tid! { ValkyrieAntlrParserExt<'a> }

impl<'input> TokenAware<'input> for ValkyrieAntlrParserExt<'input> {
    type TF = LocalTokenFactory<'input>;
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    ParserRecog<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    Actions<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
    fn get_grammar_file_name(&self) -> &str {
        "ValkyrieAntlr.g4"
    }

    fn get_rule_names(&self) -> &[&str] {
        &ruleNames
    }

    fn get_vocabulary(&self) -> &dyn Vocabulary {
        &**VOCABULARY
    }
    fn sempred(
        _localctx: Option<&(dyn ValkyrieAntlrParserContext<'input> + 'input)>,
        rule_index: isize,
        pred_index: isize,
        recog: &mut BaseParserType<'input, I>,
    ) -> bool {
        match rule_index {
            57 => ValkyrieAntlrParser::<'input, I, _>::expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            58 => ValkyrieAntlrParser::<'input, I, _>::inline_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            59 => ValkyrieAntlrParser::<'input, I, _>::type_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            93 => ValkyrieAntlrParser::<'input, I, _>::case_pattern_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            _ => true,
        }
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    fn expression_sempred(
        _localctx: Option<&ExpressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            0 => recog.precpred(None, 26),
            1 => recog.precpred(None, 25),
            2 => recog.precpred(None, 24),
            3 => recog.precpred(None, 23),
            4 => recog.precpred(None, 22),
            5 => recog.precpred(None, 21),
            6 => recog.precpred(None, 27),
            7 => recog.precpred(None, 20),
            8 => recog.precpred(None, 19),
            9 => recog.precpred(None, 18),
            _ => true,
        }
    }
    fn inline_expression_sempred(
        _localctx: Option<&Inline_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            10 => recog.precpred(None, 15),
            11 => recog.precpred(None, 14),
            12 => recog.precpred(None, 13),
            13 => recog.precpred(None, 12),
            14 => recog.precpred(None, 11),
            15 => recog.precpred(None, 10),
            16 => recog.precpred(None, 9),
            17 => recog.precpred(None, 17),
            18 => recog.precpred(None, 16),
            _ => true,
        }
    }
    fn type_expression_sempred(
        _localctx: Option<&Type_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            19 => recog.precpred(None, 9),
            20 => recog.precpred(None, 8),
            21 => recog.precpred(None, 7),
            22 => recog.precpred(None, 6),
            _ => true,
        }
    }
    fn case_pattern_sempred(
        _localctx: Option<&Case_patternContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            23 => recog.precpred(None, 3),
            24 => recog.precpred(None, 2),
            _ => true,
        }
    }
}
//------------------- program ----------------
pub type ProgramContextAll<'input> = ProgramContext<'input>;

pub type ProgramContext<'input> = BaseParserRuleContext<'input, ProgramContextExt<'input>>;

#[derive(Clone)]
pub struct ProgramContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ProgramContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ProgramContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_program(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_program(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ProgramContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_program(self);
    }
}

impl<'input> CustomRuleContext<'input> for ProgramContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_program
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_program }
}
antlr_rust::tid! {ProgramContextExt<'a>}

impl<'input> ProgramContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ProgramContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, ProgramContextExt { ph: PhantomData }))
    }
}

pub trait ProgramContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ProgramContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
    fn top_statement_all(&self) -> Vec<Rc<Top_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn top_statement(&self, i: usize) -> Option<Rc<Top_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ProgramContextAttrs<'input> for ProgramContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn program(&mut self) -> Result<Rc<ProgramContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ProgramContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_program);
        let mut _localctx: Rc<ProgramContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(243);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << SEMICOLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 57) & !0x3f) == 0
                        && ((1usize << (_la - 57))
                            & ((1usize << (OP_AND - 57))
                                | (1usize << (OP_AT - 57))
                                | (1usize << (OP_HASH - 57))
                                | (1usize << (LAMBDA_SLOT - 57))
                                | (1usize << (OP_THROW - 57))
                                | (1usize << (OP_NOT - 57))
                                | (1usize << (OP_DECONSTRUCT - 57))
                                | (1usize << (OP_INVERSE - 57))
                                | (1usize << (OP_ROOTS - 57))
                                | (1usize << (OP_REFERENCE - 57))))
                            != 0)
                    || (((_la - 89) & !0x3f) == 0
                        && ((1usize << (_la - 89))
                            & ((1usize << (OP_LABEL - 89))
                                | (1usize << (KW_NAMESPACE - 89))
                                | (1usize << (KW_IMPORT - 89))
                                | (1usize << (KW_EXTENSION - 89))
                                | (1usize << (KW_CLASS - 89))
                                | (1usize << (KW_TRAIT - 89))
                                | (1usize << (KW_UNION - 89))
                                | (1usize << (KW_BITFLAGS - 89))
                                | (1usize << (KW_TYPE - 89))
                                | (1usize << (KW_TEMPLATE - 89))
                                | (1usize << (KW_EXTENDS - 89))
                                | (1usize << (KW_WHILE - 89))
                                | (1usize << (KW_FOR - 89))
                                | (1usize << (KW_LET - 89))
                                | (1usize << (KW_NEW - 89))
                                | (1usize << (KW_OBJECT - 89))
                                | (1usize << (KW_FUNCTION - 89))
                                | (1usize << (KW_TRY - 89))
                                | (1usize << (KW_MATCH - 89))
                                | (1usize << (KW_CATCH - 89))
                                | (1usize << (INTEGER - 89))
                                | (1usize << (DECIMAL - 89))
                                | (1usize << (STRING_SINGLE - 89))
                                | (1usize << (STRING_DOUBLE - 89))
                                | (1usize << (STRING_BLOCK - 89))))
                            != 0)
                    || (((_la - 121) & !0x3f) == 0
                        && ((1usize << (_la - 121))
                            & ((1usize << (KW_IF - 121))
                                | (1usize << (RETURN - 121))
                                | (1usize << (RESUME - 121))
                                | (1usize << (YIELD - 121))
                                | (1usize << (BREAK - 121))
                                | (1usize << (CONTINUE - 121))
                                | (1usize << (RAISE - 121))
                                | (1usize << (SPECIAL - 121))
                                | (1usize << (RAW_ID - 121))
                                | (1usize << (UNICODE_ID - 121))))
                            != 0)
                {
                    {
                        {
                            /* InvokeRule top_statement */
                            recog.base.set_state(240);
                            recog.top_statement()?;
                        }
                    }
                    recog.base.set_state(245);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(246);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- top_statement ----------------
pub type Top_statementContextAll<'input> = Top_statementContext<'input>;

pub type Top_statementContext<'input> = BaseParserRuleContext<'input, Top_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Top_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Top_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Top_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_top_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_top_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Top_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_top_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Top_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_statement }
}
antlr_rust::tid! {Top_statementContextExt<'a>}

impl<'input> Top_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Top_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Top_statementContextExt { ph: PhantomData }))
    }
}

pub trait Top_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Top_statementContextExt<'input>>
{
    fn define_namespace(&self) -> Option<Rc<Define_namespaceContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn import_statement(&self) -> Option<Rc<Import_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_extension(&self) -> Option<Rc<Define_extensionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_class(&self) -> Option<Rc<Define_classContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_union(&self) -> Option<Rc<Define_unionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_bitflags(&self) -> Option<Rc<Define_bitflagsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_trait(&self) -> Option<Rc<Define_traitContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_extends(&self) -> Option<Rc<Define_extendsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_function(&self) -> Option<Rc<Define_functionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_type(&self) -> Option<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_variale(&self) -> Option<Rc<Define_varialeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn if_statement(&self) -> Option<Rc<If_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn while_statement(&self) -> Option<Rc<While_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn for_statement(&self) -> Option<Rc<For_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn top_expression(&self) -> Option<Rc<Top_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Top_statementContextAttrs<'input> for Top_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn top_statement(&mut self) -> Result<Rc<Top_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Top_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_top_statement);
        let mut _localctx: Rc<Top_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(264);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(1, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule define_namespace */
                        recog.base.set_state(248);
                        recog.define_namespace()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule import_statement */
                        recog.base.set_state(249);
                        recog.import_statement()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule define_extension */
                        recog.base.set_state(250);
                        recog.define_extension()?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule define_class */
                        recog.base.set_state(251);
                        recog.define_class()?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule define_union */
                        recog.base.set_state(252);
                        recog.define_union()?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule define_bitflags */
                        recog.base.set_state(253);
                        recog.define_bitflags()?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule define_trait */
                        recog.base.set_state(254);
                        recog.define_trait()?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        /* InvokeRule define_extends */
                        recog.base.set_state(255);
                        recog.define_extends()?;
                    }
                }
                9 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 9);
                    recog.base.enter_outer_alt(None, 9);
                    {
                        /* InvokeRule define_function */
                        recog.base.set_state(256);
                        recog.define_function()?;
                    }
                }
                10 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 10);
                    recog.base.enter_outer_alt(None, 10);
                    {
                        /* InvokeRule define_type */
                        recog.base.set_state(257);
                        recog.define_type()?;
                    }
                }
                11 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 11);
                    recog.base.enter_outer_alt(None, 11);
                    {
                        /* InvokeRule define_variale */
                        recog.base.set_state(258);
                        recog.define_variale()?;
                    }
                }
                12 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 12);
                    recog.base.enter_outer_alt(None, 12);
                    {
                        /* InvokeRule if_statement */
                        recog.base.set_state(259);
                        recog.if_statement()?;
                    }
                }
                13 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 13);
                    recog.base.enter_outer_alt(None, 13);
                    {
                        /* InvokeRule while_statement */
                        recog.base.set_state(260);
                        recog.while_statement()?;
                    }
                }
                14 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 14);
                    recog.base.enter_outer_alt(None, 14);
                    {
                        /* InvokeRule for_statement */
                        recog.base.set_state(261);
                        recog.for_statement()?;
                    }
                }
                15 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 15);
                    recog.base.enter_outer_alt(None, 15);
                    {
                        /* InvokeRule top_expression */
                        recog.base.set_state(262);
                        recog.top_expression()?;
                    }
                }
                16 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 16);
                    recog.base.enter_outer_alt(None, 16);
                    {
                        /* InvokeRule eos */
                        recog.base.set_state(263);
                        recog.eos()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_statements ----------------
pub type Function_statementsContextAll<'input> = Function_statementsContext<'input>;

pub type Function_statementsContext<'input> = BaseParserRuleContext<'input, Function_statementsContextExt<'input>>;

#[derive(Clone)]
pub struct Function_statementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_statementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_statementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_statements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_statements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_statementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_statements(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_statementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_statements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_statements }
}
antlr_rust::tid! {Function_statementsContextExt<'a>}

impl<'input> Function_statementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_statementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Function_statementsContextExt { ph: PhantomData },
        ))
    }
}

pub trait Function_statementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_statementsContextExt<'input>>
{
    fn define_lambda(&self) -> Option<Rc<Define_lambdaContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_variale(&self) -> Option<Rc<Define_varialeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn while_statement(&self) -> Option<Rc<While_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn for_statement(&self) -> Option<Rc<For_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn top_expression(&self) -> Option<Rc<Top_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Function_statementsContextAttrs<'input> for Function_statementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_statements(&mut self) -> Result<Rc<Function_statementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_statementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_function_statements);
        let mut _localctx: Rc<Function_statementsContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(272);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(2, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule define_lambda */
                        recog.base.set_state(266);
                        recog.define_lambda()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule define_variale */
                        recog.base.set_state(267);
                        recog.define_variale()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule while_statement */
                        recog.base.set_state(268);
                        recog.while_statement()?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule for_statement */
                        recog.base.set_state(269);
                        recog.for_statement()?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule top_expression */
                        recog.base.set_state(270);
                        recog.top_expression()?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule eos */
                        recog.base.set_state(271);
                        recog.eos()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos ----------------
pub type EosContextAll<'input> = EosContext<'input>;

pub type EosContext<'input> = BaseParserRuleContext<'input, EosContextExt<'input>>;

#[derive(Clone)]
pub struct EosContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for EosContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EosContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EosContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos(self);
    }
}

impl<'input> CustomRuleContext<'input> for EosContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos }
}
antlr_rust::tid! {EosContextExt<'a>}

impl<'input> EosContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<EosContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, EosContextExt { ph: PhantomData }))
    }
}

pub trait EosContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<EosContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
}

impl<'input> EosContextAttrs<'input> for EosContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos(&mut self) -> Result<Rc<EosContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = EosContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_eos);
        let mut _localctx: Rc<EosContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(274);
                recog.base.match_token(SEMICOLON, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos_free ----------------
pub type Eos_freeContextAll<'input> = Eos_freeContext<'input>;

pub type Eos_freeContext<'input> = BaseParserRuleContext<'input, Eos_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Eos_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Eos_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Eos_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Eos_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Eos_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos_free }
}
antlr_rust::tid! {Eos_freeContextExt<'a>}

impl<'input> Eos_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Eos_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Eos_freeContextExt { ph: PhantomData }))
    }
}

pub trait Eos_freeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Eos_freeContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
}

impl<'input> Eos_freeContextAttrs<'input> for Eos_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos_free(&mut self) -> Result<Rc<Eos_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Eos_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_eos_free);
        let mut _localctx: Rc<Eos_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(276);
                _la = recog.base.input.la(1);
                if { !(_la == COMMA || _la == SEMICOLON) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_namespace ----------------
pub type Define_namespaceContextAll<'input> = Define_namespaceContext<'input>;

pub type Define_namespaceContext<'input> = BaseParserRuleContext<'input, Define_namespaceContextExt<'input>>;

#[derive(Clone)]
pub struct Define_namespaceContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_namespaceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_namespaceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_namespace(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_namespace(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_namespaceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_namespace(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_namespaceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_namespace
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_namespace }
}
antlr_rust::tid! {Define_namespaceContextExt<'a>}

impl<'input> Define_namespaceContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_namespaceContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_namespaceContextExt { ph: PhantomData }))
    }
}

pub trait Define_namespaceContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_namespaceContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NAMESPACE
    /// Returns `None` if there is no child corresponding to token KW_NAMESPACE
    fn KW_NAMESPACE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NAMESPACE, 0)
    }
    fn namepath_free(&self) -> Option<Rc<Namepath_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_namespaceContextAttrs<'input> for Define_namespaceContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_namespace(&mut self) -> Result<Rc<Define_namespaceContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_namespaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_define_namespace);
        let mut _localctx: Rc<Define_namespaceContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(278);
                recog.base.match_token(KW_NAMESPACE, &mut recog.err_handler)?;

                /* InvokeRule namepath_free */
                recog.base.set_state(279);
                recog.namepath_free()?;

                recog.base.set_state(281);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(3, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(280);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_statement ----------------
pub type Import_statementContextAll<'input> = Import_statementContext<'input>;

pub type Import_statementContext<'input> = BaseParserRuleContext<'input, Import_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Import_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_statement }
}
antlr_rust::tid! {Import_statementContextExt<'a>}

impl<'input> Import_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_statementContextExt { ph: PhantomData }))
    }
}

pub trait Import_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IMPORT
    /// Returns `None` if there is no child corresponding to token KW_IMPORT
    fn KW_IMPORT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPORT, 0)
    }
    fn import_term(&self) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_statementContextAttrs<'input> for Import_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_statement(&mut self) -> Result<Rc<Import_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_import_statement);
        let mut _localctx: Rc<Import_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(283);
                recog.base.match_token(KW_IMPORT, &mut recog.err_handler)?;

                /* InvokeRule import_term */
                recog.base.set_state(284);
                recog.import_term()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_as ----------------
pub type Import_asContextAll<'input> = Import_asContext<'input>;

pub type Import_asContext<'input> = BaseParserRuleContext<'input, Import_asContextExt<'input>>;

#[derive(Clone)]
pub struct Import_asContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_asContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_asContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_as(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_as(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_asContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_as(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_asContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_as
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_as }
}
antlr_rust::tid! {Import_asContextExt<'a>}

impl<'input> Import_asContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_asContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_asContextExt { ph: PhantomData }))
    }
}

pub trait Import_asContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Import_asContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
}

impl<'input> Import_asContextAttrs<'input> for Import_asContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_as(&mut self) -> Result<Rc<Import_asContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_asContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_import_as);
        let mut _localctx: Rc<Import_asContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(286);
                recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                recog.base.set_state(288);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AT || _la == OP_HASH {
                    {
                        recog.base.set_state(287);
                        _la = recog.base.input.la(1);
                        if { !(_la == OP_AT || _la == OP_HASH) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                /* InvokeRule identifier */
                recog.base.set_state(290);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_term ----------------
pub type Import_termContextAll<'input> = Import_termContext<'input>;

pub type Import_termContext<'input> = BaseParserRuleContext<'input, Import_termContextExt<'input>>;

#[derive(Clone)]
pub struct Import_termContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_termContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_termContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_term(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_term(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_termContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_term(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_termContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_term
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_term }
}
antlr_rust::tid! {Import_termContextExt<'a>}

impl<'input> Import_termContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_termContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_termContextExt { ph: PhantomData }))
    }
}

pub trait Import_termContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_termContextExt<'input>>
{
    fn import_block(&self) -> Option<Rc<Import_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn import_name(&self) -> Option<Rc<Import_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn import_as(&self) -> Option<Rc<Import_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_termContextAttrs<'input> for Import_termContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_term(&mut self) -> Result<Rc<Import_termContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_termContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_import_term);
        let mut _localctx: Rc<Import_termContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(331);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(14, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule import_block */
                        recog.base.set_state(292);
                        recog.import_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(293);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(294);
                        recog.import_name()?;

                        recog.base.set_state(296);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(295);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(298);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(299);
                        recog.import_name()?;

                        recog.base.set_state(304);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(7, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(301);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(300);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(303);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(306);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(307);
                        recog.import_name()?;

                        recog.base.set_state(309);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(308);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(311);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(312);
                        recog.import_name()?;

                        recog.base.set_state(317);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(10, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(314);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(313);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(316);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(319);
                        recog.import_name()?;

                        recog.base.set_state(321);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(320);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(323);
                        recog.import_name()?;

                        recog.base.set_state(328);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(13, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(325);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(324);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(327);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(330);
                        recog.eos_free()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_name ----------------
pub type Import_nameContextAll<'input> = Import_nameContext<'input>;

pub type Import_nameContext<'input> = BaseParserRuleContext<'input, Import_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Import_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_name }
}
antlr_rust::tid! {Import_nameContextExt<'a>}

impl<'input> Import_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_nameContextExt { ph: PhantomData }))
    }
}

pub trait Import_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_nameContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Import_nameContextAttrs<'input> for Import_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_name(&mut self) -> Result<Rc<Import_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_import_name);
        let mut _localctx: Rc<Import_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(333);
                recog.identifier()?;

                recog.base.set_state(338);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(15, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(334);
                                _la = recog.base.input.la(1);
                                if { !(_la == DOT || _la == OP_PROPORTION) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                }
                                else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /* InvokeRule identifier */
                                recog.base.set_state(335);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(340);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(15, &mut recog.base)?;
                }
                {
                    recog.base.set_state(341);
                    _la = recog.base.input.la(1);
                    if { !(_la == DOT || _la == OP_PROPORTION) } {
                        recog.err_handler.recover_inline(&mut recog.base)?;
                    }
                    else {
                        if recog.base.input.la(1) == TOKEN_EOF {
                            recog.base.matched_eof = true
                        };
                        recog.err_handler.report_match(&mut recog.base);
                        recog.base.consume(&mut recog.err_handler);
                    }
                    {
                        recog.base.set_state(342);
                        recog.base.match_token(OP_MUL, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_block ----------------
pub type Import_blockContextAll<'input> = Import_blockContext<'input>;

pub type Import_blockContext<'input> = BaseParserRuleContext<'input, Import_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Import_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_block }
}
antlr_rust::tid! {Import_blockContextExt<'a>}

impl<'input> Import_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_blockContextExt { ph: PhantomData }))
    }
}

pub trait Import_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn import_term_all(&self) -> Vec<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn import_term(&self, i: usize) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Import_blockContextAttrs<'input> for Import_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_block(&mut self) -> Result<Rc<Import_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_import_block);
        let mut _localctx: Rc<Import_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(354);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(17, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(344);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(345);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(346);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(350);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << BRACE_L))) != 0)
                            || _la == OP_AT
                            || _la == OP_HASH
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                {
                                    /* InvokeRule import_term */
                                    recog.base.set_state(347);
                                    recog.import_term()?;
                                }
                            }
                            recog.base.set_state(352);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(353);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extension ----------------
pub type Define_extensionContextAll<'input> = Define_extensionContext<'input>;

pub type Define_extensionContext<'input> = BaseParserRuleContext<'input, Define_extensionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extensionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extensionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extensionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extension(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extension(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extensionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extension(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extensionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extension
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extension }
}
antlr_rust::tid! {Define_extensionContextExt<'a>}

impl<'input> Define_extensionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extensionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extensionContextExt { ph: PhantomData }))
    }
}

pub trait Define_extensionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extensionContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_EXTENSION
    /// Returns `None` if there is no child corresponding to token KW_EXTENSION
    fn KW_EXTENSION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENSION, 0)
    }
}

impl<'input> Define_extensionContextAttrs<'input> for Define_extensionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extension(&mut self) -> Result<Rc<Define_extensionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extensionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_define_extension);
        let mut _localctx: Rc<Define_extensionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(356);
                recog.base.match_token(KW_EXTENSION, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_class ----------------
pub type Define_classContextAll<'input> = Define_classContext<'input>;

pub type Define_classContext<'input> = BaseParserRuleContext<'input, Define_classContextExt<'input>>;

#[derive(Clone)]
pub struct Define_classContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_classContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_classContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_class(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_class(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_classContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_class(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_classContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_class
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_class }
}
antlr_rust::tid! {Define_classContextExt<'a>}

impl<'input> Define_classContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_classContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_classContextExt { ph: PhantomData }))
    }
}

pub trait Define_classContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_classContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CLASS
    /// Returns `None` if there is no child corresponding to token KW_CLASS
    fn KW_CLASS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CLASS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_classContextAttrs<'input> for Define_classContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_class(&mut self) -> Result<Rc<Define_classContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_classContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_define_class);
        let mut _localctx: Rc<Define_classContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(359);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(18, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(358);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(364);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(361);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(366);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(367);
                recog.modifiers()?;

                recog.base.set_state(368);
                recog.base.match_token(KW_CLASS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(369);
                recog.identifier()?;

                recog.base.set_state(371);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 5) & !0x3f) == 0
                    && ((1usize << (_la - 5))
                        & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                        != 0)
                {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(370);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(374);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(373);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(377);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(376);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(379);
                recog.class_block()?;

                recog.base.set_state(381);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(23, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(380);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_block ----------------
pub type Class_blockContextAll<'input> = Class_blockContext<'input>;

pub type Class_blockContext<'input> = BaseParserRuleContext<'input, Class_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Class_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_block }
}
antlr_rust::tid! {Class_blockContextExt<'a>}

impl<'input> Class_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_blockContextExt { ph: PhantomData }))
    }
}

pub trait Class_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_dsl_all(&self) -> Vec<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_dsl(&self, i: usize) -> Option<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_blockContextAttrs<'input> for Class_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_block(&mut self) -> Result<Rc<Class_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_class_block);
        let mut _localctx: Rc<Class_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(383);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(390);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(388);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(24, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_dsl */
                                    recog.base.set_state(384);
                                    recog.class_dsl()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(385);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(386);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(387);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(392);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(393);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit ----------------
pub type Class_inheritContextAll<'input> = Class_inheritContext<'input>;

pub type Class_inheritContext<'input> = BaseParserRuleContext<'input, Class_inheritContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inheritContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inheritContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inheritContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inheritContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inheritContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit }
}
antlr_rust::tid! {Class_inheritContextExt<'a>}

impl<'input> Class_inheritContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inheritContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inheritContextExt { ph: PhantomData }))
    }
}

pub trait Class_inheritContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inheritContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn class_inherit_item_all(&self) -> Vec<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_inherit_item(&self, i: usize) -> Option<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Class_inheritContextAttrs<'input> for Class_inheritContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit(&mut self) -> Result<Rc<Class_inheritContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inheritContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_class_inherit);
        let mut _localctx: Rc<Class_inheritContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(411);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(28, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(395);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(396);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(397);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule class_inherit_item */
                        recog.base.set_state(398);
                        recog.class_inherit_item()?;

                        recog.base.set_state(403);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(26, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(399);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule class_inherit_item */
                                        recog.base.set_state(400);
                                        recog.class_inherit_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(405);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(26, &mut recog.base)?;
                        }
                        recog.base.set_state(407);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(406);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(409);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit_item ----------------
pub type Class_inherit_itemContextAll<'input> = Class_inherit_itemContext<'input>;

pub type Class_inherit_itemContext<'input> = BaseParserRuleContext<'input, Class_inherit_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inherit_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inherit_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inherit_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit_item }
}
antlr_rust::tid! {Class_inherit_itemContextExt<'a>}

impl<'input> Class_inherit_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inherit_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inherit_itemContextExt { ph: PhantomData }))
    }
}

pub trait Class_inherit_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inherit_itemContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_inherit_itemContextAttrs<'input> for Class_inherit_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit_item(&mut self) -> Result<Rc<Class_inherit_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inherit_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_class_inherit_item);
        let mut _localctx: Rc<Class_inherit_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_namepath */
                recog.base.set_state(413);
                recog.modified_namepath()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_field ----------------
pub type Class_fieldContextAll<'input> = Class_fieldContext<'input>;

pub type Class_fieldContext<'input> = BaseParserRuleContext<'input, Class_fieldContextExt<'input>>;

#[derive(Clone)]
pub struct Class_fieldContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_fieldContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_fieldContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_field(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_field(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_fieldContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_field(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_fieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_field
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_field }
}
antlr_rust::tid! {Class_fieldContextExt<'a>}

impl<'input> Class_fieldContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_fieldContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_fieldContextExt { ph: PhantomData }))
    }
}

pub trait Class_fieldContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_fieldContextExt<'input>>
{
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_fieldContextAttrs<'input> for Class_fieldContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_field(&mut self) -> Result<Rc<Class_fieldContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_fieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_class_field);
        let mut _localctx: Rc<Class_fieldContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(418);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(415);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(420);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(421);
                recog.modified_identifier()?;

                recog.base.set_state(423);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(422);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(426);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        /* InvokeRule parameter_default */
                        recog.base.set_state(425);
                        recog.parameter_default()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_method ----------------
pub type Class_methodContextAll<'input> = Class_methodContext<'input>;

pub type Class_methodContext<'input> = BaseParserRuleContext<'input, Class_methodContextExt<'input>>;

#[derive(Clone)]
pub struct Class_methodContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_methodContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_methodContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_method(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_method(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_methodContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_method(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_methodContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_method
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_method }
}
antlr_rust::tid! {Class_methodContextExt<'a>}

impl<'input> Class_methodContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_methodContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_methodContextExt { ph: PhantomData }))
    }
}

pub trait Class_methodContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_methodContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn effect_hint(&self) -> Option<Rc<Effect_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_methodContextAttrs<'input> for Class_methodContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_method(&mut self) -> Result<Rc<Class_methodContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_methodContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_class_method);
        let mut _localctx: Rc<Class_methodContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(431);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(428);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(433);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_namepath */
                recog.base.set_state(434);
                recog.modified_namepath()?;

                recog.base.set_state(436);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 5) & !0x3f) == 0
                    && ((1usize << (_la - 5))
                        & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                        != 0)
                {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(435);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(438);
                recog.function_parameters()?;

                recog.base.set_state(440);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(439);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(443);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_DIV {
                    {
                        /* InvokeRule effect_hint */
                        recog.base.set_state(442);
                        recog.effect_hint()?;
                    }
                }

                recog.base.set_state(446);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule function_block */
                        recog.base.set_state(445);
                        recog.function_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_dsl ----------------
pub type Class_dslContextAll<'input> = Class_dslContext<'input>;

pub type Class_dslContext<'input> = BaseParserRuleContext<'input, Class_dslContextExt<'input>>;

#[derive(Clone)]
pub struct Class_dslContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_dslContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_dslContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_dsl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_dsl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_dslContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_dsl(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_dslContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_dsl
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_dsl }
}
antlr_rust::tid! {Class_dslContextExt<'a>}

impl<'input> Class_dslContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_dslContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_dslContextExt { ph: PhantomData }))
    }
}

pub trait Class_dslContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Class_dslContextExt<'input>> {
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_dslContextAttrs<'input> for Class_dslContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_dsl(&mut self) -> Result<Rc<Class_dslContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_dslContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_class_dsl);
        let mut _localctx: Rc<Class_dslContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(451);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(448);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(453);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(454);
                recog.modified_identifier()?;

                /* InvokeRule class_block */
                recog.base.set_state(455);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait ----------------
pub type Define_traitContextAll<'input> = Define_traitContext<'input>;

pub type Define_traitContext<'input> = BaseParserRuleContext<'input, Define_traitContextExt<'input>>;

#[derive(Clone)]
pub struct Define_traitContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_traitContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_traitContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_traitContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_traitContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait }
}
antlr_rust::tid! {Define_traitContextExt<'a>}

impl<'input> Define_traitContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_traitContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_traitContextExt { ph: PhantomData }))
    }
}

pub trait Define_traitContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_traitContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TRAIT
    /// Returns `None` if there is no child corresponding to token KW_TRAIT
    fn KW_TRAIT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRAIT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn trait_block(&self) -> Option<Rc<Trait_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn impliments(&self) -> Option<Rc<ImplimentsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_traitContextAttrs<'input> for Define_traitContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait(&mut self) -> Result<Rc<Define_traitContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_traitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_define_trait);
        let mut _localctx: Rc<Define_traitContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(458);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(38, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(457);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(463);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(460);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(465);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(466);
                recog.modifiers()?;

                recog.base.set_state(467);
                recog.base.match_token(KW_TRAIT, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(468);
                recog.identifier()?;

                recog.base.set_state(470);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 5) & !0x3f) == 0
                    && ((1usize << (_la - 5))
                        & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                        != 0)
                {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(469);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(473);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule impliments */
                        recog.base.set_state(472);
                        recog.impliments()?;
                    }
                }

                /* InvokeRule trait_block */
                recog.base.set_state(475);
                recog.trait_block()?;

                recog.base.set_state(477);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(42, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(476);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- trait_block ----------------
pub type Trait_blockContextAll<'input> = Trait_blockContext<'input>;

pub type Trait_blockContext<'input> = BaseParserRuleContext<'input, Trait_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Trait_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Trait_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Trait_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_trait_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_trait_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Trait_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_trait_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Trait_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_trait_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_trait_block }
}
antlr_rust::tid! {Trait_blockContextExt<'a>}

impl<'input> Trait_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Trait_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Trait_blockContextExt { ph: PhantomData }))
    }
}

pub trait Trait_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Trait_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_trait_type_all(&self) -> Vec<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait_type(&self, i: usize) -> Option<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Trait_blockContextAttrs<'input> for Trait_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn trait_block(&mut self) -> Result<Rc<Trait_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Trait_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_trait_block);
        let mut _localctx: Rc<Trait_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(479);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(486);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == KW_TYPE || _la == RAW_ID || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(484);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(43, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_trait_type */
                                    recog.base.set_state(480);
                                    recog.define_trait_type()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(481);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(482);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(483);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(488);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(489);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait_type ----------------
pub type Define_trait_typeContextAll<'input> = Define_trait_typeContext<'input>;

pub type Define_trait_typeContext<'input> = BaseParserRuleContext<'input, Define_trait_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_trait_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_trait_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_trait_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_trait_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_trait_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait_type }
}
antlr_rust::tid! {Define_trait_typeContextExt<'a>}

impl<'input> Define_trait_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_trait_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_trait_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_trait_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_trait_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_trait_typeContextAttrs<'input> for Define_trait_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait_type(&mut self) -> Result<Rc<Define_trait_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_trait_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_define_trait_type);
        let mut _localctx: Rc<Define_trait_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(491);
                recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(492);
                recog.identifier()?;

                recog.base.set_state(495);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(493);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(494);
                        recog.type_expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extends ----------------
pub type Define_extendsContextAll<'input> = Define_extendsContext<'input>;

pub type Define_extendsContext<'input> = BaseParserRuleContext<'input, Define_extendsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extendsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extendsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extendsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extends(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extends(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extendsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extends(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extendsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extends
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extends }
}
antlr_rust::tid! {Define_extendsContextExt<'a>}

impl<'input> Define_extendsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extendsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extendsContextExt { ph: PhantomData }))
    }
}

pub trait Define_extendsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extendsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_EXTENDS
    /// Returns `None` if there is no child corresponding to token KW_EXTENDS
    fn KW_EXTENDS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENDS, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn trait_block(&self) -> Option<Rc<Trait_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn impliments(&self) -> Option<Rc<ImplimentsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_extendsContextAttrs<'input> for Define_extendsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extends(&mut self) -> Result<Rc<Define_extendsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extendsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_define_extends);
        let mut _localctx: Rc<Define_extendsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(498);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(46, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(497);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(503);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(500);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(505);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(506);
                recog.modifiers()?;

                recog.base.set_state(507);
                recog.base.match_token(KW_EXTENDS, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(508);
                recog.namepath()?;

                recog.base.set_state(510);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 5) & !0x3f) == 0
                    && ((1usize << (_la - 5))
                        & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                        != 0)
                {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(509);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(513);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule impliments */
                        recog.base.set_state(512);
                        recog.impliments()?;
                    }
                }

                /* InvokeRule trait_block */
                recog.base.set_state(515);
                recog.trait_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- impliments ----------------
pub type ImplimentsContextAll<'input> = ImplimentsContext<'input>;

pub type ImplimentsContext<'input> = BaseParserRuleContext<'input, ImplimentsContextExt<'input>>;

#[derive(Clone)]
pub struct ImplimentsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ImplimentsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ImplimentsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_impliments(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_impliments(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ImplimentsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_impliments(self);
    }
}

impl<'input> CustomRuleContext<'input> for ImplimentsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_impliments
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_impliments }
}
antlr_rust::tid! {ImplimentsContextExt<'a>}

impl<'input> ImplimentsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ImplimentsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, ImplimentsContextExt { ph: PhantomData }))
    }
}

pub trait ImplimentsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ImplimentsContextExt<'input>> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IMPLEMENTS
    /// Returns `None` if there is no child corresponding to token KW_IMPLEMENTS
    fn KW_IMPLEMENTS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPLEMENTS, 0)
    }
}

impl<'input> ImplimentsContextAttrs<'input> for ImplimentsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn impliments(&mut self) -> Result<Rc<ImplimentsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ImplimentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_impliments);
        let mut _localctx: Rc<ImplimentsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(517);
                _la = recog.base.input.la(1);
                if { !(_la == COLON || _la == KW_IMPLEMENTS) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                /* InvokeRule type_expression */
                recog.base.set_state(518);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_union ----------------
pub type Define_unionContextAll<'input> = Define_unionContext<'input>;

pub type Define_unionContext<'input> = BaseParserRuleContext<'input, Define_unionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_unionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_unionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_unionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_union(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_union(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_unionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_union(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_unionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_union
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_union }
}
antlr_rust::tid! {Define_unionContextExt<'a>}

impl<'input> Define_unionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_unionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_unionContextExt { ph: PhantomData }))
    }
}

pub trait Define_unionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_unionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_UNION
    /// Returns `None` if there is no child corresponding to token KW_UNION
    fn KW_UNION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_UNION, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn union_block(&self) -> Option<Rc<Union_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_unionContextAttrs<'input> for Define_unionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_union(&mut self) -> Result<Rc<Define_unionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_unionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_define_union);
        let mut _localctx: Rc<Define_unionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(523);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(520);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(525);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(526);
                recog.modifiers()?;

                recog.base.set_state(527);
                recog.base.match_token(KW_UNION, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(528);
                recog.identifier()?;

                recog.base.set_state(530);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(529);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(533);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(532);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule union_block */
                recog.base.set_state(535);
                recog.union_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- base_layout ----------------
pub type Base_layoutContextAll<'input> = Base_layoutContext<'input>;

pub type Base_layoutContext<'input> = BaseParserRuleContext<'input, Base_layoutContextExt<'input>>;

#[derive(Clone)]
pub struct Base_layoutContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Base_layoutContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Base_layoutContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_base_layout(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_base_layout(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Base_layoutContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_base_layout(self);
    }
}

impl<'input> CustomRuleContext<'input> for Base_layoutContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_base_layout
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_base_layout }
}
antlr_rust::tid! {Base_layoutContextExt<'a>}

impl<'input> Base_layoutContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Base_layoutContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Base_layoutContextExt { ph: PhantomData }))
    }
}

pub trait Base_layoutContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Base_layoutContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Base_layoutContextAttrs<'input> for Base_layoutContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn base_layout(&mut self) -> Result<Rc<Base_layoutContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Base_layoutContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_base_layout);
        let mut _localctx: Rc<Base_layoutContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(537);
                recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                recog.base.set_state(539);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L
                    || (((_la - 116) & !0x3f) == 0
                        && ((1usize << (_la - 116))
                            & ((1usize << (INTEGER - 116))
                                | (1usize << (DECIMAL - 116))
                                | (1usize << (STRING_SINGLE - 116))
                                | (1usize << (STRING_DOUBLE - 116))
                                | (1usize << (STRING_BLOCK - 116))
                                | (1usize << (SPECIAL - 116))
                                | (1usize << (RAW_ID - 116))
                                | (1usize << (UNICODE_ID - 116))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(538);
                        recog.type_expression_rec(0)?;
                    }
                }

                recog.base.set_state(541);
                recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- union_block ----------------
pub type Union_blockContextAll<'input> = Union_blockContext<'input>;

pub type Union_blockContext<'input> = BaseParserRuleContext<'input, Union_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Union_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Union_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Union_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_union_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_union_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Union_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_union_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Union_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_union_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_union_block }
}
antlr_rust::tid! {Union_blockContextExt<'a>}

impl<'input> Union_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Union_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Union_blockContextExt { ph: PhantomData }))
    }
}

pub trait Union_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Union_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_variant_all(&self) -> Vec<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_variant(&self, i: usize) -> Option<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Union_blockContextAttrs<'input> for Union_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn union_block(&mut self) -> Result<Rc<Union_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Union_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_union_block);
        let mut _localctx: Rc<Union_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(543);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(549);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(547);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(54, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(544);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule define_variant */
                                    recog.base.set_state(545);
                                    recog.define_variant()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(546);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(551);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(552);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_variant ----------------
pub type Define_variantContextAll<'input> = Define_variantContext<'input>;

pub type Define_variantContext<'input> = BaseParserRuleContext<'input, Define_variantContextExt<'input>>;

#[derive(Clone)]
pub struct Define_variantContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_variantContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_variantContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_variant(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_variant(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_variantContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_variant(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_variantContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_variant
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_variant }
}
antlr_rust::tid! {Define_variantContextExt<'a>}

impl<'input> Define_variantContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_variantContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_variantContextExt { ph: PhantomData }))
    }
}

pub trait Define_variantContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_variantContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn variant_block(&self) -> Option<Rc<Variant_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_variantContextAttrs<'input> for Define_variantContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_variant(&mut self) -> Result<Rc<Define_variantContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_variantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_define_variant);
        let mut _localctx: Rc<Define_variantContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(554);
                recog.identifier()?;

                recog.base.set_state(556);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule variant_block */
                        recog.base.set_state(555);
                        recog.variant_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- variant_block ----------------
pub type Variant_blockContextAll<'input> = Variant_blockContext<'input>;

pub type Variant_blockContext<'input> = BaseParserRuleContext<'input, Variant_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Variant_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Variant_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Variant_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_variant_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_variant_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Variant_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_variant_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Variant_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_variant_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_variant_block }
}
antlr_rust::tid! {Variant_blockContextExt<'a>}

impl<'input> Variant_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Variant_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Variant_blockContextExt { ph: PhantomData }))
    }
}

pub trait Variant_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Variant_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Variant_blockContextAttrs<'input> for Variant_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn variant_block(&mut self) -> Result<Rc<Variant_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Variant_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_variant_block);
        let mut _localctx: Rc<Variant_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(558);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(563);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(561);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_HASH | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(559);
                                    recog.class_field()?;
                                }
                            }

                            COMMA | SEMICOLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(560);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(565);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(566);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_bitflags ----------------
pub type Define_bitflagsContextAll<'input> = Define_bitflagsContext<'input>;

pub type Define_bitflagsContext<'input> = BaseParserRuleContext<'input, Define_bitflagsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_bitflagsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_bitflagsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_bitflagsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_bitflags(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_bitflags(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_bitflagsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_bitflags(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_bitflagsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_bitflags
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_bitflags }
}
antlr_rust::tid! {Define_bitflagsContextExt<'a>}

impl<'input> Define_bitflagsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_bitflagsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_bitflagsContextExt { ph: PhantomData }))
    }
}

pub trait Define_bitflagsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_bitflagsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_BITFLAGS
    /// Returns `None` if there is no child corresponding to token KW_BITFLAGS
    fn KW_BITFLAGS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_BITFLAGS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn bitflags_block(&self) -> Option<Rc<Bitflags_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_bitflagsContextAttrs<'input> for Define_bitflagsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_bitflags(&mut self) -> Result<Rc<Define_bitflagsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_bitflagsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_define_bitflags);
        let mut _localctx: Rc<Define_bitflagsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(571);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(568);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(573);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(574);
                recog.modifiers()?;

                recog.base.set_state(575);
                recog.base.match_token(KW_BITFLAGS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(576);
                recog.identifier()?;

                recog.base.set_state(578);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(577);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(581);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(580);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule bitflags_block */
                recog.base.set_state(583);
                recog.bitflags_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_block ----------------
pub type Bitflags_blockContextAll<'input> = Bitflags_blockContext<'input>;

pub type Bitflags_blockContext<'input> = BaseParserRuleContext<'input, Bitflags_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_block }
}
antlr_rust::tid! {Bitflags_blockContextExt<'a>}

impl<'input> Bitflags_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_blockContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn bitflags_item_all(&self) -> Vec<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn bitflags_item(&self, i: usize) -> Option<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Bitflags_blockContextAttrs<'input> for Bitflags_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_block(&mut self) -> Result<Rc<Bitflags_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_bitflags_block);
        let mut _localctx: Rc<Bitflags_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(585);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(591);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == OP_HASH || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        recog.base.set_state(589);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(62, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(586);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule bitflags_item */
                                    recog.base.set_state(587);
                                    recog.bitflags_item()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(588);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(593);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(594);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_item ----------------
pub type Bitflags_itemContextAll<'input> = Bitflags_itemContext<'input>;

pub type Bitflags_itemContext<'input> = BaseParserRuleContext<'input, Bitflags_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_item }
}
antlr_rust::tid! {Bitflags_itemContextExt<'a>}

impl<'input> Bitflags_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_itemContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_itemContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Bitflags_itemContextAttrs<'input> for Bitflags_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_item(&mut self) -> Result<Rc<Bitflags_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_bitflags_item);
        let mut _localctx: Rc<Bitflags_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(599);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(596);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(601);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule identifier */
                recog.base.set_state(602);
                recog.identifier()?;

                recog.base.set_state(605);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(603);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(604);
                        recog.expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_function ----------------
pub type Define_functionContextAll<'input> = Define_functionContext<'input>;

pub type Define_functionContext<'input> = BaseParserRuleContext<'input, Define_functionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_functionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_functionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_functionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_function(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_function(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_functionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_function(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_functionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_function
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_function }
}
antlr_rust::tid! {Define_functionContextExt<'a>}

impl<'input> Define_functionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_functionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_functionContextExt { ph: PhantomData }))
    }
}

pub trait Define_functionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_functionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_FUNCTION
    /// Returns `None` if there is no child corresponding to token KW_FUNCTION
    fn KW_FUNCTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FUNCTION, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn effect_hint(&self) -> Option<Rc<Effect_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_functionContextAttrs<'input> for Define_functionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_function(&mut self) -> Result<Rc<Define_functionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_functionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_define_function);
        let mut _localctx: Rc<Define_functionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(608);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(66, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(607);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(613);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(610);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(615);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(616);
                recog.modifiers()?;

                recog.base.set_state(617);
                recog.base.match_token(KW_FUNCTION, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(618);
                recog.namepath()?;

                recog.base.set_state(620);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 5) & !0x3f) == 0
                    && ((1usize << (_la - 5))
                        & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                        != 0)
                {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(619);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(622);
                recog.function_parameters()?;

                recog.base.set_state(624);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(623);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(627);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_DIV {
                    {
                        /* InvokeRule effect_hint */
                        recog.base.set_state(626);
                        recog.effect_hint()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(629);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_parameters ----------------
pub type Function_parametersContextAll<'input> = Function_parametersContext<'input>;

pub type Function_parametersContext<'input> = BaseParserRuleContext<'input, Function_parametersContextExt<'input>>;

#[derive(Clone)]
pub struct Function_parametersContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_parametersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_parametersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_parameters(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_parameters(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_parametersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_parameters(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_parametersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_parameters
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_parameters }
}
antlr_rust::tid! {Function_parametersContextExt<'a>}

impl<'input> Function_parametersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_parametersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Function_parametersContextExt { ph: PhantomData },
        ))
    }
}

pub trait Function_parametersContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_parametersContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn parameter_item_all(&self) -> Vec<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn parameter_item(&self, i: usize) -> Option<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Function_parametersContextAttrs<'input> for Function_parametersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_parameters(&mut self) -> Result<Rc<Function_parametersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_parametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_function_parameters);
        let mut _localctx: Rc<Function_parametersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(644);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(72, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(631);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(632);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(633);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule parameter_item */
                        recog.base.set_state(634);
                        recog.parameter_item()?;

                        recog.base.set_state(639);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(635);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule parameter_item */
                                    recog.base.set_state(636);
                                    recog.parameter_item()?;
                                }
                            }
                            recog.base.set_state(641);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(642);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_item ----------------
pub type Parameter_itemContextAll<'input> = Parameter_itemContext<'input>;

pub type Parameter_itemContext<'input> = BaseParserRuleContext<'input, Parameter_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_item }
}
antlr_rust::tid! {Parameter_itemContextExt<'a>}

impl<'input> Parameter_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Parameter_itemContextExt { ph: PhantomData }))
    }
}

pub trait Parameter_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_itemContextExt<'input>>
{
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Parameter_itemContextAttrs<'input> for Parameter_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_item(&mut self) -> Result<Rc<Parameter_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_parameter_item);
        let mut _localctx: Rc<Parameter_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(649);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(646);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(651);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(652);
                recog.modified_identifier()?;

                recog.base.set_state(654);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(653);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(657);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        /* InvokeRule parameter_default */
                        recog.base.set_state(656);
                        recog.parameter_default()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_default ----------------
pub type Parameter_defaultContextAll<'input> = Parameter_defaultContext<'input>;

pub type Parameter_defaultContext<'input> = BaseParserRuleContext<'input, Parameter_defaultContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_defaultContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_defaultContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_defaultContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_default(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_default(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_defaultContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_default(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_defaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_default
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_default }
}
antlr_rust::tid! {Parameter_defaultContextExt<'a>}

impl<'input> Parameter_defaultContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_defaultContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Parameter_defaultContextExt { ph: PhantomData }))
    }
}

pub trait Parameter_defaultContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_defaultContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Parameter_defaultContextAttrs<'input> for Parameter_defaultContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_default(&mut self) -> Result<Rc<Parameter_defaultContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_defaultContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_parameter_default);
        let mut _localctx: Rc<Parameter_defaultContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(659);
                recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                /* InvokeRule expression */
                recog.base.set_state(660);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_call ----------------
pub type Function_callContextAll<'input> = Function_callContext<'input>;

pub type Function_callContext<'input> = BaseParserRuleContext<'input, Function_callContextExt<'input>>;

#[derive(Clone)]
pub struct Function_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_call }
}
antlr_rust::tid! {Function_callContextExt<'a>}

impl<'input> Function_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_callContextExt { ph: PhantomData }))
    }
}

pub trait Function_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_callContextExt<'input>>
{
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
}

impl<'input> Function_callContextAttrs<'input> for Function_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_call(&mut self) -> Result<Rc<Function_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_function_call);
        let mut _localctx: Rc<Function_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(663);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(662);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule tuple_call_body */
                recog.base.set_state(665);
                recog.tuple_call_body()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- dot_call ----------------
pub type Dot_callContextAll<'input> = Dot_callContext<'input>;

pub type Dot_callContext<'input> = BaseParserRuleContext<'input, Dot_callContextExt<'input>>;

#[derive(Clone)]
pub struct Dot_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Dot_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Dot_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_dot_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_dot_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Dot_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_dot_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Dot_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_dot_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_dot_call }
}
antlr_rust::tid! {Dot_callContextExt<'a>}

impl<'input> Dot_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Dot_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Dot_callContextExt { ph: PhantomData }))
    }
}

pub trait Dot_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Dot_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
}

impl<'input> Dot_callContextAttrs<'input> for Dot_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn dot_call(&mut self) -> Result<Rc<Dot_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Dot_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_dot_call);
        let mut _localctx: Rc<Dot_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(686);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(82, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(668);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_THROW {
                            {
                                recog.base.set_state(667);
                                recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(670);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        /* InvokeRule namepath */
                        recog.base.set_state(671);
                        recog.namepath()?;

                        recog.base.set_state(673);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(78, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(672);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(676);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_THROW {
                            {
                                recog.base.set_state(675);
                                recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(678);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(680);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AT {
                            {
                                recog.base.set_state(679);
                                recog.base.match_token(OP_AT, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule namepath */
                        recog.base.set_state(682);
                        recog.namepath()?;

                        recog.base.set_state(684);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(81, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(683);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_body ----------------
pub type Tuple_call_bodyContextAll<'input> = Tuple_call_bodyContext<'input>;

pub type Tuple_call_bodyContext<'input> = BaseParserRuleContext<'input, Tuple_call_bodyContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_bodyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_body(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_body(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_body(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_bodyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_body
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_body }
}
antlr_rust::tid! {Tuple_call_bodyContextExt<'a>}

impl<'input> Tuple_call_bodyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_bodyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_call_bodyContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_call_bodyContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_bodyContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn tuple_call_item_all(&self) -> Vec<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tuple_call_item(&self, i: usize) -> Option<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Tuple_call_bodyContextAttrs<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_body(&mut self) -> Result<Rc<Tuple_call_bodyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_bodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_tuple_call_body);
        let mut _localctx: Rc<Tuple_call_bodyContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(704);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(85, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(688);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(689);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(690);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule tuple_call_item */
                        recog.base.set_state(691);
                        recog.tuple_call_item()?;

                        recog.base.set_state(696);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(83, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(692);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule tuple_call_item */
                                        recog.base.set_state(693);
                                        recog.tuple_call_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(698);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(83, &mut recog.base)?;
                        }
                        recog.base.set_state(700);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(699);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(702);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_item ----------------
pub type Tuple_call_itemContextAll<'input> = Tuple_call_itemContext<'input>;

pub type Tuple_call_itemContext<'input> = BaseParserRuleContext<'input, Tuple_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_item }
}
antlr_rust::tid! {Tuple_call_itemContextExt<'a>}

impl<'input> Tuple_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_call_itemContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_itemContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Tuple_call_itemContextAttrs<'input> for Tuple_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_item(&mut self) -> Result<Rc<Tuple_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_tuple_call_item);
        let mut _localctx: Rc<Tuple_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(711);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(86, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(706);
                        recog.identifier()?;

                        recog.base.set_state(707);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(708);
                        recog.expression_rec(0)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(710);
                        recog.expression_rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_lambda ----------------
pub type Define_lambdaContextAll<'input> = Define_lambdaContext<'input>;

pub type Define_lambdaContext<'input> = BaseParserRuleContext<'input, Define_lambdaContextExt<'input>>;

#[derive(Clone)]
pub struct Define_lambdaContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_lambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_lambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_lambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_lambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_lambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_lambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_lambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_lambda
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_lambda }
}
antlr_rust::tid! {Define_lambdaContextExt<'a>}

impl<'input> Define_lambdaContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_lambdaContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_lambdaContextExt { ph: PhantomData }))
    }
}

pub trait Define_lambdaContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_lambdaContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LAMBDA
    /// Returns `None` if there is no child corresponding to token KW_LAMBDA
    fn KW_LAMBDA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LAMBDA, 0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_lambdaContextAttrs<'input> for Define_lambdaContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_lambda(&mut self) -> Result<Rc<Define_lambdaContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_lambdaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_define_lambda);
        let mut _localctx: Rc<Define_lambdaContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(716);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(713);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(718);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(719);
                recog.base.match_token(KW_LAMBDA, &mut recog.err_handler)?;

                /* InvokeRule function_parameters */
                recog.base.set_state(720);
                recog.function_parameters()?;

                recog.base.set_state(722);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(721);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(724);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- lambda_call ----------------
pub type Lambda_callContextAll<'input> = Lambda_callContext<'input>;

pub type Lambda_callContext<'input> = BaseParserRuleContext<'input, Lambda_callContextExt<'input>>;

#[derive(Clone)]
pub struct Lambda_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Lambda_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Lambda_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lambda_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_lambda_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Lambda_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_lambda_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Lambda_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_lambda_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_lambda_call }
}
antlr_rust::tid! {Lambda_callContextExt<'a>}

impl<'input> Lambda_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Lambda_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Lambda_callContextExt { ph: PhantomData }))
    }
}

pub trait Lambda_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Lambda_callContextExt<'input>>
{
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
}

impl<'input> Lambda_callContextAttrs<'input> for Lambda_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn lambda_call(&mut self) -> Result<Rc<Lambda_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Lambda_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_lambda_call);
        let mut _localctx: Rc<Lambda_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(727);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(726);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(729);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_block ----------------
pub type Function_blockContextAll<'input> = Function_blockContext<'input>;

pub type Function_blockContext<'input> = BaseParserRuleContext<'input, Function_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Function_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_block }
}
antlr_rust::tid! {Function_blockContextExt<'a>}

impl<'input> Function_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_blockContextExt { ph: PhantomData }))
    }
}

pub trait Function_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn function_statements_all(&self) -> Vec<Rc<Function_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn function_statements(&self, i: usize) -> Option<Rc<Function_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Function_blockContextAttrs<'input> for Function_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_block(&mut self) -> Result<Rc<Function_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_function_block);
        let mut _localctx: Rc<Function_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(731);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(735);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << SEMICOLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 57) & !0x3f) == 0
                        && ((1usize << (_la - 57))
                            & ((1usize << (OP_AND - 57))
                                | (1usize << (OP_AT - 57))
                                | (1usize << (OP_HASH - 57))
                                | (1usize << (LAMBDA_SLOT - 57))
                                | (1usize << (OP_THROW - 57))
                                | (1usize << (OP_NOT - 57))
                                | (1usize << (OP_DECONSTRUCT - 57))
                                | (1usize << (OP_INVERSE - 57))
                                | (1usize << (OP_ROOTS - 57))
                                | (1usize << (OP_REFERENCE - 57))))
                            != 0)
                    || (((_la - 89) & !0x3f) == 0
                        && ((1usize << (_la - 89))
                            & ((1usize << (OP_LABEL - 89))
                                | (1usize << (KW_WHILE - 89))
                                | (1usize << (KW_FOR - 89))
                                | (1usize << (KW_LET - 89))
                                | (1usize << (KW_NEW - 89))
                                | (1usize << (KW_OBJECT - 89))
                                | (1usize << (KW_LAMBDA - 89))
                                | (1usize << (KW_TRY - 89))
                                | (1usize << (KW_MATCH - 89))
                                | (1usize << (KW_CATCH - 89))
                                | (1usize << (INTEGER - 89))
                                | (1usize << (DECIMAL - 89))
                                | (1usize << (STRING_SINGLE - 89))
                                | (1usize << (STRING_DOUBLE - 89))
                                | (1usize << (STRING_BLOCK - 89))))
                            != 0)
                    || (((_la - 121) & !0x3f) == 0
                        && ((1usize << (_la - 121))
                            & ((1usize << (KW_IF - 121))
                                | (1usize << (RETURN - 121))
                                | (1usize << (RESUME - 121))
                                | (1usize << (YIELD - 121))
                                | (1usize << (BREAK - 121))
                                | (1usize << (CONTINUE - 121))
                                | (1usize << (RAISE - 121))
                                | (1usize << (SPECIAL - 121))
                                | (1usize << (RAW_ID - 121))
                                | (1usize << (UNICODE_ID - 121))))
                            != 0)
                {
                    {
                        {
                            /* InvokeRule function_statements */
                            recog.base.set_state(732);
                            recog.function_statements()?;
                        }
                    }
                    recog.base.set_state(737);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(738);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_variale ----------------
pub type Define_varialeContextAll<'input> = Define_varialeContext<'input>;

pub type Define_varialeContext<'input> = BaseParserRuleContext<'input, Define_varialeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_varialeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_varialeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_varialeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_variale(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_variale(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_varialeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_variale(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_varialeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_variale
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_variale }
}
antlr_rust::tid! {Define_varialeContextExt<'a>}

impl<'input> Define_varialeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_varialeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_varialeContextExt { ph: PhantomData }))
    }
}

pub trait Define_varialeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_varialeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_varialeContextAttrs<'input> for Define_varialeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_variale(&mut self) -> Result<Rc<Define_varialeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_varialeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_define_variale);
        let mut _localctx: Rc<Define_varialeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(740);
                recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                /* InvokeRule let_pattern */
                recog.base.set_state(741);
                recog.let_pattern()?;

                recog.base.set_state(743);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(742);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(747);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(745);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(746);
                        recog.expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern ----------------
pub type Let_patternContextAll<'input> = Let_patternContext<'input>;

pub type Let_patternContext<'input> = BaseParserRuleContext<'input, Let_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Let_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern }
}
antlr_rust::tid! {Let_patternContextExt<'a>}

impl<'input> Let_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_patternContextExt { ph: PhantomData }))
    }
}

pub trait Let_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_patternContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_plain(&self) -> Option<Rc<Let_pattern_plainContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Let_patternContextAttrs<'input> for Let_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern(&mut self) -> Result<Rc<Let_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_let_pattern);
        let mut _localctx: Rc<Let_patternContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(751);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(93, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(749);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule let_pattern_plain */
                        recog.base.set_state(750);
                        recog.let_pattern_plain()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_plain ----------------
pub type Let_pattern_plainContextAll<'input> = Let_pattern_plainContext<'input>;

pub type Let_pattern_plainContext<'input> = BaseParserRuleContext<'input, Let_pattern_plainContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_plainContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_plainContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_plain(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_plain(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_plain(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_plainContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_plain
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_plain }
}
antlr_rust::tid! {Let_pattern_plainContextExt<'a>}

impl<'input> Let_pattern_plainContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_plainContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_plainContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_plainContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_plainContextExt<'input>>
{
    fn modified_identifier_all(&self) -> Vec<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn modified_identifier(&self, i: usize) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Let_pattern_plainContextAttrs<'input> for Let_pattern_plainContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_plain(&mut self) -> Result<Rc<Let_pattern_plainContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_plainContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_let_pattern_plain);
        let mut _localctx: Rc<Let_pattern_plainContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_identifier */
                recog.base.set_state(753);
                recog.modified_identifier()?;

                recog.base.set_state(758);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(94, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(754);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                /* InvokeRule modified_identifier */
                                recog.base.set_state(755);
                                recog.modified_identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(760);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(94, &mut recog.base)?;
                }
                recog.base.set_state(762);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COMMA {
                    {
                        recog.base.set_state(761);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_tuple ----------------
pub type Let_pattern_tupleContextAll<'input> = Let_pattern_tupleContext<'input>;

pub type Let_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Let_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_tuple }
}
antlr_rust::tid! {Let_pattern_tupleContextExt<'a>}

impl<'input> Let_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn let_pattern_item_all(&self) -> Vec<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_pattern_item(&self, i: usize) -> Option<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
}

impl<'input> Let_pattern_tupleContextAttrs<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_tuple(&mut self) -> Result<Rc<Let_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_let_pattern_tuple);
        let mut _localctx: Rc<Let_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(834);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(110, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(764);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(778);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(98, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(765);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(766);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                }
                            }

                            x if x == 2 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(768);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(771);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = 1;
                                    loop {
                                        match _alt {
                                            x if x == 1 => {
                                                {
                                                    recog.base.set_state(769);
                                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                    /* InvokeRule let_pattern_item */
                                                    recog.base.set_state(770);
                                                    recog.let_pattern_item()?;
                                                }
                                            }

                                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                        }
                                        recog.base.set_state(773);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = recog.interpreter.adaptive_predict(96, &mut recog.base)?;
                                        if _alt == 2 || _alt == INVALID_ALT {
                                            break;
                                        }
                                    }
                                    recog.base.set_state(776);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == COMMA {
                                        {
                                            recog.base.set_state(775);
                                            recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                        }
                                    }
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(780);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(781);
                        recog.namepath()?;

                        recog.base.set_state(782);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(794);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DECONSTRUCT
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(783);
                                recog.let_pattern_item()?;

                                recog.base.set_state(788);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(99, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(784);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(785);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(790);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(99, &mut recog.base)?;
                                }
                                recog.base.set_state(792);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(791);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(796);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(799);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(798);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(801);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(813);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DECONSTRUCT
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(802);
                                recog.let_pattern_item()?;

                                recog.base.set_state(807);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(103, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(803);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(804);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(809);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(103, &mut recog.base)?;
                                }
                                recog.base.set_state(811);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(810);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(815);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(817);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(816);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(819);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(831);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DECONSTRUCT
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(820);
                                recog.let_pattern_item()?;

                                recog.base.set_state(825);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(107, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(821);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(822);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(827);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(107, &mut recog.base)?;
                                }
                                recog.base.set_state(829);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(828);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(833);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_item ----------------
pub type Let_pattern_itemContextAll<'input> = Let_pattern_itemContext<'input>;

pub type Let_pattern_itemContext<'input> = BaseParserRuleContext<'input, Let_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_item }
}
antlr_rust::tid! {Let_pattern_itemContextExt<'a>}

impl<'input> Let_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Let_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Let_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_itemContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DECONSTRUCT
    /// Returns `None` if there is no child corresponding to token OP_DECONSTRUCT
    fn OP_DECONSTRUCT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DECONSTRUCT, 0)
    }
}

impl<'input> Let_pattern_itemContextAttrs<'input> for Let_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_item(&mut self) -> Result<Rc<Let_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_let_pattern_item);
        let mut _localctx: Rc<Let_pattern_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(866);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(117, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(839);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(111, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(836);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(837);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(844);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(112, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(841);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(842);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(846);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(850);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(113, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(847);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(848);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(855);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(114, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(852);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(853);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule identifier */
                        recog.base.set_state(857);
                        recog.identifier()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(859);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule modified_identifier */
                                recog.base.set_state(858);
                                recog.modified_identifier()?;
                            }
                        }

                        recog.base.set_state(861);
                        recog.base.match_token(OP_DECONSTRUCT, &mut recog.err_handler)?;

                        recog.base.set_state(863);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(862);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());
                            }
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(865);
                        recog.modified_identifier()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_type ----------------
pub type Define_typeContextAll<'input> = Define_typeContext<'input>;

pub type Define_typeContext<'input> = BaseParserRuleContext<'input, Define_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_type }
}
antlr_rust::tid! {Define_typeContextExt<'a>}

impl<'input> Define_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
}

impl<'input> Define_typeContextAttrs<'input> for Define_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_type(&mut self) -> Result<Rc<Define_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_define_type);
        let mut _localctx: Rc<Define_typeContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(868);
                recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(869);
                recog.identifier()?;

                recog.base.set_state(870);
                recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(871);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- type_hint ----------------
pub type Type_hintContextAll<'input> = Type_hintContext<'input>;

pub type Type_hintContext<'input> = BaseParserRuleContext<'input, Type_hintContextExt<'input>>;

#[derive(Clone)]
pub struct Type_hintContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_hintContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_hintContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_type_hint(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_type_hint(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_hintContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_type_hint(self);
    }
}

impl<'input> CustomRuleContext<'input> for Type_hintContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_hint
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_hint }
}
antlr_rust::tid! {Type_hintContextExt<'a>}

impl<'input> Type_hintContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_hintContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Type_hintContextExt { ph: PhantomData }))
    }
}

pub trait Type_hintContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Type_hintContextExt<'input>> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
}

impl<'input> Type_hintContextAttrs<'input> for Type_hintContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_hint(&mut self) -> Result<Rc<Type_hintContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Type_hintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_type_hint);
        let mut _localctx: Rc<Type_hintContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(873);
                _la = recog.base.input.la(1);
                if { !(_la == COLON || _la == OP_ARROW) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                /* InvokeRule type_expression */
                recog.base.set_state(874);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- effect_hint ----------------
pub type Effect_hintContextAll<'input> = Effect_hintContext<'input>;

pub type Effect_hintContext<'input> = BaseParserRuleContext<'input, Effect_hintContextExt<'input>>;

#[derive(Clone)]
pub struct Effect_hintContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Effect_hintContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Effect_hintContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_effect_hint(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_effect_hint(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Effect_hintContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_effect_hint(self);
    }
}

impl<'input> CustomRuleContext<'input> for Effect_hintContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_effect_hint
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_effect_hint }
}
antlr_rust::tid! {Effect_hintContextExt<'a>}

impl<'input> Effect_hintContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Effect_hintContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Effect_hintContextExt { ph: PhantomData }))
    }
}

pub trait Effect_hintContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Effect_hintContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Effect_hintContextAttrs<'input> for Effect_hintContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn effect_hint(&mut self) -> Result<Rc<Effect_hintContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Effect_hintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_effect_hint);
        let mut _localctx: Rc<Effect_hintContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(876);
                recog.base.match_token(OP_DIV, &mut recog.err_handler)?;

                /* InvokeRule type_expression */
                recog.base.set_state(877);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_statement ----------------
#[derive(Debug)]
pub enum If_statementContextAll<'input> {
    IfFlowContext(IfFlowContext<'input>),
    IfGuardContext(IfGuardContext<'input>),
    Error(If_statementContext<'input>),
}
antlr_rust::tid! {If_statementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for If_statementContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for If_statementContextAll<'input> {}

impl<'input> Deref for If_statementContextAll<'input> {
    type Target = dyn If_statementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use If_statementContextAll::*;
        match self {
            IfFlowContext(inner) => inner,
            IfGuardContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_statementContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_statementContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type If_statementContext<'input> = BaseParserRuleContext<'input, If_statementContextExt<'input>>;

#[derive(Clone)]
pub struct If_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_statementContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_statementContext<'input> {}

impl<'input> CustomRuleContext<'input> for If_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_statement }
}
antlr_rust::tid! {If_statementContextExt<'a>}

impl<'input> If_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_statementContextAll<'input>> {
        Rc::new(If_statementContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            If_statementContextExt { ph: PhantomData },
        )))
    }
}

pub trait If_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<If_statementContextExt<'input>>
{
}

impl<'input> If_statementContextAttrs<'input> for If_statementContext<'input> {}

pub type IfFlowContext<'input> = BaseParserRuleContext<'input, IfFlowContextExt<'input>>;

pub trait IfFlowContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block_all(&self) -> Vec<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn function_block(&self, i: usize) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn else_if_statement_all(&self) -> Vec<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn else_if_statement(&self, i: usize) -> Option<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
}

impl<'input> IfFlowContextAttrs<'input> for IfFlowContext<'input> {}

pub struct IfFlowContextExt<'input> {
    base: If_statementContextExt<'input>,
    pub then_block: Option<Rc<Function_blockContextAll<'input>>>,
    pub else_block: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IfFlowContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IfFlowContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IfFlowContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IfFlow(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IfFlow(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IfFlowContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IfFlow(self);
    }
}

impl<'input> CustomRuleContext<'input> for IfFlowContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_statement }
}

impl<'input> Borrow<If_statementContextExt<'input>> for IfFlowContext<'input> {
    fn borrow(&self) -> &If_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<If_statementContextExt<'input>> for IfFlowContext<'input> {
    fn borrow_mut(&mut self) -> &mut If_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> If_statementContextAttrs<'input> for IfFlowContext<'input> {}

impl<'input> IfFlowContextExt<'input> {
    fn new(ctx: &dyn If_statementContextAttrs<'input>) -> Rc<If_statementContextAll<'input>> {
        Rc::new(If_statementContextAll::IfFlowContext(BaseParserRuleContext::copy_from(
            ctx,
            IfFlowContextExt { then_block: None, else_block: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IfGuardContext<'input> = BaseParserRuleContext<'input, IfGuardContextExt<'input>>;

pub trait IfGuardContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IfGuardContextAttrs<'input> for IfGuardContext<'input> {}

pub struct IfGuardContextExt<'input> {
    base: If_statementContextExt<'input>,
    pub then: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IfGuardContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IfGuardContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IfGuardContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IfGuard(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IfGuard(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IfGuardContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IfGuard(self);
    }
}

impl<'input> CustomRuleContext<'input> for IfGuardContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_statement }
}

impl<'input> Borrow<If_statementContextExt<'input>> for IfGuardContext<'input> {
    fn borrow(&self) -> &If_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<If_statementContextExt<'input>> for IfGuardContext<'input> {
    fn borrow_mut(&mut self) -> &mut If_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> If_statementContextAttrs<'input> for IfGuardContext<'input> {}

impl<'input> IfGuardContextExt<'input> {
    fn new(ctx: &dyn If_statementContextAttrs<'input>) -> Rc<If_statementContextAll<'input>> {
        Rc::new(If_statementContextAll::IfGuardContext(BaseParserRuleContext::copy_from(
            ctx,
            IfGuardContextExt { then: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_statement(&mut self) -> Result<Rc<If_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_if_statement);
        let mut _localctx: Rc<If_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(915);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(123, &mut recog.base)? {
                1 => {
                    let tmp = IfFlowContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(882);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(879);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(884);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(885);
                        recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(886);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(887);
                        let tmp = recog.function_block()?;
                        if let If_statementContextAll::IfFlowContext(ctx) =
                            cast_mut::<_, If_statementContextAll>(&mut _localctx)
                        {
                            ctx.then_block = Some(tmp.clone());
                        }
                        else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(891);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(119, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        /* InvokeRule else_if_statement */
                                        recog.base.set_state(888);
                                        recog.else_if_statement()?;
                                    }
                                }
                            }
                            recog.base.set_state(893);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(119, &mut recog.base)?;
                        }
                        recog.base.set_state(896);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(120, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(894);
                                    recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                                    /* InvokeRule function_block */
                                    recog.base.set_state(895);
                                    let tmp = recog.function_block()?;
                                    if let If_statementContextAll::IfFlowContext(ctx) =
                                        cast_mut::<_, If_statementContextAll>(&mut _localctx)
                                    {
                                        ctx.else_block = Some(tmp.clone());
                                    }
                                    else {
                                        unreachable!("cant cast");
                                    }
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    let tmp = IfGuardContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(901);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(898);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(903);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(904);
                        recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                        recog.base.set_state(905);
                        _la = recog.base.input.la(1);
                        if { !(_la == KW_NOT || _la == KW_LET) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        recog.base.set_state(909);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(122, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule let_pattern_tuple */
                                    recog.base.set_state(906);
                                    recog.let_pattern_tuple()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(907);
                                    recog.identifier()?;
                                }
                            }
                            3 => {
                                recog.base.set_state(908);
                                recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        recog.base.set_state(911);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(912);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(913);
                        let tmp = recog.function_block()?;
                        if let If_statementContextAll::IfGuardContext(ctx) =
                            cast_mut::<_, If_statementContextAll>(&mut _localctx)
                        {
                            ctx.then = Some(tmp.clone());
                        }
                        else {
                            unreachable!("cant cast");
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- else_if_statement ----------------
pub type Else_if_statementContextAll<'input> = Else_if_statementContext<'input>;

pub type Else_if_statementContext<'input> = BaseParserRuleContext<'input, Else_if_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Else_if_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Else_if_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Else_if_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_else_if_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_else_if_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Else_if_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_else_if_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Else_if_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_else_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_else_if_statement }
}
antlr_rust::tid! {Else_if_statementContextExt<'a>}

impl<'input> Else_if_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Else_if_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Else_if_statementContextExt { ph: PhantomData }))
    }
}

pub trait Else_if_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Else_if_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Else_if_statementContextAttrs<'input> for Else_if_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn else_if_statement(&mut self) -> Result<Rc<Else_if_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Else_if_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_else_if_statement);
        let mut _localctx: Rc<Else_if_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(917);
                recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                recog.base.set_state(918);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(919);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(920);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- while_statement ----------------
#[derive(Debug)]
pub enum While_statementContextAll<'input> {
    WhileLetContext(WhileLetContext<'input>),
    WhileExpressionContext(WhileExpressionContext<'input>),
    Error(While_statementContext<'input>),
}
antlr_rust::tid! {While_statementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for While_statementContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for While_statementContextAll<'input> {}

impl<'input> Deref for While_statementContextAll<'input> {
    type Target = dyn While_statementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use While_statementContextAll::*;
        match self {
            WhileLetContext(inner) => inner,
            WhileExpressionContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for While_statementContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for While_statementContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type While_statementContext<'input> = BaseParserRuleContext<'input, While_statementContextExt<'input>>;

#[derive(Clone)]
pub struct While_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for While_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for While_statementContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for While_statementContext<'input> {}

impl<'input> CustomRuleContext<'input> for While_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_while_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_while_statement }
}
antlr_rust::tid! {While_statementContextExt<'a>}

impl<'input> While_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<While_statementContextAll<'input>> {
        Rc::new(While_statementContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            While_statementContextExt { ph: PhantomData },
        )))
    }
}

pub trait While_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<While_statementContextExt<'input>>
{
}

impl<'input> While_statementContextAttrs<'input> for While_statementContext<'input> {}

pub type WhileLetContext<'input> = BaseParserRuleContext<'input, WhileLetContextExt<'input>>;

pub trait WhileLetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileLetContextAttrs<'input> for WhileLetContext<'input> {}

pub struct WhileLetContextExt<'input> {
    base: While_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileLetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileLetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileLetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileLet(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileLet(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileLetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileLet(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileLetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_while_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_while_statement }
}

impl<'input> Borrow<While_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow(&self) -> &While_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<While_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow_mut(&mut self) -> &mut While_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> While_statementContextAttrs<'input> for WhileLetContext<'input> {}

impl<'input> WhileLetContextExt<'input> {
    fn new(ctx: &dyn While_statementContextAttrs<'input>) -> Rc<While_statementContextAll<'input>> {
        Rc::new(While_statementContextAll::WhileLetContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileLetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type WhileExpressionContext<'input> = BaseParserRuleContext<'input, WhileExpressionContextExt<'input>>;

pub trait WhileExpressionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileExpressionContextAttrs<'input> for WhileExpressionContext<'input> {}

pub struct WhileExpressionContextExt<'input> {
    base: While_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileExpressionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileExpressionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileExpression(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileExpression(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileExpressionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileExpression(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_while_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_while_statement }
}

impl<'input> Borrow<While_statementContextExt<'input>> for WhileExpressionContext<'input> {
    fn borrow(&self) -> &While_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<While_statementContextExt<'input>> for WhileExpressionContext<'input> {
    fn borrow_mut(&mut self) -> &mut While_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> While_statementContextAttrs<'input> for WhileExpressionContext<'input> {}

impl<'input> WhileExpressionContextExt<'input> {
    fn new(ctx: &dyn While_statementContextAttrs<'input>) -> Rc<While_statementContextAll<'input>> {
        Rc::new(While_statementContextAll::WhileExpressionContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileExpressionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn while_statement(&mut self) -> Result<Rc<While_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = While_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_while_statement);
        let mut _localctx: Rc<While_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(945);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(126, &mut recog.base)? {
                1 => {
                    let tmp = WhileExpressionContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(925);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(922);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(927);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(928);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(929);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(930);
                        recog.function_block()?;
                    }
                }
                2 => {
                    let tmp = WhileLetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(935);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(932);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(937);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(938);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        recog.base.set_state(939);
                        recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                        /* InvokeRule let_pattern */
                        recog.base.set_state(940);
                        recog.let_pattern()?;

                        recog.base.set_state(941);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(942);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(943);
                        recog.function_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- for_statement ----------------
pub type For_statementContextAll<'input> = For_statementContext<'input>;

pub type For_statementContext<'input> = BaseParserRuleContext<'input, For_statementContextExt<'input>>;

#[derive(Clone)]
pub struct For_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for For_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for For_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_for_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_for_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for For_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_for_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for For_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_for_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_for_statement }
}
antlr_rust::tid! {For_statementContextExt<'a>}

impl<'input> For_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<For_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, For_statementContextExt { ph: PhantomData }))
    }
}

pub trait For_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<For_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_FOR
    /// Returns `None` if there is no child corresponding to token KW_FOR
    fn KW_FOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FOR, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn infix_in(&self) -> Option<Rc<Infix_inContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn if_guard(&self) -> Option<Rc<If_guardContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> For_statementContextAttrs<'input> for For_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn for_statement(&mut self) -> Result<Rc<For_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = For_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_for_statement);
        let mut _localctx: Rc<For_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(950);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(947);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(952);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(953);
                recog.base.match_token(KW_FOR, &mut recog.err_handler)?;

                /* InvokeRule let_pattern */
                recog.base.set_state(954);
                recog.let_pattern()?;

                /* InvokeRule infix_in */
                recog.base.set_state(955);
                recog.infix_in()?;

                /* InvokeRule inline_expression */
                recog.base.set_state(956);
                recog.inline_expression_rec(0)?;

                recog.base.set_state(958);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == KW_IF {
                    {
                        /* InvokeRule if_guard */
                        recog.base.set_state(957);
                        recog.if_guard()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(960);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_guard ----------------
pub type If_guardContextAll<'input> = If_guardContext<'input>;

pub type If_guardContext<'input> = BaseParserRuleContext<'input, If_guardContextExt<'input>>;

#[derive(Clone)]
pub struct If_guardContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_guardContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_guardContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_guard(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_guard(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_guardContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_guard(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_guardContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_guard
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_guard }
}
antlr_rust::tid! {If_guardContextExt<'a>}

impl<'input> If_guardContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_guardContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, If_guardContextExt { ph: PhantomData }))
    }
}

pub trait If_guardContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<If_guardContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> If_guardContextAttrs<'input> for If_guardContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_guard(&mut self) -> Result<Rc<If_guardContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_guardContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_if_guard);
        let mut _localctx: Rc<If_guardContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(962);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(963);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- top_expression ----------------
pub type Top_expressionContextAll<'input> = Top_expressionContext<'input>;

pub type Top_expressionContext<'input> = BaseParserRuleContext<'input, Top_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Top_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Top_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Top_expressionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_top_expression(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_top_expression(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Top_expressionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_top_expression(self);
    }
}

impl<'input> CustomRuleContext<'input> for Top_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_top_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_top_expression }
}
antlr_rust::tid! {Top_expressionContextExt<'a>}

impl<'input> Top_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Top_expressionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Top_expressionContextExt { ph: PhantomData }))
    }
}

pub trait Top_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Top_expressionContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Top_expressionContextAttrs<'input> for Top_expressionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn top_expression(&mut self) -> Result<Rc<Top_expressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Top_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_top_expression);
        let mut _localctx: Rc<Top_expressionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(968);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(129, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule annotation */
                                recog.base.set_state(965);
                                recog.annotation()?;
                            }
                        }
                    }
                    recog.base.set_state(970);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(129, &mut recog.base)?;
                }
                /* InvokeRule expression */
                recog.base.set_state(971);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression ----------------
#[derive(Debug)]
pub enum ExpressionContextAll<'input> {
    EIfContext(EIfContext<'input>),
    ESpecialContext(ESpecialContext<'input>),
    EPlusContext(EPlusContext<'input>),
    ETryContext(ETryContext<'input>),
    EObjectContext(EObjectContext<'input>),
    ERangeContext(ERangeContext<'input>),
    EAssignContext(EAssignContext<'input>),
    ENamepathContext(ENamepathContext<'input>),
    EMulContext(EMulContext<'input>),
    ELambdaContext(ELambdaContext<'input>),
    ENumberContext(ENumberContext<'input>),
    EOrElseContext(EOrElseContext<'input>),
    EGroupContext(EGroupContext<'input>),
    EFunctionContext(EFunctionContext<'input>),
    ESuffixContext(ESuffixContext<'input>),
    ECollectionContext(ECollectionContext<'input>),
    EMatchContext(EMatchContext<'input>),
    EMacroContext(EMacroContext<'input>),
    EPrefixContext(EPrefixContext<'input>),
    ECompareContext(ECompareContext<'input>),
    EIsAContext(EIsAContext<'input>),
    EPowContext(EPowContext<'input>),
    EDefineContext(EDefineContext<'input>),
    ELogicContext(ELogicContext<'input>),
    EControlContext(EControlContext<'input>),
    ENewContext(ENewContext<'input>),
    EStringContext(EStringContext<'input>),
    Error(ExpressionContext<'input>),
}
antlr_rust::tid! {ExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ExpressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContextAll<'input> {}

impl<'input> Deref for ExpressionContextAll<'input> {
    type Target = dyn ExpressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use ExpressionContextAll::*;
        match self {
            EIfContext(inner) => inner,
            ESpecialContext(inner) => inner,
            EPlusContext(inner) => inner,
            ETryContext(inner) => inner,
            EObjectContext(inner) => inner,
            ERangeContext(inner) => inner,
            EAssignContext(inner) => inner,
            ENamepathContext(inner) => inner,
            EMulContext(inner) => inner,
            ELambdaContext(inner) => inner,
            ENumberContext(inner) => inner,
            EOrElseContext(inner) => inner,
            EGroupContext(inner) => inner,
            EFunctionContext(inner) => inner,
            ESuffixContext(inner) => inner,
            ECollectionContext(inner) => inner,
            EMatchContext(inner) => inner,
            EMacroContext(inner) => inner,
            EPrefixContext(inner) => inner,
            ECompareContext(inner) => inner,
            EIsAContext(inner) => inner,
            EPowContext(inner) => inner,
            EDefineContext(inner) => inner,
            ELogicContext(inner) => inner,
            EControlContext(inner) => inner,
            ENewContext(inner) => inner,
            EStringContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type ExpressionContext<'input> = BaseParserRuleContext<'input, ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid! {ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ExpressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait ExpressionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ExpressionContextExt<'input>> {}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input> {}

pub type EIfContext<'input> = BaseParserRuleContext<'input, EIfContextExt<'input>>;

pub trait EIfContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn if_statement(&self) -> Option<Rc<If_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EIfContextAttrs<'input> for EIfContext<'input> {}

pub struct EIfContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EIfContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EIfContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EIfContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIf(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIf(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EIfContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIf(self);
    }
}

impl<'input> CustomRuleContext<'input> for EIfContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EIfContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EIfContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EIfContext<'input> {}

impl<'input> EIfContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EIfContext(BaseParserRuleContext::copy_from(
            ctx,
            EIfContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESpecialContext<'input> = BaseParserRuleContext<'input, ESpecialContextExt<'input>>;

pub trait ESpecialContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> ESpecialContextAttrs<'input> for ESpecialContext<'input> {}

pub struct ESpecialContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESpecialContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESpecialContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESpecialContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESpecial(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESpecial(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESpecialContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESpecial(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESpecialContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESpecialContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESpecialContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESpecialContext<'input> {}

impl<'input> ESpecialContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESpecialContext(BaseParserRuleContext::copy_from(
            ctx,
            ESpecialContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPlusContext<'input> = BaseParserRuleContext<'input, EPlusContextExt<'input>>;

pub trait EPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EPlusContextAttrs<'input> for EPlusContext<'input> {}

pub struct EPlusContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPlusContext<'input> {}

impl<'input> EPlusContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            EPlusContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ETryContext<'input> = BaseParserRuleContext<'input, ETryContextExt<'input>>;

pub trait ETryContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn try_statement(&self) -> Option<Rc<Try_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ETryContextAttrs<'input> for ETryContext<'input> {}

pub struct ETryContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ETryContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ETryContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ETryContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ETry(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ETry(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ETryContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ETry(self);
    }
}

impl<'input> CustomRuleContext<'input> for ETryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ETryContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ETryContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ETryContext<'input> {}

impl<'input> ETryContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ETryContext(BaseParserRuleContext::copy_from(
            ctx,
            ETryContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EObjectContext<'input> = BaseParserRuleContext<'input, EObjectContextExt<'input>>;

pub trait EObjectContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn object_statement(&self) -> Option<Rc<Object_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EObjectContextAttrs<'input> for EObjectContext<'input> {}

pub struct EObjectContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EObjectContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EObjectContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EObjectContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EObject(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EObject(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EObjectContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EObject(self);
    }
}

impl<'input> CustomRuleContext<'input> for EObjectContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EObjectContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EObjectContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EObjectContext<'input> {}

impl<'input> EObjectContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EObjectContext(BaseParserRuleContext::copy_from(
            ctx,
            EObjectContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ERangeContext<'input> = BaseParserRuleContext<'input, ERangeContextExt<'input>>;

pub trait ERangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> ERangeContextAttrs<'input> for ERangeContext<'input> {}

pub struct ERangeContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ERangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ERangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ERangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ERange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ERange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ERangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ERange(self);
    }
}

impl<'input> CustomRuleContext<'input> for ERangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ERangeContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ERangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ERangeContext<'input> {}

impl<'input> ERangeContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ERangeContext(BaseParserRuleContext::copy_from(
            ctx,
            ERangeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAssignContext<'input> = BaseParserRuleContext<'input, EAssignContextExt<'input>>;

pub trait EAssignContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn op_assign(&self) -> Option<Rc<Op_assignContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EAssignContextAttrs<'input> for EAssignContext<'input> {}

pub struct EAssignContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAssignContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAssignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAssignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAssign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAssign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAssignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAssign(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAssignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAssignContext<'input> {}

impl<'input> EAssignContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAssignContext(BaseParserRuleContext::copy_from(
            ctx,
            EAssignContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ENamepathContext<'input> = BaseParserRuleContext<'input, ENamepathContextExt<'input>>;

pub trait ENamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ENamepathContextAttrs<'input> for ENamepathContext<'input> {}

pub struct ENamepathContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ENamepathContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ENamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ENamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ENamepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ENamepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ENamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ENamepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for ENamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ENamepathContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ENamepathContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ENamepathContext<'input> {}

impl<'input> ENamepathContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ENamepathContext(BaseParserRuleContext::copy_from(
            ctx,
            ENamepathContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMulContext<'input> = BaseParserRuleContext<'input, EMulContextExt<'input>>;

pub trait EMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMulContextAttrs<'input> for EMulContext<'input> {}

pub struct EMulContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMulContext<'input> {}

impl<'input> EMulContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMulContext(BaseParserRuleContext::copy_from(
            ctx,
            EMulContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELambdaContext<'input> = BaseParserRuleContext<'input, ELambdaContextExt<'input>>;

pub trait ELambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn lambda_name(&self) -> Option<Rc<Lambda_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ELambdaContextAttrs<'input> for ELambdaContext<'input> {}

pub struct ELambdaContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELambdaContext<'input> {}

impl<'input> ELambdaContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            ELambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ENumberContext<'input> = BaseParserRuleContext<'input, ENumberContextExt<'input>>;

pub trait ENumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ENumberContextAttrs<'input> for ENumberContext<'input> {}

pub struct ENumberContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ENumberContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ENumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ENumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ENumber(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ENumber(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ENumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ENumber(self);
    }
}

impl<'input> CustomRuleContext<'input> for ENumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ENumberContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ENumberContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ENumberContext<'input> {}

impl<'input> ENumberContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ENumberContext(BaseParserRuleContext::copy_from(
            ctx,
            ENumberContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EOrElseContext<'input> = BaseParserRuleContext<'input, EOrElseContextExt<'input>>;

pub trait EOrElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR_ELSE
    /// Returns `None` if there is no child corresponding to token OP_OR_ELSE
    fn OP_OR_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR_ELSE, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EOrElseContextAttrs<'input> for EOrElseContext<'input> {}

pub struct EOrElseContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EOrElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EOrElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EOrElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EOrElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EOrElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EOrElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EOrElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for EOrElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EOrElseContext<'input> {}

impl<'input> EOrElseContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EOrElseContext(BaseParserRuleContext::copy_from(
            ctx,
            EOrElseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EGroupContext<'input> = BaseParserRuleContext<'input, EGroupContextExt<'input>>;

pub trait EGroupContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
}

impl<'input> EGroupContextAttrs<'input> for EGroupContext<'input> {}

pub struct EGroupContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EGroupContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EGroupContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EGroupContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EGroup(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EGroup(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EGroupContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EGroup(self);
    }
}

impl<'input> CustomRuleContext<'input> for EGroupContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EGroupContext<'input> {}

impl<'input> EGroupContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EGroupContext(BaseParserRuleContext::copy_from(
            ctx,
            EGroupContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EFunctionContext<'input> = BaseParserRuleContext<'input, EFunctionContextExt<'input>>;

pub trait EFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EFunctionContextAttrs<'input> for EFunctionContext<'input> {}

pub struct EFunctionContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for EFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EFunctionContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EFunctionContext<'input> {}

impl<'input> EFunctionContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            EFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESuffixContext<'input> = BaseParserRuleContext<'input, ESuffixContextExt<'input>>;

pub trait ESuffixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn suffix_call(&self) -> Option<Rc<Suffix_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ESuffixContextAttrs<'input> for ESuffixContext<'input> {}

pub struct ESuffixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESuffixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESuffixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESuffixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESuffix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESuffix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESuffixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESuffix(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESuffixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESuffixContext<'input> {}

impl<'input> ESuffixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESuffixContext(BaseParserRuleContext::copy_from(
            ctx,
            ESuffixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ECollectionContext<'input> = BaseParserRuleContext<'input, ECollectionContextExt<'input>>;

pub trait ECollectionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn collection_literal(&self) -> Option<Rc<Collection_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ECollectionContextAttrs<'input> for ECollectionContext<'input> {}

pub struct ECollectionContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ECollectionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ECollectionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ECollectionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ECollection(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ECollection(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ECollectionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ECollection(self);
    }
}

impl<'input> CustomRuleContext<'input> for ECollectionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ECollectionContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ECollectionContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ECollectionContext<'input> {}

impl<'input> ECollectionContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ECollectionContext(BaseParserRuleContext::copy_from(
            ctx,
            ECollectionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMatchContext<'input> = BaseParserRuleContext<'input, EMatchContextExt<'input>>;

pub trait EMatchContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn match_statement(&self) -> Option<Rc<Match_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMatchContextAttrs<'input> for EMatchContext<'input> {}

pub struct EMatchContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMatchContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMatchContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMatch(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMatchContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMatch(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMatchContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMatchContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMatchContext<'input> {}

impl<'input> EMatchContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMatchContext(BaseParserRuleContext::copy_from(
            ctx,
            EMatchContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMacroContext<'input> = BaseParserRuleContext<'input, EMacroContextExt<'input>>;

pub trait EMacroContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn macro_call(&self) -> Option<Rc<Macro_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMacroContextAttrs<'input> for EMacroContext<'input> {}

pub struct EMacroContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMacroContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMacroContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMacroContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMacro(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMacro(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMacroContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMacro(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMacroContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMacroContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMacroContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMacroContext<'input> {}

impl<'input> EMacroContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMacroContext(BaseParserRuleContext::copy_from(
            ctx,
            EMacroContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPrefixContext<'input> = BaseParserRuleContext<'input, EPrefixContextExt<'input>>;

pub trait EPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn prefix_call(&self) -> Option<Rc<Prefix_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EPrefixContextAttrs<'input> for EPrefixContext<'input> {}

pub struct EPrefixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPrefixContext<'input> {}

impl<'input> EPrefixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            EPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ECompareContext<'input> = BaseParserRuleContext<'input, ECompareContextExt<'input>>;

pub trait ECompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ECompareContextAttrs<'input> for ECompareContext<'input> {}

pub struct ECompareContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ECompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ECompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ECompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ECompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ECompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ECompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ECompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ECompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ECompareContext<'input> {}

impl<'input> ECompareContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ECompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ECompareContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EIsAContext<'input> = BaseParserRuleContext<'input, EIsAContextExt<'input>>;

pub trait EIsAContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn infix_is(&self) -> Option<Rc<Infix_isContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EIsAContextAttrs<'input> for EIsAContext<'input> {}

pub struct EIsAContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EIsAContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EIsAContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EIsAContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIsA(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIsA(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EIsAContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIsA(self);
    }
}

impl<'input> CustomRuleContext<'input> for EIsAContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EIsAContext<'input> {}

impl<'input> EIsAContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EIsAContext(BaseParserRuleContext::copy_from(
            ctx,
            EIsAContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPowContext<'input> = BaseParserRuleContext<'input, EPowContextExt<'input>>;

pub trait EPowContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_POW
    /// Returns `None` if there is no child corresponding to token OP_POW
    fn OP_POW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_POW, 0)
    }
}

impl<'input> EPowContextAttrs<'input> for EPowContext<'input> {}

pub struct EPowContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPowContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPowContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPowContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPow(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPow(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPowContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPow(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPowContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPowContext<'input> {}

impl<'input> EPowContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPowContext(BaseParserRuleContext::copy_from(
            ctx,
            EPowContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDefineContext<'input> = BaseParserRuleContext<'input, EDefineContextExt<'input>>;

pub trait EDefineContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_label(&self) -> Option<Rc<Define_labelContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDefineContextAttrs<'input> for EDefineContext<'input> {}

pub struct EDefineContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDefineContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDefineContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDefineContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDefine(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDefine(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDefineContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDefine(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDefineContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDefineContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDefineContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDefineContext<'input> {}

impl<'input> EDefineContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDefineContext(BaseParserRuleContext::copy_from(
            ctx,
            EDefineContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELogicContext<'input> = BaseParserRuleContext<'input, ELogicContextExt<'input>>;

pub trait ELogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ELogicContextAttrs<'input> for ELogicContext<'input> {}

pub struct ELogicContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELogicContext<'input> {}

impl<'input> ELogicContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ELogicContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EControlContext<'input> = BaseParserRuleContext<'input, EControlContextExt<'input>>;

pub trait EControlContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn control_expression(&self) -> Option<Rc<Control_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EControlContextAttrs<'input> for EControlContext<'input> {}

pub struct EControlContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EControlContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EControlContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EControlContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EControl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EControl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EControlContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EControl(self);
    }
}

impl<'input> CustomRuleContext<'input> for EControlContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EControlContext<'input> {}

impl<'input> EControlContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EControlContext(BaseParserRuleContext::copy_from(
            ctx,
            EControlContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ENewContext<'input> = BaseParserRuleContext<'input, ENewContextExt<'input>>;

pub trait ENewContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn new_statement(&self) -> Option<Rc<New_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ENewContextAttrs<'input> for ENewContext<'input> {}

pub struct ENewContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ENewContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ENewContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ENewContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ENew(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ENew(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ENewContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ENew(self);
    }
}

impl<'input> CustomRuleContext<'input> for ENewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ENewContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ENewContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ENewContext<'input> {}

impl<'input> ENewContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ENewContext(BaseParserRuleContext::copy_from(
            ctx,
            ENewContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EStringContext<'input> = BaseParserRuleContext<'input, EStringContextExt<'input>>;

pub trait EStringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EStringContextAttrs<'input> for EStringContext<'input> {}

pub struct EStringContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EStringContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EStringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EStringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EString(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EString(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EStringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EString(self);
    }
}

impl<'input> CustomRuleContext<'input> for EStringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EStringContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EStringContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EStringContext<'input> {}

impl<'input> EStringContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EStringContext(BaseParserRuleContext::copy_from(
            ctx,
            EStringContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression(&mut self) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        self.expression_rec(0)
    }

    fn expression_rec(&mut self, _p: isize) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 114, RULE_expression, _p);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 114;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(996);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(130, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = EControlContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule control_expression */
                            recog.base.set_state(974);
                            recog.control_expression()?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = EPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule prefix_call */
                            recog.base.set_state(975);
                            recog.prefix_call()?;

                            /* InvokeRule expression */
                            recog.base.set_state(976);
                            recog.expression_rec(16)?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = EGroupContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(978);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(979);
                            recog.expression_rec(0)?;

                            recog.base.set_state(980);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = ETryContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule try_statement */
                            recog.base.set_state(982);
                            recog.try_statement()?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = EIfContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule if_statement */
                            recog.base.set_state(983);
                            recog.if_statement()?;
                        }
                    }
                    6 => {
                        {
                            let mut tmp = EMatchContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule match_statement */
                            recog.base.set_state(984);
                            recog.match_statement()?;
                        }
                    }
                    7 => {
                        {
                            let mut tmp = ENewContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule new_statement */
                            recog.base.set_state(985);
                            recog.new_statement()?;
                        }
                    }
                    8 => {
                        {
                            let mut tmp = EObjectContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule object_statement */
                            recog.base.set_state(986);
                            recog.object_statement()?;
                        }
                    }
                    9 => {
                        {
                            let mut tmp = EMacroContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule macro_call */
                            recog.base.set_state(987);
                            recog.macro_call()?;
                        }
                    }
                    10 => {
                        {
                            let mut tmp = EFunctionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule function_call */
                            recog.base.set_state(988);
                            recog.function_call()?;
                        }
                    }
                    11 => {
                        {
                            let mut tmp = EDefineContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule define_label */
                            recog.base.set_state(989);
                            recog.define_label()?;
                        }
                    }
                    12 => {
                        {
                            let mut tmp = ECollectionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule collection_literal */
                            recog.base.set_state(990);
                            recog.collection_literal()?;
                        }
                    }
                    13 => {
                        {
                            let mut tmp = EStringContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule string_literal */
                            recog.base.set_state(991);
                            recog.string_literal()?;
                        }
                    }
                    14 => {
                        {
                            let mut tmp = ENumberContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule number_literal */
                            recog.base.set_state(992);
                            recog.number_literal()?;
                        }
                    }
                    15 => {
                        {
                            let mut tmp = ELambdaContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule lambda_name */
                            recog.base.set_state(993);
                            recog.lambda_name()?;
                        }
                    }
                    16 => {
                        {
                            let mut tmp = ENamepathContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule namepath */
                            recog.base.set_state(994);
                            recog.namepath()?;
                        }
                    }
                    17 => {
                        let mut tmp = ESpecialContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(995);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1035);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(132, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1033);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(131, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EPowContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(998);
                                        if !({ recog.precpred(None, 26) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 26)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(999);
                                        recog.base.match_token(OP_POW, &mut recog.err_handler)?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1000);
                                        recog.expression_rec(26)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EMulContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1001);
                                        if !({ recog.precpred(None, 25) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 25)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(1002);
                                        recog.op_multiple()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1003);
                                        recog.expression_rec(26)?;
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EPlusContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1005);
                                        if !({ recog.precpred(None, 24) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 24)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(1006);
                                        recog.op_plus()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1007);
                                        recog.expression_rec(25)?;
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ELogicContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1009);
                                        if !({ recog.precpred(None, 23) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 23)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(1010);
                                        recog.op_logic()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1011);
                                        recog.expression_rec(24)?;
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ECompareContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1013);
                                        if !({ recog.precpred(None, 22) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 22)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1014);
                                        recog.op_compare()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1015);
                                        recog.expression_rec(23)?;
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ERangeContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1017);
                                        if !({ recog.precpred(None, 21) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 21)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1018);
                                        recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1019);
                                        recog.expression_rec(22)?;
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ESuffixContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1020);
                                        if !({ recog.precpred(None, 27) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 27)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule suffix_call */
                                        recog.base.set_state(1021);
                                        recog.suffix_call()?;
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EIsAContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1022);
                                        if !({ recog.precpred(None, 20) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 20)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_is */
                                        recog.base.set_state(1023);
                                        recog.infix_is()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1024);
                                        recog.type_expression_rec(0)?;
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EAssignContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1026);
                                        if !({ recog.precpred(None, 19) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 19)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_assign */
                                        recog.base.set_state(1027);
                                        recog.op_assign()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1028);
                                        recog.type_expression_rec(0)?;
                                    }
                                }
                                10 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EOrElseContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1030);
                                        if !({ recog.precpred(None, 18) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 18)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1031);
                                        recog.base.match_token(OP_OR_ELSE, &mut recog.err_handler)?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1032);
                                        recog.type_expression_rec(0)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1037);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(132, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- inline_expression ----------------
#[derive(Debug)]
pub enum Inline_expressionContextAll<'input> {
    ILogicContext(ILogicContext<'input>),
    IDotContext(IDotContext<'input>),
    INamepathContext(INamepathContext<'input>),
    ISpecialContext(ISpecialContext<'input>),
    IPlusContext(IPlusContext<'input>),
    ICompareContext(ICompareContext<'input>),
    IFunctionContext(IFunctionContext<'input>),
    IIsAContext(IIsAContext<'input>),
    INumberContext(INumberContext<'input>),
    IRangeContext(IRangeContext<'input>),
    ICollectionContext(ICollectionContext<'input>),
    IMulContext(IMulContext<'input>),
    IAsContext(IAsContext<'input>),
    IPrefixContext(IPrefixContext<'input>),
    IStringContext(IStringContext<'input>),
    IMacroContext(IMacroContext<'input>),
    ISliceContext(ISliceContext<'input>),
    Error(Inline_expressionContext<'input>),
}
antlr_rust::tid! {Inline_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Inline_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContextAll<'input> {}

impl<'input> Deref for Inline_expressionContextAll<'input> {
    type Target = dyn Inline_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Inline_expressionContextAll::*;
        match self {
            ILogicContext(inner) => inner,
            IDotContext(inner) => inner,
            INamepathContext(inner) => inner,
            ISpecialContext(inner) => inner,
            IPlusContext(inner) => inner,
            ICompareContext(inner) => inner,
            IFunctionContext(inner) => inner,
            IIsAContext(inner) => inner,
            INumberContext(inner) => inner,
            IRangeContext(inner) => inner,
            ICollectionContext(inner) => inner,
            IMulContext(inner) => inner,
            IAsContext(inner) => inner,
            IPrefixContext(inner) => inner,
            IStringContext(inner) => inner,
            IMacroContext(inner) => inner,
            ISliceContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Inline_expressionContext<'input> = BaseParserRuleContext<'input, Inline_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Inline_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Inline_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}
antlr_rust::tid! {Inline_expressionContextExt<'a>}

impl<'input> Inline_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Inline_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Inline_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Inline_expressionContextExt<'input>>
{
}

impl<'input> Inline_expressionContextAttrs<'input> for Inline_expressionContext<'input> {}

pub type ILogicContext<'input> = BaseParserRuleContext<'input, ILogicContextExt<'input>>;

pub trait ILogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ILogicContextAttrs<'input> for ILogicContext<'input> {}

pub struct ILogicContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ILogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ILogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ILogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ILogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ILogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ILogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ILogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ILogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ILogicContext<'input> {}

impl<'input> ILogicContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ILogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ILogicContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IDotContext<'input> = BaseParserRuleContext<'input, IDotContextExt<'input>>;

pub trait IDotContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn dot_call(&self) -> Option<Rc<Dot_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IDotContextAttrs<'input> for IDotContext<'input> {}

pub struct IDotContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IDotContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IDotContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IDotContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IDot(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IDot(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IDotContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IDot(self);
    }
}

impl<'input> CustomRuleContext<'input> for IDotContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IDotContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IDotContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IDotContext<'input> {}

impl<'input> IDotContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IDotContext(BaseParserRuleContext::copy_from(
            ctx,
            IDotContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type INamepathContext<'input> = BaseParserRuleContext<'input, INamepathContextExt<'input>>;

pub trait INamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> INamepathContextAttrs<'input> for INamepathContext<'input> {}

pub struct INamepathContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {INamepathContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for INamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for INamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_INamepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_INamepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for INamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_INamepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for INamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for INamepathContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for INamepathContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for INamepathContext<'input> {}

impl<'input> INamepathContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::INamepathContext(BaseParserRuleContext::copy_from(
            ctx,
            INamepathContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ISpecialContext<'input> = BaseParserRuleContext<'input, ISpecialContextExt<'input>>;

pub trait ISpecialContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> ISpecialContextAttrs<'input> for ISpecialContext<'input> {}

pub struct ISpecialContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ISpecialContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ISpecialContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ISpecialContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ISpecial(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ISpecial(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ISpecialContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ISpecial(self);
    }
}

impl<'input> CustomRuleContext<'input> for ISpecialContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ISpecialContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ISpecialContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ISpecialContext<'input> {}

impl<'input> ISpecialContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ISpecialContext(BaseParserRuleContext::copy_from(
            ctx,
            ISpecialContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPlusContext<'input> = BaseParserRuleContext<'input, IPlusContextExt<'input>>;

pub trait IPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IPlusContextAttrs<'input> for IPlusContext<'input> {}

pub struct IPlusContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPlusContext<'input> {}

impl<'input> IPlusContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            IPlusContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ICompareContext<'input> = BaseParserRuleContext<'input, ICompareContextExt<'input>>;

pub trait ICompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ICompareContextAttrs<'input> for ICompareContext<'input> {}

pub struct ICompareContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ICompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ICompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ICompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ICompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ICompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ICompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ICompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ICompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ICompareContext<'input> {}

impl<'input> ICompareContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ICompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ICompareContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IFunctionContext<'input> = BaseParserRuleContext<'input, IFunctionContextExt<'input>>;

pub trait IFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IFunctionContextAttrs<'input> for IFunctionContext<'input> {}

pub struct IFunctionContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for IFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IFunctionContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IFunctionContext<'input> {}

impl<'input> IFunctionContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            IFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IIsAContext<'input> = BaseParserRuleContext<'input, IIsAContextExt<'input>>;

pub trait IIsAContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IS
    /// Returns `None` if there is no child corresponding to token KW_IS
    fn KW_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
}

impl<'input> IIsAContextAttrs<'input> for IIsAContext<'input> {}

pub struct IIsAContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IIsAContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IIsAContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IIsAContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IIsA(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IIsA(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IIsAContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IIsA(self);
    }
}

impl<'input> CustomRuleContext<'input> for IIsAContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IIsAContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IIsAContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IIsAContext<'input> {}

impl<'input> IIsAContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IIsAContext(BaseParserRuleContext::copy_from(
            ctx,
            IIsAContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type INumberContext<'input> = BaseParserRuleContext<'input, INumberContextExt<'input>>;

pub trait INumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> INumberContextAttrs<'input> for INumberContext<'input> {}

pub struct INumberContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {INumberContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for INumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for INumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_INumber(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_INumber(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for INumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_INumber(self);
    }
}

impl<'input> CustomRuleContext<'input> for INumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for INumberContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for INumberContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for INumberContext<'input> {}

impl<'input> INumberContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::INumberContext(BaseParserRuleContext::copy_from(
            ctx,
            INumberContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IRangeContext<'input> = BaseParserRuleContext<'input, IRangeContextExt<'input>>;

pub trait IRangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> IRangeContextAttrs<'input> for IRangeContext<'input> {}

pub struct IRangeContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IRangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IRangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IRangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IRange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IRange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IRangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IRange(self);
    }
}

impl<'input> CustomRuleContext<'input> for IRangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IRangeContext<'input> {}

impl<'input> IRangeContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IRangeContext(BaseParserRuleContext::copy_from(
            ctx,
            IRangeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ICollectionContext<'input> = BaseParserRuleContext<'input, ICollectionContextExt<'input>>;

pub trait ICollectionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn collection_literal(&self) -> Option<Rc<Collection_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ICollectionContextAttrs<'input> for ICollectionContext<'input> {}

pub struct ICollectionContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ICollectionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ICollectionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ICollectionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ICollection(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ICollection(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ICollectionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ICollection(self);
    }
}

impl<'input> CustomRuleContext<'input> for ICollectionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ICollectionContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ICollectionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ICollectionContext<'input> {}

impl<'input> ICollectionContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ICollectionContext(BaseParserRuleContext::copy_from(
            ctx,
            ICollectionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IMulContext<'input> = BaseParserRuleContext<'input, IMulContextExt<'input>>;

pub trait IMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IMulContextAttrs<'input> for IMulContext<'input> {}

pub struct IMulContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for IMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IMulContext<'input> {}

impl<'input> IMulContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IMulContext(BaseParserRuleContext::copy_from(
            ctx,
            IMulContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IAsContext<'input> = BaseParserRuleContext<'input, IAsContextExt<'input>>;

pub trait IAsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
}

impl<'input> IAsContextAttrs<'input> for IAsContext<'input> {}

pub struct IAsContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IAsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IAsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IAsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IAs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IAs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IAsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IAs(self);
    }
}

impl<'input> CustomRuleContext<'input> for IAsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IAsContext<'input> {}

impl<'input> IAsContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IAsContext(BaseParserRuleContext::copy_from(
            ctx,
            IAsContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPrefixContext<'input> = BaseParserRuleContext<'input, IPrefixContextExt<'input>>;

pub trait IPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn prefix_call(&self) -> Option<Rc<Prefix_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IPrefixContextAttrs<'input> for IPrefixContext<'input> {}

pub struct IPrefixContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPrefixContext<'input> {}

impl<'input> IPrefixContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            IPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IStringContext<'input> = BaseParserRuleContext<'input, IStringContextExt<'input>>;

pub trait IStringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IStringContextAttrs<'input> for IStringContext<'input> {}

pub struct IStringContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IStringContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IStringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IStringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IString(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IString(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IStringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IString(self);
    }
}

impl<'input> CustomRuleContext<'input> for IStringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IStringContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IStringContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IStringContext<'input> {}

impl<'input> IStringContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IStringContext(BaseParserRuleContext::copy_from(
            ctx,
            IStringContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IMacroContext<'input> = BaseParserRuleContext<'input, IMacroContextExt<'input>>;

pub trait IMacroContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn macro_call(&self) -> Option<Rc<Macro_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IMacroContextAttrs<'input> for IMacroContext<'input> {}

pub struct IMacroContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IMacroContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IMacroContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IMacroContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IMacro(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IMacro(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IMacroContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IMacro(self);
    }
}

impl<'input> CustomRuleContext<'input> for IMacroContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IMacroContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IMacroContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IMacroContext<'input> {}

impl<'input> IMacroContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IMacroContext(BaseParserRuleContext::copy_from(
            ctx,
            IMacroContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ISliceContext<'input> = BaseParserRuleContext<'input, ISliceContextExt<'input>>;

pub trait ISliceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ISliceContextAttrs<'input> for ISliceContext<'input> {}

pub struct ISliceContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ISliceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ISliceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ISliceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ISlice(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ISlice(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ISliceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ISlice(self);
    }
}

impl<'input> CustomRuleContext<'input> for ISliceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ISliceContext<'input> {}

impl<'input> ISliceContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ISliceContext(BaseParserRuleContext::copy_from(
            ctx,
            ISliceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn inline_expression(&mut self) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        self.inline_expression_rec(0)
    }

    fn inline_expression_rec(&mut self, _p: isize) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Inline_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 116, RULE_inline_expression, _p);
        let mut _localctx: Rc<Inline_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 116;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1049);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(133, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = IPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule prefix_call */
                            recog.base.set_state(1039);
                            recog.prefix_call()?;

                            /* InvokeRule inline_expression */
                            recog.base.set_state(1040);
                            recog.inline_expression_rec(8)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = IMacroContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule macro_call */
                            recog.base.set_state(1042);
                            recog.macro_call()?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = IFunctionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule function_call */
                            recog.base.set_state(1043);
                            recog.function_call()?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = ICollectionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule collection_literal */
                            recog.base.set_state(1044);
                            recog.collection_literal()?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = IStringContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule string_literal */
                            recog.base.set_state(1045);
                            recog.string_literal()?;
                        }
                    }
                    6 => {
                        {
                            let mut tmp = INumberContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule number_literal */
                            recog.base.set_state(1046);
                            recog.number_literal()?;
                        }
                    }
                    7 => {
                        {
                            let mut tmp = INamepathContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule namepath */
                            recog.base.set_state(1047);
                            recog.namepath()?;
                        }
                    }
                    8 => {
                        let mut tmp = ISpecialContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(1048);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1086);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(136, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1084);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(135, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IMulContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1051);
                                        if !({ recog.precpred(None, 15) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 15)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(1052);
                                        recog.op_multiple()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1053);
                                        recog.inline_expression_rec(16)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IPlusContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1055);
                                        if !({ recog.precpred(None, 14) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 14)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(1056);
                                        recog.op_plus()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1057);
                                        recog.inline_expression_rec(15)?;
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ILogicContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1059);
                                        if !({ recog.precpred(None, 13) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 13)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(1060);
                                        recog.op_logic()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1061);
                                        recog.inline_expression_rec(14)?;
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ICompareContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1063);
                                        if !({ recog.precpred(None, 12) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 12)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1064);
                                        recog.op_compare()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1065);
                                        recog.inline_expression_rec(13)?;
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IIsAContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1067);
                                        if !({ recog.precpred(None, 11) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 11)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1071);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        match recog.interpreter.adaptive_predict(134, &mut recog.base)? {
                                            1 => {
                                                recog.base.set_state(1068);
                                                recog.base.match_token(KW_IS, &mut recog.err_handler)?;
                                            }
                                            2 => {
                                                recog.base.set_state(1069);
                                                recog.base.match_token(KW_IS, &mut recog.err_handler)?;

                                                recog.base.set_state(1070);
                                                recog.base.match_token(KW_NOT, &mut recog.err_handler)?;
                                            }

                                            _ => {}
                                        }
                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1073);
                                        recog.inline_expression_rec(12)?;
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IRangeContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1074);
                                        if !({ recog.precpred(None, 10) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 10)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1075);
                                        recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1076);
                                        recog.inline_expression_rec(11)?;
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IAsContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1077);
                                        if !({ recog.precpred(None, 9) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 9)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1078);
                                        recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1079);
                                        recog.inline_expression_rec(10)?;
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IDotContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1080);
                                        if !({ recog.precpred(None, 17) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 17)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule dot_call */
                                        recog.base.set_state(1081);
                                        recog.dot_call()?;
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ISliceContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1082);
                                        if !({ recog.precpred(None, 16) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 16)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule slice_call */
                                        recog.base.set_state(1083);
                                        recog.slice_call()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1088);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(136, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- type_expression ----------------
#[derive(Debug)]
pub enum Type_expressionContextAll<'input> {
    TSpecialContext(TSpecialContext<'input>),
    TStrigContext(TStrigContext<'input>),
    TNumberContext(TNumberContext<'input>),
    TNamepathContext(TNamepathContext<'input>),
    TGenericContext(TGenericContext<'input>),
    TPatternContext(TPatternContext<'input>),
    TTupleContext(TTupleContext<'input>),
    TAddContext(TAddContext<'input>),
    TArrowsContext(TArrowsContext<'input>),
    Error(Type_expressionContext<'input>),
}
antlr_rust::tid! {Type_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Type_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContextAll<'input> {}

impl<'input> Deref for Type_expressionContextAll<'input> {
    type Target = dyn Type_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Type_expressionContextAll::*;
        match self {
            TSpecialContext(inner) => inner,
            TStrigContext(inner) => inner,
            TNumberContext(inner) => inner,
            TNamepathContext(inner) => inner,
            TGenericContext(inner) => inner,
            TPatternContext(inner) => inner,
            TTupleContext(inner) => inner,
            TAddContext(inner) => inner,
            TArrowsContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Type_expressionContext<'input> = BaseParserRuleContext<'input, Type_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Type_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Type_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}
antlr_rust::tid! {Type_expressionContextExt<'a>}

impl<'input> Type_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Type_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Type_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Type_expressionContextExt<'input>>
{
}

impl<'input> Type_expressionContextAttrs<'input> for Type_expressionContext<'input> {}

pub type TSpecialContext<'input> = BaseParserRuleContext<'input, TSpecialContextExt<'input>>;

pub trait TSpecialContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> TSpecialContextAttrs<'input> for TSpecialContext<'input> {}

pub struct TSpecialContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TSpecialContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TSpecialContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TSpecialContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TSpecial(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TSpecial(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TSpecialContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TSpecial(self);
    }
}

impl<'input> CustomRuleContext<'input> for TSpecialContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TSpecialContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TSpecialContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TSpecialContext<'input> {}

impl<'input> TSpecialContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TSpecialContext(BaseParserRuleContext::copy_from(
            ctx,
            TSpecialContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TStrigContext<'input> = BaseParserRuleContext<'input, TStrigContextExt<'input>>;

pub trait TStrigContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TStrigContextAttrs<'input> for TStrigContext<'input> {}

pub struct TStrigContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TStrigContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TStrigContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TStrigContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TStrig(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TStrig(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TStrigContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TStrig(self);
    }
}

impl<'input> CustomRuleContext<'input> for TStrigContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TStrigContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TStrigContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TStrigContext<'input> {}

impl<'input> TStrigContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TStrigContext(BaseParserRuleContext::copy_from(
            ctx,
            TStrigContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TNumberContext<'input> = BaseParserRuleContext<'input, TNumberContextExt<'input>>;

pub trait TNumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TNumberContextAttrs<'input> for TNumberContext<'input> {}

pub struct TNumberContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TNumberContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TNumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TNumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TNumber(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TNumber(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TNumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TNumber(self);
    }
}

impl<'input> CustomRuleContext<'input> for TNumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TNumberContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TNumberContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TNumberContext<'input> {}

impl<'input> TNumberContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TNumberContext(BaseParserRuleContext::copy_from(
            ctx,
            TNumberContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TNamepathContext<'input> = BaseParserRuleContext<'input, TNamepathContextExt<'input>>;

pub trait TNamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TNamepathContextAttrs<'input> for TNamepathContext<'input> {}

pub struct TNamepathContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TNamepathContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TNamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TNamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TNamepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TNamepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TNamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TNamepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for TNamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TNamepathContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TNamepathContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TNamepathContext<'input> {}

impl<'input> TNamepathContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TNamepathContext(BaseParserRuleContext::copy_from(
            ctx,
            TNamepathContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TGenericContext<'input> = BaseParserRuleContext<'input, TGenericContextExt<'input>>;

pub trait TGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TGenericContextAttrs<'input> for TGenericContext<'input> {}

pub struct TGenericContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for TGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TGenericContext<'input> {}

impl<'input> TGenericContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            TGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TPatternContext<'input> = BaseParserRuleContext<'input, TPatternContextExt<'input>>;

pub trait TPatternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_pattern(&self) -> Option<Rc<Op_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TPatternContextAttrs<'input> for TPatternContext<'input> {}

pub struct TPatternContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TPatternContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TPatternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TPattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TPattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TPatternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TPattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for TPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TPatternContext<'input> {}

impl<'input> TPatternContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TPatternContext(BaseParserRuleContext::copy_from(
            ctx,
            TPatternContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TTupleContext<'input> = BaseParserRuleContext<'input, TTupleContextExt<'input>>;

pub trait TTupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> TTupleContextAttrs<'input> for TTupleContext<'input> {}

pub struct TTupleContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TTupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TTupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TTupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TTuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TTuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TTupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TTuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for TTupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TTupleContext<'input> {}

impl<'input> TTupleContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TTupleContext(BaseParserRuleContext::copy_from(
            ctx,
            TTupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TAddContext<'input> = BaseParserRuleContext<'input, TAddContextExt<'input>>;

pub trait TAddContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> TAddContextAttrs<'input> for TAddContext<'input> {}

pub struct TAddContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TAddContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TAddContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TAddContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TAdd(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TAdd(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TAddContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TAdd(self);
    }
}

impl<'input> CustomRuleContext<'input> for TAddContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TAddContext<'input> {}

impl<'input> TAddContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TAddContext(BaseParserRuleContext::copy_from(
            ctx,
            TAddContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TArrowsContext<'input> = BaseParserRuleContext<'input, TArrowsContextExt<'input>>;

pub trait TArrowsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn infix_arrows(&self) -> Option<Rc<Infix_arrowsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TArrowsContextAttrs<'input> for TArrowsContext<'input> {}

pub struct TArrowsContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TArrowsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TArrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TArrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TArrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TArrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TArrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TArrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for TArrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TArrowsContext<'input> {}

impl<'input> TArrowsContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TArrowsContext(BaseParserRuleContext::copy_from(
            ctx,
            TArrowsContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_expression(&mut self) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        self.type_expression_rec(0)
    }

    fn type_expression_rec(&mut self, _p: isize) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Type_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 118, RULE_type_expression, _p);
        let mut _localctx: Rc<Type_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 118;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1111);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(140, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = TTupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            recog.base.set_state(1090);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            recog.base.set_state(1104);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(139, &mut recog.base)? {
                                x if x == 1 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1091);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1092);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }

                                x if x == 2 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1094);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1097);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = 1;
                                        loop {
                                            match _alt {
                                                x if x == 1 => {
                                                    {
                                                        recog.base.set_state(1095);
                                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                        /* InvokeRule type_expression */
                                                        recog.base.set_state(1096);
                                                        recog.type_expression_rec(0)?;
                                                    }
                                                }

                                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                            }
                                            recog.base.set_state(1099);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _alt = recog.interpreter.adaptive_predict(137, &mut recog.base)?;
                                            if _alt == 2 || _alt == INVALID_ALT {
                                                break;
                                            }
                                        }
                                        recog.base.set_state(1102);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == COMMA {
                                            {
                                                recog.base.set_state(1101);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                            }
                                        }
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(1106);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = TStrigContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule string_literal */
                            recog.base.set_state(1107);
                            recog.string_literal()?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = TNumberContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule number_literal */
                            recog.base.set_state(1108);
                            recog.number_literal()?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = TNamepathContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule namepath */
                            recog.base.set_state(1109);
                            recog.namepath()?;
                        }
                    }
                    5 => {
                        let mut tmp = TSpecialContextExt::new(&**_localctx);
                        recog.ctx = Some(tmp.clone());
                        _localctx = tmp;
                        _prevctx = _localctx.clone();
                        recog.base.set_state(1110);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1128);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(142, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1126);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(141, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TPatternContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1113);
                                        if !({ recog.precpred(None, 9) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 9)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_pattern */
                                        recog.base.set_state(1114);
                                        recog.op_pattern()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1115);
                                        recog.type_expression_rec(10)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TArrowsContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1117);
                                        if !({ recog.precpred(None, 8) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 8)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_arrows */
                                        recog.base.set_state(1118);
                                        recog.infix_arrows()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1119);
                                        recog.type_expression_rec(9)?;
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TAddContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1121);
                                        if !({ recog.precpred(None, 7) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 7)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1122);
                                        recog.base.match_token(OP_ADD, &mut recog.err_handler)?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1123);
                                        recog.type_expression_rec(8)?;
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TGenericContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1124);
                                        if !({ recog.precpred(None, 6) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 6)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call_in_type */
                                        recog.base.set_state(1125);
                                        recog.generic_call_in_type()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1130);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(142, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- prefix_call ----------------
pub type Prefix_callContextAll<'input> = Prefix_callContext<'input>;

pub type Prefix_callContext<'input> = BaseParserRuleContext<'input, Prefix_callContextExt<'input>>;

#[derive(Clone)]
pub struct Prefix_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Prefix_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Prefix_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_prefix_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_prefix_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Prefix_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_prefix_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Prefix_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_prefix_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_prefix_call }
}
antlr_rust::tid! {Prefix_callContextExt<'a>}

impl<'input> Prefix_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Prefix_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Prefix_callContextExt { ph: PhantomData }))
    }
}

pub trait Prefix_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Prefix_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_NOT
    /// Returns `None` if there is no child corresponding to token OP_NOT
    fn OP_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REFERENCE
    /// Returns `None` if there is no child corresponding to token OP_REFERENCE
    fn OP_REFERENCE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REFERENCE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DECONSTRUCT
    /// Returns `None` if there is no child corresponding to token OP_DECONSTRUCT
    fn OP_DECONSTRUCT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DECONSTRUCT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_INVERSE
    /// Returns `None` if there is no child corresponding to token OP_INVERSE
    fn OP_INVERSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_INVERSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOTS
    /// Returns `None` if there is no child corresponding to token OP_ROOTS
    fn OP_ROOTS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOTS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Prefix_callContextAttrs<'input> for Prefix_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn prefix_call(&mut self) -> Result<Rc<Prefix_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Prefix_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_prefix_call);
        let mut _localctx: Rc<Prefix_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1131);
                _la = recog.base.input.la(1);
                if {
                    !((((_la) & !0x3f) == 0
                        && ((1usize << _la) & ((1usize << OP_ADD) | (1usize << OP_SUB) | (1usize << OP_MUL))) != 0)
                        || (((_la - 57) & !0x3f) == 0
                            && ((1usize << (_la - 57))
                                & ((1usize << (OP_AND - 57))
                                    | (1usize << (OP_NOT - 57))
                                    | (1usize << (OP_DECONSTRUCT - 57))
                                    | (1usize << (OP_INVERSE - 57))
                                    | (1usize << (OP_ROOTS - 57))
                                    | (1usize << (OP_REFERENCE - 57))))
                                != 0))
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- suffix_call ----------------
pub type Suffix_callContextAll<'input> = Suffix_callContext<'input>;

pub type Suffix_callContext<'input> = BaseParserRuleContext<'input, Suffix_callContextExt<'input>>;

#[derive(Clone)]
pub struct Suffix_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Suffix_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Suffix_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_suffix_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_suffix_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Suffix_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_suffix_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Suffix_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_suffix_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_suffix_call }
}
antlr_rust::tid! {Suffix_callContextExt<'a>}

impl<'input> Suffix_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Suffix_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Suffix_callContextExt { ph: PhantomData }))
    }
}

pub trait Suffix_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Suffix_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_NOT
    /// Returns `None` if there is no child corresponding to token OP_NOT
    fn OP_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TEMPERATURE
    /// Returns `None` if there is no child corresponding to token OP_TEMPERATURE
    fn OP_TEMPERATURE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TEMPERATURE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TRANSPOSE
    /// Returns `None` if there is no child corresponding to token OP_TRANSPOSE
    fn OP_TRANSPOSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TRANSPOSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PERCENT
    /// Returns `None` if there is no child corresponding to token OP_PERCENT
    fn OP_PERCENT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PERCENT, 0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn offset_call(&self) -> Option<Rc<Offset_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call(&self) -> Option<Rc<Generic_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn lambda_call(&self) -> Option<Rc<Lambda_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_call(&self) -> Option<Rc<Match_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn dot_call(&self) -> Option<Rc<Dot_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Suffix_callContextAttrs<'input> for Suffix_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn suffix_call(&mut self) -> Result<Rc<Suffix_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Suffix_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_suffix_call);
        let mut _localctx: Rc<Suffix_callContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1144);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(143, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1133);
                        recog.base.match_token(OP_NOT, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1134);
                        recog.base.match_token(OP_TEMPERATURE, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1135);
                        recog.base.match_token(OP_TRANSPOSE, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1136);
                        recog.base.match_token(OP_PERCENT, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule slice_call */
                        recog.base.set_state(1137);
                        recog.slice_call()?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule offset_call */
                        recog.base.set_state(1138);
                        recog.offset_call()?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule generic_call */
                        recog.base.set_state(1139);
                        recog.generic_call()?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        /* InvokeRule lambda_call */
                        recog.base.set_state(1140);
                        recog.lambda_call()?;
                    }
                }
                9 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 9);
                    recog.base.enter_outer_alt(None, 9);
                    {
                        /* InvokeRule match_call */
                        recog.base.set_state(1141);
                        recog.match_call()?;
                    }
                }
                10 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 10);
                    recog.base.enter_outer_alt(None, 10);
                    {
                        /* InvokeRule function_call */
                        recog.base.set_state(1142);
                        recog.function_call()?;
                    }
                }
                11 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 11);
                    recog.base.enter_outer_alt(None, 11);
                    {
                        /* InvokeRule dot_call */
                        recog.base.set_state(1143);
                        recog.dot_call()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- control_expression ----------------
pub type Control_expressionContextAll<'input> = Control_expressionContext<'input>;

pub type Control_expressionContext<'input> = BaseParserRuleContext<'input, Control_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Control_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Control_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Control_expressionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_control_expression(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_control_expression(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Control_expressionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_control_expression(self);
    }
}

impl<'input> CustomRuleContext<'input> for Control_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}
antlr_rust::tid! {Control_expressionContextExt<'a>}

impl<'input> Control_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Control_expressionContextExt { ph: PhantomData }))
    }
}

pub trait Control_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Control_expressionContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token RETURN
    /// Returns `None` if there is no child corresponding to token RETURN
    fn RETURN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token RESUME
    /// Returns `None` if there is no child corresponding to token RESUME
    fn RESUME(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESUME, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BREAK
    /// Returns `None` if there is no child corresponding to token BREAK
    fn BREAK(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BREAK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token CONTINUE
    /// Returns `None` if there is no child corresponding to token CONTINUE
    fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CONTINUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RAISE
    /// Returns `None` if there is no child corresponding to token RAISE
    fn RAISE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAISE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
}

impl<'input> Control_expressionContextAttrs<'input> for Control_expressionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn control_expression(&mut self) -> Result<Rc<Control_expressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Control_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_control_expression);
        let mut _localctx: Rc<Control_expressionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1177);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(149, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1146);
                        recog.base.match_token(RETURN, &mut recog.err_handler)?;

                        recog.base.set_state(1148);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(144, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule expression */
                                    recog.base.set_state(1147);
                                    recog.expression_rec(0)?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1150);
                        recog.base.match_token(RESUME, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1151);
                        recog.expression_rec(0)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1152);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;

                        recog.base.set_state(1155);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(145, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1153);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1154);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1157);
                        recog.base.match_token(CONTINUE, &mut recog.err_handler)?;

                        recog.base.set_state(1160);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(146, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1158);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1159);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1162);
                        recog.base.match_token(RAISE, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1163);
                        recog.expression_rec(0)?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        recog.base.set_state(1164);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1167);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(147, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1165);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1166);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(1170);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(148, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule expression */
                                    recog.base.set_state(1169);
                                    recog.expression_rec(0)?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        recog.base.set_state(1172);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1173);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1174);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1175);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1176);
                        recog.expression_rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_compare ----------------
pub type Op_compareContextAll<'input> = Op_compareContext<'input>;

pub type Op_compareContext<'input> = BaseParserRuleContext<'input, Op_compareContextExt<'input>>;

#[derive(Clone)]
pub struct Op_compareContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_compareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_compareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_compare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_compare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_compareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_compare(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_compareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_compare
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_compare }
}
antlr_rust::tid! {Op_compareContextExt<'a>}

impl<'input> Op_compareContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_compareContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_compareContextExt { ph: PhantomData }))
    }
}

pub trait Op_compareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_compareContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LEQ
    /// Returns `None` if there is no child corresponding to token OP_LEQ
    fn OP_LEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GEQ
    /// Returns `None` if there is no child corresponding to token OP_GEQ
    fn OP_GEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_EQ
    /// Returns `None` if there is no child corresponding to token OP_EQ
    fn OP_EQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_EQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NE
    /// Returns `None` if there is no child corresponding to token OP_NE
    fn OP_NE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NE, 0)
    }
}

impl<'input> Op_compareContextAttrs<'input> for Op_compareContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_compare(&mut self) -> Result<Rc<Op_compareContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_compareContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_op_compare);
        let mut _localctx: Rc<Op_compareContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1179);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 31) & !0x3f) == 0
                        && ((1usize << (_la - 31))
                            & ((1usize << (OP_EQ - 31))
                                | (1usize << (OP_NE - 31))
                                | (1usize << (OP_LEQ - 31))
                                | (1usize << (OP_LT - 31))
                                | (1usize << (OP_GEQ - 31))
                                | (1usize << (OP_GT - 31))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_pattern ----------------
pub type Op_patternContextAll<'input> = Op_patternContext<'input>;

pub type Op_patternContext<'input> = BaseParserRuleContext<'input, Op_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Op_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_pattern }
}
antlr_rust::tid! {Op_patternContextExt<'a>}

impl<'input> Op_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_patternContextExt { ph: PhantomData }))
    }
}

pub trait Op_patternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_patternContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
}

impl<'input> Op_patternContextAttrs<'input> for Op_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_pattern(&mut self) -> Result<Rc<Op_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_op_pattern);
        let mut _localctx: Rc<Op_patternContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1181);
                _la = recog.base.input.la(1);
                if { !(_la == OP_AND || _la == OP_OR) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_arrows ----------------
pub type Infix_arrowsContextAll<'input> = Infix_arrowsContext<'input>;

pub type Infix_arrowsContext<'input> = BaseParserRuleContext<'input, Infix_arrowsContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_arrowsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_arrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_arrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_arrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_arrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_arrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_arrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_arrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_arrows
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_arrows }
}
antlr_rust::tid! {Infix_arrowsContextExt<'a>}

impl<'input> Infix_arrowsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_arrowsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_arrowsContextExt { ph: PhantomData }))
    }
}

pub trait Infix_arrowsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_arrowsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW2
    /// Returns `None` if there is no child corresponding to token OP_ARROW2
    fn OP_ARROW2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW2, 0)
    }
}

impl<'input> Infix_arrowsContextAttrs<'input> for Infix_arrowsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_arrows(&mut self) -> Result<Rc<Infix_arrowsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_arrowsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_infix_arrows);
        let mut _localctx: Rc<Infix_arrowsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1183);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ARROW || _la == OP_ARROW2) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_multiple ----------------
pub type Op_multipleContextAll<'input> = Op_multipleContext<'input>;

pub type Op_multipleContext<'input> = BaseParserRuleContext<'input, Op_multipleContextExt<'input>>;

#[derive(Clone)]
pub struct Op_multipleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_multipleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_multipleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_multiple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_multiple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_multipleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_multiple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_multipleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_multiple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_multiple }
}
antlr_rust::tid! {Op_multipleContextExt<'a>}

impl<'input> Op_multipleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_multipleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_multipleContextExt { ph: PhantomData }))
    }
}

pub trait Op_multipleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Op_multipleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
}

impl<'input> Op_multipleContextAttrs<'input> for Op_multipleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_multiple(&mut self) -> Result<Rc<Op_multipleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_multipleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_op_multiple);
        let mut _localctx: Rc<Op_multipleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1185);
                _la = recog.base.input.la(1);
                if { !(_la == OP_MUL || _la == OP_DIV) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_plus ----------------
pub type Op_plusContextAll<'input> = Op_plusContext<'input>;

pub type Op_plusContext<'input> = BaseParserRuleContext<'input, Op_plusContextExt<'input>>;

#[derive(Clone)]
pub struct Op_plusContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_plusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_plusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_plus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_plus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_plusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_plus(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_plusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_plus
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_plus }
}
antlr_rust::tid! {Op_plusContextExt<'a>}

impl<'input> Op_plusContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_plusContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_plusContextExt { ph: PhantomData }))
    }
}

pub trait Op_plusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_plusContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
}

impl<'input> Op_plusContextAttrs<'input> for Op_plusContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_plus(&mut self) -> Result<Rc<Op_plusContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_plusContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_op_plus);
        let mut _localctx: Rc<Op_plusContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1187);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ADD || _la == OP_SUB) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_logic ----------------
pub type Op_logicContextAll<'input> = Op_logicContext<'input>;

pub type Op_logicContext<'input> = BaseParserRuleContext<'input, Op_logicContextExt<'input>>;

#[derive(Clone)]
pub struct Op_logicContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_logicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_logicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_logic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_logic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_logicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_logic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_logicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_logic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_logic }
}
antlr_rust::tid! {Op_logicContextExt<'a>}

impl<'input> Op_logicContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_logicContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_logicContextExt { ph: PhantomData }))
    }
}

pub trait Op_logicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_logicContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token LOGIC_OR
    /// Returns `None` if there is no child corresponding to token LOGIC_OR
    fn LOGIC_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_AND
    /// Returns `None` if there is no child corresponding to token LOGIC_AND
    fn LOGIC_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_XOR
    /// Returns `None` if there is no child corresponding to token LOGIC_XOR
    fn LOGIC_XOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_XOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NOR
    /// Returns `None` if there is no child corresponding to token LOGIC_NOR
    fn LOGIC_NOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NAND
    /// Returns `None` if there is no child corresponding to token LOGIC_NAND
    fn LOGIC_NAND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NAND, 0)
    }
}

impl<'input> Op_logicContextAttrs<'input> for Op_logicContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_logic(&mut self) -> Result<Rc<Op_logicContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_logicContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_op_logic);
        let mut _localctx: Rc<Op_logicContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1189);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 52) & !0x3f) == 0
                        && ((1usize << (_la - 52))
                            & ((1usize << (LOGIC_AND - 52))
                                | (1usize << (LOGIC_OR - 52))
                                | (1usize << (LOGIC_XOR - 52))
                                | (1usize << (LOGIC_NOR - 52))
                                | (1usize << (LOGIC_NAND - 52))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_assign ----------------
pub type Op_assignContextAll<'input> = Op_assignContext<'input>;

pub type Op_assignContext<'input> = BaseParserRuleContext<'input, Op_assignContextExt<'input>>;

#[derive(Clone)]
pub struct Op_assignContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_assignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_assignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_assign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_assign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_assignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_assign(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_assignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_assign
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_assign }
}
antlr_rust::tid! {Op_assignContextExt<'a>}

impl<'input> Op_assignContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_assignContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_assignContextExt { ph: PhantomData }))
    }
}

pub trait Op_assignContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_assignContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ADD_ASSIGN
    fn OP_ADD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_SUB_ASSIGN
    fn OP_SUB_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MUL_ASSIGN
    fn OP_MUL_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_DIV_ASSIGN
    fn OP_DIV_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MAY_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MAY_ASSIGN
    fn OP_MAY_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MAY_ASSIGN, 0)
    }
}

impl<'input> Op_assignContextAttrs<'input> for Op_assignContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_assign(&mut self) -> Result<Rc<Op_assignContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_assignContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_op_assign);
        let mut _localctx: Rc<Op_assignContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1191);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 44) & !0x3f) == 0
                        && ((1usize << (_la - 44))
                            & ((1usize << (OP_ASSIGN - 44))
                                | (1usize << (OP_MAY_ASSIGN - 44))
                                | (1usize << (OP_ADD_ASSIGN - 44))
                                | (1usize << (OP_SUB_ASSIGN - 44))
                                | (1usize << (OP_MUL_ASSIGN - 44))
                                | (1usize << (OP_DIV_ASSIGN - 44))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_is ----------------
pub type Infix_isContextAll<'input> = Infix_isContext<'input>;

pub type Infix_isContext<'input> = BaseParserRuleContext<'input, Infix_isContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_isContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_isContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_isContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_is(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_is(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_isContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_is(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_isContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_is
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_is }
}
antlr_rust::tid! {Infix_isContextExt<'a>}

impl<'input> Infix_isContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_isContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_isContextExt { ph: PhantomData }))
    }
}

pub trait Infix_isContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_isContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IS
    /// Returns `None` if there is no child corresponding to token KW_IS
    fn KW_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
}

impl<'input> Infix_isContextAttrs<'input> for Infix_isContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_is(&mut self) -> Result<Rc<Infix_isContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_isContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_infix_is);
        let mut _localctx: Rc<Infix_isContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1196);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(150, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1193);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1194);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;

                        recog.base.set_state(1195);
                        recog.base.match_token(KW_NOT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_in ----------------
pub type Infix_inContextAll<'input> = Infix_inContext<'input>;

pub type Infix_inContext<'input> = BaseParserRuleContext<'input, Infix_inContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_inContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_inContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_inContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_in(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_in(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_inContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_in(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_inContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_in
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_in }
}
antlr_rust::tid! {Infix_inContextExt<'a>}

impl<'input> Infix_inContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_inContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_inContextExt { ph: PhantomData }))
    }
}

pub trait Infix_inContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_inContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IN
    /// Returns `None` if there is no child corresponding to token KW_IN
    fn KW_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IN
    /// Returns `None` if there is no child corresponding to token OP_IN
    fn OP_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IN, 0)
    }
}

impl<'input> Infix_inContextAttrs<'input> for Infix_inContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_in(&mut self) -> Result<Rc<Infix_inContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_inContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_infix_in);
        let mut _localctx: Rc<Infix_inContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1198);
                _la = recog.base.input.la(1);
                if { !(_la == OP_IN || _la == KW_IN) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_generic ----------------
pub type Define_genericContextAll<'input> = Define_genericContext<'input>;

pub type Define_genericContext<'input> = BaseParserRuleContext<'input, Define_genericContextExt<'input>>;

#[derive(Clone)]
pub struct Define_genericContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_genericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_genericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_generic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_generic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_genericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_generic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_genericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_generic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_generic }
}
antlr_rust::tid! {Define_genericContextExt<'a>}

impl<'input> Define_genericContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_genericContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_genericContextExt { ph: PhantomData }))
    }
}

pub trait Define_genericContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_genericContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
    fn generic_item_all(&self) -> Vec<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_item(&self, i: usize) -> Option<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
}

impl<'input> Define_genericContextAttrs<'input> for Define_genericContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_generic(&mut self) -> Result<Rc<Define_genericContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_genericContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_define_generic);
        let mut _localctx: Rc<Define_genericContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1238);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(157, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1200);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1201);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1202);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1203);
                        recog.generic_item()?;

                        recog.base.set_state(1208);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(151, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1204);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1205);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1210);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(151, &mut recog.base)?;
                        }
                        recog.base.set_state(1212);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1211);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1214);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1217);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1216);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1219);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1220);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1222);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1221);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1224);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1225);
                        recog.generic_item()?;

                        recog.base.set_state(1230);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(155, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1226);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1227);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1232);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(155, &mut recog.base)?;
                        }
                        recog.base.set_state(1234);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1233);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1236);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_item ----------------
pub type Generic_itemContextAll<'input> = Generic_itemContext<'input>;

pub type Generic_itemContext<'input> = BaseParserRuleContext<'input, Generic_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_item }
}
antlr_rust::tid! {Generic_itemContextExt<'a>}

impl<'input> Generic_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_itemContextExt { ph: PhantomData }))
    }
}

pub trait Generic_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_itemContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_itemContextAttrs<'input> for Generic_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_item(&mut self) -> Result<Rc<Generic_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_generic_item);
        let mut _localctx: Rc<Generic_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1243);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(158, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1240);
                            recog.identifier()?;

                            recog.base.set_state(1241);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1245);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call ----------------
pub type Generic_callContextAll<'input> = Generic_callContext<'input>;

pub type Generic_callContext<'input> = BaseParserRuleContext<'input, Generic_callContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call }
}
antlr_rust::tid! {Generic_callContextExt<'a>}

impl<'input> Generic_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_callContextExt { ph: PhantomData }))
    }
}

pub trait Generic_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_callContextAttrs<'input> for Generic_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call(&mut self) -> Result<Rc<Generic_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_generic_call);
        let mut _localctx: Rc<Generic_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1281);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(163, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1247);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1248);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1249);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1250);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1251);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1252);
                        recog.generic_pair()?;

                        recog.base.set_state(1257);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(159, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1253);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1254);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1259);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(159, &mut recog.base)?;
                        }
                        recog.base.set_state(1261);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1260);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1263);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1265);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1266);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1267);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1268);
                        recog.generic_pair()?;

                        recog.base.set_state(1273);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(161, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1269);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1270);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1275);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(161, &mut recog.base)?;
                        }
                        recog.base.set_state(1277);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1276);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1279);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call_in_type ----------------
pub type Generic_call_in_typeContextAll<'input> = Generic_call_in_typeContext<'input>;

pub type Generic_call_in_typeContext<'input> = BaseParserRuleContext<'input, Generic_call_in_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_call_in_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call_in_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call_in_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call_in_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_call_in_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call_in_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call_in_type }
}
antlr_rust::tid! {Generic_call_in_typeContextExt<'a>}

impl<'input> Generic_call_in_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_call_in_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Generic_call_in_typeContextExt { ph: PhantomData },
        ))
    }
}

pub trait Generic_call_in_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_call_in_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_call_in_typeContextAttrs<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call_in_type(&mut self) -> Result<Rc<Generic_call_in_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_call_in_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_generic_call_in_type);
        let mut _localctx: Rc<Generic_call_in_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1308);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_PROPORTION | OP_LT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1284);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1283);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1286);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1287);
                        recog.generic_pair()?;

                        recog.base.set_state(1292);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1288);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1289);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1294);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1295);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                GENERIC_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1297);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1298);
                        recog.generic_pair()?;

                        recog.base.set_state(1303);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1299);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1300);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1305);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1306);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_pair ----------------
pub type Generic_pairContextAll<'input> = Generic_pairContext<'input>;

pub type Generic_pairContext<'input> = BaseParserRuleContext<'input, Generic_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_pair }
}
antlr_rust::tid! {Generic_pairContextExt<'a>}

impl<'input> Generic_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_pairContextExt { ph: PhantomData }))
    }
}

pub trait Generic_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_pairContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_pairContextAttrs<'input> for Generic_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_pair(&mut self) -> Result<Rc<Generic_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_generic_pair);
        let mut _localctx: Rc<Generic_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1313);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(168, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1310);
                            recog.identifier()?;

                            recog.base.set_state(1311);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1315);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_label ----------------
pub type Define_labelContextAll<'input> = Define_labelContext<'input>;

pub type Define_labelContext<'input> = BaseParserRuleContext<'input, Define_labelContextExt<'input>>;

#[derive(Clone)]
pub struct Define_labelContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_labelContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_labelContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_label(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_label(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_labelContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_label(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_labelContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_label
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_label }
}
antlr_rust::tid! {Define_labelContextExt<'a>}

impl<'input> Define_labelContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_labelContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_labelContextExt { ph: PhantomData }))
    }
}

pub trait Define_labelContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_labelContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_labelContextAttrs<'input> for Define_labelContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_label(&mut self) -> Result<Rc<Define_labelContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_labelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_define_label);
        let mut _localctx: Rc<Define_labelContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1317);
                recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(1318);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- offset_call ----------------
pub type Offset_callContextAll<'input> = Offset_callContext<'input>;

pub type Offset_callContext<'input> = BaseParserRuleContext<'input, Offset_callContextExt<'input>>;

#[derive(Clone)]
pub struct Offset_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Offset_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Offset_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_offset_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_offset_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Offset_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_offset_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Offset_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_offset_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_offset_call }
}
antlr_rust::tid! {Offset_callContextExt<'a>}

impl<'input> Offset_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Offset_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Offset_callContextExt { ph: PhantomData }))
    }
}

pub trait Offset_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Offset_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_L
    /// Returns `None` if there is no child corresponding to token OFFSET_L
    fn OFFSET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_R
    /// Returns `None` if there is no child corresponding to token OFFSET_R
    fn OFFSET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_R, 0)
    }
}

impl<'input> Offset_callContextAttrs<'input> for Offset_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn offset_call(&mut self) -> Result<Rc<Offset_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Offset_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_offset_call);
        let mut _localctx: Rc<Offset_callContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1329);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_PROPORTION => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1320);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1321);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1322);
                        recog.expression_rec(0)?;

                        recog.base.set_state(1323);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                OFFSET_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1325);
                        recog.base.match_token(OFFSET_L, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1326);
                        recog.expression_rec(0)?;

                        recog.base.set_state(1327);
                        recog.base.match_token(OFFSET_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_call ----------------
pub type Template_callContextAll<'input> = Template_callContext<'input>;

pub type Template_callContext<'input> = BaseParserRuleContext<'input, Template_callContextExt<'input>>;

#[derive(Clone)]
pub struct Template_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_call }
}
antlr_rust::tid! {Template_callContextExt<'a>}

impl<'input> Template_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_callContextExt { ph: PhantomData }))
    }
}

pub trait Template_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_callContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TEMPLATE
    /// Returns `None` if there is no child corresponding to token KW_TEMPLATE
    fn KW_TEMPLATE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TEMPLATE, 0)
    }
    fn template_block(&self) -> Option<Rc<Template_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Template_callContextAttrs<'input> for Template_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_call(&mut self) -> Result<Rc<Template_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_template_call);
        let mut _localctx: Rc<Template_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1362);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(174, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1334);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1331);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1336);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1337);
                        recog.modifiers()?;

                        recog.base.set_state(1338);
                        recog.base.match_token(KW_TEMPLATE, &mut recog.err_handler)?;

                        /* InvokeRule template_block */
                        recog.base.set_state(1339);
                        recog.template_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1344);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1341);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1346);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1347);
                        recog.modifiers()?;

                        recog.base.set_state(1348);
                        recog.base.match_token(KW_TEMPLATE, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1349);
                        recog.identifier()?;

                        recog.base.set_state(1354);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(172, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1350);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule identifier */
                                        recog.base.set_state(1351);
                                        recog.identifier()?;
                                    }
                                }
                            }
                            recog.base.set_state(1356);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(172, &mut recog.base)?;
                        }
                        recog.base.set_state(1358);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1357);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule template_block */
                        recog.base.set_state(1360);
                        recog.template_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_block ----------------
pub type Template_blockContextAll<'input> = Template_blockContext<'input>;

pub type Template_blockContext<'input> = BaseParserRuleContext<'input, Template_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Template_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_block }
}
antlr_rust::tid! {Template_blockContextExt<'a>}

impl<'input> Template_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_blockContextExt { ph: PhantomData }))
    }
}

pub trait Template_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn tempalte_terms_all(&self) -> Vec<Rc<Tempalte_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tempalte_terms(&self, i: usize) -> Option<Rc<Tempalte_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Template_blockContextAttrs<'input> for Template_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_block(&mut self) -> Result<Rc<Template_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_template_block);
        let mut _localctx: Rc<Template_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1364);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1368);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == KW_WHERE {
                    {
                        {
                            /* InvokeRule tempalte_terms */
                            recog.base.set_state(1365);
                            recog.tempalte_terms()?;
                        }
                    }
                    recog.base.set_state(1370);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1371);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tempalte_terms ----------------
pub type Tempalte_termsContextAll<'input> = Tempalte_termsContext<'input>;

pub type Tempalte_termsContext<'input> = BaseParserRuleContext<'input, Tempalte_termsContextExt<'input>>;

#[derive(Clone)]
pub struct Tempalte_termsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tempalte_termsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tempalte_termsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tempalte_terms(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tempalte_terms(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tempalte_termsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tempalte_terms(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tempalte_termsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tempalte_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tempalte_terms }
}
antlr_rust::tid! {Tempalte_termsContextExt<'a>}

impl<'input> Tempalte_termsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tempalte_termsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tempalte_termsContextExt { ph: PhantomData }))
    }
}

pub trait Tempalte_termsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tempalte_termsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_WHERE
    /// Returns `None` if there is no child corresponding to token KW_WHERE
    fn KW_WHERE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHERE, 0)
    }
    fn where_block(&self) -> Option<Rc<Where_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Tempalte_termsContextAttrs<'input> for Tempalte_termsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tempalte_terms(&mut self) -> Result<Rc<Tempalte_termsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tempalte_termsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_tempalte_terms);
        let mut _localctx: Rc<Tempalte_termsContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1376);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                KW_WHERE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1373);
                        recog.base.match_token(KW_WHERE, &mut recog.err_handler)?;

                        /* InvokeRule where_block */
                        recog.base.set_state(1374);
                        recog.where_block()?;
                    }
                }

                COMMA | SEMICOLON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(1375);
                        recog.eos_free()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_block ----------------
pub type Where_blockContextAll<'input> = Where_blockContext<'input>;

pub type Where_blockContext<'input> = BaseParserRuleContext<'input, Where_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Where_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_block }
}
antlr_rust::tid! {Where_blockContextExt<'a>}

impl<'input> Where_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_blockContextExt { ph: PhantomData }))
    }
}

pub trait Where_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn where_bound_all(&self) -> Vec<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn where_bound(&self, i: usize) -> Option<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Where_blockContextAttrs<'input> for Where_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_block(&mut self) -> Result<Rc<Where_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_where_block);
        let mut _localctx: Rc<Where_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1378);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1382);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA || _la == SEMICOLON || _la == RAW_ID || _la == UNICODE_ID {
                    {
                        {
                            /* InvokeRule where_bound */
                            recog.base.set_state(1379);
                            recog.where_bound()?;
                        }
                    }
                    recog.base.set_state(1384);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1385);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_bound ----------------
pub type Where_boundContextAll<'input> = Where_boundContext<'input>;

pub type Where_boundContext<'input> = BaseParserRuleContext<'input, Where_boundContextExt<'input>>;

#[derive(Clone)]
pub struct Where_boundContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_boundContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_boundContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_bound(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_bound(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_boundContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_bound(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_boundContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_bound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_bound }
}
antlr_rust::tid! {Where_boundContextExt<'a>}

impl<'input> Where_boundContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_boundContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_boundContextExt { ph: PhantomData }))
    }
}

pub trait Where_boundContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_boundContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Where_boundContextAttrs<'input> for Where_boundContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_bound(&mut self) -> Result<Rc<Where_boundContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_boundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_where_bound);
        let mut _localctx: Rc<Where_boundContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1392);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                RAW_ID | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1387);
                        recog.identifier()?;

                        recog.base.set_state(1388);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1389);
                        recog.type_expression_rec(0)?;
                    }
                }

                COMMA | SEMICOLON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(1391);
                        recog.eos_free()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- macro_call ----------------
pub type Macro_callContextAll<'input> = Macro_callContext<'input>;

pub type Macro_callContext<'input> = BaseParserRuleContext<'input, Macro_callContextExt<'input>>;

#[derive(Clone)]
pub struct Macro_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Macro_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Macro_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_macro_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_macro_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Macro_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_macro_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Macro_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_macro_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_macro_call }
}
antlr_rust::tid! {Macro_callContextExt<'a>}

impl<'input> Macro_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Macro_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Macro_callContextExt { ph: PhantomData }))
    }
}

pub trait Macro_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Macro_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn annotation_call_item(&self) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Macro_callContextAttrs<'input> for Macro_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn macro_call(&mut self) -> Result<Rc<Macro_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Macro_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_macro_call);
        let mut _localctx: Rc<Macro_callContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1394);
                recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                /* InvokeRule annotation_call_item */
                recog.base.set_state(1395);
                recog.annotation_call_item()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;

pub type AnnotationContext<'input> = BaseParserRuleContext<'input, AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for AnnotationContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AnnotationContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AnnotationContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation(self);
    }
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::tid! {AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AnnotationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, AnnotationContextExt { ph: PhantomData }))
    }
}

pub trait AnnotationContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<AnnotationContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn annotation_call_item_all(&self) -> Vec<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation_call_item(&self, i: usize) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation(&mut self) -> Result<Rc<AnnotationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1411);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(180, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1397);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1398);
                        recog.annotation_call_item()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1399);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        recog.base.set_state(1400);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1401);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1406);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1402);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule annotation_call_item */
                                    recog.base.set_state(1403);
                                    recog.annotation_call_item()?;
                                }
                            }
                            recog.base.set_state(1408);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1409);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation_call_item ----------------
pub type Annotation_call_itemContextAll<'input> = Annotation_call_itemContext<'input>;

pub type Annotation_call_itemContext<'input> = BaseParserRuleContext<'input, Annotation_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Annotation_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Annotation_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Annotation_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation_call_item }
}
antlr_rust::tid! {Annotation_call_itemContextExt<'a>}

impl<'input> Annotation_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Annotation_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Annotation_call_itemContextExt { ph: PhantomData },
        ))
    }
}

pub trait Annotation_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Annotation_call_itemContextExt<'input>>
{
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Annotation_call_itemContextAttrs<'input> for Annotation_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation_call_item(&mut self) -> Result<Rc<Annotation_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Annotation_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_annotation_call_item);
        let mut _localctx: Rc<Annotation_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule namepath */
                recog.base.set_state(1413);
                recog.namepath()?;

                recog.base.set_state(1415);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(181, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule tuple_call_body */
                            recog.base.set_state(1414);
                            recog.tuple_call_body()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1418);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(182, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule class_block */
                            recog.base.set_state(1417);
                            recog.class_block()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- try_statement ----------------
pub type Try_statementContextAll<'input> = Try_statementContext<'input>;

pub type Try_statementContext<'input> = BaseParserRuleContext<'input, Try_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Try_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Try_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Try_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_try_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_try_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Try_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_try_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Try_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_try_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_try_statement }
}
antlr_rust::tid! {Try_statementContextExt<'a>}

impl<'input> Try_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Try_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Try_statementContextExt { ph: PhantomData }))
    }
}

pub trait Try_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Try_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TRY
    /// Returns `None` if there is no child corresponding to token KW_TRY
    fn KW_TRY(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRY, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Try_statementContextAttrs<'input> for Try_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn try_statement(&mut self) -> Result<Rc<Try_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Try_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_try_statement);
        let mut _localctx: Rc<Try_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1423);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1420);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1425);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1426);
                recog.base.match_token(KW_TRY, &mut recog.err_handler)?;

                recog.base.set_state(1428);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L
                    || (((_la - 116) & !0x3f) == 0
                        && ((1usize << (_la - 116))
                            & ((1usize << (INTEGER - 116))
                                | (1usize << (DECIMAL - 116))
                                | (1usize << (STRING_SINGLE - 116))
                                | (1usize << (STRING_DOUBLE - 116))
                                | (1usize << (STRING_BLOCK - 116))
                                | (1usize << (SPECIAL - 116))
                                | (1usize << (RAW_ID - 116))
                                | (1usize << (UNICODE_ID - 116))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(1427);
                        recog.type_expression_rec(0)?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(1430);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_statement ----------------
pub type Match_statementContextAll<'input> = Match_statementContext<'input>;

pub type Match_statementContext<'input> = BaseParserRuleContext<'input, Match_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Match_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_statement }
}
antlr_rust::tid! {Match_statementContextExt<'a>}

impl<'input> Match_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_statementContextExt { ph: PhantomData }))
    }
}

pub trait Match_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_statementContextExt<'input>>
{
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
}

impl<'input> Match_statementContextAttrs<'input> for Match_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_statement(&mut self) -> Result<Rc<Match_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_match_statement);
        let mut _localctx: Rc<Match_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1435);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1432);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1437);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1438);
                _la = recog.base.input.la(1);
                if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(1442);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(186, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1439);
                            recog.identifier()?;

                            recog.base.set_state(1440);
                            recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule inline_expression */
                recog.base.set_state(1444);
                recog.inline_expression_rec(0)?;

                /* InvokeRule match_block */
                recog.base.set_state(1445);
                recog.match_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_call ----------------
pub type Match_callContextAll<'input> = Match_callContext<'input>;

pub type Match_callContext<'input> = BaseParserRuleContext<'input, Match_callContextExt<'input>>;

#[derive(Clone)]
pub struct Match_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_call }
}
antlr_rust::tid! {Match_callContextExt<'a>}

impl<'input> Match_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_callContextExt { ph: PhantomData }))
    }
}

pub trait Match_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Match_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Match_callContextAttrs<'input> for Match_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_call(&mut self) -> Result<Rc<Match_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_match_call);
        let mut _localctx: Rc<Match_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1448);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(1447);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                recog.base.set_state(1450);
                recog.base.match_token(DOT, &mut recog.err_handler)?;

                recog.base.set_state(1451);
                _la = recog.base.input.la(1);
                if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(1457);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == KW_AS {
                    {
                        recog.base.set_state(1452);
                        recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1453);
                        recog.identifier()?;

                        recog.base.set_state(1455);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON || _la == OP_ARROW {
                            {
                                /* InvokeRule type_hint */
                                recog.base.set_state(1454);
                                recog.type_hint()?;
                            }
                        }
                    }
                }

                /* InvokeRule match_block */
                recog.base.set_state(1459);
                recog.match_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_block ----------------
pub type Match_blockContextAll<'input> = Match_blockContext<'input>;

pub type Match_blockContext<'input> = BaseParserRuleContext<'input, Match_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_block }
}
antlr_rust::tid! {Match_blockContextExt<'a>}

impl<'input> Match_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn match_terms_all(&self) -> Vec<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn match_terms(&self, i: usize) -> Option<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_blockContextAttrs<'input> for Match_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_block(&mut self) -> Result<Rc<Match_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_match_block);
        let mut _localctx: Rc<Match_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1461);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1465);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == COMMA
                    || _la == SEMICOLON
                    || _la == OP_HASH
                    || (((_la - 97) & !0x3f) == 0
                        && ((1usize << (_la - 97))
                            & ((1usize << (KW_TYPE - 97))
                                | (1usize << (KW_WITH - 97))
                                | (1usize << (KW_CASE - 97))
                                | (1usize << (KW_WHEN - 97))
                                | (1usize << (KW_ELSE - 97))))
                            != 0)
                {
                    {
                        {
                            /* InvokeRule match_terms */
                            recog.base.set_state(1462);
                            recog.match_terms()?;
                        }
                    }
                    recog.base.set_state(1467);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1468);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_terms ----------------
#[derive(Debug)]
pub enum Match_termsContextAll<'input> {
    MatchWhenContext(MatchWhenContext<'input>),
    MatchTypeContext(MatchTypeContext<'input>),
    MatchCaseContext(MatchCaseContext<'input>),
    MatchWithContext(MatchWithContext<'input>),
    MatchWithManyContext(MatchWithManyContext<'input>),
    MatchElseContext(MatchElseContext<'input>),
    MatchSkipContext(MatchSkipContext<'input>),
    Error(Match_termsContext<'input>),
}
antlr_rust::tid! {Match_termsContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Match_termsContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContextAll<'input> {}

impl<'input> Deref for Match_termsContextAll<'input> {
    type Target = dyn Match_termsContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Match_termsContextAll::*;
        match self {
            MatchWhenContext(inner) => inner,
            MatchTypeContext(inner) => inner,
            MatchCaseContext(inner) => inner,
            MatchWithContext(inner) => inner,
            MatchWithManyContext(inner) => inner,
            MatchElseContext(inner) => inner,
            MatchSkipContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Match_termsContext<'input> = BaseParserRuleContext<'input, Match_termsContextExt<'input>>;

#[derive(Clone)]
pub struct Match_termsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContext<'input> {}

impl<'input> CustomRuleContext<'input> for Match_termsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}
antlr_rust::tid! {Match_termsContextExt<'a>}

impl<'input> Match_termsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Match_termsContextExt { ph: PhantomData },
        )))
    }
}

pub trait Match_termsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_termsContextExt<'input>>
{
}

impl<'input> Match_termsContextAttrs<'input> for Match_termsContext<'input> {}

pub type MatchWhenContext<'input> = BaseParserRuleContext<'input, MatchWhenContextExt<'input>>;

pub trait MatchWhenContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHEN
    /// Returns `None` if there is no child corresponding to token KW_WHEN
    fn KW_WHEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHEN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWhenContextAttrs<'input> for MatchWhenContext<'input> {}

pub struct MatchWhenContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWhenContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWhenContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWhenContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWhen(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWhen(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWhenContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWhen(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWhenContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWhenContext<'input> {}

impl<'input> MatchWhenContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWhenContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWhenContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchTypeContext<'input> = BaseParserRuleContext<'input, MatchTypeContextExt<'input>>;

pub trait MatchTypeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchTypeContextAttrs<'input> for MatchTypeContext<'input> {}

pub struct MatchTypeContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchTypeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchTypeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchType(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchTypeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchType(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchTypeContext<'input> {}

impl<'input> MatchTypeContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchTypeContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchTypeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchCaseContext<'input> = BaseParserRuleContext<'input, MatchCaseContextExt<'input>>;

pub trait MatchCaseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_CASE
    /// Returns `None` if there is no child corresponding to token KW_CASE
    fn KW_CASE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CASE, 0)
    }
    fn case_pattern(&self) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchCaseContextAttrs<'input> for MatchCaseContext<'input> {}

pub struct MatchCaseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchCaseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchCaseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchCaseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchCase(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchCase(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchCaseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchCase(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchCaseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchCaseContext<'input> {}

impl<'input> MatchCaseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchCaseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchCaseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithContext<'input> = BaseParserRuleContext<'input, MatchWithContextExt<'input>>;

pub trait MatchWithContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWithContextAttrs<'input> for MatchWithContext<'input> {}

pub struct MatchWithContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWith(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWith(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithContext<'input> {}

impl<'input> MatchWithContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithManyContext<'input> = BaseParserRuleContext<'input, MatchWithManyContextExt<'input>>;

pub trait MatchWithManyContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> MatchWithManyContextAttrs<'input> for MatchWithManyContext<'input> {}

pub struct MatchWithManyContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithManyContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithManyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithManyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWithMany(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWithMany(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithManyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWithMany(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithManyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithManyContext<'input> {}

impl<'input> MatchWithManyContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithManyContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithManyContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchElseContext<'input> = BaseParserRuleContext<'input, MatchElseContextExt<'input>>;

pub trait MatchElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchElseContextAttrs<'input> for MatchElseContext<'input> {}

pub struct MatchElseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchElseContext<'input> {}

impl<'input> MatchElseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchElseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchElseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchSkipContext<'input> = BaseParserRuleContext<'input, MatchSkipContextExt<'input>>;

pub trait MatchSkipContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchSkipContextAttrs<'input> for MatchSkipContext<'input> {}

pub struct MatchSkipContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchSkipContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchSkipContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchSkipContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchSkip(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchSkip(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchSkipContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchSkip(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchSkipContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchSkipContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchSkipContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchSkipContext<'input> {}

impl<'input> MatchSkipContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchSkipContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchSkipContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_terms(&mut self) -> Result<Rc<Match_termsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_termsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_match_terms);
        let mut _localctx: Rc<Match_termsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1547);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(202, &mut recog.base)? {
                1 => {
                    let tmp = MatchWithContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1473);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1470);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1475);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1476);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1477);
                        recog.identifier()?;
                    }
                }
                2 => {
                    let tmp = MatchWithManyContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1481);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1478);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1483);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1484);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        recog.base.set_state(1485);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1497);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1486);
                                recog.identifier()?;

                                recog.base.set_state(1491);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(193, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1487);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule identifier */
                                                recog.base.set_state(1488);
                                                recog.identifier()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1493);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(193, &mut recog.base)?;
                                }
                                recog.base.set_state(1495);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1494);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1499);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = MatchTypeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1503);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1500);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1505);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1506);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1507);
                        recog.type_expression_rec(0)?;

                        recog.base.set_state(1510);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1508);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1509);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1512);
                        recog.match_case_block()?;
                    }
                }
                4 => {
                    let tmp = MatchWhenContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1517);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1514);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1519);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1520);
                        recog.base.match_token(KW_WHEN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1521);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1522);
                        recog.match_case_block()?;
                    }
                }
                5 => {
                    let tmp = MatchElseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1527);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1524);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1529);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1530);
                        recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1531);
                        recog.match_case_block()?;
                    }
                }
                6 => {
                    let tmp = MatchCaseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1535);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1532);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1537);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1538);
                        recog.base.match_token(KW_CASE, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern */
                        recog.base.set_state(1539);
                        recog.case_pattern_rec(0)?;

                        recog.base.set_state(1542);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1540);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1541);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1544);
                        recog.match_case_block()?;
                    }
                }
                7 => {
                    let tmp = MatchSkipContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(1546);
                        recog.eos_free()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_case_block ----------------
pub type Match_case_blockContextAll<'input> = Match_case_blockContext<'input>;

pub type Match_case_blockContext<'input> = BaseParserRuleContext<'input, Match_case_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_case_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_case_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_case_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_case_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_case_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_case_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_case_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_case_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_case_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_case_block }
}
antlr_rust::tid! {Match_case_blockContextExt<'a>}

impl<'input> Match_case_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_case_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_case_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_case_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_case_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_case_blockContextAttrs<'input> for Match_case_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_case_block(&mut self) -> Result<Rc<Match_case_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_case_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_match_case_block);
        let mut _localctx: Rc<Match_case_blockContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1549);
                recog.base.match_token(COLON, &mut recog.err_handler)?;

                recog.base.set_state(1553);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(203, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule expression */
                                recog.base.set_state(1550);
                                recog.expression_rec(0)?;
                            }
                        }
                    }
                    recog.base.set_state(1555);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(203, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern ----------------
#[derive(Debug)]
pub enum Case_patternContextAll<'input> {
    CaseORContext(CaseORContext<'input>),
    CaseAtomContext(CaseAtomContext<'input>),
    CaseUntilContext(CaseUntilContext<'input>),
    Error(Case_patternContext<'input>),
}
antlr_rust::tid! {Case_patternContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Case_patternContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContextAll<'input> {}

impl<'input> Deref for Case_patternContextAll<'input> {
    type Target = dyn Case_patternContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Case_patternContextAll::*;
        match self {
            CaseORContext(inner) => inner,
            CaseAtomContext(inner) => inner,
            CaseUntilContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Case_patternContext<'input> = BaseParserRuleContext<'input, Case_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Case_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContext<'input> {}

impl<'input> CustomRuleContext<'input> for Case_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}
antlr_rust::tid! {Case_patternContextExt<'a>}

impl<'input> Case_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_patternContextExt { ph: PhantomData },
        )))
    }
}

pub trait Case_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_patternContextExt<'input>>
{
}

impl<'input> Case_patternContextAttrs<'input> for Case_patternContext<'input> {}

pub type CaseORContext<'input> = BaseParserRuleContext<'input, CaseORContextExt<'input>>;

pub trait CaseORContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> CaseORContextAttrs<'input> for CaseORContext<'input> {}

pub struct CaseORContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseORContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseORContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseORContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseOR(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseOR(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseORContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseOR(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseORContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseORContext<'input> {}

impl<'input> CaseORContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseORContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseORContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseAtomContext<'input> = BaseParserRuleContext<'input, CaseAtomContextExt<'input>>;

pub trait CaseAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CaseAtomContextAttrs<'input> for CaseAtomContext<'input> {}

pub struct CaseAtomContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseAtomContext<'input> {}

impl<'input> CaseAtomContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseUntilContext<'input> = BaseParserRuleContext<'input, CaseUntilContextExt<'input>>;

pub trait CaseUntilContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> CaseUntilContextAttrs<'input> for CaseUntilContext<'input> {}

pub struct CaseUntilContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseUntilContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseUntilContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseUntilContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseUntil(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseUntil(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseUntilContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseUntil(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseUntilContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseUntilContext<'input> {}

impl<'input> CaseUntilContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseUntilContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseUntilContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern(&mut self) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        self.case_pattern_rec(0)
    }

    fn case_pattern_rec(&mut self, _p: isize) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Case_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 186, RULE_case_pattern, _p);
        let mut _localctx: Rc<Case_patternContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 186;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                {
                    let mut tmp = CaseAtomContextExt::new(&**_localctx);
                    recog.ctx = Some(tmp.clone());
                    _localctx = tmp;
                    _prevctx = _localctx.clone();

                    /* InvokeRule case_pattern_item */
                    recog.base.set_state(1557);
                    recog.case_pattern_item()?;
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1567);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(205, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1565);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(204, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseORContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1559);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1560);
                                        _la = recog.base.input.la(1);
                                        if { !(_la == OP_ADD || _la == OP_OR) } {
                                            recog.err_handler.recover_inline(&mut recog.base)?;
                                        }
                                        else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog.err_handler.report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1561);
                                        recog.case_pattern_rec(4)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseUntilContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1562);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 2)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        {
                                            recog.base.set_state(1563);
                                            recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1564);
                                        recog.case_pattern_rec(3)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1569);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(205, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- case_pattern_item ----------------
pub type Case_pattern_itemContextAll<'input> = Case_pattern_itemContext<'input>;

pub type Case_pattern_itemContext<'input> = BaseParserRuleContext<'input, Case_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_item }
}
antlr_rust::tid! {Case_pattern_itemContextExt<'a>}

impl<'input> Case_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Case_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_itemContextExt<'input>>
{
    fn case_pattern_tuple(&self) -> Option<Rc<Case_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> Case_pattern_itemContextAttrs<'input> for Case_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_item(&mut self) -> Result<Rc<Case_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_case_pattern_item);
        let mut _localctx: Rc<Case_pattern_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1589);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(207, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule case_pattern_tuple */
                        recog.base.set_state(1570);
                        recog.case_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1571);
                        let tmp = recog.identifier()?;
                        cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                        recog.base.set_state(1572);
                        recog.base.match_token(OP_BIND, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1573);
                        recog.case_pattern_item()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1575);
                        recog.modified_identifier()?;

                        recog.base.set_state(1576);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        recog.base.set_state(1580);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(206, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(1577);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(1578);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1582);
                        recog.case_pattern_item()?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1584);
                        recog.modified_identifier()?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1585);
                        recog.namepath()?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule number_literal */
                        recog.base.set_state(1586);
                        recog.number_literal()?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule string_literal */
                        recog.base.set_state(1587);
                        recog.string_literal()?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1588);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern_tuple ----------------
pub type Case_pattern_tupleContextAll<'input> = Case_pattern_tupleContext<'input>;

pub type Case_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Case_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_tuple }
}
antlr_rust::tid! {Case_pattern_tupleContextExt<'a>}

impl<'input> Case_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Case_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Case_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn case_pattern_item_all(&self) -> Vec<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern_item(&self, i: usize) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Case_pattern_tupleContextAttrs<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_tuple(&mut self) -> Result<Rc<Case_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_case_pattern_tuple);
        let mut _localctx: Rc<Case_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1673);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(221, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1592);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1591);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1594);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(1595);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1597);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1596);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1599);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1600);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1602);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1601);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1604);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(1605);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1606);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1607);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1608);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(1609);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1611);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1612);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1615);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1613);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1614);
                                        recog.case_pattern_item()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(1617);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(211, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(1620);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1619);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1622);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1624);
                        recog.namepath()?;

                        recog.base.set_state(1625);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1626);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1631);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(213, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1627);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1628);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1633);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(213, &mut recog.base)?;
                        }
                        recog.base.set_state(1635);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1634);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1637);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        recog.base.set_state(1640);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1639);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1642);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1643);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1648);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(216, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1644);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1645);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1650);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(216, &mut recog.base)?;
                        }
                        recog.base.set_state(1652);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1651);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1654);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1657);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1656);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1659);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1660);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1665);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(219, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1661);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1662);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1667);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(219, &mut recog.base)?;
                        }
                        recog.base.set_state(1669);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1668);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1671);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- object_statement ----------------
pub type Object_statementContextAll<'input> = Object_statementContext<'input>;

pub type Object_statementContext<'input> = BaseParserRuleContext<'input, Object_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Object_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Object_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Object_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_object_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_object_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Object_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_object_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Object_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_object_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_object_statement }
}
antlr_rust::tid! {Object_statementContextExt<'a>}

impl<'input> Object_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Object_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Object_statementContextExt { ph: PhantomData }))
    }
}

pub trait Object_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Object_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_OBJECT
    /// Returns `None` if there is no child corresponding to token KW_OBJECT
    fn KW_OBJECT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_OBJECT, 0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Object_statementContextAttrs<'input> for Object_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn object_statement(&mut self) -> Result<Rc<Object_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Object_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_object_statement);
        let mut _localctx: Rc<Object_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1675);
                recog.base.match_token(KW_OBJECT, &mut recog.err_handler)?;

                recog.base.set_state(1677);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 5) & !0x3f) == 0
                    && ((1usize << (_la - 5))
                        & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                        != 0)
                {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(1676);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(1680);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(1679);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(1683);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(1682);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(1685);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_statement ----------------
pub type New_statementContextAll<'input> = New_statementContext<'input>;

pub type New_statementContext<'input> = BaseParserRuleContext<'input, New_statementContextExt<'input>>;

#[derive(Clone)]
pub struct New_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_statement }
}
antlr_rust::tid! {New_statementContextExt<'a>}

impl<'input> New_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_statementContextExt { ph: PhantomData }))
    }
}

pub trait New_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<New_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NEW
    /// Returns `None` if there is no child corresponding to token KW_NEW
    fn KW_NEW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NEW, 0)
    }
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn new_block(&self) -> Option<Rc<New_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_statementContextAttrs<'input> for New_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_statement(&mut self) -> Result<Rc<New_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_new_statement);
        let mut _localctx: Rc<New_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1704);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(228, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1687);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(1688);
                        recog.modified_namepath()?;

                        recog.base.set_state(1690);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la - 5) & !0x3f) == 0
                            && ((1usize << (_la - 5))
                                & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                                != 0)
                        {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(1689);
                                recog.generic_call_in_type()?;
                            }
                        }

                        recog.base.set_state(1693);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == PARENTHESES_L {
                            {
                                /* InvokeRule tuple_call_body */
                                recog.base.set_state(1692);
                                recog.tuple_call_body()?;
                            }
                        }

                        /* InvokeRule new_block */
                        recog.base.set_state(1695);
                        recog.new_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1697);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(1698);
                        recog.modified_namepath()?;

                        recog.base.set_state(1700);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la - 5) & !0x3f) == 0
                            && ((1usize << (_la - 5))
                                & ((1usize << (OP_PROPORTION - 5)) | (1usize << (GENERIC_L - 5)) | (1usize << (OP_LT - 5))))
                                != 0)
                        {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(1699);
                                recog.generic_call_in_type()?;
                            }
                        }

                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(1702);
                        recog.tuple_call_body()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_body ----------------
pub type New_bodyContextAll<'input> = New_bodyContext<'input>;

pub type New_bodyContext<'input> = BaseParserRuleContext<'input, New_bodyContextExt<'input>>;

#[derive(Clone)]
pub struct New_bodyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_bodyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_bodyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_body(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_body(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_bodyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_body(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_bodyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_body
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_body }
}
antlr_rust::tid! {New_bodyContextExt<'a>}

impl<'input> New_bodyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_bodyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_bodyContextExt { ph: PhantomData }))
    }
}

pub trait New_bodyContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<New_bodyContextExt<'input>> {
    fn new_block(&self) -> Option<Rc<New_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_bodyContextAttrs<'input> for New_bodyContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_body(&mut self) -> Result<Rc<New_bodyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_bodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_new_body);
        let mut _localctx: Rc<New_bodyContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1711);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(230, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1707);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == PARENTHESES_L {
                            {
                                /* InvokeRule tuple_call_body */
                                recog.base.set_state(1706);
                                recog.tuple_call_body()?;
                            }
                        }

                        /* InvokeRule new_block */
                        recog.base.set_state(1709);
                        recog.new_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(1710);
                        recog.tuple_call_body()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_block ----------------
pub type New_blockContextAll<'input> = New_blockContext<'input>;

pub type New_blockContext<'input> = BaseParserRuleContext<'input, New_blockContextExt<'input>>;

#[derive(Clone)]
pub struct New_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_block }
}
antlr_rust::tid! {New_blockContextExt<'a>}

impl<'input> New_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_blockContextExt { ph: PhantomData }))
    }
}

pub trait New_blockContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<New_blockContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn tuple_call_item_all(&self) -> Vec<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tuple_call_item(&self, i: usize) -> Option<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> New_blockContextAttrs<'input> for New_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_block(&mut self) -> Result<Rc<New_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_new_block);
        let mut _localctx: Rc<New_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1713);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1718);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << COMMA)
                            | (1usize << SEMICOLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 57) & !0x3f) == 0
                        && ((1usize << (_la - 57))
                            & ((1usize << (OP_AND - 57))
                                | (1usize << (OP_AT - 57))
                                | (1usize << (OP_HASH - 57))
                                | (1usize << (LAMBDA_SLOT - 57))
                                | (1usize << (OP_THROW - 57))
                                | (1usize << (OP_NOT - 57))
                                | (1usize << (OP_DECONSTRUCT - 57))
                                | (1usize << (OP_INVERSE - 57))
                                | (1usize << (OP_ROOTS - 57))
                                | (1usize << (OP_REFERENCE - 57))))
                            != 0)
                    || (((_la - 89) & !0x3f) == 0
                        && ((1usize << (_la - 89))
                            & ((1usize << (OP_LABEL - 89))
                                | (1usize << (KW_NEW - 89))
                                | (1usize << (KW_OBJECT - 89))
                                | (1usize << (KW_TRY - 89))
                                | (1usize << (KW_MATCH - 89))
                                | (1usize << (KW_CATCH - 89))
                                | (1usize << (INTEGER - 89))
                                | (1usize << (DECIMAL - 89))
                                | (1usize << (STRING_SINGLE - 89))
                                | (1usize << (STRING_DOUBLE - 89))
                                | (1usize << (STRING_BLOCK - 89))))
                            != 0)
                    || (((_la - 121) & !0x3f) == 0
                        && ((1usize << (_la - 121))
                            & ((1usize << (KW_IF - 121))
                                | (1usize << (RETURN - 121))
                                | (1usize << (RESUME - 121))
                                | (1usize << (YIELD - 121))
                                | (1usize << (BREAK - 121))
                                | (1usize << (CONTINUE - 121))
                                | (1usize << (RAISE - 121))
                                | (1usize << (SPECIAL - 121))
                                | (1usize << (RAW_ID - 121))
                                | (1usize << (UNICODE_ID - 121))))
                            != 0)
                {
                    {
                        recog.base.set_state(1716);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | OP_ADD | OP_SUB | OP_MUL | OP_AND | OP_AT | OP_HASH | LAMBDA_SLOT
                            | OP_THROW | OP_NOT | OP_DECONSTRUCT | OP_INVERSE | OP_ROOTS | OP_REFERENCE | OP_LABEL | KW_NEW
                            | KW_OBJECT | KW_TRY | KW_MATCH | KW_CATCH | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE
                            | STRING_BLOCK | KW_IF | RETURN | RESUME | YIELD | BREAK | CONTINUE | RAISE | SPECIAL | RAW_ID
                            | UNICODE_ID => {
                                {
                                    /* InvokeRule tuple_call_item */
                                    recog.base.set_state(1714);
                                    recog.tuple_call_item()?;
                                }
                            }

                            COMMA | SEMICOLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1715);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1720);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1721);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- collection_literal ----------------
pub type Collection_literalContextAll<'input> = Collection_literalContext<'input>;

pub type Collection_literalContext<'input> = BaseParserRuleContext<'input, Collection_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Collection_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Collection_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Collection_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_collection_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_collection_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Collection_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_collection_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Collection_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_literal }
}
antlr_rust::tid! {Collection_literalContextExt<'a>}

impl<'input> Collection_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Collection_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Collection_literalContextExt { ph: PhantomData }))
    }
}

pub trait Collection_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Collection_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn collection_pair_all(&self) -> Vec<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn collection_pair(&self, i: usize) -> Option<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
}

impl<'input> Collection_literalContextAttrs<'input> for Collection_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn collection_literal(&mut self) -> Result<Rc<Collection_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Collection_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_collection_literal);
        let mut _localctx: Rc<Collection_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1759);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(237, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1723);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1724);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1725);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(1726);
                        recog.collection_pair()?;

                        recog.base.set_state(1731);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(233, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1727);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule collection_pair */
                                        recog.base.set_state(1728);
                                        recog.collection_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1733);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(233, &mut recog.base)?;
                        }
                        recog.base.set_state(1735);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1734);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1737);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1739);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(1740);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1741);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(1742);
                        recog.collection_pair()?;

                        recog.base.set_state(1745);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1743);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule collection_pair */
                                        recog.base.set_state(1744);
                                        recog.collection_pair()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(1747);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(235, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(1750);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1749);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1752);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1754);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(1755);
                        recog.collection_pair()?;

                        recog.base.set_state(1756);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(1757);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- collection_pair ----------------
pub type Collection_pairContextAll<'input> = Collection_pairContext<'input>;

pub type Collection_pairContext<'input> = BaseParserRuleContext<'input, Collection_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Collection_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Collection_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Collection_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_collection_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_collection_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Collection_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_collection_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Collection_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_pair }
}
antlr_rust::tid! {Collection_pairContextExt<'a>}

impl<'input> Collection_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Collection_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Collection_pairContextExt { ph: PhantomData }))
    }
}

pub trait Collection_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Collection_pairContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Collection_pairContextAttrs<'input> for Collection_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn collection_pair(&mut self) -> Result<Rc<Collection_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Collection_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_collection_pair);
        let mut _localctx: Rc<Collection_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1764);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(238, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1761);
                            recog.identifier()?;

                            recog.base.set_state(1762);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule expression */
                recog.base.set_state(1766);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- slice_call ----------------
pub type Slice_callContextAll<'input> = Slice_callContext<'input>;

pub type Slice_callContext<'input> = BaseParserRuleContext<'input, Slice_callContextExt<'input>>;

#[derive(Clone)]
pub struct Slice_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Slice_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Slice_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_slice_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_slice_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Slice_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_slice_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Slice_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_slice_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_slice_call }
}
antlr_rust::tid! {Slice_callContextExt<'a>}

impl<'input> Slice_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Slice_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Slice_callContextExt { ph: PhantomData }))
    }
}

pub trait Slice_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Slice_callContextExt<'input>> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_THROW
    /// Returns `None` if there is no child corresponding to token OP_THROW
    fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_THROW, 0)
    }
}

impl<'input> Slice_callContextAttrs<'input> for Slice_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn slice_call(&mut self) -> Result<Rc<Slice_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Slice_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_slice_call);
        let mut _localctx: Rc<Slice_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1769);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_THROW {
                    {
                        recog.base.set_state(1768);
                        recog.base.match_token(OP_THROW, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule range_literal */
                recog.base.set_state(1771);
                recog.range_literal()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_literal ----------------
#[derive(Debug)]
pub enum Range_literalContextAll<'input> {
    OrdinalContext(OrdinalContext<'input>),
    OffsetContext(OffsetContext<'input>),
    Error(Range_literalContext<'input>),
}
antlr_rust::tid! {Range_literalContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Range_literalContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_literalContextAll<'input> {}

impl<'input> Deref for Range_literalContextAll<'input> {
    type Target = dyn Range_literalContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Range_literalContextAll::*;
        match self {
            OrdinalContext(inner) => inner,
            OffsetContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_literalContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_literalContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Range_literalContext<'input> = BaseParserRuleContext<'input, Range_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Range_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_literalContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_literalContext<'input> {}

impl<'input> CustomRuleContext<'input> for Range_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}
antlr_rust::tid! {Range_literalContextExt<'a>}

impl<'input> Range_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Range_literalContextExt { ph: PhantomData },
        )))
    }
}

pub trait Range_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Range_literalContextExt<'input>>
{
}

impl<'input> Range_literalContextAttrs<'input> for Range_literalContext<'input> {}

pub type OrdinalContext<'input> = BaseParserRuleContext<'input, OrdinalContextExt<'input>>;

pub trait OrdinalContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn range_axis_all(&self) -> Vec<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn range_axis(&self, i: usize) -> Option<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> OrdinalContextAttrs<'input> for OrdinalContext<'input> {}

pub struct OrdinalContextExt<'input> {
    base: Range_literalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OrdinalContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for OrdinalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for OrdinalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_Ordinal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_Ordinal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for OrdinalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_Ordinal(self);
    }
}

impl<'input> CustomRuleContext<'input> for OrdinalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}

impl<'input> Borrow<Range_literalContextExt<'input>> for OrdinalContext<'input> {
    fn borrow(&self) -> &Range_literalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Range_literalContextExt<'input>> for OrdinalContext<'input> {
    fn borrow_mut(&mut self) -> &mut Range_literalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Range_literalContextAttrs<'input> for OrdinalContext<'input> {}

impl<'input> OrdinalContextExt<'input> {
    fn new(ctx: &dyn Range_literalContextAttrs<'input>) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::OrdinalContext(BaseParserRuleContext::copy_from(
            ctx,
            OrdinalContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type OffsetContext<'input> = BaseParserRuleContext<'input, OffsetContextExt<'input>>;

pub trait OffsetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OFFSET_L
    /// Returns `None` if there is no child corresponding to token OFFSET_L
    fn OFFSET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_R
    /// Returns `None` if there is no child corresponding to token OFFSET_R
    fn OFFSET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_R, 0)
    }
    fn range_axis_all(&self) -> Vec<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn range_axis(&self, i: usize) -> Option<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> OffsetContextAttrs<'input> for OffsetContext<'input> {}

pub struct OffsetContextExt<'input> {
    base: Range_literalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OffsetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for OffsetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for OffsetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_Offset(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_Offset(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for OffsetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_Offset(self);
    }
}

impl<'input> CustomRuleContext<'input> for OffsetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}

impl<'input> Borrow<Range_literalContextExt<'input>> for OffsetContext<'input> {
    fn borrow(&self) -> &Range_literalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Range_literalContextExt<'input>> for OffsetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Range_literalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Range_literalContextAttrs<'input> for OffsetContext<'input> {}

impl<'input> OffsetContextExt<'input> {
    fn new(ctx: &dyn Range_literalContextAttrs<'input>) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::OffsetContext(BaseParserRuleContext::copy_from(
            ctx,
            OffsetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_literal(&mut self) -> Result<Rc<Range_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_range_literal);
        let mut _localctx: Rc<Range_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1803);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                BRACKET_L => {
                    let tmp = OrdinalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1773);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1785);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << OP_PROPORTION)
                                    | (1usize << COLON)
                                    | (1usize << PARENTHESES_L)
                                    | (1usize << BRACKET_L)
                                    | (1usize << OP_ADD)
                                    | (1usize << OP_SUB)
                                    | (1usize << OP_MUL)))
                                != 0)
                            || (((_la - 57) & !0x3f) == 0
                                && ((1usize << (_la - 57))
                                    & ((1usize << (OP_AND - 57))
                                        | (1usize << (OP_AT - 57))
                                        | (1usize << (OP_THROW - 57))
                                        | (1usize << (OP_NOT - 57))
                                        | (1usize << (OP_DECONSTRUCT - 57))
                                        | (1usize << (OP_INVERSE - 57))
                                        | (1usize << (OP_ROOTS - 57))
                                        | (1usize << (OP_REFERENCE - 57))))
                                    != 0)
                            || (((_la - 116) & !0x3f) == 0
                                && ((1usize << (_la - 116))
                                    & ((1usize << (INTEGER - 116))
                                        | (1usize << (DECIMAL - 116))
                                        | (1usize << (STRING_SINGLE - 116))
                                        | (1usize << (STRING_DOUBLE - 116))
                                        | (1usize << (STRING_BLOCK - 116))
                                        | (1usize << (SPECIAL - 116))
                                        | (1usize << (RAW_ID - 116))
                                        | (1usize << (UNICODE_ID - 116))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(1774);
                                recog.range_axis()?;

                                recog.base.set_state(1779);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(240, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1775);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(1776);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1781);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(240, &mut recog.base)?;
                                }
                                recog.base.set_state(1783);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1782);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1787);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                OFFSET_L => {
                    let tmp = OffsetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1788);
                        recog.base.match_token(OFFSET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1800);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << OP_PROPORTION)
                                    | (1usize << COLON)
                                    | (1usize << PARENTHESES_L)
                                    | (1usize << BRACKET_L)
                                    | (1usize << OP_ADD)
                                    | (1usize << OP_SUB)
                                    | (1usize << OP_MUL)))
                                != 0)
                            || (((_la - 57) & !0x3f) == 0
                                && ((1usize << (_la - 57))
                                    & ((1usize << (OP_AND - 57))
                                        | (1usize << (OP_AT - 57))
                                        | (1usize << (OP_THROW - 57))
                                        | (1usize << (OP_NOT - 57))
                                        | (1usize << (OP_DECONSTRUCT - 57))
                                        | (1usize << (OP_INVERSE - 57))
                                        | (1usize << (OP_ROOTS - 57))
                                        | (1usize << (OP_REFERENCE - 57))))
                                    != 0)
                            || (((_la - 116) & !0x3f) == 0
                                && ((1usize << (_la - 116))
                                    & ((1usize << (INTEGER - 116))
                                        | (1usize << (DECIMAL - 116))
                                        | (1usize << (STRING_SINGLE - 116))
                                        | (1usize << (STRING_DOUBLE - 116))
                                        | (1usize << (STRING_BLOCK - 116))
                                        | (1usize << (SPECIAL - 116))
                                        | (1usize << (RAW_ID - 116))
                                        | (1usize << (UNICODE_ID - 116))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(1789);
                                recog.range_axis()?;

                                recog.base.set_state(1794);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(243, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1790);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(1791);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1796);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(243, &mut recog.base)?;
                                }
                                recog.base.set_state(1798);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1797);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1802);
                        recog.base.match_token(OFFSET_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_axis ----------------
pub type Range_axisContextAll<'input> = Range_axisContext<'input>;

pub type Range_axisContext<'input> = BaseParserRuleContext<'input, Range_axisContextExt<'input>>;

#[derive(Clone)]
pub struct Range_axisContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_axisContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_axisContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_axis(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_axis(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_axisContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_axis(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_axisContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_axis
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_axis }
}
antlr_rust::tid! {Range_axisContextExt<'a>}

impl<'input> Range_axisContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_axisContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_axisContextExt { ph: PhantomData }))
    }
}

pub trait Range_axisContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_axisContextExt<'input>> {
    /// Retrieves all `TerminalNode`s corresponding to token COLON in current rule
    fn COLON_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COLON, starting from 0.
    /// Returns `None` if number of children corresponding to token COLON is less or equal than `i`.
    fn COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    fn range_start(&self) -> Option<Rc<Range_startContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn range_end(&self) -> Option<Rc<Range_endContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn range_step(&self) -> Option<Rc<Range_stepContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_axisContextAttrs<'input> for Range_axisContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_axis(&mut self) -> Result<Rc<Range_axisContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_axisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_range_axis);
        let mut _localctx: Rc<Range_axisContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1816);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                COLON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1805);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                OP_PROPORTION => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1806);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                    }
                }

                PARENTHESES_L | BRACKET_L | OP_ADD | OP_SUB | OP_MUL | OP_AND | OP_AT | OP_THROW | OP_NOT | OP_DECONSTRUCT
                | OP_INVERSE | OP_ROOTS | OP_REFERENCE | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK
                | SPECIAL | RAW_ID | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule range_start */
                        recog.base.set_state(1807);
                        recog.range_start()?;

                        recog.base.set_state(1810);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(247, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1808);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;

                                    /* InvokeRule range_end */
                                    recog.base.set_state(1809);
                                    recog.range_end()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(1814);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON {
                            {
                                recog.base.set_state(1812);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                /* InvokeRule range_step */
                                recog.base.set_state(1813);
                                recog.range_step()?;
                            }
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_start ----------------
pub type Range_startContextAll<'input> = Range_startContext<'input>;

pub type Range_startContext<'input> = BaseParserRuleContext<'input, Range_startContextExt<'input>>;

#[derive(Clone)]
pub struct Range_startContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_startContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_startContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_start(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_start(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_startContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_start(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_startContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_start
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_start }
}
antlr_rust::tid! {Range_startContextExt<'a>}

impl<'input> Range_startContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_startContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_startContextExt { ph: PhantomData }))
    }
}

pub trait Range_startContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Range_startContextExt<'input>>
{
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_startContextAttrs<'input> for Range_startContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_start(&mut self) -> Result<Rc<Range_startContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_startContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_range_start);
        let mut _localctx: Rc<Range_startContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule inline_expression */
                recog.base.set_state(1818);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_end ----------------
pub type Range_endContextAll<'input> = Range_endContext<'input>;

pub type Range_endContext<'input> = BaseParserRuleContext<'input, Range_endContextExt<'input>>;

#[derive(Clone)]
pub struct Range_endContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_endContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_endContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_end(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_end(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_endContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_end(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_endContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_end
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_end }
}
antlr_rust::tid! {Range_endContextExt<'a>}

impl<'input> Range_endContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_endContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_endContextExt { ph: PhantomData }))
    }
}

pub trait Range_endContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_endContextExt<'input>> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_endContextAttrs<'input> for Range_endContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_end(&mut self) -> Result<Rc<Range_endContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_endContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_range_end);
        let mut _localctx: Rc<Range_endContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule inline_expression */
                recog.base.set_state(1820);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_step ----------------
pub type Range_stepContextAll<'input> = Range_stepContext<'input>;

pub type Range_stepContext<'input> = BaseParserRuleContext<'input, Range_stepContextExt<'input>>;

#[derive(Clone)]
pub struct Range_stepContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_stepContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_stepContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_step(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_step(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_stepContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_step(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_stepContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_step
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_step }
}
antlr_rust::tid! {Range_stepContextExt<'a>}

impl<'input> Range_stepContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_stepContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_stepContextExt { ph: PhantomData }))
    }
}

pub trait Range_stepContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_stepContextExt<'input>> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Range_stepContextAttrs<'input> for Range_stepContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_step(&mut self) -> Result<Rc<Range_stepContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_stepContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_range_step);
        let mut _localctx: Rc<Range_stepContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule inline_expression */
                recog.base.set_state(1822);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modifiers ----------------
pub type ModifiersContextAll<'input> = ModifiersContext<'input>;

pub type ModifiersContext<'input> = BaseParserRuleContext<'input, ModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ModifiersContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ModifiersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ModifiersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modifiers(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modifiers(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ModifiersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modifiers(self);
    }
}

impl<'input> CustomRuleContext<'input> for ModifiersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modifiers
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modifiers }
}
antlr_rust::tid! {ModifiersContextExt<'a>}

impl<'input> ModifiersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ModifiersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, ModifiersContextExt { ph: PhantomData }))
    }
}

pub trait ModifiersContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ModifiersContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ModifiersContextAttrs<'input> for ModifiersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modifiers(&mut self) -> Result<Rc<ModifiersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_modifiers);
        let mut _localctx: Rc<ModifiersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1827);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == RAW_ID || _la == UNICODE_ID {
                    {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1824);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(1829);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_identifier ----------------
pub type Modified_identifierContextAll<'input> = Modified_identifierContext<'input>;

pub type Modified_identifierContext<'input> = BaseParserRuleContext<'input, Modified_identifierContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_identifierContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub id: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_identifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_identifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_identifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_identifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_identifier }
}
antlr_rust::tid! {Modified_identifierContextExt<'a>}

impl<'input> Modified_identifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_identifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_identifierContextExt { identifier: None, id: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_identifierContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_identifierContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Modified_identifierContextAttrs<'input> for Modified_identifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_identifier(&mut self) -> Result<Rc<Modified_identifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_identifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_modified_identifier);
        let mut _localctx: Rc<Modified_identifierContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1833);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(251, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1830);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp =
                                    cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(1835);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(251, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(1836);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_identifierContext>(&mut _localctx).id = Some(tmp.clone());
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_namepath ----------------
pub type Modified_namepathContextAll<'input> = Modified_namepathContext<'input>;

pub type Modified_namepathContext<'input> = BaseParserRuleContext<'input, Modified_namepathContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_namepathContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub path: Vec<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_namepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_namepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_namepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_namepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_namepath }
}
antlr_rust::tid! {Modified_namepathContextExt<'a>}

impl<'input> Modified_namepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_namepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_namepathContextExt { identifier: None, mods: Vec::new(), path: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_namepathContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_namepathContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> Modified_namepathContextAttrs<'input> for Modified_namepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_namepath(&mut self) -> Result<Rc<Modified_namepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_namepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_modified_namepath);
        let mut _localctx: Rc<Modified_namepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1841);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(252, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1838);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(1843);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(252, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(1844);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);

                recog.base.set_state(1849);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(253, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(1845);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(1846);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(1851);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(253, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- lambda_name ----------------
pub type Lambda_nameContextAll<'input> = Lambda_nameContext<'input>;

pub type Lambda_nameContext<'input> = BaseParserRuleContext<'input, Lambda_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Lambda_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Lambda_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Lambda_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lambda_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_lambda_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Lambda_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_lambda_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Lambda_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_lambda_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_lambda_name }
}
antlr_rust::tid! {Lambda_nameContextExt<'a>}

impl<'input> Lambda_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Lambda_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Lambda_nameContextExt { ph: PhantomData }))
    }
}

pub trait Lambda_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Lambda_nameContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token LAMBDA_SLOT
    /// Returns `None` if there is no child corresponding to token LAMBDA_SLOT
    fn LAMBDA_SLOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LAMBDA_SLOT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Lambda_nameContextAttrs<'input> for Lambda_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn lambda_name(&mut self) -> Result<Rc<Lambda_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Lambda_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_lambda_name);
        let mut _localctx: Rc<Lambda_nameContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1852);
                recog.base.match_token(LAMBDA_SLOT, &mut recog.err_handler)?;

                recog.base.set_state(1855);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(254, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1853);
                            recog.identifier()?;
                        }
                    }

                    x if x == 2 => {
                        {
                            /* InvokeRule number */
                            recog.base.set_state(1854);
                            recog.number()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_name ----------------
pub type Function_nameContextAll<'input> = Function_nameContext<'input>;

pub type Function_nameContext<'input> = BaseParserRuleContext<'input, Function_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Function_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_name }
}
antlr_rust::tid! {Function_nameContextExt<'a>}

impl<'input> Function_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_nameContextExt { ph: PhantomData }))
    }
}

pub trait Function_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_nameContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
}

impl<'input> Function_nameContextAttrs<'input> for Function_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_name(&mut self) -> Result<Rc<Function_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_function_name);
        let mut _localctx: Rc<Function_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(1857);
                recog.identifier()?;

                recog.base.set_state(1862);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_PROPORTION {
                    {
                        {
                            recog.base.set_state(1858);
                            recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                            /* InvokeRule identifier */
                            recog.base.set_state(1859);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(1864);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1867);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == DOT {
                    {
                        recog.base.set_state(1865);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1866);
                        recog.identifier()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath_free ----------------
pub type Namepath_freeContextAll<'input> = Namepath_freeContext<'input>;

pub type Namepath_freeContext<'input> = BaseParserRuleContext<'input, Namepath_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Namepath_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Namepath_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Namepath_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Namepath_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Namepath_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath_free }
}
antlr_rust::tid! {Namepath_freeContextExt<'a>}

impl<'input> Namepath_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Namepath_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Namepath_freeContextExt { ph: PhantomData }))
    }
}

pub trait Namepath_freeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Namepath_freeContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
}

impl<'input> Namepath_freeContextAttrs<'input> for Namepath_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath_free(&mut self) -> Result<Rc<Namepath_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Namepath_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_namepath_free);
        let mut _localctx: Rc<Namepath_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(1869);
                recog.identifier()?;

                recog.base.set_state(1874);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == DOT || _la == OP_PROPORTION {
                    {
                        {
                            recog.base.set_state(1870);
                            _la = recog.base.input.la(1);
                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            }
                            else {
                                if recog.base.input.la(1) == TOKEN_EOF {
                                    recog.base.matched_eof = true
                                };
                                recog.err_handler.report_match(&mut recog.base);
                                recog.base.consume(&mut recog.err_handler);
                            }
                            /* InvokeRule identifier */
                            recog.base.set_state(1871);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(1876);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath ----------------
pub type NamepathContextAll<'input> = NamepathContext<'input>;

pub type NamepathContext<'input> = BaseParserRuleContext<'input, NamepathContextExt<'input>>;

#[derive(Clone)]
pub struct NamepathContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for NamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath }
}
antlr_rust::tid! {NamepathContextExt<'a>}

impl<'input> NamepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NamepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NamepathContextExt { ph: PhantomData }))
    }
}

pub trait NamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NamepathContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> NamepathContextAttrs<'input> for NamepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath(&mut self) -> Result<Rc<NamepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NamepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_namepath);
        let mut _localctx: Rc<NamepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(1877);
                recog.identifier()?;

                recog.base.set_state(1882);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(258, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(1878);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(1879);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(1884);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(258, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;

pub type IdentifierContext<'input> = BaseParserRuleContext<'input, IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for IdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IdentifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IdentifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid! {IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, IdentifierContextExt { ph: PhantomData }))
    }
}

pub trait IdentifierContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<IdentifierContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token UNICODE_ID
    /// Returns `None` if there is no child corresponding to token UNICODE_ID
    fn UNICODE_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNICODE_ID, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RAW_ID
    /// Returns `None` if there is no child corresponding to token RAW_ID
    fn RAW_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAW_ID, 0)
    }
}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn identifier(&mut self) -> Result<Rc<IdentifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1885);
                _la = recog.base.input.la(1);
                if { !(_la == RAW_ID || _la == UNICODE_ID) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number ----------------
pub type NumberContextAll<'input> = NumberContext<'input>;

pub type NumberContext<'input> = BaseParserRuleContext<'input, NumberContextExt<'input>>;

#[derive(Clone)]
pub struct NumberContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number(self);
    }
}

impl<'input> CustomRuleContext<'input> for NumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}
antlr_rust::tid! {NumberContextExt<'a>}

impl<'input> NumberContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NumberContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NumberContextExt { ph: PhantomData }))
    }
}

pub trait NumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NumberContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DECIMAL
    /// Returns `None` if there is no child corresponding to token DECIMAL
    fn DECIMAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DECIMAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
}

impl<'input> NumberContextAttrs<'input> for NumberContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number(&mut self) -> Result<Rc<NumberContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NumberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_number);
        let mut _localctx: Rc<NumberContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1887);
                _la = recog.base.input.la(1);
                if { !(_la == INTEGER || _la == DECIMAL) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number_literal ----------------
pub type Number_literalContextAll<'input> = Number_literalContext<'input>;

pub type Number_literalContext<'input> = BaseParserRuleContext<'input, Number_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Number_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Number_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Number_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Number_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Number_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number_literal }
}
antlr_rust::tid! {Number_literalContextExt<'a>}

impl<'input> Number_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Number_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Number_literalContextExt { ph: PhantomData }))
    }
}

pub trait Number_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Number_literalContextExt<'input>>
{
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Number_literalContextAttrs<'input> for Number_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number_literal(&mut self) -> Result<Rc<Number_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Number_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_number_literal);
        let mut _localctx: Rc<Number_literalContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule number */
                recog.base.set_state(1889);
                recog.number()?;

                recog.base.set_state(1891);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(259, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1890);
                            recog.identifier()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string ----------------
pub type StringContextAll<'input> = StringContext<'input>;

pub type StringContext<'input> = BaseParserRuleContext<'input, StringContextExt<'input>>;

#[derive(Clone)]
pub struct StringContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for StringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for StringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for StringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string(self);
    }
}

impl<'input> CustomRuleContext<'input> for StringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string }
}
antlr_rust::tid! {StringContextExt<'a>}

impl<'input> StringContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StringContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, StringContextExt { ph: PhantomData }))
    }
}

pub trait StringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<StringContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token STRING_SINGLE
    /// Returns `None` if there is no child corresponding to token STRING_SINGLE
    fn STRING_SINGLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_SINGLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_DOUBLE
    /// Returns `None` if there is no child corresponding to token STRING_DOUBLE
    fn STRING_DOUBLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_DOUBLE, 0)
    }
}

impl<'input> StringContextAttrs<'input> for StringContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string(&mut self) -> Result<Rc<StringContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = StringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_string);
        let mut _localctx: Rc<StringContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1893);
                _la = recog.base.input.la(1);
                if { !(_la == STRING_SINGLE || _la == STRING_DOUBLE) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string_literal ----------------
pub type String_literalContextAll<'input> = String_literalContext<'input>;

pub type String_literalContext<'input> = BaseParserRuleContext<'input, String_literalContextExt<'input>>;

#[derive(Clone)]
pub struct String_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for String_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for String_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for String_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for String_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string_literal }
}
antlr_rust::tid! {String_literalContextExt<'a>}

impl<'input> String_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<String_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, String_literalContextExt { ph: PhantomData }))
    }
}

pub trait String_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<String_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token STRING_SINGLE
    /// Returns `None` if there is no child corresponding to token STRING_SINGLE
    fn STRING_SINGLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_SINGLE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_DOUBLE
    /// Returns `None` if there is no child corresponding to token STRING_DOUBLE
    fn STRING_DOUBLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_DOUBLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_BLOCK
    /// Returns `None` if there is no child corresponding to token STRING_BLOCK
    fn STRING_BLOCK(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_BLOCK, 0)
    }
}

impl<'input> String_literalContextAttrs<'input> for String_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string_literal(&mut self) -> Result<Rc<String_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = String_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_string_literal);
        let mut _localctx: Rc<String_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1907);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(263, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1896);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1895);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(1898);
                        recog.base.match_token(STRING_SINGLE, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1900);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1899);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(1902);
                        recog.base.match_token(STRING_DOUBLE, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1904);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1903);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(1906);
                        recog.base.match_token(STRING_BLOCK, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}

lazy_static! {
    static ref _ATN: Arc<ATN> = Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(_ATN.clone(), _ATN.get_decision_state(i), i as isize).into())
        }
        Arc::new(dfa)
    };
}

const _serializedATN: &'static str = "\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{8a}\u{778}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x03\x02\x07\
	\x02\u{f4}\x0a\x02\x0c\x02\x0e\x02\u{f7}\x0b\x02\x03\x02\x03\x02\x03\x03\
	\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\
	\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x05\x03\u{10b}\x0a\x03\
	\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x03\x04\x05\x04\u{113}\x0a\x04\
	\x03\x05\x03\x05\x03\x06\x03\x06\x03\x07\x03\x07\x03\x07\x05\x07\u{11c}\
	\x0a\x07\x03\x08\x03\x08\x03\x08\x03\x09\x03\x09\x05\x09\u{123}\x0a\x09\
	\x03\x09\x03\x09\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{12b}\x0a\x0a\
	\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{130}\x0a\x0a\x03\x0a\x05\x0a\u{133}\x0a\
	\x0a\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{138}\x0a\x0a\x03\x0a\x03\x0a\x03\
	\x0a\x05\x0a\u{13d}\x0a\x0a\x03\x0a\x05\x0a\u{140}\x0a\x0a\x03\x0a\x03\x0a\
	\x05\x0a\u{144}\x0a\x0a\x03\x0a\x03\x0a\x05\x0a\u{148}\x0a\x0a\x03\x0a\x05\
	\x0a\u{14b}\x0a\x0a\x03\x0a\x05\x0a\u{14e}\x0a\x0a\x03\x0b\x03\x0b\x03\x0b\
	\x07\x0b\u{153}\x0a\x0b\x0c\x0b\x0e\x0b\u{156}\x0b\x0b\x03\x0b\x03\x0b\x03\
	\x0b\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x07\x0c\u{15f}\x0a\x0c\x0c\x0c\x0e\
	\x0c\u{162}\x0b\x0c\x03\x0c\x05\x0c\u{165}\x0a\x0c\x03\x0d\x03\x0d\x03\x0e\
	\x05\x0e\u{16a}\x0a\x0e\x03\x0e\x07\x0e\u{16d}\x0a\x0e\x0c\x0e\x0e\x0e\u{170}\
	\x0b\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x05\x0e\u{176}\x0a\x0e\x03\x0e\
	\x05\x0e\u{179}\x0a\x0e\x03\x0e\x05\x0e\u{17c}\x0a\x0e\x03\x0e\x03\x0e\x05\
	\x0e\u{180}\x0a\x0e\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x07\x0f\u{187}\
	\x0a\x0f\x0c\x0f\x0e\x0f\u{18a}\x0b\x0f\x03\x0f\x03\x0f\x03\x10\x03\x10\
	\x03\x10\x03\x10\x03\x10\x03\x10\x07\x10\u{194}\x0a\x10\x0c\x10\x0e\x10\
	\u{197}\x0b\x10\x03\x10\x05\x10\u{19a}\x0a\x10\x03\x10\x03\x10\x05\x10\u{19e}\
	\x0a\x10\x03\x11\x03\x11\x03\x12\x07\x12\u{1a3}\x0a\x12\x0c\x12\x0e\x12\
	\u{1a6}\x0b\x12\x03\x12\x03\x12\x05\x12\u{1aa}\x0a\x12\x03\x12\x05\x12\u{1ad}\
	\x0a\x12\x03\x13\x07\x13\u{1b0}\x0a\x13\x0c\x13\x0e\x13\u{1b3}\x0b\x13\x03\
	\x13\x03\x13\x05\x13\u{1b7}\x0a\x13\x03\x13\x03\x13\x05\x13\u{1bb}\x0a\x13\
	\x03\x13\x05\x13\u{1be}\x0a\x13\x03\x13\x05\x13\u{1c1}\x0a\x13\x03\x14\x07\
	\x14\u{1c4}\x0a\x14\x0c\x14\x0e\x14\u{1c7}\x0b\x14\x03\x14\x03\x14\x03\x14\
	\x03\x15\x05\x15\u{1cd}\x0a\x15\x03\x15\x07\x15\u{1d0}\x0a\x15\x0c\x15\x0e\
	\x15\u{1d3}\x0b\x15\x03\x15\x03\x15\x03\x15\x03\x15\x05\x15\u{1d9}\x0a\x15\
	\x03\x15\x05\x15\u{1dc}\x0a\x15\x03\x15\x03\x15\x05\x15\u{1e0}\x0a\x15\x03\
	\x16\x03\x16\x03\x16\x03\x16\x03\x16\x07\x16\u{1e7}\x0a\x16\x0c\x16\x0e\
	\x16\u{1ea}\x0b\x16\x03\x16\x03\x16\x03\x17\x03\x17\x03\x17\x03\x17\x05\
	\x17\u{1f2}\x0a\x17\x03\x18\x05\x18\u{1f5}\x0a\x18\x03\x18\x07\x18\u{1f8}\
	\x0a\x18\x0c\x18\x0e\x18\u{1fb}\x0b\x18\x03\x18\x03\x18\x03\x18\x03\x18\
	\x05\x18\u{201}\x0a\x18\x03\x18\x05\x18\u{204}\x0a\x18\x03\x18\x03\x18\x03\
	\x19\x03\x19\x03\x19\x03\x1a\x07\x1a\u{20c}\x0a\x1a\x0c\x1a\x0e\x1a\u{20f}\
	\x0b\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x05\x1a\u{215}\x0a\x1a\x03\x1a\
	\x05\x1a\u{218}\x0a\x1a\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x05\x1b\u{21e}\x0a\
	\x1b\x03\x1b\x03\x1b\x03\x1c\x03\x1c\x03\x1c\x03\x1c\x07\x1c\u{226}\x0a\
	\x1c\x0c\x1c\x0e\x1c\u{229}\x0b\x1c\x03\x1c\x03\x1c\x03\x1d\x03\x1d\x05\
	\x1d\u{22f}\x0a\x1d\x03\x1e\x03\x1e\x03\x1e\x07\x1e\u{234}\x0a\x1e\x0c\x1e\
	\x0e\x1e\u{237}\x0b\x1e\x03\x1e\x03\x1e\x03\x1f\x07\x1f\u{23c}\x0a\x1f\x0c\
	\x1f\x0e\x1f\u{23f}\x0b\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x05\x1f\u{245}\
	\x0a\x1f\x03\x1f\x05\x1f\u{248}\x0a\x1f\x03\x1f\x03\x1f\x03\x20\x03\x20\
	\x03\x20\x03\x20\x07\x20\u{250}\x0a\x20\x0c\x20\x0e\x20\u{253}\x0b\x20\x03\
	\x20\x03\x20\x03\x21\x07\x21\u{258}\x0a\x21\x0c\x21\x0e\x21\u{25b}\x0b\x21\
	\x03\x21\x03\x21\x03\x21\x05\x21\u{260}\x0a\x21\x03\x22\x05\x22\u{263}\x0a\
	\x22\x03\x22\x07\x22\u{266}\x0a\x22\x0c\x22\x0e\x22\u{269}\x0b\x22\x03\x22\
	\x03\x22\x03\x22\x03\x22\x05\x22\u{26f}\x0a\x22\x03\x22\x03\x22\x05\x22\
	\u{273}\x0a\x22\x03\x22\x05\x22\u{276}\x0a\x22\x03\x22\x03\x22\x03\x23\x03\
	\x23\x03\x23\x03\x23\x03\x23\x03\x23\x07\x23\u{280}\x0a\x23\x0c\x23\x0e\
	\x23\u{283}\x0b\x23\x03\x23\x03\x23\x05\x23\u{287}\x0a\x23\x03\x24\x07\x24\
	\u{28a}\x0a\x24\x0c\x24\x0e\x24\u{28d}\x0b\x24\x03\x24\x03\x24\x05\x24\u{291}\
	\x0a\x24\x03\x24\x05\x24\u{294}\x0a\x24\x03\x25\x03\x25\x03\x25\x03\x26\
	\x05\x26\u{29a}\x0a\x26\x03\x26\x03\x26\x03\x27\x05\x27\u{29f}\x0a\x27\x03\
	\x27\x03\x27\x03\x27\x05\x27\u{2a4}\x0a\x27\x03\x27\x05\x27\u{2a7}\x0a\x27\
	\x03\x27\x03\x27\x05\x27\u{2ab}\x0a\x27\x03\x27\x03\x27\x05\x27\u{2af}\x0a\
	\x27\x05\x27\u{2b1}\x0a\x27\x03\x28\x03\x28\x03\x28\x03\x28\x03\x28\x03\
	\x28\x07\x28\u{2b9}\x0a\x28\x0c\x28\x0e\x28\u{2bc}\x0b\x28\x03\x28\x05\x28\
	\u{2bf}\x0a\x28\x03\x28\x03\x28\x05\x28\u{2c3}\x0a\x28\x03\x29\x03\x29\x03\
	\x29\x03\x29\x03\x29\x05\x29\u{2ca}\x0a\x29\x03\x2a\x07\x2a\u{2cd}\x0a\x2a\
	\x0c\x2a\x0e\x2a\u{2d0}\x0b\x2a\x03\x2a\x03\x2a\x03\x2a\x05\x2a\u{2d5}\x0a\
	\x2a\x03\x2a\x03\x2a\x03\x2b\x05\x2b\u{2da}\x0a\x2b\x03\x2b\x03\x2b\x03\
	\x2c\x03\x2c\x07\x2c\u{2e0}\x0a\x2c\x0c\x2c\x0e\x2c\u{2e3}\x0b\x2c\x03\x2c\
	\x03\x2c\x03\x2d\x03\x2d\x03\x2d\x05\x2d\u{2ea}\x0a\x2d\x03\x2d\x03\x2d\
	\x05\x2d\u{2ee}\x0a\x2d\x03\x2e\x03\x2e\x05\x2e\u{2f2}\x0a\x2e\x03\x2f\x03\
	\x2f\x03\x2f\x07\x2f\u{2f7}\x0a\x2f\x0c\x2f\x0e\x2f\u{2fa}\x0b\x2f\x03\x2f\
	\x05\x2f\u{2fd}\x0a\x2f\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\
	\x03\x30\x06\x30\u{306}\x0a\x30\x0d\x30\x0e\x30\u{307}\x03\x30\x05\x30\u{30b}\
	\x0a\x30\x05\x30\u{30d}\x0a\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\
	\x03\x30\x07\x30\u{315}\x0a\x30\x0c\x30\x0e\x30\u{318}\x0b\x30\x03\x30\x05\
	\x30\u{31b}\x0a\x30\x05\x30\u{31d}\x0a\x30\x03\x30\x03\x30\x03\x30\x05\x30\
	\u{322}\x0a\x30\x03\x30\x03\x30\x03\x30\x03\x30\x07\x30\u{328}\x0a\x30\x0c\
	\x30\x0e\x30\u{32b}\x0b\x30\x03\x30\x05\x30\u{32e}\x0a\x30\x05\x30\u{330}\
	\x0a\x30\x03\x30\x03\x30\x05\x30\u{334}\x0a\x30\x03\x30\x03\x30\x03\x30\
	\x03\x30\x07\x30\u{33a}\x0a\x30\x0c\x30\x0e\x30\u{33d}\x0b\x30\x03\x30\x05\
	\x30\u{340}\x0a\x30\x05\x30\u{342}\x0a\x30\x03\x30\x05\x30\u{345}\x0a\x30\
	\x03\x31\x03\x31\x03\x31\x05\x31\u{34a}\x0a\x31\x03\x31\x03\x31\x03\x31\
	\x05\x31\u{34f}\x0a\x31\x03\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{355}\x0a\
	\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{35a}\x0a\x31\x03\x31\x03\x31\x05\
	\x31\u{35e}\x0a\x31\x03\x31\x03\x31\x05\x31\u{362}\x0a\x31\x03\x31\x05\x31\
	\u{365}\x0a\x31\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x33\x03\x33\
	\x03\x33\x03\x34\x03\x34\x03\x34\x03\x35\x07\x35\u{373}\x0a\x35\x0c\x35\
	\x0e\x35\u{376}\x0b\x35\x03\x35\x03\x35\x03\x35\x03\x35\x07\x35\u{37c}\x0a\
	\x35\x0c\x35\x0e\x35\u{37f}\x0b\x35\x03\x35\x03\x35\x05\x35\u{383}\x0a\x35\
	\x03\x35\x07\x35\u{386}\x0a\x35\x0c\x35\x0e\x35\u{389}\x0b\x35\x03\x35\x03\
	\x35\x03\x35\x03\x35\x03\x35\x05\x35\u{390}\x0a\x35\x03\x35\x03\x35\x03\
	\x35\x03\x35\x05\x35\u{396}\x0a\x35\x03\x36\x03\x36\x03\x36\x03\x36\x03\
	\x36\x03\x37\x07\x37\u{39e}\x0a\x37\x0c\x37\x0e\x37\u{3a1}\x0b\x37\x03\x37\
	\x03\x37\x03\x37\x03\x37\x03\x37\x07\x37\u{3a8}\x0a\x37\x0c\x37\x0e\x37\
	\u{3ab}\x0b\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\
	\x05\x37\u{3b4}\x0a\x37\x03\x38\x07\x38\u{3b7}\x0a\x38\x0c\x38\x0e\x38\u{3ba}\
	\x0b\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x05\x38\u{3c1}\x0a\x38\
	\x03\x38\x03\x38\x03\x39\x03\x39\x03\x39\x03\x3a\x07\x3a\u{3c9}\x0a\x3a\
	\x0c\x3a\x0e\x3a\u{3cc}\x0b\x3a\x03\x3a\x03\x3a\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x05\x3b\u{3e7}\x0a\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x07\x3b\u{40c}\x0a\x3b\x0c\x3b\x0e\x3b\
	\u{40f}\x0b\x3b\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\
	\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{41c}\x0a\x3c\x03\x3c\x03\x3c\
	\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\
	\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\
	\x05\x3c\u{432}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\
	\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x07\x3c\u{43f}\x0a\x3c\x0c\x3c\
	\x0e\x3c\u{442}\x0b\x3c\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\
	\x03\x3d\x03\x3d\x06\x3d\u{44c}\x0a\x3d\x0d\x3d\x0e\x3d\u{44d}\x03\x3d\x05\
	\x3d\u{451}\x0a\x3d\x05\x3d\u{453}\x0a\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\
	\x03\x3d\x05\x3d\u{45a}\x0a\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\
	\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x07\x3d\
	\u{469}\x0a\x3d\x0c\x3d\x0e\x3d\u{46c}\x0b\x3d\x03\x3e\x03\x3e\x03\x3f\x03\
	\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\
	\x3f\x05\x3f\u{47b}\x0a\x3f\x03\x40\x03\x40\x05\x40\u{47f}\x0a\x40\x03\x40\
	\x03\x40\x03\x40\x03\x40\x03\x40\x05\x40\u{486}\x0a\x40\x03\x40\x03\x40\
	\x03\x40\x05\x40\u{48b}\x0a\x40\x03\x40\x03\x40\x03\x40\x03\x40\x03\x40\
	\x05\x40\u{492}\x0a\x40\x03\x40\x05\x40\u{495}\x0a\x40\x03\x40\x03\x40\x03\
	\x40\x03\x40\x03\x40\x05\x40\u{49c}\x0a\x40\x03\x41\x03\x41\x03\x42\x03\
	\x42\x03\x43\x03\x43\x03\x44\x03\x44\x03\x45\x03\x45\x03\x46\x03\x46\x03\
	\x47\x03\x47\x03\x48\x03\x48\x03\x48\x05\x48\u{4af}\x0a\x48\x03\x49\x03\
	\x49\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x07\x4a\u{4b9}\x0a\
	\x4a\x0c\x4a\x0e\x4a\u{4bc}\x0b\x4a\x03\x4a\x05\x4a\u{4bf}\x0a\x4a\x03\x4a\
	\x03\x4a\x03\x4a\x05\x4a\u{4c4}\x0a\x4a\x03\x4a\x03\x4a\x03\x4a\x05\x4a\
	\u{4c9}\x0a\x4a\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x07\x4a\u{4cf}\x0a\x4a\x0c\
	\x4a\x0e\x4a\u{4d2}\x0b\x4a\x03\x4a\x05\x4a\u{4d5}\x0a\x4a\x03\x4a\x03\x4a\
	\x05\x4a\u{4d9}\x0a\x4a\x03\x4b\x03\x4b\x03\x4b\x05\x4b\u{4de}\x0a\x4b\x03\
	\x4b\x03\x4b\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\
	\x4c\x07\x4c\u{4ea}\x0a\x4c\x0c\x4c\x0e\x4c\u{4ed}\x0b\x4c\x03\x4c\x05\x4c\
	\u{4f0}\x0a\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\
	\x03\x4c\x07\x4c\u{4fa}\x0a\x4c\x0c\x4c\x0e\x4c\u{4fd}\x0b\x4c\x03\x4c\x05\
	\x4c\u{500}\x0a\x4c\x03\x4c\x03\x4c\x05\x4c\u{504}\x0a\x4c\x03\x4d\x05\x4d\
	\u{507}\x0a\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x07\x4d\u{50d}\x0a\x4d\x0c\
	\x4d\x0e\x4d\u{510}\x0b\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\
	\x4d\x07\x4d\u{518}\x0a\x4d\x0c\x4d\x0e\x4d\u{51b}\x0b\x4d\x03\x4d\x03\x4d\
	\x05\x4d\u{51f}\x0a\x4d\x03\x4e\x03\x4e\x03\x4e\x05\x4e\u{524}\x0a\x4e\x03\
	\x4e\x03\x4e\x03\x4f\x03\x4f\x03\x4f\x03\x50\x03\x50\x03\x50\x03\x50\x03\
	\x50\x03\x50\x03\x50\x03\x50\x03\x50\x05\x50\u{534}\x0a\x50\x03\x51\x07\
	\x51\u{537}\x0a\x51\x0c\x51\x0e\x51\u{53a}\x0b\x51\x03\x51\x03\x51\x03\x51\
	\x03\x51\x03\x51\x07\x51\u{541}\x0a\x51\x0c\x51\x0e\x51\u{544}\x0b\x51\x03\
	\x51\x03\x51\x03\x51\x03\x51\x03\x51\x07\x51\u{54b}\x0a\x51\x0c\x51\x0e\
	\x51\u{54e}\x0b\x51\x03\x51\x05\x51\u{551}\x0a\x51\x03\x51\x03\x51\x05\x51\
	\u{555}\x0a\x51\x03\x52\x03\x52\x07\x52\u{559}\x0a\x52\x0c\x52\x0e\x52\u{55c}\
	\x0b\x52\x03\x52\x03\x52\x03\x53\x03\x53\x03\x53\x05\x53\u{563}\x0a\x53\
	\x03\x54\x03\x54\x07\x54\u{567}\x0a\x54\x0c\x54\x0e\x54\u{56a}\x0b\x54\x03\
	\x54\x03\x54\x03\x55\x03\x55\x03\x55\x03\x55\x03\x55\x05\x55\u{573}\x0a\
	\x55\x03\x56\x03\x56\x03\x56\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\
	\x57\x03\x57\x07\x57\u{57f}\x0a\x57\x0c\x57\x0e\x57\u{582}\x0b\x57\x03\x57\
	\x03\x57\x05\x57\u{586}\x0a\x57\x03\x58\x03\x58\x05\x58\u{58a}\x0a\x58\x03\
	\x58\x05\x58\u{58d}\x0a\x58\x03\x59\x07\x59\u{590}\x0a\x59\x0c\x59\x0e\x59\
	\u{593}\x0b\x59\x03\x59\x03\x59\x05\x59\u{597}\x0a\x59\x03\x59\x03\x59\x03\
	\x5a\x07\x5a\u{59c}\x0a\x5a\x0c\x5a\x0e\x5a\u{59f}\x0b\x5a\x03\x5a\x03\x5a\
	\x03\x5a\x03\x5a\x05\x5a\u{5a5}\x0a\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5b\
	\x05\x5b\u{5ab}\x0a\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x05\x5b\
	\u{5b2}\x0a\x5b\x05\x5b\u{5b4}\x0a\x5b\x03\x5b\x03\x5b\x03\x5c\x03\x5c\x07\
	\x5c\u{5ba}\x0a\x5c\x0c\x5c\x0e\x5c\u{5bd}\x0b\x5c\x03\x5c\x03\x5c\x03\x5d\
	\x07\x5d\u{5c2}\x0a\x5d\x0c\x5d\x0e\x5d\u{5c5}\x0b\x5d\x03\x5d\x03\x5d\x03\
	\x5d\x07\x5d\u{5ca}\x0a\x5d\x0c\x5d\x0e\x5d\u{5cd}\x0b\x5d\x03\x5d\x03\x5d\
	\x03\x5d\x03\x5d\x03\x5d\x07\x5d\u{5d4}\x0a\x5d\x0c\x5d\x0e\x5d\u{5d7}\x0b\
	\x5d\x03\x5d\x05\x5d\u{5da}\x0a\x5d\x05\x5d\u{5dc}\x0a\x5d\x03\x5d\x03\x5d\
	\x07\x5d\u{5e0}\x0a\x5d\x0c\x5d\x0e\x5d\u{5e3}\x0b\x5d\x03\x5d\x03\x5d\x03\
	\x5d\x03\x5d\x05\x5d\u{5e9}\x0a\x5d\x03\x5d\x03\x5d\x03\x5d\x07\x5d\u{5ee}\
	\x0a\x5d\x0c\x5d\x0e\x5d\u{5f1}\x0b\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\
	\x03\x5d\x07\x5d\u{5f8}\x0a\x5d\x0c\x5d\x0e\x5d\u{5fb}\x0b\x5d\x03\x5d\x03\
	\x5d\x03\x5d\x07\x5d\u{600}\x0a\x5d\x0c\x5d\x0e\x5d\u{603}\x0b\x5d\x03\x5d\
	\x03\x5d\x03\x5d\x03\x5d\x05\x5d\u{609}\x0a\x5d\x03\x5d\x03\x5d\x03\x5d\
	\x05\x5d\u{60e}\x0a\x5d\x03\x5e\x03\x5e\x07\x5e\u{612}\x0a\x5e\x0c\x5e\x0e\
	\x5e\u{615}\x0b\x5e\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\
	\x5f\x03\x5f\x03\x5f\x07\x5f\u{620}\x0a\x5f\x0c\x5f\x0e\x5f\u{623}\x0b\x5f\
	\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\
	\x03\x60\x05\x60\u{62f}\x0a\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x60\
	\x03\x60\x03\x60\x05\x60\u{638}\x0a\x60\x03\x61\x05\x61\u{63b}\x0a\x61\x03\
	\x61\x03\x61\x03\x61\x05\x61\u{640}\x0a\x61\x03\x61\x03\x61\x03\x61\x05\
	\x61\u{645}\x0a\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\
	\x61\x03\x61\x03\x61\x03\x61\x03\x61\x06\x61\u{652}\x0a\x61\x0d\x61\x0e\
	\x61\u{653}\x03\x61\x05\x61\u{657}\x0a\x61\x03\x61\x03\x61\x03\x61\x03\x61\
	\x03\x61\x03\x61\x03\x61\x07\x61\u{660}\x0a\x61\x0c\x61\x0e\x61\u{663}\x0b\
	\x61\x03\x61\x05\x61\u{666}\x0a\x61\x03\x61\x03\x61\x03\x61\x05\x61\u{66b}\
	\x0a\x61\x03\x61\x03\x61\x03\x61\x03\x61\x07\x61\u{671}\x0a\x61\x0c\x61\
	\x0e\x61\u{674}\x0b\x61\x03\x61\x05\x61\u{677}\x0a\x61\x03\x61\x03\x61\x03\
	\x61\x05\x61\u{67c}\x0a\x61\x03\x61\x03\x61\x03\x61\x03\x61\x07\x61\u{682}\
	\x0a\x61\x0c\x61\x0e\x61\u{685}\x0b\x61\x03\x61\x05\x61\u{688}\x0a\x61\x03\
	\x61\x03\x61\x05\x61\u{68c}\x0a\x61\x03\x62\x03\x62\x05\x62\u{690}\x0a\x62\
	\x03\x62\x05\x62\u{693}\x0a\x62\x03\x62\x05\x62\u{696}\x0a\x62\x03\x62\x03\
	\x62\x03\x63\x03\x63\x03\x63\x05\x63\u{69d}\x0a\x63\x03\x63\x05\x63\u{6a0}\
	\x0a\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{6a7}\x0a\x63\
	\x03\x63\x03\x63\x05\x63\u{6ab}\x0a\x63\x03\x64\x05\x64\u{6ae}\x0a\x64\x03\
	\x64\x03\x64\x05\x64\u{6b2}\x0a\x64\x03\x65\x03\x65\x03\x65\x07\x65\u{6b7}\
	\x0a\x65\x0c\x65\x0e\x65\u{6ba}\x0b\x65\x03\x65\x03\x65\x03\x66\x03\x66\
	\x03\x66\x03\x66\x03\x66\x03\x66\x07\x66\u{6c4}\x0a\x66\x0c\x66\x0e\x66\
	\u{6c7}\x0b\x66\x03\x66\x05\x66\u{6ca}\x0a\x66\x03\x66\x03\x66\x03\x66\x03\
	\x66\x03\x66\x03\x66\x03\x66\x03\x66\x06\x66\u{6d4}\x0a\x66\x0d\x66\x0e\
	\x66\u{6d5}\x03\x66\x05\x66\u{6d9}\x0a\x66\x03\x66\x03\x66\x03\x66\x03\x66\
	\x03\x66\x03\x66\x03\x66\x05\x66\u{6e2}\x0a\x66\x03\x67\x03\x67\x03\x67\
	\x05\x67\u{6e7}\x0a\x67\x03\x67\x03\x67\x03\x68\x05\x68\u{6ec}\x0a\x68\x03\
	\x68\x03\x68\x03\x69\x03\x69\x03\x69\x03\x69\x07\x69\u{6f4}\x0a\x69\x0c\
	\x69\x0e\x69\u{6f7}\x0b\x69\x03\x69\x05\x69\u{6fa}\x0a\x69\x05\x69\u{6fc}\
	\x0a\x69\x03\x69\x03\x69\x03\x69\x03\x69\x03\x69\x07\x69\u{703}\x0a\x69\
	\x0c\x69\x0e\x69\u{706}\x0b\x69\x03\x69\x05\x69\u{709}\x0a\x69\x05\x69\u{70b}\
	\x0a\x69\x03\x69\x05\x69\u{70e}\x0a\x69\x03\x6a\x03\x6a\x03\x6a\x03\x6a\
	\x03\x6a\x05\x6a\u{715}\x0a\x6a\x03\x6a\x03\x6a\x05\x6a\u{719}\x0a\x6a\x05\
	\x6a\u{71b}\x0a\x6a\x03\x6b\x03\x6b\x03\x6c\x03\x6c\x03\x6d\x03\x6d\x03\
	\x6e\x07\x6e\u{724}\x0a\x6e\x0c\x6e\x0e\x6e\u{727}\x0b\x6e\x03\x6f\x07\x6f\
	\u{72a}\x0a\x6f\x0c\x6f\x0e\x6f\u{72d}\x0b\x6f\x03\x6f\x03\x6f\x03\x70\x07\
	\x70\u{732}\x0a\x70\x0c\x70\x0e\x70\u{735}\x0b\x70\x03\x70\x03\x70\x03\x70\
	\x07\x70\u{73a}\x0a\x70\x0c\x70\x0e\x70\u{73d}\x0b\x70\x03\x71\x03\x71\x03\
	\x71\x05\x71\u{742}\x0a\x71\x03\x72\x03\x72\x03\x72\x07\x72\u{747}\x0a\x72\
	\x0c\x72\x0e\x72\u{74a}\x0b\x72\x03\x72\x03\x72\x05\x72\u{74e}\x0a\x72\x03\
	\x73\x03\x73\x03\x73\x07\x73\u{753}\x0a\x73\x0c\x73\x0e\x73\u{756}\x0b\x73\
	\x03\x74\x03\x74\x03\x74\x07\x74\u{75b}\x0a\x74\x0c\x74\x0e\x74\u{75e}\x0b\
	\x74\x03\x75\x03\x75\x03\x76\x03\x76\x03\x77\x03\x77\x05\x77\u{766}\x0a\
	\x77\x03\x78\x03\x78\x03\x79\x05\x79\u{76b}\x0a\x79\x03\x79\x03\x79\x05\
	\x79\u{76f}\x0a\x79\x03\x79\x03\x79\x05\x79\u{773}\x0a\x79\x03\x79\x05\x79\
	\u{776}\x0a\x79\x03\x79\x02\x06\x74\x76\x78\u{bc}\x7a\x02\x04\x06\x08\x0a\
	\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\x2c\x2e\
	\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\x50\x52\
	\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\x74\x76\
	\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\
	\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\
	\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\
	\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\
	\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\x02\x16\
	\x03\x02\x04\x05\x03\x02\x41\x42\x04\x02\x03\x03\x07\x07\x04\x02\x08\x08\
	\x66\x66\x04\x02\x08\x08\x2c\x2c\x04\x02\x49\x49\x6a\x6a\x0a\x02\x1b\x1b\
	\x1d\x1d\x1f\x1f\x3b\x3b\x48\x48\x52\x52\x55\x56\x5a\x5a\x05\x02\x21\x23\
	\x26\x27\x2a\x2a\x03\x02\x3b\x3c\x03\x02\x2c\x2d\x03\x02\x1f\x20\x04\x02\
	\x1b\x1b\x1d\x1d\x03\x02\x36\x3a\x04\x02\x2e\x2e\x30\x34\x03\x02\x4a\x4b\
	\x03\x02\x71\x72\x04\x02\x1b\x1b\x3c\x3c\x03\x02\u{85}\u{86}\x03\x02\x76\
	\x77\x03\x02\x78\x79\x02\u{87f}\x02\u{f5}\x03\x02\x02\x02\x04\u{10a}\x03\
	\x02\x02\x02\x06\u{112}\x03\x02\x02\x02\x08\u{114}\x03\x02\x02\x02\x0a\u{116}\
	\x03\x02\x02\x02\x0c\u{118}\x03\x02\x02\x02\x0e\u{11d}\x03\x02\x02\x02\x10\
	\u{120}\x03\x02\x02\x02\x12\u{14d}\x03\x02\x02\x02\x14\u{14f}\x03\x02\x02\
	\x02\x16\u{164}\x03\x02\x02\x02\x18\u{166}\x03\x02\x02\x02\x1a\u{169}\x03\
	\x02\x02\x02\x1c\u{181}\x03\x02\x02\x02\x1e\u{19d}\x03\x02\x02\x02\x20\u{19f}\
	\x03\x02\x02\x02\x22\u{1a4}\x03\x02\x02\x02\x24\u{1b1}\x03\x02\x02\x02\x26\
	\u{1c5}\x03\x02\x02\x02\x28\u{1cc}\x03\x02\x02\x02\x2a\u{1e1}\x03\x02\x02\
	\x02\x2c\u{1ed}\x03\x02\x02\x02\x2e\u{1f4}\x03\x02\x02\x02\x30\u{207}\x03\
	\x02\x02\x02\x32\u{20d}\x03\x02\x02\x02\x34\u{21b}\x03\x02\x02\x02\x36\u{221}\
	\x03\x02\x02\x02\x38\u{22c}\x03\x02\x02\x02\x3a\u{230}\x03\x02\x02\x02\x3c\
	\u{23d}\x03\x02\x02\x02\x3e\u{24b}\x03\x02\x02\x02\x40\u{259}\x03\x02\x02\
	\x02\x42\u{262}\x03\x02\x02\x02\x44\u{286}\x03\x02\x02\x02\x46\u{28b}\x03\
	\x02\x02\x02\x48\u{295}\x03\x02\x02\x02\x4a\u{299}\x03\x02\x02\x02\x4c\u{2b0}\
	\x03\x02\x02\x02\x4e\u{2c2}\x03\x02\x02\x02\x50\u{2c9}\x03\x02\x02\x02\x52\
	\u{2ce}\x03\x02\x02\x02\x54\u{2d9}\x03\x02\x02\x02\x56\u{2dd}\x03\x02\x02\
	\x02\x58\u{2e6}\x03\x02\x02\x02\x5a\u{2f1}\x03\x02\x02\x02\x5c\u{2f3}\x03\
	\x02\x02\x02\x5e\u{344}\x03\x02\x02\x02\x60\u{364}\x03\x02\x02\x02\x62\u{366}\
	\x03\x02\x02\x02\x64\u{36b}\x03\x02\x02\x02\x66\u{36e}\x03\x02\x02\x02\x68\
	\u{395}\x03\x02\x02\x02\x6a\u{397}\x03\x02\x02\x02\x6c\u{3b3}\x03\x02\x02\
	\x02\x6e\u{3b8}\x03\x02\x02\x02\x70\u{3c4}\x03\x02\x02\x02\x72\u{3ca}\x03\
	\x02\x02\x02\x74\u{3e6}\x03\x02\x02\x02\x76\u{41b}\x03\x02\x02\x02\x78\u{459}\
	\x03\x02\x02\x02\x7a\u{46d}\x03\x02\x02\x02\x7c\u{47a}\x03\x02\x02\x02\x7e\
	\u{49b}\x03\x02\x02\x02\u{80}\u{49d}\x03\x02\x02\x02\u{82}\u{49f}\x03\x02\
	\x02\x02\u{84}\u{4a1}\x03\x02\x02\x02\u{86}\u{4a3}\x03\x02\x02\x02\u{88}\
	\u{4a5}\x03\x02\x02\x02\u{8a}\u{4a7}\x03\x02\x02\x02\u{8c}\u{4a9}\x03\x02\
	\x02\x02\u{8e}\u{4ae}\x03\x02\x02\x02\u{90}\u{4b0}\x03\x02\x02\x02\u{92}\
	\u{4d8}\x03\x02\x02\x02\u{94}\u{4dd}\x03\x02\x02\x02\u{96}\u{503}\x03\x02\
	\x02\x02\u{98}\u{51e}\x03\x02\x02\x02\u{9a}\u{523}\x03\x02\x02\x02\u{9c}\
	\u{527}\x03\x02\x02\x02\u{9e}\u{533}\x03\x02\x02\x02\u{a0}\u{554}\x03\x02\
	\x02\x02\u{a2}\u{556}\x03\x02\x02\x02\u{a4}\u{562}\x03\x02\x02\x02\u{a6}\
	\u{564}\x03\x02\x02\x02\u{a8}\u{572}\x03\x02\x02\x02\u{aa}\u{574}\x03\x02\
	\x02\x02\u{ac}\u{585}\x03\x02\x02\x02\u{ae}\u{587}\x03\x02\x02\x02\u{b0}\
	\u{591}\x03\x02\x02\x02\u{b2}\u{59d}\x03\x02\x02\x02\u{b4}\u{5aa}\x03\x02\
	\x02\x02\u{b6}\u{5b7}\x03\x02\x02\x02\u{b8}\u{60d}\x03\x02\x02\x02\u{ba}\
	\u{60f}\x03\x02\x02\x02\u{bc}\u{616}\x03\x02\x02\x02\u{be}\u{637}\x03\x02\
	\x02\x02\u{c0}\u{68b}\x03\x02\x02\x02\u{c2}\u{68d}\x03\x02\x02\x02\u{c4}\
	\u{6aa}\x03\x02\x02\x02\u{c6}\u{6b1}\x03\x02\x02\x02\u{c8}\u{6b3}\x03\x02\
	\x02\x02\u{ca}\u{6e1}\x03\x02\x02\x02\u{cc}\u{6e6}\x03\x02\x02\x02\u{ce}\
	\u{6eb}\x03\x02\x02\x02\u{d0}\u{70d}\x03\x02\x02\x02\u{d2}\u{71a}\x03\x02\
	\x02\x02\u{d4}\u{71c}\x03\x02\x02\x02\u{d6}\u{71e}\x03\x02\x02\x02\u{d8}\
	\u{720}\x03\x02\x02\x02\u{da}\u{725}\x03\x02\x02\x02\u{dc}\u{72b}\x03\x02\
	\x02\x02\u{de}\u{733}\x03\x02\x02\x02\u{e0}\u{73e}\x03\x02\x02\x02\u{e2}\
	\u{743}\x03\x02\x02\x02\u{e4}\u{74f}\x03\x02\x02\x02\u{e6}\u{757}\x03\x02\
	\x02\x02\u{e8}\u{75f}\x03\x02\x02\x02\u{ea}\u{761}\x03\x02\x02\x02\u{ec}\
	\u{763}\x03\x02\x02\x02\u{ee}\u{767}\x03\x02\x02\x02\u{f0}\u{775}\x03\x02\
	\x02\x02\u{f2}\u{f4}\x05\x04\x03\x02\u{f3}\u{f2}\x03\x02\x02\x02\u{f4}\u{f7}\
	\x03\x02\x02\x02\u{f5}\u{f3}\x03\x02\x02\x02\u{f5}\u{f6}\x03\x02\x02\x02\
	\u{f6}\u{f8}\x03\x02\x02\x02\u{f7}\u{f5}\x03\x02\x02\x02\u{f8}\u{f9}\x07\
	\x02\x02\x03\u{f9}\x03\x03\x02\x02\x02\u{fa}\u{10b}\x05\x0c\x07\x02\u{fb}\
	\u{10b}\x05\x0e\x08\x02\u{fc}\u{10b}\x05\x18\x0d\x02\u{fd}\u{10b}\x05\x1a\
	\x0e\x02\u{fe}\u{10b}\x05\x32\x1a\x02\u{ff}\u{10b}\x05\x3c\x1f\x02\u{100}\
	\u{10b}\x05\x28\x15\x02\u{101}\u{10b}\x05\x2e\x18\x02\u{102}\u{10b}\x05\
	\x42\x22\x02\u{103}\u{10b}\x05\x62\x32\x02\u{104}\u{10b}\x05\x58\x2d\x02\
	\u{105}\u{10b}\x05\x68\x35\x02\u{106}\u{10b}\x05\x6c\x37\x02\u{107}\u{10b}\
	\x05\x6e\x38\x02\u{108}\u{10b}\x05\x72\x3a\x02\u{109}\u{10b}\x05\x08\x05\
	\x02\u{10a}\u{fa}\x03\x02\x02\x02\u{10a}\u{fb}\x03\x02\x02\x02\u{10a}\u{fc}\
	\x03\x02\x02\x02\u{10a}\u{fd}\x03\x02\x02\x02\u{10a}\u{fe}\x03\x02\x02\x02\
	\u{10a}\u{ff}\x03\x02\x02\x02\u{10a}\u{100}\x03\x02\x02\x02\u{10a}\u{101}\
	\x03\x02\x02\x02\u{10a}\u{102}\x03\x02\x02\x02\u{10a}\u{103}\x03\x02\x02\
	\x02\u{10a}\u{104}\x03\x02\x02\x02\u{10a}\u{105}\x03\x02\x02\x02\u{10a}\
	\u{106}\x03\x02\x02\x02\u{10a}\u{107}\x03\x02\x02\x02\u{10a}\u{108}\x03\
	\x02\x02\x02\u{10a}\u{109}\x03\x02\x02\x02\u{10b}\x05\x03\x02\x02\x02\u{10c}\
	\u{113}\x05\x52\x2a\x02\u{10d}\u{113}\x05\x58\x2d\x02\u{10e}\u{113}\x05\
	\x6c\x37\x02\u{10f}\u{113}\x05\x6e\x38\x02\u{110}\u{113}\x05\x72\x3a\x02\
	\u{111}\u{113}\x05\x08\x05\x02\u{112}\u{10c}\x03\x02\x02\x02\u{112}\u{10d}\
	\x03\x02\x02\x02\u{112}\u{10e}\x03\x02\x02\x02\u{112}\u{10f}\x03\x02\x02\
	\x02\u{112}\u{110}\x03\x02\x02\x02\u{112}\u{111}\x03\x02\x02\x02\u{113}\
	\x07\x03\x02\x02\x02\u{114}\u{115}\x07\x05\x02\x02\u{115}\x09\x03\x02\x02\
	\x02\u{116}\u{117}\x09\x02\x02\x02\u{117}\x0b\x03\x02\x02\x02\u{118}\u{119}\
	\x07\x5c\x02\x02\u{119}\u{11b}\x05\u{e4}\x73\x02\u{11a}\u{11c}\x05\x08\x05\
	\x02\u{11b}\u{11a}\x03\x02\x02\x02\u{11b}\u{11c}\x03\x02\x02\x02\u{11c}\
	\x0d\x03\x02\x02\x02\u{11d}\u{11e}\x07\x5d\x02\x02\u{11e}\u{11f}\x05\x12\
	\x0a\x02\u{11f}\x0f\x03\x02\x02\x02\u{120}\u{122}\x07\x51\x02\x02\u{121}\
	\u{123}\x09\x03\x02\x02\u{122}\u{121}\x03\x02\x02\x02\u{122}\u{123}\x03\
	\x02\x02\x02\u{123}\u{124}\x03\x02\x02\x02\u{124}\u{125}\x05\u{e8}\x75\x02\
	\u{125}\x11\x03\x02\x02\x02\u{126}\u{14e}\x05\x16\x0c\x02\u{127}\u{128}\
	\x07\x41\x02\x02\u{128}\u{12a}\x05\x14\x0b\x02\u{129}\u{12b}\x05\x10\x09\
	\x02\u{12a}\u{129}\x03\x02\x02\x02\u{12a}\u{12b}\x03\x02\x02\x02\u{12b}\
	\u{14e}\x03\x02\x02\x02\u{12c}\u{12d}\x07\x41\x02\x02\u{12d}\u{132}\x05\
	\x14\x0b\x02\u{12e}\u{130}\x09\x04\x02\x02\u{12f}\u{12e}\x03\x02\x02\x02\
	\u{12f}\u{130}\x03\x02\x02\x02\u{130}\u{131}\x03\x02\x02\x02\u{131}\u{133}\
	\x05\x16\x0c\x02\u{132}\u{12f}\x03\x02\x02\x02\u{132}\u{133}\x03\x02\x02\
	\x02\u{133}\u{14e}\x03\x02\x02\x02\u{134}\u{135}\x07\x42\x02\x02\u{135}\
	\u{137}\x05\x14\x0b\x02\u{136}\u{138}\x05\x10\x09\x02\u{137}\u{136}\x03\
	\x02\x02\x02\u{137}\u{138}\x03\x02\x02\x02\u{138}\u{14e}\x03\x02\x02\x02\
	\u{139}\u{13a}\x07\x42\x02\x02\u{13a}\u{13f}\x05\x14\x0b\x02\u{13b}\u{13d}\
	\x09\x04\x02\x02\u{13c}\u{13b}\x03\x02\x02\x02\u{13c}\u{13d}\x03\x02\x02\
	\x02\u{13d}\u{13e}\x03\x02\x02\x02\u{13e}\u{140}\x05\x16\x0c\x02\u{13f}\
	\u{13c}\x03\x02\x02\x02\u{13f}\u{140}\x03\x02\x02\x02\u{140}\u{14e}\x03\
	\x02\x02\x02\u{141}\u{143}\x05\x14\x0b\x02\u{142}\u{144}\x05\x10\x09\x02\
	\u{143}\u{142}\x03\x02\x02\x02\u{143}\u{144}\x03\x02\x02\x02\u{144}\u{14e}\
	\x03\x02\x02\x02\u{145}\u{14a}\x05\x14\x0b\x02\u{146}\u{148}\x09\x04\x02\
	\x02\u{147}\u{146}\x03\x02\x02\x02\u{147}\u{148}\x03\x02\x02\x02\u{148}\
	\u{149}\x03\x02\x02\x02\u{149}\u{14b}\x05\x16\x0c\x02\u{14a}\u{147}\x03\
	\x02\x02\x02\u{14a}\u{14b}\x03\x02\x02\x02\u{14b}\u{14e}\x03\x02\x02\x02\
	\u{14c}\u{14e}\x05\x0a\x06\x02\u{14d}\u{126}\x03\x02\x02\x02\u{14d}\u{127}\
	\x03\x02\x02\x02\u{14d}\u{12c}\x03\x02\x02\x02\u{14d}\u{134}\x03\x02\x02\
	\x02\u{14d}\u{139}\x03\x02\x02\x02\u{14d}\u{141}\x03\x02\x02\x02\u{14d}\
	\u{145}\x03\x02\x02\x02\u{14d}\u{14c}\x03\x02\x02\x02\u{14e}\x13\x03\x02\
	\x02\x02\u{14f}\u{154}\x05\u{e8}\x75\x02\u{150}\u{151}\x09\x04\x02\x02\u{151}\
	\u{153}\x05\u{e8}\x75\x02\u{152}\u{150}\x03\x02\x02\x02\u{153}\u{156}\x03\
	\x02\x02\x02\u{154}\u{152}\x03\x02\x02\x02\u{154}\u{155}\x03\x02\x02\x02\
	\u{155}\u{157}\x03\x02\x02\x02\u{156}\u{154}\x03\x02\x02\x02\u{157}\u{158}\
	\x09\x04\x02\x02\u{158}\u{159}\x07\x1f\x02\x02\u{159}\x15\x03\x02\x02\x02\
	\u{15a}\u{15b}\x07\x0d\x02\x02\u{15b}\u{165}\x07\x0e\x02\x02\u{15c}\u{160}\
	\x07\x0d\x02\x02\u{15d}\u{15f}\x05\x12\x0a\x02\u{15e}\u{15d}\x03\x02\x02\
	\x02\u{15f}\u{162}\x03\x02\x02\x02\u{160}\u{15e}\x03\x02\x02\x02\u{160}\
	\u{161}\x03\x02\x02\x02\u{161}\u{163}\x03\x02\x02\x02\u{162}\u{160}\x03\
	\x02\x02\x02\u{163}\u{165}\x07\x0e\x02\x02\u{164}\u{15a}\x03\x02\x02\x02\
	\u{164}\u{15c}\x03\x02\x02\x02\u{165}\x17\x03\x02\x02\x02\u{166}\u{167}\
	\x07\x5e\x02\x02\u{167}\x19\x03\x02\x02\x02\u{168}\u{16a}\x05\u{a0}\x51\
	\x02\u{169}\u{168}\x03\x02\x02\x02\u{169}\u{16a}\x03\x02\x02\x02\u{16a}\
	\u{16e}\x03\x02\x02\x02\u{16b}\u{16d}\x05\u{ac}\x57\x02\u{16c}\u{16b}\x03\
	\x02\x02\x02\u{16d}\u{170}\x03\x02\x02\x02\u{16e}\u{16c}\x03\x02\x02\x02\
	\u{16e}\u{16f}\x03\x02\x02\x02\u{16f}\u{171}\x03\x02\x02\x02\u{170}\u{16e}\
	\x03\x02\x02\x02\u{171}\u{172}\x05\u{da}\x6e\x02\u{172}\u{173}\x07\x5f\x02\
	\x02\u{173}\u{175}\x05\u{e8}\x75\x02\u{174}\u{176}\x05\u{92}\x4a\x02\u{175}\
	\u{174}\x03\x02\x02\x02\u{175}\u{176}\x03\x02\x02\x02\u{176}\u{178}\x03\
	\x02\x02\x02\u{177}\u{179}\x05\x1e\x10\x02\u{178}\u{177}\x03\x02\x02\x02\
	\u{178}\u{179}\x03\x02\x02\x02\u{179}\u{17b}\x03\x02\x02\x02\u{17a}\u{17c}\
	\x05\x64\x33\x02\u{17b}\u{17a}\x03\x02\x02\x02\u{17b}\u{17c}\x03\x02\x02\
	\x02\u{17c}\u{17d}\x03\x02\x02\x02\u{17d}\u{17f}\x05\x1c\x0f\x02\u{17e}\
	\u{180}\x05\x08\x05\x02\u{17f}\u{17e}\x03\x02\x02\x02\u{17f}\u{180}\x03\
	\x02\x02\x02\u{180}\x1b\x03\x02\x02\x02\u{181}\u{188}\x07\x0d\x02\x02\u{182}\
	\u{187}\x05\x26\x14\x02\u{183}\u{187}\x05\x24\x13\x02\u{184}\u{187}\x05\
	\x22\x12\x02\u{185}\u{187}\x05\x0a\x06\x02\u{186}\u{182}\x03\x02\x02\x02\
	\u{186}\u{183}\x03\x02\x02\x02\u{186}\u{184}\x03\x02\x02\x02\u{186}\u{185}\
	\x03\x02\x02\x02\u{187}\u{18a}\x03\x02\x02\x02\u{188}\u{186}\x03\x02\x02\
	\x02\u{188}\u{189}\x03\x02\x02\x02\u{189}\u{18b}\x03\x02\x02\x02\u{18a}\
	\u{188}\x03\x02\x02\x02\u{18b}\u{18c}\x07\x0e\x02\x02\u{18c}\x1d\x03\x02\
	\x02\x02\u{18d}\u{18e}\x07\x09\x02\x02\u{18e}\u{19e}\x07\x0a\x02\x02\u{18f}\
	\u{190}\x07\x09\x02\x02\u{190}\u{195}\x05\x20\x11\x02\u{191}\u{192}\x07\
	\x04\x02\x02\u{192}\u{194}\x05\x20\x11\x02\u{193}\u{191}\x03\x02\x02\x02\
	\u{194}\u{197}\x03\x02\x02\x02\u{195}\u{193}\x03\x02\x02\x02\u{195}\u{196}\
	\x03\x02\x02\x02\u{196}\u{199}\x03\x02\x02\x02\u{197}\u{195}\x03\x02\x02\
	\x02\u{198}\u{19a}\x07\x04\x02\x02\u{199}\u{198}\x03\x02\x02\x02\u{199}\
	\u{19a}\x03\x02\x02\x02\u{19a}\u{19b}\x03\x02\x02\x02\u{19b}\u{19c}\x07\
	\x0a\x02\x02\u{19c}\u{19e}\x03\x02\x02\x02\u{19d}\u{18d}\x03\x02\x02\x02\
	\u{19d}\u{18f}\x03\x02\x02\x02\u{19e}\x1f\x03\x02\x02\x02\u{19f}\u{1a0}\
	\x05\u{de}\x70\x02\u{1a0}\x21\x03\x02\x02\x02\u{1a1}\u{1a3}\x05\u{ac}\x57\
	\x02\u{1a2}\u{1a1}\x03\x02\x02\x02\u{1a3}\u{1a6}\x03\x02\x02\x02\u{1a4}\
	\u{1a2}\x03\x02\x02\x02\u{1a4}\u{1a5}\x03\x02\x02\x02\u{1a5}\u{1a7}\x03\
	\x02\x02\x02\u{1a6}\u{1a4}\x03\x02\x02\x02\u{1a7}\u{1a9}\x05\u{dc}\x6f\x02\
	\u{1a8}\u{1aa}\x05\x64\x33\x02\u{1a9}\u{1a8}\x03\x02\x02\x02\u{1a9}\u{1aa}\
	\x03\x02\x02\x02\u{1aa}\u{1ac}\x03\x02\x02\x02\u{1ab}\u{1ad}\x05\x48\x25\
	\x02\u{1ac}\u{1ab}\x03\x02\x02\x02\u{1ac}\u{1ad}\x03\x02\x02\x02\u{1ad}\
	\x23\x03\x02\x02\x02\u{1ae}\u{1b0}\x05\u{ac}\x57\x02\u{1af}\u{1ae}\x03\x02\
	\x02\x02\u{1b0}\u{1b3}\x03\x02\x02\x02\u{1b1}\u{1af}\x03\x02\x02\x02\u{1b1}\
	\u{1b2}\x03\x02\x02\x02\u{1b2}\u{1b4}\x03\x02\x02\x02\u{1b3}\u{1b1}\x03\
	\x02\x02\x02\u{1b4}\u{1b6}\x05\u{de}\x70\x02\u{1b5}\u{1b7}\x05\u{92}\x4a\
	\x02\u{1b6}\u{1b5}\x03\x02\x02\x02\u{1b6}\u{1b7}\x03\x02\x02\x02\u{1b7}\
	\u{1b8}\x03\x02\x02\x02\u{1b8}\u{1ba}\x05\x44\x23\x02\u{1b9}\u{1bb}\x05\
	\x64\x33\x02\u{1ba}\u{1b9}\x03\x02\x02\x02\u{1ba}\u{1bb}\x03\x02\x02\x02\
	\u{1bb}\u{1bd}\x03\x02\x02\x02\u{1bc}\u{1be}\x05\x66\x34\x02\u{1bd}\u{1bc}\
	\x03\x02\x02\x02\u{1bd}\u{1be}\x03\x02\x02\x02\u{1be}\u{1c0}\x03\x02\x02\
	\x02\u{1bf}\u{1c1}\x05\x56\x2c\x02\u{1c0}\u{1bf}\x03\x02\x02\x02\u{1c0}\
	\u{1c1}\x03\x02\x02\x02\u{1c1}\x25\x03\x02\x02\x02\u{1c2}\u{1c4}\x05\u{ac}\
	\x57\x02\u{1c3}\u{1c2}\x03\x02\x02\x02\u{1c4}\u{1c7}\x03\x02\x02\x02\u{1c5}\
	\u{1c3}\x03\x02\x02\x02\u{1c5}\u{1c6}\x03\x02\x02\x02\u{1c6}\u{1c8}\x03\
	\x02\x02\x02\u{1c7}\u{1c5}\x03\x02\x02\x02\u{1c8}\u{1c9}\x05\u{dc}\x6f\x02\
	\u{1c9}\u{1ca}\x05\x1c\x0f\x02\u{1ca}\x27\x03\x02\x02\x02\u{1cb}\u{1cd}\
	\x05\u{a0}\x51\x02\u{1cc}\u{1cb}\x03\x02\x02\x02\u{1cc}\u{1cd}\x03\x02\x02\
	\x02\u{1cd}\u{1d1}\x03\x02\x02\x02\u{1ce}\u{1d0}\x05\u{ac}\x57\x02\u{1cf}\
	\u{1ce}\x03\x02\x02\x02\u{1d0}\u{1d3}\x03\x02\x02\x02\u{1d1}\u{1cf}\x03\
	\x02\x02\x02\u{1d1}\u{1d2}\x03\x02\x02\x02\u{1d2}\u{1d4}\x03\x02\x02\x02\
	\u{1d3}\u{1d1}\x03\x02\x02\x02\u{1d4}\u{1d5}\x05\u{da}\x6e\x02\u{1d5}\u{1d6}\
	\x07\x60\x02\x02\u{1d6}\u{1d8}\x05\u{e8}\x75\x02\u{1d7}\u{1d9}\x05\u{92}\
	\x4a\x02\u{1d8}\u{1d7}\x03\x02\x02\x02\u{1d8}\u{1d9}\x03\x02\x02\x02\u{1d9}\
	\u{1db}\x03\x02\x02\x02\u{1da}\u{1dc}\x05\x30\x19\x02\u{1db}\u{1da}\x03\
	\x02\x02\x02\u{1db}\u{1dc}\x03\x02\x02\x02\u{1dc}\u{1dd}\x03\x02\x02\x02\
	\u{1dd}\u{1df}\x05\x2a\x16\x02\u{1de}\u{1e0}\x05\x08\x05\x02\u{1df}\u{1de}\
	\x03\x02\x02\x02\u{1df}\u{1e0}\x03\x02\x02\x02\u{1e0}\x29\x03\x02\x02\x02\
	\u{1e1}\u{1e8}\x07\x0d\x02\x02\u{1e2}\u{1e7}\x05\x2c\x17\x02\u{1e3}\u{1e7}\
	\x05\x24\x13\x02\u{1e4}\u{1e7}\x05\x22\x12\x02\u{1e5}\u{1e7}\x05\x0a\x06\
	\x02\u{1e6}\u{1e2}\x03\x02\x02\x02\u{1e6}\u{1e3}\x03\x02\x02\x02\u{1e6}\
	\u{1e4}\x03\x02\x02\x02\u{1e6}\u{1e5}\x03\x02\x02\x02\u{1e7}\u{1ea}\x03\
	\x02\x02\x02\u{1e8}\u{1e6}\x03\x02\x02\x02\u{1e8}\u{1e9}\x03\x02\x02\x02\
	\u{1e9}\u{1eb}\x03\x02\x02\x02\u{1ea}\u{1e8}\x03\x02\x02\x02\u{1eb}\u{1ec}\
	\x07\x0e\x02\x02\u{1ec}\x2b\x03\x02\x02\x02\u{1ed}\u{1ee}\x07\x63\x02\x02\
	\u{1ee}\u{1f1}\x05\u{e8}\x75\x02\u{1ef}\u{1f0}\x07\x2e\x02\x02\u{1f0}\u{1f2}\
	\x05\x78\x3d\x02\u{1f1}\u{1ef}\x03\x02\x02\x02\u{1f1}\u{1f2}\x03\x02\x02\
	\x02\u{1f2}\x2d\x03\x02\x02\x02\u{1f3}\u{1f5}\x05\u{a0}\x51\x02\u{1f4}\u{1f3}\
	\x03\x02\x02\x02\u{1f4}\u{1f5}\x03\x02\x02\x02\u{1f5}\u{1f9}\x03\x02\x02\
	\x02\u{1f6}\u{1f8}\x05\u{ac}\x57\x02\u{1f7}\u{1f6}\x03\x02\x02\x02\u{1f8}\
	\u{1fb}\x03\x02\x02\x02\u{1f9}\u{1f7}\x03\x02\x02\x02\u{1f9}\u{1fa}\x03\
	\x02\x02\x02\u{1fa}\u{1fc}\x03\x02\x02\x02\u{1fb}\u{1f9}\x03\x02\x02\x02\
	\u{1fc}\u{1fd}\x05\u{da}\x6e\x02\u{1fd}\u{1fe}\x07\x65\x02\x02\u{1fe}\u{200}\
	\x05\u{e6}\x74\x02\u{1ff}\u{201}\x05\u{92}\x4a\x02\u{200}\u{1ff}\x03\x02\
	\x02\x02\u{200}\u{201}\x03\x02\x02\x02\u{201}\u{203}\x03\x02\x02\x02\u{202}\
	\u{204}\x05\x30\x19\x02\u{203}\u{202}\x03\x02\x02\x02\u{203}\u{204}\x03\
	\x02\x02\x02\u{204}\u{205}\x03\x02\x02\x02\u{205}\u{206}\x05\x2a\x16\x02\
	\u{206}\x2f\x03\x02\x02\x02\u{207}\u{208}\x09\x05\x02\x02\u{208}\u{209}\
	\x05\x78\x3d\x02\u{209}\x31\x03\x02\x02\x02\u{20a}\u{20c}\x05\u{ac}\x57\
	\x02\u{20b}\u{20a}\x03\x02\x02\x02\u{20c}\u{20f}\x03\x02\x02\x02\u{20d}\
	\u{20b}\x03\x02\x02\x02\u{20d}\u{20e}\x03\x02\x02\x02\u{20e}\u{210}\x03\
	\x02\x02\x02\u{20f}\u{20d}\x03\x02\x02\x02\u{210}\u{211}\x05\u{da}\x6e\x02\
	\u{211}\u{212}\x07\x61\x02\x02\u{212}\u{214}\x05\u{e8}\x75\x02\u{213}\u{215}\
	\x05\x34\x1b\x02\u{214}\u{213}\x03\x02\x02\x02\u{214}\u{215}\x03\x02\x02\
	\x02\u{215}\u{217}\x03\x02\x02\x02\u{216}\u{218}\x05\x64\x33\x02\u{217}\
	\u{216}\x03\x02\x02\x02\u{217}\u{218}\x03\x02\x02\x02\u{218}\u{219}\x03\
	\x02\x02\x02\u{219}\u{21a}\x05\x36\x1c\x02\u{21a}\x33\x03\x02\x02\x02\u{21b}\
	\u{21d}\x07\x09\x02\x02\u{21c}\u{21e}\x05\x78\x3d\x02\u{21d}\u{21c}\x03\
	\x02\x02\x02\u{21d}\u{21e}\x03\x02\x02\x02\u{21e}\u{21f}\x03\x02\x02\x02\
	\u{21f}\u{220}\x07\x0a\x02\x02\u{220}\x35\x03\x02\x02\x02\u{221}\u{227}\
	\x07\x0d\x02\x02\u{222}\u{226}\x05\x24\x13\x02\u{223}\u{226}\x05\x38\x1d\
	\x02\u{224}\u{226}\x05\x0a\x06\x02\u{225}\u{222}\x03\x02\x02\x02\u{225}\
	\u{223}\x03\x02\x02\x02\u{225}\u{224}\x03\x02\x02\x02\u{226}\u{229}\x03\
	\x02\x02\x02\u{227}\u{225}\x03\x02\x02\x02\u{227}\u{228}\x03\x02\x02\x02\
	\u{228}\u{22a}\x03\x02\x02\x02\u{229}\u{227}\x03\x02\x02\x02\u{22a}\u{22b}\
	\x07\x0e\x02\x02\u{22b}\x37\x03\x02\x02\x02\u{22c}\u{22e}\x05\u{e8}\x75\
	\x02\u{22d}\u{22f}\x05\x3a\x1e\x02\u{22e}\u{22d}\x03\x02\x02\x02\u{22e}\
	\u{22f}\x03\x02\x02\x02\u{22f}\x39\x03\x02\x02\x02\u{230}\u{235}\x07\x0d\
	\x02\x02\u{231}\u{234}\x05\x22\x12\x02\u{232}\u{234}\x05\x0a\x06\x02\u{233}\
	\u{231}\x03\x02\x02\x02\u{233}\u{232}\x03\x02\x02\x02\u{234}\u{237}\x03\
	\x02\x02\x02\u{235}\u{233}\x03\x02\x02\x02\u{235}\u{236}\x03\x02\x02\x02\
	\u{236}\u{238}\x03\x02\x02\x02\u{237}\u{235}\x03\x02\x02\x02\u{238}\u{239}\
	\x07\x0e\x02\x02\u{239}\x3b\x03\x02\x02\x02\u{23a}\u{23c}\x05\u{ac}\x57\
	\x02\u{23b}\u{23a}\x03\x02\x02\x02\u{23c}\u{23f}\x03\x02\x02\x02\u{23d}\
	\u{23b}\x03\x02\x02\x02\u{23d}\u{23e}\x03\x02\x02\x02\u{23e}\u{240}\x03\
	\x02\x02\x02\u{23f}\u{23d}\x03\x02\x02\x02\u{240}\u{241}\x05\u{da}\x6e\x02\
	\u{241}\u{242}\x07\x62\x02\x02\u{242}\u{244}\x05\u{e8}\x75\x02\u{243}\u{245}\
	\x05\x34\x1b\x02\u{244}\u{243}\x03\x02\x02\x02\u{244}\u{245}\x03\x02\x02\
	\x02\u{245}\u{247}\x03\x02\x02\x02\u{246}\u{248}\x05\x64\x33\x02\u{247}\
	\u{246}\x03\x02\x02\x02\u{247}\u{248}\x03\x02\x02\x02\u{248}\u{249}\x03\
	\x02\x02\x02\u{249}\u{24a}\x05\x3e\x20\x02\u{24a}\x3d\x03\x02\x02\x02\u{24b}\
	\u{251}\x07\x0d\x02\x02\u{24c}\u{250}\x05\x24\x13\x02\u{24d}\u{250}\x05\
	\x40\x21\x02\u{24e}\u{250}\x05\x0a\x06\x02\u{24f}\u{24c}\x03\x02\x02\x02\
	\u{24f}\u{24d}\x03\x02\x02\x02\u{24f}\u{24e}\x03\x02\x02\x02\u{250}\u{253}\
	\x03\x02\x02\x02\u{251}\u{24f}\x03\x02\x02\x02\u{251}\u{252}\x03\x02\x02\
	\x02\u{252}\u{254}\x03\x02\x02\x02\u{253}\u{251}\x03\x02\x02\x02\u{254}\
	\u{255}\x07\x0e\x02\x02\u{255}\x3f\x03\x02\x02\x02\u{256}\u{258}\x05\u{ac}\
	\x57\x02\u{257}\u{256}\x03\x02\x02\x02\u{258}\u{25b}\x03\x02\x02\x02\u{259}\
	\u{257}\x03\x02\x02\x02\u{259}\u{25a}\x03\x02\x02\x02\u{25a}\u{25c}\x03\
	\x02\x02\x02\u{25b}\u{259}\x03\x02\x02\x02\u{25c}\u{25f}\x05\u{e8}\x75\x02\
	\u{25d}\u{25e}\x07\x2e\x02\x02\u{25e}\u{260}\x05\x74\x3b\x02\u{25f}\u{25d}\
	\x03\x02\x02\x02\u{25f}\u{260}\x03\x02\x02\x02\u{260}\x41\x03\x02\x02\x02\
	\u{261}\u{263}\x05\u{a0}\x51\x02\u{262}\u{261}\x03\x02\x02\x02\u{262}\u{263}\
	\x03\x02\x02\x02\u{263}\u{267}\x03\x02\x02\x02\u{264}\u{266}\x05\u{ac}\x57\
	\x02\u{265}\u{264}\x03\x02\x02\x02\u{266}\u{269}\x03\x02\x02\x02\u{267}\
	\u{265}\x03\x02\x02\x02\u{267}\u{268}\x03\x02\x02\x02\u{268}\u{26a}\x03\
	\x02\x02\x02\u{269}\u{267}\x03\x02\x02\x02\u{26a}\u{26b}\x05\u{da}\x6e\x02\
	\u{26b}\u{26c}\x07\x6f\x02\x02\u{26c}\u{26e}\x05\u{e6}\x74\x02\u{26d}\u{26f}\
	\x05\u{92}\x4a\x02\u{26e}\u{26d}\x03\x02\x02\x02\u{26e}\u{26f}\x03\x02\x02\
	\x02\u{26f}\u{270}\x03\x02\x02\x02\u{270}\u{272}\x05\x44\x23\x02\u{271}\
	\u{273}\x05\x64\x33\x02\u{272}\u{271}\x03\x02\x02\x02\u{272}\u{273}\x03\
	\x02\x02\x02\u{273}\u{275}\x03\x02\x02\x02\u{274}\u{276}\x05\x66\x34\x02\
	\u{275}\u{274}\x03\x02\x02\x02\u{275}\u{276}\x03\x02\x02\x02\u{276}\u{277}\
	\x03\x02\x02\x02\u{277}\u{278}\x05\x56\x2c\x02\u{278}\x43\x03\x02\x02\x02\
	\u{279}\u{27a}\x07\x09\x02\x02\u{27a}\u{287}\x07\x0a\x02\x02\u{27b}\u{27c}\
	\x07\x09\x02\x02\u{27c}\u{281}\x05\x46\x24\x02\u{27d}\u{27e}\x07\x04\x02\
	\x02\u{27e}\u{280}\x05\x46\x24\x02\u{27f}\u{27d}\x03\x02\x02\x02\u{280}\
	\u{283}\x03\x02\x02\x02\u{281}\u{27f}\x03\x02\x02\x02\u{281}\u{282}\x03\
	\x02\x02\x02\u{282}\u{284}\x03\x02\x02\x02\u{283}\u{281}\x03\x02\x02\x02\
	\u{284}\u{285}\x07\x0a\x02\x02\u{285}\u{287}\x03\x02\x02\x02\u{286}\u{279}\
	\x03\x02\x02\x02\u{286}\u{27b}\x03\x02\x02\x02\u{287}\x45\x03\x02\x02\x02\
	\u{288}\u{28a}\x05\u{ac}\x57\x02\u{289}\u{288}\x03\x02\x02\x02\u{28a}\u{28d}\
	\x03\x02\x02\x02\u{28b}\u{289}\x03\x02\x02\x02\u{28b}\u{28c}\x03\x02\x02\
	\x02\u{28c}\u{28e}\x03\x02\x02\x02\u{28d}\u{28b}\x03\x02\x02\x02\u{28e}\
	\u{290}\x05\u{dc}\x6f\x02\u{28f}\u{291}\x05\x64\x33\x02\u{290}\u{28f}\x03\
	\x02\x02\x02\u{290}\u{291}\x03\x02\x02\x02\u{291}\u{293}\x03\x02\x02\x02\
	\u{292}\u{294}\x05\x48\x25\x02\u{293}\u{292}\x03\x02\x02\x02\u{293}\u{294}\
	\x03\x02\x02\x02\u{294}\x47\x03\x02\x02\x02\u{295}\u{296}\x07\x2e\x02\x02\
	\u{296}\u{297}\x05\x74\x3b\x02\u{297}\x49\x03\x02\x02\x02\u{298}\u{29a}\
	\x07\x47\x02\x02\u{299}\u{298}\x03\x02\x02\x02\u{299}\u{29a}\x03\x02\x02\
	\x02\u{29a}\u{29b}\x03\x02\x02\x02\u{29b}\u{29c}\x05\x4e\x28\x02\u{29c}\
	\x4b\x03\x02\x02\x02\u{29d}\u{29f}\x07\x47\x02\x02\u{29e}\u{29d}\x03\x02\
	\x02\x02\u{29e}\u{29f}\x03\x02\x02\x02\u{29f}\u{2a0}\x03\x02\x02\x02\u{2a0}\
	\u{2a1}\x07\x03\x02\x02\u{2a1}\u{2a3}\x05\u{e6}\x74\x02\u{2a2}\u{2a4}\x05\
	\x4e\x28\x02\u{2a3}\u{2a2}\x03\x02\x02\x02\u{2a3}\u{2a4}\x03\x02\x02\x02\
	\u{2a4}\u{2b1}\x03\x02\x02\x02\u{2a5}\u{2a7}\x07\x47\x02\x02\u{2a6}\u{2a5}\
	\x03\x02\x02\x02\u{2a6}\u{2a7}\x03\x02\x02\x02\u{2a7}\u{2a8}\x03\x02\x02\
	\x02\u{2a8}\u{2aa}\x07\x03\x02\x02\u{2a9}\u{2ab}\x07\x41\x02\x02\u{2aa}\
	\u{2a9}\x03\x02\x02\x02\u{2aa}\u{2ab}\x03\x02\x02\x02\u{2ab}\u{2ac}\x03\
	\x02\x02\x02\u{2ac}\u{2ae}\x05\u{e6}\x74\x02\u{2ad}\u{2af}\x05\x4e\x28\x02\
	\u{2ae}\u{2ad}\x03\x02\x02\x02\u{2ae}\u{2af}\x03\x02\x02\x02\u{2af}\u{2b1}\
	\x03\x02\x02\x02\u{2b0}\u{29e}\x03\x02\x02\x02\u{2b0}\u{2a6}\x03\x02\x02\
	\x02\u{2b1}\x4d\x03\x02\x02\x02\u{2b2}\u{2b3}\x07\x09\x02\x02\u{2b3}\u{2c3}\
	\x07\x0a\x02\x02\u{2b4}\u{2b5}\x07\x09\x02\x02\u{2b5}\u{2ba}\x05\x50\x29\
	\x02\u{2b6}\u{2b7}\x07\x04\x02\x02\u{2b7}\u{2b9}\x05\x50\x29\x02\u{2b8}\
	\u{2b6}\x03\x02\x02\x02\u{2b9}\u{2bc}\x03\x02\x02\x02\u{2ba}\u{2b8}\x03\
	\x02\x02\x02\u{2ba}\u{2bb}\x03\x02\x02\x02\u{2bb}\u{2be}\x03\x02\x02\x02\
	\u{2bc}\u{2ba}\x03\x02\x02\x02\u{2bd}\u{2bf}\x07\x04\x02\x02\u{2be}\u{2bd}\
	\x03\x02\x02\x02\u{2be}\u{2bf}\x03\x02\x02\x02\u{2bf}\u{2c0}\x03\x02\x02\
	\x02\u{2c0}\u{2c1}\x07\x0a\x02\x02\u{2c1}\u{2c3}\x03\x02\x02\x02\u{2c2}\
	\u{2b2}\x03\x02\x02\x02\u{2c2}\u{2b4}\x03\x02\x02\x02\u{2c3}\x4f\x03\x02\
	\x02\x02\u{2c4}\u{2c5}\x05\u{e8}\x75\x02\u{2c5}\u{2c6}\x07\x08\x02\x02\u{2c6}\
	\u{2c7}\x05\x74\x3b\x02\u{2c7}\u{2ca}\x03\x02\x02\x02\u{2c8}\u{2ca}\x05\
	\x74\x3b\x02\u{2c9}\u{2c4}\x03\x02\x02\x02\u{2c9}\u{2c8}\x03\x02\x02\x02\
	\u{2ca}\x51\x03\x02\x02\x02\u{2cb}\u{2cd}\x05\u{ac}\x57\x02\u{2cc}\u{2cb}\
	\x03\x02\x02\x02\u{2cd}\u{2d0}\x03\x02\x02\x02\u{2ce}\u{2cc}\x03\x02\x02\
	\x02\u{2ce}\u{2cf}\x03\x02\x02\x02\u{2cf}\u{2d1}\x03\x02\x02\x02\u{2d0}\
	\u{2ce}\x03\x02\x02\x02\u{2d1}\u{2d2}\x07\x6e\x02\x02\u{2d2}\u{2d4}\x05\
	\x44\x23\x02\u{2d3}\u{2d5}\x05\x64\x33\x02\u{2d4}\u{2d3}\x03\x02\x02\x02\
	\u{2d4}\u{2d5}\x03\x02\x02\x02\u{2d5}\u{2d6}\x03\x02\x02\x02\u{2d6}\u{2d7}\
	\x05\x56\x2c\x02\u{2d7}\x53\x03\x02\x02\x02\u{2d8}\u{2da}\x07\x47\x02\x02\
	\u{2d9}\u{2d8}\x03\x02\x02\x02\u{2d9}\u{2da}\x03\x02\x02\x02\u{2da}\u{2db}\
	\x03\x02\x02\x02\u{2db}\u{2dc}\x05\x56\x2c\x02\u{2dc}\x55\x03\x02\x02\x02\
	\u{2dd}\u{2e1}\x07\x0d\x02\x02\u{2de}\u{2e0}\x05\x06\x04\x02\u{2df}\u{2de}\
	\x03\x02\x02\x02\u{2e0}\u{2e3}\x03\x02\x02\x02\u{2e1}\u{2df}\x03\x02\x02\
	\x02\u{2e1}\u{2e2}\x03\x02\x02\x02\u{2e2}\u{2e4}\x03\x02\x02\x02\u{2e3}\
	\u{2e1}\x03\x02\x02\x02\u{2e4}\u{2e5}\x07\x0e\x02\x02\u{2e5}\x57\x03\x02\
	\x02\x02\u{2e6}\u{2e7}\x07\x6a\x02\x02\u{2e7}\u{2e9}\x05\x5a\x2e\x02\u{2e8}\
	\u{2ea}\x05\x64\x33\x02\u{2e9}\u{2e8}\x03\x02\x02\x02\u{2e9}\u{2ea}\x03\
	\x02\x02\x02\u{2ea}\u{2ed}\x03\x02\x02\x02\u{2eb}\u{2ec}\x07\x2e\x02\x02\
	\u{2ec}\u{2ee}\x05\x74\x3b\x02\u{2ed}\u{2eb}\x03\x02\x02\x02\u{2ed}\u{2ee}\
	\x03\x02\x02\x02\u{2ee}\x59\x03\x02\x02\x02\u{2ef}\u{2f2}\x05\x5e\x30\x02\
	\u{2f0}\u{2f2}\x05\x5c\x2f\x02\u{2f1}\u{2ef}\x03\x02\x02\x02\u{2f1}\u{2f0}\
	\x03\x02\x02\x02\u{2f2}\x5b\x03\x02\x02\x02\u{2f3}\u{2f8}\x05\u{dc}\x6f\
	\x02\u{2f4}\u{2f5}\x07\x04\x02\x02\u{2f5}\u{2f7}\x05\u{dc}\x6f\x02\u{2f6}\
	\u{2f4}\x03\x02\x02\x02\u{2f7}\u{2fa}\x03\x02\x02\x02\u{2f8}\u{2f6}\x03\
	\x02\x02\x02\u{2f8}\u{2f9}\x03\x02\x02\x02\u{2f9}\u{2fc}\x03\x02\x02\x02\
	\u{2fa}\u{2f8}\x03\x02\x02\x02\u{2fb}\u{2fd}\x07\x04\x02\x02\u{2fc}\u{2fb}\
	\x03\x02\x02\x02\u{2fc}\u{2fd}\x03\x02\x02\x02\u{2fd}\x5d\x03\x02\x02\x02\
	\u{2fe}\u{30c}\x07\x09\x02\x02\u{2ff}\u{300}\x05\x60\x31\x02\u{300}\u{301}\
	\x07\x04\x02\x02\u{301}\u{30d}\x03\x02\x02\x02\u{302}\u{305}\x05\x60\x31\
	\x02\u{303}\u{304}\x07\x04\x02\x02\u{304}\u{306}\x05\x60\x31\x02\u{305}\
	\u{303}\x03\x02\x02\x02\u{306}\u{307}\x03\x02\x02\x02\u{307}\u{305}\x03\
	\x02\x02\x02\u{307}\u{308}\x03\x02\x02\x02\u{308}\u{30a}\x03\x02\x02\x02\
	\u{309}\u{30b}\x07\x04\x02\x02\u{30a}\u{309}\x03\x02\x02\x02\u{30a}\u{30b}\
	\x03\x02\x02\x02\u{30b}\u{30d}\x03\x02\x02\x02\u{30c}\u{2ff}\x03\x02\x02\
	\x02\u{30c}\u{302}\x03\x02\x02\x02\u{30c}\u{30d}\x03\x02\x02\x02\u{30d}\
	\u{30e}\x03\x02\x02\x02\u{30e}\u{345}\x07\x0a\x02\x02\u{30f}\u{310}\x05\
	\u{e6}\x74\x02\u{310}\u{31c}\x07\x09\x02\x02\u{311}\u{316}\x05\x60\x31\x02\
	\u{312}\u{313}\x07\x04\x02\x02\u{313}\u{315}\x05\x60\x31\x02\u{314}\u{312}\
	\x03\x02\x02\x02\u{315}\u{318}\x03\x02\x02\x02\u{316}\u{314}\x03\x02\x02\
	\x02\u{316}\u{317}\x03\x02\x02\x02\u{317}\u{31a}\x03\x02\x02\x02\u{318}\
	\u{316}\x03\x02\x02\x02\u{319}\u{31b}\x07\x04\x02\x02\u{31a}\u{319}\x03\
	\x02\x02\x02\u{31a}\u{31b}\x03\x02\x02\x02\u{31b}\u{31d}\x03\x02\x02\x02\
	\u{31c}\u{311}\x03\x02\x02\x02\u{31c}\u{31d}\x03\x02\x02\x02\u{31d}\u{31e}\
	\x03\x02\x02\x02\u{31e}\u{31f}\x07\x0a\x02\x02\u{31f}\u{345}\x03\x02\x02\
	\x02\u{320}\u{322}\x05\u{e6}\x74\x02\u{321}\u{320}\x03\x02\x02\x02\u{321}\
	\u{322}\x03\x02\x02\x02\u{322}\u{323}\x03\x02\x02\x02\u{323}\u{32f}\x07\
	\x0b\x02\x02\u{324}\u{329}\x05\x60\x31\x02\u{325}\u{326}\x07\x04\x02\x02\
	\u{326}\u{328}\x05\x60\x31\x02\u{327}\u{325}\x03\x02\x02\x02\u{328}\u{32b}\
	\x03\x02\x02\x02\u{329}\u{327}\x03\x02\x02\x02\u{329}\u{32a}\x03\x02\x02\
	\x02\u{32a}\u{32d}\x03\x02\x02\x02\u{32b}\u{329}\x03\x02\x02\x02\u{32c}\
	\u{32e}\x07\x04\x02\x02\u{32d}\u{32c}\x03\x02\x02\x02\u{32d}\u{32e}\x03\
	\x02\x02\x02\u{32e}\u{330}\x03\x02\x02\x02\u{32f}\u{324}\x03\x02\x02\x02\
	\u{32f}\u{330}\x03\x02\x02\x02\u{330}\u{331}\x03\x02\x02\x02\u{331}\u{345}\
	\x07\x0c\x02\x02\u{332}\u{334}\x05\u{e6}\x74\x02\u{333}\u{332}\x03\x02\x02\
	\x02\u{333}\u{334}\x03\x02\x02\x02\u{334}\u{335}\x03\x02\x02\x02\u{335}\
	\u{341}\x07\x0d\x02\x02\u{336}\u{33b}\x05\x60\x31\x02\u{337}\u{338}\x07\
	\x04\x02\x02\u{338}\u{33a}\x05\x60\x31\x02\u{339}\u{337}\x03\x02\x02\x02\
	\u{33a}\u{33d}\x03\x02\x02\x02\u{33b}\u{339}\x03\x02\x02\x02\u{33b}\u{33c}\
	\x03\x02\x02\x02\u{33c}\u{33f}\x03\x02\x02\x02\u{33d}\u{33b}\x03\x02\x02\
	\x02\u{33e}\u{340}\x07\x04\x02\x02\u{33f}\u{33e}\x03\x02\x02\x02\u{33f}\
	\u{340}\x03\x02\x02\x02\u{340}\u{342}\x03\x02\x02\x02\u{341}\u{336}\x03\
	\x02\x02\x02\u{341}\u{342}\x03\x02\x02\x02\u{342}\u{343}\x03\x02\x02\x02\
	\u{343}\u{345}\x07\x0e\x02\x02\u{344}\u{2fe}\x03\x02\x02\x02\u{344}\u{30f}\
	\x03\x02\x02\x02\u{344}\u{321}\x03\x02\x02\x02\u{344}\u{333}\x03\x02\x02\
	\x02\u{345}\x5f\x03\x02\x02\x02\u{346}\u{347}\x05\u{dc}\x6f\x02\u{347}\u{348}\
	\x07\x08\x02\x02\u{348}\u{34a}\x03\x02\x02\x02\u{349}\u{346}\x03\x02\x02\
	\x02\u{349}\u{34a}\x03\x02\x02\x02\u{34a}\u{34e}\x03\x02\x02\x02\u{34b}\
	\u{34c}\x05\u{e8}\x75\x02\u{34c}\u{34d}\x07\x2f\x02\x02\u{34d}\u{34f}\x03\
	\x02\x02\x02\u{34e}\u{34b}\x03\x02\x02\x02\u{34e}\u{34f}\x03\x02\x02\x02\
	\u{34f}\u{350}\x03\x02\x02\x02\u{350}\u{365}\x05\x5e\x30\x02\u{351}\u{352}\
	\x05\u{dc}\x6f\x02\u{352}\u{353}\x07\x08\x02\x02\u{353}\u{355}\x03\x02\x02\
	\x02\u{354}\u{351}\x03\x02\x02\x02\u{354}\u{355}\x03\x02\x02\x02\u{355}\
	\u{359}\x03\x02\x02\x02\u{356}\u{357}\x05\u{e8}\x75\x02\u{357}\u{358}\x07\
	\x2f\x02\x02\u{358}\u{35a}\x03\x02\x02\x02\u{359}\u{356}\x03\x02\x02\x02\
	\u{359}\u{35a}\x03\x02\x02\x02\u{35a}\u{35b}\x03\x02\x02\x02\u{35b}\u{365}\
	\x05\u{e8}\x75\x02\u{35c}\u{35e}\x05\u{dc}\x6f\x02\u{35d}\u{35c}\x03\x02\
	\x02\x02\u{35d}\u{35e}\x03\x02\x02\x02\u{35e}\u{35f}\x03\x02\x02\x02\u{35f}\
	\u{361}\x07\x52\x02\x02\u{360}\u{362}\x05\u{e8}\x75\x02\u{361}\u{360}\x03\
	\x02\x02\x02\u{361}\u{362}\x03\x02\x02\x02\u{362}\u{365}\x03\x02\x02\x02\
	\u{363}\u{365}\x05\u{dc}\x6f\x02\u{364}\u{349}\x03\x02\x02\x02\u{364}\u{354}\
	\x03\x02\x02\x02\u{364}\u{35d}\x03\x02\x02\x02\u{364}\u{363}\x03\x02\x02\
	\x02\u{365}\x61\x03\x02\x02\x02\u{366}\u{367}\x07\x63\x02\x02\u{367}\u{368}\
	\x05\u{e8}\x75\x02\u{368}\u{369}\x07\x2e\x02\x02\u{369}\u{36a}\x05\u{e8}\
	\x75\x02\u{36a}\x63\x03\x02\x02\x02\u{36b}\u{36c}\x09\x06\x02\x02\u{36c}\
	\u{36d}\x05\x78\x3d\x02\u{36d}\x65\x03\x02\x02\x02\u{36e}\u{36f}\x07\x20\
	\x02\x02\u{36f}\u{370}\x05\x78\x3d\x02\u{370}\x67\x03\x02\x02\x02\u{371}\
	\u{373}\x05\u{ac}\x57\x02\u{372}\u{371}\x03\x02\x02\x02\u{373}\u{376}\x03\
	\x02\x02\x02\u{374}\u{372}\x03\x02\x02\x02\u{374}\u{375}\x03\x02\x02\x02\
	\u{375}\u{377}\x03\x02\x02\x02\u{376}\u{374}\x03\x02\x02\x02\u{377}\u{378}\
	\x07\x7b\x02\x02\u{378}\u{379}\x05\x76\x3c\x02\u{379}\u{37d}\x05\x56\x2c\
	\x02\u{37a}\u{37c}\x05\x6a\x36\x02\u{37b}\u{37a}\x03\x02\x02\x02\u{37c}\
	\u{37f}\x03\x02\x02\x02\u{37d}\u{37b}\x03\x02\x02\x02\u{37d}\u{37e}\x03\
	\x02\x02\x02\u{37e}\u{382}\x03\x02\x02\x02\u{37f}\u{37d}\x03\x02\x02\x02\
	\u{380}\u{381}\x07\x7c\x02\x02\u{381}\u{383}\x05\x56\x2c\x02\u{382}\u{380}\
	\x03\x02\x02\x02\u{382}\u{383}\x03\x02\x02\x02\u{383}\u{396}\x03\x02\x02\
	\x02\u{384}\u{386}\x05\u{ac}\x57\x02\u{385}\u{384}\x03\x02\x02\x02\u{386}\
	\u{389}\x03\x02\x02\x02\u{387}\u{385}\x03\x02\x02\x02\u{387}\u{388}\x03\
	\x02\x02\x02\u{388}\u{38a}\x03\x02\x02\x02\u{389}\u{387}\x03\x02\x02\x02\
	\u{38a}\u{38b}\x07\x7b\x02\x02\u{38b}\u{38f}\x09\x07\x02\x02\u{38c}\u{390}\
	\x05\x5e\x30\x02\u{38d}\u{390}\x05\u{e8}\x75\x02\u{38e}\u{390}\x07\u{84}\
	\x02\x02\u{38f}\u{38c}\x03\x02\x02\x02\u{38f}\u{38d}\x03\x02\x02\x02\u{38f}\
	\u{38e}\x03\x02\x02\x02\u{390}\u{391}\x03\x02\x02\x02\u{391}\u{392}\x07\
	\x2e\x02\x02\u{392}\u{393}\x05\x76\x3c\x02\u{393}\u{394}\x05\x56\x2c\x02\
	\u{394}\u{396}\x03\x02\x02\x02\u{395}\u{374}\x03\x02\x02\x02\u{395}\u{387}\
	\x03\x02\x02\x02\u{396}\x69\x03\x02\x02\x02\u{397}\u{398}\x07\x7c\x02\x02\
	\u{398}\u{399}\x07\x7b\x02\x02\u{399}\u{39a}\x05\x76\x3c\x02\u{39a}\u{39b}\
	\x05\x56\x2c\x02\u{39b}\x6b\x03\x02\x02\x02\u{39c}\u{39e}\x05\u{ac}\x57\
	\x02\u{39d}\u{39c}\x03\x02\x02\x02\u{39e}\u{3a1}\x03\x02\x02\x02\u{39f}\
	\u{39d}\x03\x02\x02\x02\u{39f}\u{3a0}\x03\x02\x02\x02\u{3a0}\u{3a2}\x03\
	\x02\x02\x02\u{3a1}\u{39f}\x03\x02\x02\x02\u{3a2}\u{3a3}\x07\x68\x02\x02\
	\u{3a3}\u{3a4}\x05\x76\x3c\x02\u{3a4}\u{3a5}\x05\x56\x2c\x02\u{3a5}\u{3b4}\
	\x03\x02\x02\x02\u{3a6}\u{3a8}\x05\u{ac}\x57\x02\u{3a7}\u{3a6}\x03\x02\x02\
	\x02\u{3a8}\u{3ab}\x03\x02\x02\x02\u{3a9}\u{3a7}\x03\x02\x02\x02\u{3a9}\
	\u{3aa}\x03\x02\x02\x02\u{3aa}\u{3ac}\x03\x02\x02\x02\u{3ab}\u{3a9}\x03\
	\x02\x02\x02\u{3ac}\u{3ad}\x07\x68\x02\x02\u{3ad}\u{3ae}\x07\x6a\x02\x02\
	\u{3ae}\u{3af}\x05\x5a\x2e\x02\u{3af}\u{3b0}\x07\x2e\x02\x02\u{3b0}\u{3b1}\
	\x05\x76\x3c\x02\u{3b1}\u{3b2}\x05\x56\x2c\x02\u{3b2}\u{3b4}\x03\x02\x02\
	\x02\u{3b3}\u{39f}\x03\x02\x02\x02\u{3b3}\u{3a9}\x03\x02\x02\x02\u{3b4}\
	\x6d\x03\x02\x02\x02\u{3b5}\u{3b7}\x05\u{ac}\x57\x02\u{3b6}\u{3b5}\x03\x02\
	\x02\x02\u{3b7}\u{3ba}\x03\x02\x02\x02\u{3b8}\u{3b6}\x03\x02\x02\x02\u{3b8}\
	\u{3b9}\x03\x02\x02\x02\u{3b9}\u{3bb}\x03\x02\x02\x02\u{3ba}\u{3b8}\x03\
	\x02\x02\x02\u{3bb}\u{3bc}\x07\x69\x02\x02\u{3bc}\u{3bd}\x05\x5a\x2e\x02\
	\u{3bd}\u{3be}\x05\u{90}\x49\x02\u{3be}\u{3c0}\x05\x76\x3c\x02\u{3bf}\u{3c1}\
	\x05\x70\x39\x02\u{3c0}\u{3bf}\x03\x02\x02\x02\u{3c0}\u{3c1}\x03\x02\x02\
	\x02\u{3c1}\u{3c2}\x03\x02\x02\x02\u{3c2}\u{3c3}\x05\x56\x2c\x02\u{3c3}\
	\x6f\x03\x02\x02\x02\u{3c4}\u{3c5}\x07\x7b\x02\x02\u{3c5}\u{3c6}\x05\x76\
	\x3c\x02\u{3c6}\x71\x03\x02\x02\x02\u{3c7}\u{3c9}\x05\u{ac}\x57\x02\u{3c8}\
	\u{3c7}\x03\x02\x02\x02\u{3c9}\u{3cc}\x03\x02\x02\x02\u{3ca}\u{3c8}\x03\
	\x02\x02\x02\u{3ca}\u{3cb}\x03\x02\x02\x02\u{3cb}\u{3cd}\x03\x02\x02\x02\
	\u{3cc}\u{3ca}\x03\x02\x02\x02\u{3cd}\u{3ce}\x05\x74\x3b\x02\u{3ce}\x73\
	\x03\x02\x02\x02\u{3cf}\u{3d0}\x08\x3b\x01\x02\u{3d0}\u{3e7}\x05\x7e\x40\
	\x02\u{3d1}\u{3d2}\x05\x7a\x3e\x02\u{3d2}\u{3d3}\x05\x74\x3b\x12\u{3d3}\
	\u{3e7}\x03\x02\x02\x02\u{3d4}\u{3d5}\x07\x09\x02\x02\u{3d5}\u{3d6}\x05\
	\x74\x3b\x02\u{3d6}\u{3d7}\x07\x0a\x02\x02\u{3d7}\u{3e7}\x03\x02\x02\x02\
	\u{3d8}\u{3e7}\x05\u{b0}\x59\x02\u{3d9}\u{3e7}\x05\x68\x35\x02\u{3da}\u{3e7}\
	\x05\u{b2}\x5a\x02\u{3db}\u{3e7}\x05\u{c4}\x63\x02\u{3dc}\u{3e7}\x05\u{c2}\
	\x62\x02\u{3dd}\u{3e7}\x05\u{aa}\x56\x02\u{3de}\u{3e7}\x05\x4a\x26\x02\u{3df}\
	\u{3e7}\x05\u{9c}\x4f\x02\u{3e0}\u{3e7}\x05\u{ca}\x66\x02\u{3e1}\u{3e7}\
	\x05\u{f0}\x79\x02\u{3e2}\u{3e7}\x05\u{ec}\x77\x02\u{3e3}\u{3e7}\x05\u{e0}\
	\x71\x02\u{3e4}\u{3e7}\x05\u{e6}\x74\x02\u{3e5}\u{3e7}\x07\u{84}\x02\x02\
	\u{3e6}\u{3cf}\x03\x02\x02\x02\u{3e6}\u{3d1}\x03\x02\x02\x02\u{3e6}\u{3d4}\
	\x03\x02\x02\x02\u{3e6}\u{3d8}\x03\x02\x02\x02\u{3e6}\u{3d9}\x03\x02\x02\
	\x02\u{3e6}\u{3da}\x03\x02\x02\x02\u{3e6}\u{3db}\x03\x02\x02\x02\u{3e6}\
	\u{3dc}\x03\x02\x02\x02\u{3e6}\u{3dd}\x03\x02\x02\x02\u{3e6}\u{3de}\x03\
	\x02\x02\x02\u{3e6}\u{3df}\x03\x02\x02\x02\u{3e6}\u{3e0}\x03\x02\x02\x02\
	\u{3e6}\u{3e1}\x03\x02\x02\x02\u{3e6}\u{3e2}\x03\x02\x02\x02\u{3e6}\u{3e3}\
	\x03\x02\x02\x02\u{3e6}\u{3e4}\x03\x02\x02\x02\u{3e6}\u{3e5}\x03\x02\x02\
	\x02\u{3e7}\u{40d}\x03\x02\x02\x02\u{3e8}\u{3e9}\x0c\x1c\x02\x02\u{3e9}\
	\u{3ea}\x07\x54\x02\x02\u{3ea}\u{40c}\x05\x74\x3b\x1c\u{3eb}\u{3ec}\x0c\
	\x1b\x02\x02\u{3ec}\u{3ed}\x05\u{86}\x44\x02\u{3ed}\u{3ee}\x05\x74\x3b\x1c\
	\u{3ee}\u{40c}\x03\x02\x02\x02\u{3ef}\u{3f0}\x0c\x1a\x02\x02\u{3f0}\u{3f1}\
	\x05\u{88}\x45\x02\u{3f1}\u{3f2}\x05\x74\x3b\x1b\u{3f2}\u{40c}\x03\x02\x02\
	\x02\u{3f3}\u{3f4}\x0c\x19\x02\x02\u{3f4}\u{3f5}\x05\u{8a}\x46\x02\u{3f5}\
	\u{3f6}\x05\x74\x3b\x1a\u{3f6}\u{40c}\x03\x02\x02\x02\u{3f7}\u{3f8}\x0c\
	\x18\x02\x02\u{3f8}\u{3f9}\x05\u{80}\x41\x02\u{3f9}\u{3fa}\x05\x74\x3b\x19\
	\u{3fa}\u{40c}\x03\x02\x02\x02\u{3fb}\u{3fc}\x0c\x17\x02\x02\u{3fc}\u{3fd}\
	\x07\x53\x02\x02\u{3fd}\u{40c}\x05\x74\x3b\x18\u{3fe}\u{3ff}\x0c\x1d\x02\
	\x02\u{3ff}\u{40c}\x05\x7c\x3f\x02\u{400}\u{401}\x0c\x16\x02\x02\u{401}\
	\u{402}\x05\u{8e}\x48\x02\u{402}\u{403}\x05\x78\x3d\x02\u{403}\u{40c}\x03\
	\x02\x02\x02\u{404}\u{405}\x0c\x15\x02\x02\u{405}\u{406}\x05\u{8c}\x47\x02\
	\u{406}\u{407}\x05\x78\x3d\x02\u{407}\u{40c}\x03\x02\x02\x02\u{408}\u{409}\
	\x0c\x14\x02\x02\u{409}\u{40a}\x07\x46\x02\x02\u{40a}\u{40c}\x05\x78\x3d\
	\x02\u{40b}\u{3e8}\x03\x02\x02\x02\u{40b}\u{3eb}\x03\x02\x02\x02\u{40b}\
	\u{3ef}\x03\x02\x02\x02\u{40b}\u{3f3}\x03\x02\x02\x02\u{40b}\u{3f7}\x03\
	\x02\x02\x02\u{40b}\u{3fb}\x03\x02\x02\x02\u{40b}\u{3fe}\x03\x02\x02\x02\
	\u{40b}\u{400}\x03\x02\x02\x02\u{40b}\u{404}\x03\x02\x02\x02\u{40b}\u{408}\
	\x03\x02\x02\x02\u{40c}\u{40f}\x03\x02\x02\x02\u{40d}\u{40b}\x03\x02\x02\
	\x02\u{40d}\u{40e}\x03\x02\x02\x02\u{40e}\x75\x03\x02\x02\x02\u{40f}\u{40d}\
	\x03\x02\x02\x02\u{410}\u{411}\x08\x3c\x01\x02\u{411}\u{412}\x05\x7a\x3e\
	\x02\u{412}\u{413}\x05\x76\x3c\x0a\u{413}\u{41c}\x03\x02\x02\x02\u{414}\
	\u{41c}\x05\u{aa}\x56\x02\u{415}\u{41c}\x05\x4a\x26\x02\u{416}\u{41c}\x05\
	\u{ca}\x66\x02\u{417}\u{41c}\x05\u{f0}\x79\x02\u{418}\u{41c}\x05\u{ec}\x77\
	\x02\u{419}\u{41c}\x05\u{e6}\x74\x02\u{41a}\u{41c}\x07\u{84}\x02\x02\u{41b}\
	\u{410}\x03\x02\x02\x02\u{41b}\u{414}\x03\x02\x02\x02\u{41b}\u{415}\x03\
	\x02\x02\x02\u{41b}\u{416}\x03\x02\x02\x02\u{41b}\u{417}\x03\x02\x02\x02\
	\u{41b}\u{418}\x03\x02\x02\x02\u{41b}\u{419}\x03\x02\x02\x02\u{41b}\u{41a}\
	\x03\x02\x02\x02\u{41c}\u{440}\x03\x02\x02\x02\u{41d}\u{41e}\x0c\x11\x02\
	\x02\u{41e}\u{41f}\x05\u{86}\x44\x02\u{41f}\u{420}\x05\x76\x3c\x12\u{420}\
	\u{43f}\x03\x02\x02\x02\u{421}\u{422}\x0c\x10\x02\x02\u{422}\u{423}\x05\
	\u{88}\x45\x02\u{423}\u{424}\x05\x76\x3c\x11\u{424}\u{43f}\x03\x02\x02\x02\
	\u{425}\u{426}\x0c\x0f\x02\x02\u{426}\u{427}\x05\u{8a}\x46\x02\u{427}\u{428}\
	\x05\x76\x3c\x10\u{428}\u{43f}\x03\x02\x02\x02\u{429}\u{42a}\x0c\x0e\x02\
	\x02\u{42a}\u{42b}\x05\u{80}\x41\x02\u{42b}\u{42c}\x05\x76\x3c\x0f\u{42c}\
	\u{43f}\x03\x02\x02\x02\u{42d}\u{431}\x0c\x0d\x02\x02\u{42e}\u{432}\x07\
	\x4e\x02\x02\u{42f}\u{430}\x07\x4e\x02\x02\u{430}\u{432}\x07\x49\x02\x02\
	\u{431}\u{42e}\x03\x02\x02\x02\u{431}\u{42f}\x03\x02\x02\x02\u{432}\u{433}\
	\x03\x02\x02\x02\u{433}\u{43f}\x05\x76\x3c\x0e\u{434}\u{435}\x0c\x0c\x02\
	\x02\u{435}\u{436}\x07\x53\x02\x02\u{436}\u{43f}\x05\x76\x3c\x0d\u{437}\
	\u{438}\x0c\x0b\x02\x02\u{438}\u{439}\x07\x51\x02\x02\u{439}\u{43f}\x05\
	\x76\x3c\x0c\u{43a}\u{43b}\x0c\x13\x02\x02\u{43b}\u{43f}\x05\x4c\x27\x02\
	\u{43c}\u{43d}\x0c\x12\x02\x02\u{43d}\u{43f}\x05\u{ce}\x68\x02\u{43e}\u{41d}\
	\x03\x02\x02\x02\u{43e}\u{421}\x03\x02\x02\x02\u{43e}\u{425}\x03\x02\x02\
	\x02\u{43e}\u{429}\x03\x02\x02\x02\u{43e}\u{42d}\x03\x02\x02\x02\u{43e}\
	\u{434}\x03\x02\x02\x02\u{43e}\u{437}\x03\x02\x02\x02\u{43e}\u{43a}\x03\
	\x02\x02\x02\u{43e}\u{43c}\x03\x02\x02\x02\u{43f}\u{442}\x03\x02\x02\x02\
	\u{440}\u{43e}\x03\x02\x02\x02\u{440}\u{441}\x03\x02\x02\x02\u{441}\x77\
	\x03\x02\x02\x02\u{442}\u{440}\x03\x02\x02\x02\u{443}\u{444}\x08\x3d\x01\
	\x02\u{444}\u{452}\x07\x09\x02\x02\u{445}\u{446}\x05\x78\x3d\x02\u{446}\
	\u{447}\x07\x04\x02\x02\u{447}\u{453}\x03\x02\x02\x02\u{448}\u{44b}\x05\
	\x78\x3d\x02\u{449}\u{44a}\x07\x04\x02\x02\u{44a}\u{44c}\x05\x78\x3d\x02\
	\u{44b}\u{449}\x03\x02\x02\x02\u{44c}\u{44d}\x03\x02\x02\x02\u{44d}\u{44b}\
	\x03\x02\x02\x02\u{44d}\u{44e}\x03\x02\x02\x02\u{44e}\u{450}\x03\x02\x02\
	\x02\u{44f}\u{451}\x07\x04\x02\x02\u{450}\u{44f}\x03\x02\x02\x02\u{450}\
	\u{451}\x03\x02\x02\x02\u{451}\u{453}\x03\x02\x02\x02\u{452}\u{445}\x03\
	\x02\x02\x02\u{452}\u{448}\x03\x02\x02\x02\u{452}\u{453}\x03\x02\x02\x02\
	\u{453}\u{454}\x03\x02\x02\x02\u{454}\u{45a}\x07\x0a\x02\x02\u{455}\u{45a}\
	\x05\u{f0}\x79\x02\u{456}\u{45a}\x05\u{ec}\x77\x02\u{457}\u{45a}\x05\u{e6}\
	\x74\x02\u{458}\u{45a}\x07\u{84}\x02\x02\u{459}\u{443}\x03\x02\x02\x02\u{459}\
	\u{455}\x03\x02\x02\x02\u{459}\u{456}\x03\x02\x02\x02\u{459}\u{457}\x03\
	\x02\x02\x02\u{459}\u{458}\x03\x02\x02\x02\u{45a}\u{46a}\x03\x02\x02\x02\
	\u{45b}\u{45c}\x0c\x0b\x02\x02\u{45c}\u{45d}\x05\u{82}\x42\x02\u{45d}\u{45e}\
	\x05\x78\x3d\x0c\u{45e}\u{469}\x03\x02\x02\x02\u{45f}\u{460}\x0c\x0a\x02\
	\x02\u{460}\u{461}\x05\u{84}\x43\x02\u{461}\u{462}\x05\x78\x3d\x0b\u{462}\
	\u{469}\x03\x02\x02\x02\u{463}\u{464}\x0c\x09\x02\x02\u{464}\u{465}\x07\
	\x1b\x02\x02\u{465}\u{469}\x05\x78\x3d\x0a\u{466}\u{467}\x0c\x08\x02\x02\
	\u{467}\u{469}\x05\u{98}\x4d\x02\u{468}\u{45b}\x03\x02\x02\x02\u{468}\u{45f}\
	\x03\x02\x02\x02\u{468}\u{463}\x03\x02\x02\x02\u{468}\u{466}\x03\x02\x02\
	\x02\u{469}\u{46c}\x03\x02\x02\x02\u{46a}\u{468}\x03\x02\x02\x02\u{46a}\
	\u{46b}\x03\x02\x02\x02\u{46b}\x79\x03\x02\x02\x02\u{46c}\u{46a}\x03\x02\
	\x02\x02\u{46d}\u{46e}\x09\x08\x02\x02\u{46e}\x7b\x03\x02\x02\x02\u{46f}\
	\u{47b}\x07\x48\x02\x02\u{470}\u{47b}\x07\x57\x02\x02\u{471}\u{47b}\x07\
	\x58\x02\x02\u{472}\u{47b}\x07\x59\x02\x02\u{473}\u{47b}\x05\u{ce}\x68\x02\
	\u{474}\u{47b}\x05\u{9e}\x50\x02\u{475}\u{47b}\x05\u{96}\x4c\x02\u{476}\
	\u{47b}\x05\x54\x2b\x02\u{477}\u{47b}\x05\u{b4}\x5b\x02\u{478}\u{47b}\x05\
	\x4a\x26\x02\u{479}\u{47b}\x05\x4c\x27\x02\u{47a}\u{46f}\x03\x02\x02\x02\
	\u{47a}\u{470}\x03\x02\x02\x02\u{47a}\u{471}\x03\x02\x02\x02\u{47a}\u{472}\
	\x03\x02\x02\x02\u{47a}\u{473}\x03\x02\x02\x02\u{47a}\u{474}\x03\x02\x02\
	\x02\u{47a}\u{475}\x03\x02\x02\x02\u{47a}\u{476}\x03\x02\x02\x02\u{47a}\
	\u{477}\x03\x02\x02\x02\u{47a}\u{478}\x03\x02\x02\x02\u{47a}\u{479}\x03\
	\x02\x02\x02\u{47b}\x7d\x03\x02\x02\x02\u{47c}\u{47e}\x07\x7e\x02\x02\u{47d}\
	\u{47f}\x05\x74\x3b\x02\u{47e}\u{47d}\x03\x02\x02\x02\u{47e}\u{47f}\x03\
	\x02\x02\x02\u{47f}\u{49c}\x03\x02\x02\x02\u{480}\u{481}\x07\x7f\x02\x02\
	\u{481}\u{49c}\x05\x74\x3b\x02\u{482}\u{485}\x07\u{81}\x02\x02\u{483}\u{484}\
	\x07\x5b\x02\x02\u{484}\u{486}\x05\u{e8}\x75\x02\u{485}\u{483}\x03\x02\x02\
	\x02\u{485}\u{486}\x03\x02\x02\x02\u{486}\u{49c}\x03\x02\x02\x02\u{487}\
	\u{48a}\x07\u{82}\x02\x02\u{488}\u{489}\x07\x5b\x02\x02\u{489}\u{48b}\x05\
	\u{e8}\x75\x02\u{48a}\u{488}\x03\x02\x02\x02\u{48a}\u{48b}\x03\x02\x02\x02\
	\u{48b}\u{49c}\x03\x02\x02\x02\u{48c}\u{48d}\x07\u{83}\x02\x02\u{48d}\u{49c}\
	\x05\x74\x3b\x02\u{48e}\u{491}\x07\u{80}\x02\x02\u{48f}\u{490}\x07\x5b\x02\
	\x02\u{490}\u{492}\x05\u{e8}\x75\x02\u{491}\u{48f}\x03\x02\x02\x02\u{491}\
	\u{492}\x03\x02\x02\x02\u{492}\u{494}\x03\x02\x02\x02\u{493}\u{495}\x05\
	\x74\x3b\x02\u{494}\u{493}\x03\x02\x02\x02\u{494}\u{495}\x03\x02\x02\x02\
	\u{495}\u{49c}\x03\x02\x02\x02\u{496}\u{497}\x07\u{80}\x02\x02\u{497}\u{49c}\
	\x07\u{81}\x02\x02\u{498}\u{499}\x07\u{80}\x02\x02\u{499}\u{49a}\x07\x73\
	\x02\x02\u{49a}\u{49c}\x05\x74\x3b\x02\u{49b}\u{47c}\x03\x02\x02\x02\u{49b}\
	\u{480}\x03\x02\x02\x02\u{49b}\u{482}\x03\x02\x02\x02\u{49b}\u{487}\x03\
	\x02\x02\x02\u{49b}\u{48c}\x03\x02\x02\x02\u{49b}\u{48e}\x03\x02\x02\x02\
	\u{49b}\u{496}\x03\x02\x02\x02\u{49b}\u{498}\x03\x02\x02\x02\u{49c}\x7f\
	\x03\x02\x02\x02\u{49d}\u{49e}\x09\x09\x02\x02\u{49e}\u{81}\x03\x02\x02\
	\x02\u{49f}\u{4a0}\x09\x0a\x02\x02\u{4a0}\u{83}\x03\x02\x02\x02\u{4a1}\u{4a2}\
	\x09\x0b\x02\x02\u{4a2}\u{85}\x03\x02\x02\x02\u{4a3}\u{4a4}\x09\x0c\x02\
	\x02\u{4a4}\u{87}\x03\x02\x02\x02\u{4a5}\u{4a6}\x09\x0d\x02\x02\u{4a6}\u{89}\
	\x03\x02\x02\x02\u{4a7}\u{4a8}\x09\x0e\x02\x02\u{4a8}\u{8b}\x03\x02\x02\
	\x02\u{4a9}\u{4aa}\x09\x0f\x02\x02\u{4aa}\u{8d}\x03\x02\x02\x02\u{4ab}\u{4af}\
	\x07\x4e\x02\x02\u{4ac}\u{4ad}\x07\x4e\x02\x02\u{4ad}\u{4af}\x07\x49\x02\
	\x02\u{4ae}\u{4ab}\x03\x02\x02\x02\u{4ae}\u{4ac}\x03\x02\x02\x02\u{4af}\
	\u{8f}\x03\x02\x02\x02\u{4b0}\u{4b1}\x09\x10\x02\x02\u{4b1}\u{91}\x03\x02\
	\x02\x02\u{4b2}\u{4b3}\x07\x0f\x02\x02\u{4b3}\u{4d9}\x07\x10\x02\x02\u{4b4}\
	\u{4b5}\x07\x0f\x02\x02\u{4b5}\u{4ba}\x05\u{94}\x4b\x02\u{4b6}\u{4b7}\x07\
	\x04\x02\x02\u{4b7}\u{4b9}\x05\u{94}\x4b\x02\u{4b8}\u{4b6}\x03\x02\x02\x02\
	\u{4b9}\u{4bc}\x03\x02\x02\x02\u{4ba}\u{4b8}\x03\x02\x02\x02\u{4ba}\u{4bb}\
	\x03\x02\x02\x02\u{4bb}\u{4be}\x03\x02\x02\x02\u{4bc}\u{4ba}\x03\x02\x02\
	\x02\u{4bd}\u{4bf}\x07\x04\x02\x02\u{4be}\u{4bd}\x03\x02\x02\x02\u{4be}\
	\u{4bf}\x03\x02\x02\x02\u{4bf}\u{4c0}\x03\x02\x02\x02\u{4c0}\u{4c1}\x07\
	\x10\x02\x02\u{4c1}\u{4d9}\x03\x02\x02\x02\u{4c2}\u{4c4}\x07\x07\x02\x02\
	\u{4c3}\u{4c2}\x03\x02\x02\x02\u{4c3}\u{4c4}\x03\x02\x02\x02\u{4c4}\u{4c5}\
	\x03\x02\x02\x02\u{4c5}\u{4c6}\x07\x26\x02\x02\u{4c6}\u{4d9}\x07\x2a\x02\
	\x02\u{4c7}\u{4c9}\x07\x07\x02\x02\u{4c8}\u{4c7}\x03\x02\x02\x02\u{4c8}\
	\u{4c9}\x03\x02\x02\x02\u{4c9}\u{4ca}\x03\x02\x02\x02\u{4ca}\u{4cb}\x07\
	\x26\x02\x02\u{4cb}\u{4d0}\x05\u{94}\x4b\x02\u{4cc}\u{4cd}\x07\x04\x02\x02\
	\u{4cd}\u{4cf}\x05\u{94}\x4b\x02\u{4ce}\u{4cc}\x03\x02\x02\x02\u{4cf}\u{4d2}\
	\x03\x02\x02\x02\u{4d0}\u{4ce}\x03\x02\x02\x02\u{4d0}\u{4d1}\x03\x02\x02\
	\x02\u{4d1}\u{4d4}\x03\x02\x02\x02\u{4d2}\u{4d0}\x03\x02\x02\x02\u{4d3}\
	\u{4d5}\x07\x04\x02\x02\u{4d4}\u{4d3}\x03\x02\x02\x02\u{4d4}\u{4d5}\x03\
	\x02\x02\x02\u{4d5}\u{4d6}\x03\x02\x02\x02\u{4d6}\u{4d7}\x07\x2a\x02\x02\
	\u{4d7}\u{4d9}\x03\x02\x02\x02\u{4d8}\u{4b2}\x03\x02\x02\x02\u{4d8}\u{4b4}\
	\x03\x02\x02\x02\u{4d8}\u{4c3}\x03\x02\x02\x02\u{4d8}\u{4c8}\x03\x02\x02\
	\x02\u{4d9}\u{93}\x03\x02\x02\x02\u{4da}\u{4db}\x05\u{e8}\x75\x02\u{4db}\
	\u{4dc}\x07\x08\x02\x02\u{4dc}\u{4de}\x03\x02\x02\x02\u{4dd}\u{4da}\x03\
	\x02\x02\x02\u{4dd}\u{4de}\x03\x02\x02\x02\u{4de}\u{4df}\x03\x02\x02\x02\
	\u{4df}\u{4e0}\x05\x78\x3d\x02\u{4e0}\u{95}\x03\x02\x02\x02\u{4e1}\u{4e2}\
	\x07\x07\x02\x02\u{4e2}\u{4e3}\x07\x26\x02\x02\u{4e3}\u{504}\x07\x2a\x02\
	\x02\u{4e4}\u{4e5}\x07\x07\x02\x02\u{4e5}\u{4e6}\x07\x26\x02\x02\u{4e6}\
	\u{4eb}\x05\u{9a}\x4e\x02\u{4e7}\u{4e8}\x07\x04\x02\x02\u{4e8}\u{4ea}\x05\
	\u{9a}\x4e\x02\u{4e9}\u{4e7}\x03\x02\x02\x02\u{4ea}\u{4ed}\x03\x02\x02\x02\
	\u{4eb}\u{4e9}\x03\x02\x02\x02\u{4eb}\u{4ec}\x03\x02\x02\x02\u{4ec}\u{4ef}\
	\x03\x02\x02\x02\u{4ed}\u{4eb}\x03\x02\x02\x02\u{4ee}\u{4f0}\x07\x04\x02\
	\x02\u{4ef}\u{4ee}\x03\x02\x02\x02\u{4ef}\u{4f0}\x03\x02\x02\x02\u{4f0}\
	\u{4f1}\x03\x02\x02\x02\u{4f1}\u{4f2}\x07\x2a\x02\x02\u{4f2}\u{504}\x03\
	\x02\x02\x02\u{4f3}\u{4f4}\x07\x0f\x02\x02\u{4f4}\u{504}\x07\x10\x02\x02\
	\u{4f5}\u{4f6}\x07\x0f\x02\x02\u{4f6}\u{4fb}\x05\u{9a}\x4e\x02\u{4f7}\u{4f8}\
	\x07\x04\x02\x02\u{4f8}\u{4fa}\x05\u{9a}\x4e\x02\u{4f9}\u{4f7}\x03\x02\x02\
	\x02\u{4fa}\u{4fd}\x03\x02\x02\x02\u{4fb}\u{4f9}\x03\x02\x02\x02\u{4fb}\
	\u{4fc}\x03\x02\x02\x02\u{4fc}\u{4ff}\x03\x02\x02\x02\u{4fd}\u{4fb}\x03\
	\x02\x02\x02\u{4fe}\u{500}\x07\x04\x02\x02\u{4ff}\u{4fe}\x03\x02\x02\x02\
	\u{4ff}\u{500}\x03\x02\x02\x02\u{500}\u{501}\x03\x02\x02\x02\u{501}\u{502}\
	\x07\x10\x02\x02\u{502}\u{504}\x03\x02\x02\x02\u{503}\u{4e1}\x03\x02\x02\
	\x02\u{503}\u{4e4}\x03\x02\x02\x02\u{503}\u{4f3}\x03\x02\x02\x02\u{503}\
	\u{4f5}\x03\x02\x02\x02\u{504}\u{97}\x03\x02\x02\x02\u{505}\u{507}\x07\x07\
	\x02\x02\u{506}\u{505}\x03\x02\x02\x02\u{506}\u{507}\x03\x02\x02\x02\u{507}\
	\u{508}\x03\x02\x02\x02\u{508}\u{509}\x07\x26\x02\x02\u{509}\u{50e}\x05\
	\u{9a}\x4e\x02\u{50a}\u{50b}\x07\x04\x02\x02\u{50b}\u{50d}\x05\u{9a}\x4e\
	\x02\u{50c}\u{50a}\x03\x02\x02\x02\u{50d}\u{510}\x03\x02\x02\x02\u{50e}\
	\u{50c}\x03\x02\x02\x02\u{50e}\u{50f}\x03\x02\x02\x02\u{50f}\u{511}\x03\
	\x02\x02\x02\u{510}\u{50e}\x03\x02\x02\x02\u{511}\u{512}\x07\x2a\x02\x02\
	\u{512}\u{51f}\x03\x02\x02\x02\u{513}\u{514}\x07\x0f\x02\x02\u{514}\u{519}\
	\x05\u{9a}\x4e\x02\u{515}\u{516}\x07\x04\x02\x02\u{516}\u{518}\x05\u{9a}\
	\x4e\x02\u{517}\u{515}\x03\x02\x02\x02\u{518}\u{51b}\x03\x02\x02\x02\u{519}\
	\u{517}\x03\x02\x02\x02\u{519}\u{51a}\x03\x02\x02\x02\u{51a}\u{51c}\x03\
	\x02\x02\x02\u{51b}\u{519}\x03\x02\x02\x02\u{51c}\u{51d}\x07\x10\x02\x02\
	\u{51d}\u{51f}\x03\x02\x02\x02\u{51e}\u{506}\x03\x02\x02\x02\u{51e}\u{513}\
	\x03\x02\x02\x02\u{51f}\u{99}\x03\x02\x02\x02\u{520}\u{521}\x05\u{e8}\x75\
	\x02\u{521}\u{522}\x07\x08\x02\x02\u{522}\u{524}\x03\x02\x02\x02\u{523}\
	\u{520}\x03\x02\x02\x02\u{523}\u{524}\x03\x02\x02\x02\u{524}\u{525}\x03\
	\x02\x02\x02\u{525}\u{526}\x05\x78\x3d\x02\u{526}\u{9b}\x03\x02\x02\x02\
	\u{527}\u{528}\x07\x5b\x02\x02\u{528}\u{529}\x05\u{e8}\x75\x02\u{529}\u{9d}\
	\x03\x02\x02\x02\u{52a}\u{52b}\x07\x07\x02\x02\u{52b}\u{52c}\x07\x0b\x02\
	\x02\u{52c}\u{52d}\x05\x74\x3b\x02\u{52d}\u{52e}\x07\x0c\x02\x02\u{52e}\
	\u{534}\x03\x02\x02\x02\u{52f}\u{530}\x07\x11\x02\x02\u{530}\u{531}\x05\
	\x74\x3b\x02\u{531}\u{532}\x07\x12\x02\x02\u{532}\u{534}\x03\x02\x02\x02\
	\u{533}\u{52a}\x03\x02\x02\x02\u{533}\u{52f}\x03\x02\x02\x02\u{534}\u{9f}\
	\x03\x02\x02\x02\u{535}\u{537}\x05\u{ac}\x57\x02\u{536}\u{535}\x03\x02\x02\
	\x02\u{537}\u{53a}\x03\x02\x02\x02\u{538}\u{536}\x03\x02\x02\x02\u{538}\
	\u{539}\x03\x02\x02\x02\u{539}\u{53b}\x03\x02\x02\x02\u{53a}\u{538}\x03\
	\x02\x02\x02\u{53b}\u{53c}\x05\u{da}\x6e\x02\u{53c}\u{53d}\x07\x64\x02\x02\
	\u{53d}\u{53e}\x05\u{a2}\x52\x02\u{53e}\u{555}\x03\x02\x02\x02\u{53f}\u{541}\
	\x05\u{ac}\x57\x02\u{540}\u{53f}\x03\x02\x02\x02\u{541}\u{544}\x03\x02\x02\
	\x02\u{542}\u{540}\x03\x02\x02\x02\u{542}\u{543}\x03\x02\x02\x02\u{543}\
	\u{545}\x03\x02\x02\x02\u{544}\u{542}\x03\x02\x02\x02\u{545}\u{546}\x05\
	\u{da}\x6e\x02\u{546}\u{547}\x07\x64\x02\x02\u{547}\u{54c}\x05\u{e8}\x75\
	\x02\u{548}\u{549}\x07\x04\x02\x02\u{549}\u{54b}\x05\u{e8}\x75\x02\u{54a}\
	\u{548}\x03\x02\x02\x02\u{54b}\u{54e}\x03\x02\x02\x02\u{54c}\u{54a}\x03\
	\x02\x02\x02\u{54c}\u{54d}\x03\x02\x02\x02\u{54d}\u{550}\x03\x02\x02\x02\
	\u{54e}\u{54c}\x03\x02\x02\x02\u{54f}\u{551}\x07\x04\x02\x02\u{550}\u{54f}\
	\x03\x02\x02\x02\u{550}\u{551}\x03\x02\x02\x02\u{551}\u{552}\x03\x02\x02\
	\x02\u{552}\u{553}\x05\u{a2}\x52\x02\u{553}\u{555}\x03\x02\x02\x02\u{554}\
	\u{538}\x03\x02\x02\x02\u{554}\u{542}\x03\x02\x02\x02\u{555}\u{a1}\x03\x02\
	\x02\x02\u{556}\u{55a}\x07\x0d\x02\x02\u{557}\u{559}\x05\u{a4}\x53\x02\u{558}\
	\u{557}\x03\x02\x02\x02\u{559}\u{55c}\x03\x02\x02\x02\u{55a}\u{558}\x03\
	\x02\x02\x02\u{55a}\u{55b}\x03\x02\x02\x02\u{55b}\u{55d}\x03\x02\x02\x02\
	\u{55c}\u{55a}\x03\x02\x02\x02\u{55d}\u{55e}\x07\x0e\x02\x02\u{55e}\u{a3}\
	\x03\x02\x02\x02\u{55f}\u{560}\x07\x67\x02\x02\u{560}\u{563}\x05\u{a6}\x54\
	\x02\u{561}\u{563}\x05\x0a\x06\x02\u{562}\u{55f}\x03\x02\x02\x02\u{562}\
	\u{561}\x03\x02\x02\x02\u{563}\u{a5}\x03\x02\x02\x02\u{564}\u{568}\x07\x0d\
	\x02\x02\u{565}\u{567}\x05\u{a8}\x55\x02\u{566}\u{565}\x03\x02\x02\x02\u{567}\
	\u{56a}\x03\x02\x02\x02\u{568}\u{566}\x03\x02\x02\x02\u{568}\u{569}\x03\
	\x02\x02\x02\u{569}\u{56b}\x03\x02\x02\x02\u{56a}\u{568}\x03\x02\x02\x02\
	\u{56b}\u{56c}\x07\x0e\x02\x02\u{56c}\u{a7}\x03\x02\x02\x02\u{56d}\u{56e}\
	\x05\u{e8}\x75\x02\u{56e}\u{56f}\x07\x08\x02\x02\u{56f}\u{570}\x05\x78\x3d\
	\x02\u{570}\u{573}\x03\x02\x02\x02\u{571}\u{573}\x05\x0a\x06\x02\u{572}\
	\u{56d}\x03\x02\x02\x02\u{572}\u{571}\x03\x02\x02\x02\u{573}\u{a9}\x03\x02\
	\x02\x02\u{574}\u{575}\x07\x41\x02\x02\u{575}\u{576}\x05\u{ae}\x58\x02\u{576}\
	\u{ab}\x03\x02\x02\x02\u{577}\u{578}\x07\x42\x02\x02\u{578}\u{586}\x05\u{ae}\
	\x58\x02\u{579}\u{57a}\x07\x42\x02\x02\u{57a}\u{57b}\x07\x0b\x02\x02\u{57b}\
	\u{580}\x05\u{ae}\x58\x02\u{57c}\u{57d}\x07\x04\x02\x02\u{57d}\u{57f}\x05\
	\u{ae}\x58\x02\u{57e}\u{57c}\x03\x02\x02\x02\u{57f}\u{582}\x03\x02\x02\x02\
	\u{580}\u{57e}\x03\x02\x02\x02\u{580}\u{581}\x03\x02\x02\x02\u{581}\u{583}\
	\x03\x02\x02\x02\u{582}\u{580}\x03\x02\x02\x02\u{583}\u{584}\x07\x0c\x02\
	\x02\u{584}\u{586}\x03\x02\x02\x02\u{585}\u{577}\x03\x02\x02\x02\u{585}\
	\u{579}\x03\x02\x02\x02\u{586}\u{ad}\x03\x02\x02\x02\u{587}\u{589}\x05\u{e6}\
	\x74\x02\u{588}\u{58a}\x05\x4e\x28\x02\u{589}\u{588}\x03\x02\x02\x02\u{589}\
	\u{58a}\x03\x02\x02\x02\u{58a}\u{58c}\x03\x02\x02\x02\u{58b}\u{58d}\x05\
	\x1c\x0f\x02\u{58c}\u{58b}\x03\x02\x02\x02\u{58c}\u{58d}\x03\x02\x02\x02\
	\u{58d}\u{af}\x03\x02\x02\x02\u{58e}\u{590}\x05\u{ac}\x57\x02\u{58f}\u{58e}\
	\x03\x02\x02\x02\u{590}\u{593}\x03\x02\x02\x02\u{591}\u{58f}\x03\x02\x02\
	\x02\u{591}\u{592}\x03\x02\x02\x02\u{592}\u{594}\x03\x02\x02\x02\u{593}\
	\u{591}\x03\x02\x02\x02\u{594}\u{596}\x07\x70\x02\x02\u{595}\u{597}\x05\
	\x78\x3d\x02\u{596}\u{595}\x03\x02\x02\x02\u{596}\u{597}\x03\x02\x02\x02\
	\u{597}\u{598}\x03\x02\x02\x02\u{598}\u{599}\x05\x56\x2c\x02\u{599}\u{b1}\
	\x03\x02\x02\x02\u{59a}\u{59c}\x05\u{ac}\x57\x02\u{59b}\u{59a}\x03\x02\x02\
	\x02\u{59c}\u{59f}\x03\x02\x02\x02\u{59d}\u{59b}\x03\x02\x02\x02\u{59d}\
	\u{59e}\x03\x02\x02\x02\u{59e}\u{5a0}\x03\x02\x02\x02\u{59f}\u{59d}\x03\
	\x02\x02\x02\u{5a0}\u{5a4}\x09\x11\x02\x02\u{5a1}\u{5a2}\x05\u{e8}\x75\x02\
	\u{5a2}\u{5a3}\x07\x2f\x02\x02\u{5a3}\u{5a5}\x03\x02\x02\x02\u{5a4}\u{5a1}\
	\x03\x02\x02\x02\u{5a4}\u{5a5}\x03\x02\x02\x02\u{5a5}\u{5a6}\x03\x02\x02\
	\x02\u{5a6}\u{5a7}\x05\x76\x3c\x02\u{5a7}\u{5a8}\x05\u{b6}\x5c\x02\u{5a8}\
	\u{b3}\x03\x02\x02\x02\u{5a9}\u{5ab}\x07\x47\x02\x02\u{5aa}\u{5a9}\x03\x02\
	\x02\x02\u{5aa}\u{5ab}\x03\x02\x02\x02\u{5ab}\u{5ac}\x03\x02\x02\x02\u{5ac}\
	\u{5ad}\x07\x03\x02\x02\u{5ad}\u{5b3}\x09\x11\x02\x02\u{5ae}\u{5af}\x07\
	\x51\x02\x02\u{5af}\u{5b1}\x05\u{e8}\x75\x02\u{5b0}\u{5b2}\x05\x64\x33\x02\
	\u{5b1}\u{5b0}\x03\x02\x02\x02\u{5b1}\u{5b2}\x03\x02\x02\x02\u{5b2}\u{5b4}\
	\x03\x02\x02\x02\u{5b3}\u{5ae}\x03\x02\x02\x02\u{5b3}\u{5b4}\x03\x02\x02\
	\x02\u{5b4}\u{5b5}\x03\x02\x02\x02\u{5b5}\u{5b6}\x05\u{b6}\x5c\x02\u{5b6}\
	\u{b5}\x03\x02\x02\x02\u{5b7}\u{5bb}\x07\x0d\x02\x02\u{5b8}\u{5ba}\x05\u{b8}\
	\x5d\x02\u{5b9}\u{5b8}\x03\x02\x02\x02\u{5ba}\u{5bd}\x03\x02\x02\x02\u{5bb}\
	\u{5b9}\x03\x02\x02\x02\u{5bb}\u{5bc}\x03\x02\x02\x02\u{5bc}\u{5be}\x03\
	\x02\x02\x02\u{5bd}\u{5bb}\x03\x02\x02\x02\u{5be}\u{5bf}\x07\x0e\x02\x02\
	\u{5bf}\u{b7}\x03\x02\x02\x02\u{5c0}\u{5c2}\x05\u{ac}\x57\x02\u{5c1}\u{5c0}\
	\x03\x02\x02\x02\u{5c2}\u{5c5}\x03\x02\x02\x02\u{5c3}\u{5c1}\x03\x02\x02\
	\x02\u{5c3}\u{5c4}\x03\x02\x02\x02\u{5c4}\u{5c6}\x03\x02\x02\x02\u{5c5}\
	\u{5c3}\x03\x02\x02\x02\u{5c6}\u{5c7}\x07\x73\x02\x02\u{5c7}\u{60e}\x05\
	\u{e8}\x75\x02\u{5c8}\u{5ca}\x05\u{ac}\x57\x02\u{5c9}\u{5c8}\x03\x02\x02\
	\x02\u{5ca}\u{5cd}\x03\x02\x02\x02\u{5cb}\u{5c9}\x03\x02\x02\x02\u{5cb}\
	\u{5cc}\x03\x02\x02\x02\u{5cc}\u{5ce}\x03\x02\x02\x02\u{5cd}\u{5cb}\x03\
	\x02\x02\x02\u{5ce}\u{5cf}\x07\x73\x02\x02\u{5cf}\u{5db}\x07\x0b\x02\x02\
	\u{5d0}\u{5d5}\x05\u{e8}\x75\x02\u{5d1}\u{5d2}\x07\x04\x02\x02\u{5d2}\u{5d4}\
	\x05\u{e8}\x75\x02\u{5d3}\u{5d1}\x03\x02\x02\x02\u{5d4}\u{5d7}\x03\x02\x02\
	\x02\u{5d5}\u{5d3}\x03\x02\x02\x02\u{5d5}\u{5d6}\x03\x02\x02\x02\u{5d6}\
	\u{5d9}\x03\x02\x02\x02\u{5d7}\u{5d5}\x03\x02\x02\x02\u{5d8}\u{5da}\x07\
	\x04\x02\x02\u{5d9}\u{5d8}\x03\x02\x02\x02\u{5d9}\u{5da}\x03\x02\x02\x02\
	\u{5da}\u{5dc}\x03\x02\x02\x02\u{5db}\u{5d0}\x03\x02\x02\x02\u{5db}\u{5dc}\
	\x03\x02\x02\x02\u{5dc}\u{5dd}\x03\x02\x02\x02\u{5dd}\u{60e}\x07\x0c\x02\
	\x02\u{5de}\u{5e0}\x05\u{ac}\x57\x02\u{5df}\u{5de}\x03\x02\x02\x02\u{5e0}\
	\u{5e3}\x03\x02\x02\x02\u{5e1}\u{5df}\x03\x02\x02\x02\u{5e1}\u{5e2}\x03\
	\x02\x02\x02\u{5e2}\u{5e4}\x03\x02\x02\x02\u{5e3}\u{5e1}\x03\x02\x02\x02\
	\u{5e4}\u{5e5}\x07\x63\x02\x02\u{5e5}\u{5e8}\x05\x78\x3d\x02\u{5e6}\u{5e7}\
	\x07\x7b\x02\x02\u{5e7}\u{5e9}\x05\x76\x3c\x02\u{5e8}\u{5e6}\x03\x02\x02\
	\x02\u{5e8}\u{5e9}\x03\x02\x02\x02\u{5e9}\u{5ea}\x03\x02\x02\x02\u{5ea}\
	\u{5eb}\x05\u{ba}\x5e\x02\u{5eb}\u{60e}\x03\x02\x02\x02\u{5ec}\u{5ee}\x05\
	\u{ac}\x57\x02\u{5ed}\u{5ec}\x03\x02\x02\x02\u{5ee}\u{5f1}\x03\x02\x02\x02\
	\u{5ef}\u{5ed}\x03\x02\x02\x02\u{5ef}\u{5f0}\x03\x02\x02\x02\u{5f0}\u{5f2}\
	\x03\x02\x02\x02\u{5f1}\u{5ef}\x03\x02\x02\x02\u{5f2}\u{5f3}\x07\x75\x02\
	\x02\u{5f3}\u{5f4}\x05\x76\x3c\x02\u{5f4}\u{5f5}\x05\u{ba}\x5e\x02\u{5f5}\
	\u{60e}\x03\x02\x02\x02\u{5f6}\u{5f8}\x05\u{ac}\x57\x02\u{5f7}\u{5f6}\x03\
	\x02\x02\x02\u{5f8}\u{5fb}\x03\x02\x02\x02\u{5f9}\u{5f7}\x03\x02\x02\x02\
	\u{5f9}\u{5fa}\x03\x02\x02\x02\u{5fa}\u{5fc}\x03\x02\x02\x02\u{5fb}\u{5f9}\
	\x03\x02\x02\x02\u{5fc}\u{5fd}\x07\x7c\x02\x02\u{5fd}\u{60e}\x05\u{ba}\x5e\
	\x02\u{5fe}\u{600}\x05\u{ac}\x57\x02\u{5ff}\u{5fe}\x03\x02\x02\x02\u{600}\
	\u{603}\x03\x02\x02\x02\u{601}\u{5ff}\x03\x02\x02\x02\u{601}\u{602}\x03\
	\x02\x02\x02\u{602}\u{604}\x03\x02\x02\x02\u{603}\u{601}\x03\x02\x02\x02\
	\u{604}\u{605}\x07\x74\x02\x02\u{605}\u{608}\x05\u{bc}\x5f\x02\u{606}\u{607}\
	\x07\x7b\x02\x02\u{607}\u{609}\x05\x76\x3c\x02\u{608}\u{606}\x03\x02\x02\
	\x02\u{608}\u{609}\x03\x02\x02\x02\u{609}\u{60a}\x03\x02\x02\x02\u{60a}\
	\u{60b}\x05\u{ba}\x5e\x02\u{60b}\u{60e}\x03\x02\x02\x02\u{60c}\u{60e}\x05\
	\x0a\x06\x02\u{60d}\u{5c3}\x03\x02\x02\x02\u{60d}\u{5cb}\x03\x02\x02\x02\
	\u{60d}\u{5e1}\x03\x02\x02\x02\u{60d}\u{5ef}\x03\x02\x02\x02\u{60d}\u{5f9}\
	\x03\x02\x02\x02\u{60d}\u{601}\x03\x02\x02\x02\u{60d}\u{60c}\x03\x02\x02\
	\x02\u{60e}\u{b9}\x03\x02\x02\x02\u{60f}\u{613}\x07\x08\x02\x02\u{610}\u{612}\
	\x05\x74\x3b\x02\u{611}\u{610}\x03\x02\x02\x02\u{612}\u{615}\x03\x02\x02\
	\x02\u{613}\u{611}\x03\x02\x02\x02\u{613}\u{614}\x03\x02\x02\x02\u{614}\
	\u{bb}\x03\x02\x02\x02\u{615}\u{613}\x03\x02\x02\x02\u{616}\u{617}\x08\x5f\
	\x01\x02\u{617}\u{618}\x05\u{be}\x60\x02\u{618}\u{621}\x03\x02\x02\x02\u{619}\
	\u{61a}\x0c\x05\x02\x02\u{61a}\u{61b}\x09\x12\x02\x02\u{61b}\u{620}\x05\
	\u{bc}\x5f\x06\u{61c}\u{61d}\x0c\x04\x02\x02\u{61d}\u{61e}\x07\x53\x02\x02\
	\u{61e}\u{620}\x05\u{bc}\x5f\x05\u{61f}\u{619}\x03\x02\x02\x02\u{61f}\u{61c}\
	\x03\x02\x02\x02\u{620}\u{623}\x03\x02\x02\x02\u{621}\u{61f}\x03\x02\x02\
	\x02\u{621}\u{622}\x03\x02\x02\x02\u{622}\u{bd}\x03\x02\x02\x02\u{623}\u{621}\
	\x03\x02\x02\x02\u{624}\u{638}\x05\u{c0}\x61\x02\u{625}\u{626}\x05\u{e8}\
	\x75\x02\u{626}\u{627}\x07\x2f\x02\x02\u{627}\u{628}\x05\u{be}\x60\x02\u{628}\
	\u{638}\x03\x02\x02\x02\u{629}\u{62a}\x05\u{dc}\x6f\x02\u{62a}\u{62e}\x07\
	\x08\x02\x02\u{62b}\u{62c}\x05\u{e8}\x75\x02\u{62c}\u{62d}\x07\x2f\x02\x02\
	\u{62d}\u{62f}\x03\x02\x02\x02\u{62e}\u{62b}\x03\x02\x02\x02\u{62e}\u{62f}\
	\x03\x02\x02\x02\u{62f}\u{630}\x03\x02\x02\x02\u{630}\u{631}\x05\u{be}\x60\
	\x02\u{631}\u{638}\x03\x02\x02\x02\u{632}\u{638}\x05\u{dc}\x6f\x02\u{633}\
	\u{638}\x05\u{e6}\x74\x02\u{634}\u{638}\x05\u{ec}\x77\x02\u{635}\u{638}\
	\x05\u{f0}\x79\x02\u{636}\u{638}\x07\u{84}\x02\x02\u{637}\u{624}\x03\x02\
	\x02\x02\u{637}\u{625}\x03\x02\x02\x02\u{637}\u{629}\x03\x02\x02\x02\u{637}\
	\u{632}\x03\x02\x02\x02\u{637}\u{633}\x03\x02\x02\x02\u{637}\u{634}\x03\
	\x02\x02\x02\u{637}\u{635}\x03\x02\x02\x02\u{637}\u{636}\x03\x02\x02\x02\
	\u{638}\u{bf}\x03\x02\x02\x02\u{639}\u{63b}\x05\u{e6}\x74\x02\u{63a}\u{639}\
	\x03\x02\x02\x02\u{63a}\u{63b}\x03\x02\x02\x02\u{63b}\u{63c}\x03\x02\x02\
	\x02\u{63c}\u{63d}\x07\x09\x02\x02\u{63d}\u{68c}\x07\x0a\x02\x02\u{63e}\
	\u{640}\x05\u{e6}\x74\x02\u{63f}\u{63e}\x03\x02\x02\x02\u{63f}\u{640}\x03\
	\x02\x02\x02\u{640}\u{641}\x03\x02\x02\x02\u{641}\u{642}\x07\x0b\x02\x02\
	\u{642}\u{68c}\x07\x0c\x02\x02\u{643}\u{645}\x05\u{e6}\x74\x02\u{644}\u{643}\
	\x03\x02\x02\x02\u{644}\u{645}\x03\x02\x02\x02\u{645}\u{646}\x03\x02\x02\
	\x02\u{646}\u{647}\x07\x0d\x02\x02\u{647}\u{68c}\x07\x0e\x02\x02\u{648}\
	\u{649}\x07\x09\x02\x02\u{649}\u{64a}\x05\u{be}\x60\x02\u{64a}\u{64b}\x07\
	\x04\x02\x02\u{64b}\u{64c}\x07\x0a\x02\x02\u{64c}\u{68c}\x03\x02\x02\x02\
	\u{64d}\u{64e}\x07\x09\x02\x02\u{64e}\u{651}\x05\u{be}\x60\x02\u{64f}\u{650}\
	\x07\x04\x02\x02\u{650}\u{652}\x05\u{be}\x60\x02\u{651}\u{64f}\x03\x02\x02\
	\x02\u{652}\u{653}\x03\x02\x02\x02\u{653}\u{651}\x03\x02\x02\x02\u{653}\
	\u{654}\x03\x02\x02\x02\u{654}\u{656}\x03\x02\x02\x02\u{655}\u{657}\x07\
	\x04\x02\x02\u{656}\u{655}\x03\x02\x02\x02\u{656}\u{657}\x03\x02\x02\x02\
	\u{657}\u{658}\x03\x02\x02\x02\u{658}\u{659}\x07\x0a\x02\x02\u{659}\u{68c}\
	\x03\x02\x02\x02\u{65a}\u{65b}\x05\u{e6}\x74\x02\u{65b}\u{65c}\x07\x09\x02\
	\x02\u{65c}\u{661}\x05\u{be}\x60\x02\u{65d}\u{65e}\x07\x04\x02\x02\u{65e}\
	\u{660}\x05\u{be}\x60\x02\u{65f}\u{65d}\x03\x02\x02\x02\u{660}\u{663}\x03\
	\x02\x02\x02\u{661}\u{65f}\x03\x02\x02\x02\u{661}\u{662}\x03\x02\x02\x02\
	\u{662}\u{665}\x03\x02\x02\x02\u{663}\u{661}\x03\x02\x02\x02\u{664}\u{666}\
	\x07\x04\x02\x02\u{665}\u{664}\x03\x02\x02\x02\u{665}\u{666}\x03\x02\x02\
	\x02\u{666}\u{667}\x03\x02\x02\x02\u{667}\u{668}\x07\x0a\x02\x02\u{668}\
	\u{68c}\x03\x02\x02\x02\u{669}\u{66b}\x05\u{e6}\x74\x02\u{66a}\u{669}\x03\
	\x02\x02\x02\u{66a}\u{66b}\x03\x02\x02\x02\u{66b}\u{66c}\x03\x02\x02\x02\
	\u{66c}\u{66d}\x07\x0b\x02\x02\u{66d}\u{672}\x05\u{be}\x60\x02\u{66e}\u{66f}\
	\x07\x04\x02\x02\u{66f}\u{671}\x05\u{be}\x60\x02\u{670}\u{66e}\x03\x02\x02\
	\x02\u{671}\u{674}\x03\x02\x02\x02\u{672}\u{670}\x03\x02\x02\x02\u{672}\
	\u{673}\x03\x02\x02\x02\u{673}\u{676}\x03\x02\x02\x02\u{674}\u{672}\x03\
	\x02\x02\x02\u{675}\u{677}\x07\x04\x02\x02\u{676}\u{675}\x03\x02\x02\x02\
	\u{676}\u{677}\x03\x02\x02\x02\u{677}\u{678}\x03\x02\x02\x02\u{678}\u{679}\
	\x07\x0c\x02\x02\u{679}\u{68c}\x03\x02\x02\x02\u{67a}\u{67c}\x05\u{e6}\x74\
	\x02\u{67b}\u{67a}\x03\x02\x02\x02\u{67b}\u{67c}\x03\x02\x02\x02\u{67c}\
	\u{67d}\x03\x02\x02\x02\u{67d}\u{67e}\x07\x0d\x02\x02\u{67e}\u{683}\x05\
	\u{be}\x60\x02\u{67f}\u{680}\x07\x04\x02\x02\u{680}\u{682}\x05\u{be}\x60\
	\x02\u{681}\u{67f}\x03\x02\x02\x02\u{682}\u{685}\x03\x02\x02\x02\u{683}\
	\u{681}\x03\x02\x02\x02\u{683}\u{684}\x03\x02\x02\x02\u{684}\u{687}\x03\
	\x02\x02\x02\u{685}\u{683}\x03\x02\x02\x02\u{686}\u{688}\x07\x04\x02\x02\
	\u{687}\u{686}\x03\x02\x02\x02\u{687}\u{688}\x03\x02\x02\x02\u{688}\u{689}\
	\x03\x02\x02\x02\u{689}\u{68a}\x07\x0e\x02\x02\u{68a}\u{68c}\x03\x02\x02\
	\x02\u{68b}\u{63a}\x03\x02\x02\x02\u{68b}\u{63f}\x03\x02\x02\x02\u{68b}\
	\u{644}\x03\x02\x02\x02\u{68b}\u{648}\x03\x02\x02\x02\u{68b}\u{64d}\x03\
	\x02\x02\x02\u{68b}\u{65a}\x03\x02\x02\x02\u{68b}\u{66a}\x03\x02\x02\x02\
	\u{68b}\u{67b}\x03\x02\x02\x02\u{68c}\u{c1}\x03\x02\x02\x02\u{68d}\u{68f}\
	\x07\x6d\x02\x02\u{68e}\u{690}\x05\u{92}\x4a\x02\u{68f}\u{68e}\x03\x02\x02\
	\x02\u{68f}\u{690}\x03\x02\x02\x02\u{690}\u{692}\x03\x02\x02\x02\u{691}\
	\u{693}\x05\x1e\x10\x02\u{692}\u{691}\x03\x02\x02\x02\u{692}\u{693}\x03\
	\x02\x02\x02\u{693}\u{695}\x03\x02\x02\x02\u{694}\u{696}\x05\x64\x33\x02\
	\u{695}\u{694}\x03\x02\x02\x02\u{695}\u{696}\x03\x02\x02\x02\u{696}\u{697}\
	\x03\x02\x02\x02\u{697}\u{698}\x05\x1c\x0f\x02\u{698}\u{c3}\x03\x02\x02\
	\x02\u{699}\u{69a}\x07\x6c\x02\x02\u{69a}\u{69c}\x05\u{de}\x70\x02\u{69b}\
	\u{69d}\x05\u{98}\x4d\x02\u{69c}\u{69b}\x03\x02\x02\x02\u{69c}\u{69d}\x03\
	\x02\x02\x02\u{69d}\u{69f}\x03\x02\x02\x02\u{69e}\u{6a0}\x05\x4e\x28\x02\
	\u{69f}\u{69e}\x03\x02\x02\x02\u{69f}\u{6a0}\x03\x02\x02\x02\u{6a0}\u{6a1}\
	\x03\x02\x02\x02\u{6a1}\u{6a2}\x05\u{c8}\x65\x02\u{6a2}\u{6ab}\x03\x02\x02\
	\x02\u{6a3}\u{6a4}\x07\x6c\x02\x02\u{6a4}\u{6a6}\x05\u{de}\x70\x02\u{6a5}\
	\u{6a7}\x05\u{98}\x4d\x02\u{6a6}\u{6a5}\x03\x02\x02\x02\u{6a6}\u{6a7}\x03\
	\x02\x02\x02\u{6a7}\u{6a8}\x03\x02\x02\x02\u{6a8}\u{6a9}\x05\x4e\x28\x02\
	\u{6a9}\u{6ab}\x03\x02\x02\x02\u{6aa}\u{699}\x03\x02\x02\x02\u{6aa}\u{6a3}\
	\x03\x02\x02\x02\u{6ab}\u{c5}\x03\x02\x02\x02\u{6ac}\u{6ae}\x05\x4e\x28\
	\x02\u{6ad}\u{6ac}\x03\x02\x02\x02\u{6ad}\u{6ae}\x03\x02\x02\x02\u{6ae}\
	\u{6af}\x03\x02\x02\x02\u{6af}\u{6b2}\x05\u{c8}\x65\x02\u{6b0}\u{6b2}\x05\
	\x4e\x28\x02\u{6b1}\u{6ad}\x03\x02\x02\x02\u{6b1}\u{6b0}\x03\x02\x02\x02\
	\u{6b2}\u{c7}\x03\x02\x02\x02\u{6b3}\u{6b8}\x07\x0d\x02\x02\u{6b4}\u{6b7}\
	\x05\x50\x29\x02\u{6b5}\u{6b7}\x05\x0a\x06\x02\u{6b6}\u{6b4}\x03\x02\x02\
	\x02\u{6b6}\u{6b5}\x03\x02\x02\x02\u{6b7}\u{6ba}\x03\x02\x02\x02\u{6b8}\
	\u{6b6}\x03\x02\x02\x02\u{6b8}\u{6b9}\x03\x02\x02\x02\u{6b9}\u{6bb}\x03\
	\x02\x02\x02\u{6ba}\u{6b8}\x03\x02\x02\x02\u{6bb}\u{6bc}\x07\x0e\x02\x02\
	\u{6bc}\u{c9}\x03\x02\x02\x02\u{6bd}\u{6be}\x07\x0b\x02\x02\u{6be}\u{6e2}\
	\x07\x0c\x02\x02\u{6bf}\u{6c0}\x07\x0b\x02\x02\u{6c0}\u{6c5}\x05\u{cc}\x67\
	\x02\u{6c1}\u{6c2}\x07\x04\x02\x02\u{6c2}\u{6c4}\x05\u{cc}\x67\x02\u{6c3}\
	\u{6c1}\x03\x02\x02\x02\u{6c4}\u{6c7}\x03\x02\x02\x02\u{6c5}\u{6c3}\x03\
	\x02\x02\x02\u{6c5}\u{6c6}\x03\x02\x02\x02\u{6c6}\u{6c9}\x03\x02\x02\x02\
	\u{6c7}\u{6c5}\x03\x02\x02\x02\u{6c8}\u{6ca}\x07\x04\x02\x02\u{6c9}\u{6c8}\
	\x03\x02\x02\x02\u{6c9}\u{6ca}\x03\x02\x02\x02\u{6ca}\u{6cb}\x03\x02\x02\
	\x02\u{6cb}\u{6cc}\x07\x0c\x02\x02\u{6cc}\u{6e2}\x03\x02\x02\x02\u{6cd}\
	\u{6ce}\x07\x09\x02\x02\u{6ce}\u{6e2}\x07\x0a\x02\x02\u{6cf}\u{6d0}\x07\
	\x09\x02\x02\u{6d0}\u{6d3}\x05\u{cc}\x67\x02\u{6d1}\u{6d2}\x07\x04\x02\x02\
	\u{6d2}\u{6d4}\x05\u{cc}\x67\x02\u{6d3}\u{6d1}\x03\x02\x02\x02\u{6d4}\u{6d5}\
	\x03\x02\x02\x02\u{6d5}\u{6d3}\x03\x02\x02\x02\u{6d5}\u{6d6}\x03\x02\x02\
	\x02\u{6d6}\u{6d8}\x03\x02\x02\x02\u{6d7}\u{6d9}\x07\x04\x02\x02\u{6d8}\
	\u{6d7}\x03\x02\x02\x02\u{6d8}\u{6d9}\x03\x02\x02\x02\u{6d9}\u{6da}\x03\
	\x02\x02\x02\u{6da}\u{6db}\x07\x0a\x02\x02\u{6db}\u{6e2}\x03\x02\x02\x02\
	\u{6dc}\u{6dd}\x07\x09\x02\x02\u{6dd}\u{6de}\x05\u{cc}\x67\x02\u{6de}\u{6df}\
	\x07\x04\x02\x02\u{6df}\u{6e0}\x07\x0a\x02\x02\u{6e0}\u{6e2}\x03\x02\x02\
	\x02\u{6e1}\u{6bd}\x03\x02\x02\x02\u{6e1}\u{6bf}\x03\x02\x02\x02\u{6e1}\
	\u{6cd}\x03\x02\x02\x02\u{6e1}\u{6cf}\x03\x02\x02\x02\u{6e1}\u{6dc}\x03\
	\x02\x02\x02\u{6e2}\u{cb}\x03\x02\x02\x02\u{6e3}\u{6e4}\x05\u{e8}\x75\x02\
	\u{6e4}\u{6e5}\x07\x08\x02\x02\u{6e5}\u{6e7}\x03\x02\x02\x02\u{6e6}\u{6e3}\
	\x03\x02\x02\x02\u{6e6}\u{6e7}\x03\x02\x02\x02\u{6e7}\u{6e8}\x03\x02\x02\
	\x02\u{6e8}\u{6e9}\x05\x74\x3b\x02\u{6e9}\u{cd}\x03\x02\x02\x02\u{6ea}\u{6ec}\
	\x07\x47\x02\x02\u{6eb}\u{6ea}\x03\x02\x02\x02\u{6eb}\u{6ec}\x03\x02\x02\
	\x02\u{6ec}\u{6ed}\x03\x02\x02\x02\u{6ed}\u{6ee}\x05\u{d0}\x69\x02\u{6ee}\
	\u{cf}\x03\x02\x02\x02\u{6ef}\u{6fb}\x07\x0b\x02\x02\u{6f0}\u{6f5}\x05\u{d2}\
	\x6a\x02\u{6f1}\u{6f2}\x07\x04\x02\x02\u{6f2}\u{6f4}\x05\u{d2}\x6a\x02\u{6f3}\
	\u{6f1}\x03\x02\x02\x02\u{6f4}\u{6f7}\x03\x02\x02\x02\u{6f5}\u{6f3}\x03\
	\x02\x02\x02\u{6f5}\u{6f6}\x03\x02\x02\x02\u{6f6}\u{6f9}\x03\x02\x02\x02\
	\u{6f7}\u{6f5}\x03\x02\x02\x02\u{6f8}\u{6fa}\x07\x04\x02\x02\u{6f9}\u{6f8}\
	\x03\x02\x02\x02\u{6f9}\u{6fa}\x03\x02\x02\x02\u{6fa}\u{6fc}\x03\x02\x02\
	\x02\u{6fb}\u{6f0}\x03\x02\x02\x02\u{6fb}\u{6fc}\x03\x02\x02\x02\u{6fc}\
	\u{6fd}\x03\x02\x02\x02\u{6fd}\u{70e}\x07\x0c\x02\x02\u{6fe}\u{70a}\x07\
	\x11\x02\x02\u{6ff}\u{704}\x05\u{d2}\x6a\x02\u{700}\u{701}\x07\x04\x02\x02\
	\u{701}\u{703}\x05\u{d2}\x6a\x02\u{702}\u{700}\x03\x02\x02\x02\u{703}\u{706}\
	\x03\x02\x02\x02\u{704}\u{702}\x03\x02\x02\x02\u{704}\u{705}\x03\x02\x02\
	\x02\u{705}\u{708}\x03\x02\x02\x02\u{706}\u{704}\x03\x02\x02\x02\u{707}\
	\u{709}\x07\x04\x02\x02\u{708}\u{707}\x03\x02\x02\x02\u{708}\u{709}\x03\
	\x02\x02\x02\u{709}\u{70b}\x03\x02\x02\x02\u{70a}\u{6ff}\x03\x02\x02\x02\
	\u{70a}\u{70b}\x03\x02\x02\x02\u{70b}\u{70c}\x03\x02\x02\x02\u{70c}\u{70e}\
	\x07\x12\x02\x02\u{70d}\u{6ef}\x03\x02\x02\x02\u{70d}\u{6fe}\x03\x02\x02\
	\x02\u{70e}\u{d1}\x03\x02\x02\x02\u{70f}\u{71b}\x07\x08\x02\x02\u{710}\u{71b}\
	\x07\x07\x02\x02\u{711}\u{714}\x05\u{d4}\x6b\x02\u{712}\u{713}\x07\x08\x02\
	\x02\u{713}\u{715}\x05\u{d6}\x6c\x02\u{714}\u{712}\x03\x02\x02\x02\u{714}\
	\u{715}\x03\x02\x02\x02\u{715}\u{718}\x03\x02\x02\x02\u{716}\u{717}\x07\
	\x08\x02\x02\u{717}\u{719}\x05\u{d8}\x6d\x02\u{718}\u{716}\x03\x02\x02\x02\
	\u{718}\u{719}\x03\x02\x02\x02\u{719}\u{71b}\x03\x02\x02\x02\u{71a}\u{70f}\
	\x03\x02\x02\x02\u{71a}\u{710}\x03\x02\x02\x02\u{71a}\u{711}\x03\x02\x02\
	\x02\u{71b}\u{d3}\x03\x02\x02\x02\u{71c}\u{71d}\x05\x76\x3c\x02\u{71d}\u{d5}\
	\x03\x02\x02\x02\u{71e}\u{71f}\x05\x76\x3c\x02\u{71f}\u{d7}\x03\x02\x02\
	\x02\u{720}\u{721}\x05\x76\x3c\x02\u{721}\u{d9}\x03\x02\x02\x02\u{722}\u{724}\
	\x05\u{e8}\x75\x02\u{723}\u{722}\x03\x02\x02\x02\u{724}\u{727}\x03\x02\x02\
	\x02\u{725}\u{723}\x03\x02\x02\x02\u{725}\u{726}\x03\x02\x02\x02\u{726}\
	\u{db}\x03\x02\x02\x02\u{727}\u{725}\x03\x02\x02\x02\u{728}\u{72a}\x05\u{e8}\
	\x75\x02\u{729}\u{728}\x03\x02\x02\x02\u{72a}\u{72d}\x03\x02\x02\x02\u{72b}\
	\u{729}\x03\x02\x02\x02\u{72b}\u{72c}\x03\x02\x02\x02\u{72c}\u{72e}\x03\
	\x02\x02\x02\u{72d}\u{72b}\x03\x02\x02\x02\u{72e}\u{72f}\x05\u{e8}\x75\x02\
	\u{72f}\u{dd}\x03\x02\x02\x02\u{730}\u{732}\x05\u{e8}\x75\x02\u{731}\u{730}\
	\x03\x02\x02\x02\u{732}\u{735}\x03\x02\x02\x02\u{733}\u{731}\x03\x02\x02\
	\x02\u{733}\u{734}\x03\x02\x02\x02\u{734}\u{736}\x03\x02\x02\x02\u{735}\
	\u{733}\x03\x02\x02\x02\u{736}\u{73b}\x05\u{e8}\x75\x02\u{737}\u{738}\x07\
	\x07\x02\x02\u{738}\u{73a}\x05\u{e8}\x75\x02\u{739}\u{737}\x03\x02\x02\x02\
	\u{73a}\u{73d}\x03\x02\x02\x02\u{73b}\u{739}\x03\x02\x02\x02\u{73b}\u{73c}\
	\x03\x02\x02\x02\u{73c}\u{df}\x03\x02\x02\x02\u{73d}\u{73b}\x03\x02\x02\
	\x02\u{73e}\u{741}\x07\x43\x02\x02\u{73f}\u{742}\x05\u{e8}\x75\x02\u{740}\
	\u{742}\x05\u{ea}\x76\x02\u{741}\u{73f}\x03\x02\x02\x02\u{741}\u{740}\x03\
	\x02\x02\x02\u{741}\u{742}\x03\x02\x02\x02\u{742}\u{e1}\x03\x02\x02\x02\
	\u{743}\u{748}\x05\u{e8}\x75\x02\u{744}\u{745}\x07\x07\x02\x02\u{745}\u{747}\
	\x05\u{e8}\x75\x02\u{746}\u{744}\x03\x02\x02\x02\u{747}\u{74a}\x03\x02\x02\
	\x02\u{748}\u{746}\x03\x02\x02\x02\u{748}\u{749}\x03\x02\x02\x02\u{749}\
	\u{74d}\x03\x02\x02\x02\u{74a}\u{748}\x03\x02\x02\x02\u{74b}\u{74c}\x07\
	\x03\x02\x02\u{74c}\u{74e}\x05\u{e8}\x75\x02\u{74d}\u{74b}\x03\x02\x02\x02\
	\u{74d}\u{74e}\x03\x02\x02\x02\u{74e}\u{e3}\x03\x02\x02\x02\u{74f}\u{754}\
	\x05\u{e8}\x75\x02\u{750}\u{751}\x09\x04\x02\x02\u{751}\u{753}\x05\u{e8}\
	\x75\x02\u{752}\u{750}\x03\x02\x02\x02\u{753}\u{756}\x03\x02\x02\x02\u{754}\
	\u{752}\x03\x02\x02\x02\u{754}\u{755}\x03\x02\x02\x02\u{755}\u{e5}\x03\x02\
	\x02\x02\u{756}\u{754}\x03\x02\x02\x02\u{757}\u{75c}\x05\u{e8}\x75\x02\u{758}\
	\u{759}\x07\x07\x02\x02\u{759}\u{75b}\x05\u{e8}\x75\x02\u{75a}\u{758}\x03\
	\x02\x02\x02\u{75b}\u{75e}\x03\x02\x02\x02\u{75c}\u{75a}\x03\x02\x02\x02\
	\u{75c}\u{75d}\x03\x02\x02\x02\u{75d}\u{e7}\x03\x02\x02\x02\u{75e}\u{75c}\
	\x03\x02\x02\x02\u{75f}\u{760}\x09\x13\x02\x02\u{760}\u{e9}\x03\x02\x02\
	\x02\u{761}\u{762}\x09\x14\x02\x02\u{762}\u{eb}\x03\x02\x02\x02\u{763}\u{765}\
	\x05\u{ea}\x76\x02\u{764}\u{766}\x05\u{e8}\x75\x02\u{765}\u{764}\x03\x02\
	\x02\x02\u{765}\u{766}\x03\x02\x02\x02\u{766}\u{ed}\x03\x02\x02\x02\u{767}\
	\u{768}\x09\x15\x02\x02\u{768}\u{ef}\x03\x02\x02\x02\u{769}\u{76b}\x05\u{e8}\
	\x75\x02\u{76a}\u{769}\x03\x02\x02\x02\u{76a}\u{76b}\x03\x02\x02\x02\u{76b}\
	\u{76c}\x03\x02\x02\x02\u{76c}\u{776}\x07\x78\x02\x02\u{76d}\u{76f}\x05\
	\u{e8}\x75\x02\u{76e}\u{76d}\x03\x02\x02\x02\u{76e}\u{76f}\x03\x02\x02\x02\
	\u{76f}\u{770}\x03\x02\x02\x02\u{770}\u{776}\x07\x79\x02\x02\u{771}\u{773}\
	\x05\u{e8}\x75\x02\u{772}\u{771}\x03\x02\x02\x02\u{772}\u{773}\x03\x02\x02\
	\x02\u{773}\u{774}\x03\x02\x02\x02\u{774}\u{776}\x07\x7a\x02\x02\u{775}\
	\u{76a}\x03\x02\x02\x02\u{775}\u{76e}\x03\x02\x02\x02\u{775}\u{772}\x03\
	\x02\x02\x02\u{776}\u{f1}\x03\x02\x02\x02\u{10a}\u{f5}\u{10a}\u{112}\u{11b}\
	\u{122}\u{12a}\u{12f}\u{132}\u{137}\u{13c}\u{13f}\u{143}\u{147}\u{14a}\u{14d}\
	\u{154}\u{160}\u{164}\u{169}\u{16e}\u{175}\u{178}\u{17b}\u{17f}\u{186}\u{188}\
	\u{195}\u{199}\u{19d}\u{1a4}\u{1a9}\u{1ac}\u{1b1}\u{1b6}\u{1ba}\u{1bd}\u{1c0}\
	\u{1c5}\u{1cc}\u{1d1}\u{1d8}\u{1db}\u{1df}\u{1e6}\u{1e8}\u{1f1}\u{1f4}\u{1f9}\
	\u{200}\u{203}\u{20d}\u{214}\u{217}\u{21d}\u{225}\u{227}\u{22e}\u{233}\u{235}\
	\u{23d}\u{244}\u{247}\u{24f}\u{251}\u{259}\u{25f}\u{262}\u{267}\u{26e}\u{272}\
	\u{275}\u{281}\u{286}\u{28b}\u{290}\u{293}\u{299}\u{29e}\u{2a3}\u{2a6}\u{2aa}\
	\u{2ae}\u{2b0}\u{2ba}\u{2be}\u{2c2}\u{2c9}\u{2ce}\u{2d4}\u{2d9}\u{2e1}\u{2e9}\
	\u{2ed}\u{2f1}\u{2f8}\u{2fc}\u{307}\u{30a}\u{30c}\u{316}\u{31a}\u{31c}\u{321}\
	\u{329}\u{32d}\u{32f}\u{333}\u{33b}\u{33f}\u{341}\u{344}\u{349}\u{34e}\u{354}\
	\u{359}\u{35d}\u{361}\u{364}\u{374}\u{37d}\u{382}\u{387}\u{38f}\u{395}\u{39f}\
	\u{3a9}\u{3b3}\u{3b8}\u{3c0}\u{3ca}\u{3e6}\u{40b}\u{40d}\u{41b}\u{431}\u{43e}\
	\u{440}\u{44d}\u{450}\u{452}\u{459}\u{468}\u{46a}\u{47a}\u{47e}\u{485}\u{48a}\
	\u{491}\u{494}\u{49b}\u{4ae}\u{4ba}\u{4be}\u{4c3}\u{4c8}\u{4d0}\u{4d4}\u{4d8}\
	\u{4dd}\u{4eb}\u{4ef}\u{4fb}\u{4ff}\u{503}\u{506}\u{50e}\u{519}\u{51e}\u{523}\
	\u{533}\u{538}\u{542}\u{54c}\u{550}\u{554}\u{55a}\u{562}\u{568}\u{572}\u{580}\
	\u{585}\u{589}\u{58c}\u{591}\u{596}\u{59d}\u{5a4}\u{5aa}\u{5b1}\u{5b3}\u{5bb}\
	\u{5c3}\u{5cb}\u{5d5}\u{5d9}\u{5db}\u{5e1}\u{5e8}\u{5ef}\u{5f9}\u{601}\u{608}\
	\u{60d}\u{613}\u{61f}\u{621}\u{62e}\u{637}\u{63a}\u{63f}\u{644}\u{653}\u{656}\
	\u{661}\u{665}\u{66a}\u{672}\u{676}\u{67b}\u{683}\u{687}\u{68b}\u{68f}\u{692}\
	\u{695}\u{69c}\u{69f}\u{6a6}\u{6aa}\u{6ad}\u{6b1}\u{6b6}\u{6b8}\u{6c5}\u{6c9}\
	\u{6d5}\u{6d8}\u{6e1}\u{6e6}\u{6eb}\u{6f5}\u{6f9}\u{6fb}\u{704}\u{708}\u{70a}\
	\u{70d}\u{714}\u{718}\u{71a}\u{725}\u{72b}\u{733}\u{73b}\u{741}\u{748}\u{74d}\
	\u{754}\u{75c}\u{765}\u{76a}\u{76e}\u{772}\u{775}";
