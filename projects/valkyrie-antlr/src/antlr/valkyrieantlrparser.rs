// Generated from ValkyrieAntlr.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use super::{valkyrieantlrlistener::*, valkyrieantlrvisitor::*};
use antlr_rust::{
    atn::{ATN, INVALID_ALT},
    atn_deserializer::ATNDeserializer,
    dfa::DFA,
    error_strategy::{DefaultErrorStrategy, ErrorStrategy},
    errors::*,
    int_stream::EOF,
    parser::{BaseParser, Parser, ParserNodeType, ParserRecog},
    parser_atn_simulator::ParserATNSimulator,
    parser_rule_context::{cast, cast_mut, BaseParserRuleContext, ParserRuleContext},
    recognizer::{Actions, Recognizer},
    rule_context::{BaseRuleContext, CustomRuleContext, RuleContext},
    token::{OwningToken, Token, TOKEN_EOF},
    token_factory::{CommonTokenFactory, TokenAware, TokenFactory},
    token_stream::TokenStream,
    tree::*,
    vocabulary::{Vocabulary, VocabularyImpl},
    PredictionContextCache, TokenSource,
};

use antlr_rust::{lazy_static, TidAble, TidExt};

use std::{
    any::{Any, TypeId},
    borrow::{Borrow, BorrowMut},
    cell::RefCell,
    convert::TryFrom,
    marker::PhantomData,
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::Arc,
};

pub const DOT: isize = 1;
pub const COMMA: isize = 2;
pub const SEMICOLON: isize = 3;
pub const FAKE_COLON: isize = 4;
pub const OP_PROPORTION: isize = 5;
pub const COLON: isize = 6;
pub const PARENTHESES_L: isize = 7;
pub const PARENTHESES_R: isize = 8;
pub const BRACKET_L: isize = 9;
pub const BRACKET_R: isize = 10;
pub const BRACE_L: isize = 11;
pub const BRACE_R: isize = 12;
pub const GENERIC_L: isize = 13;
pub const GENERIC_R: isize = 14;
pub const OFFSET_L: isize = 15;
pub const OFFSET_R: isize = 16;
pub const RANGE_L: isize = 17;
pub const RANGE_R: isize = 18;
pub const CEILING_L: isize = 19;
pub const CEILING_R: isize = 20;
pub const FLOOR_L: isize = 21;
pub const FLOOR_R: isize = 22;
pub const COLLECTION_L: isize = 23;
pub const COLLECTION_R: isize = 24;
pub const OP_ADD: isize = 25;
pub const OP_SUB: isize = 26;
pub const OP_INC: isize = 27;
pub const OP_DEC: isize = 28;
pub const OP_MUL: isize = 29;
pub const OP_DIV: isize = 30;
pub const OP_REM: isize = 31;
pub const OP_DIV_REM: isize = 32;
pub const OP_EQ: isize = 33;
pub const OP_NE: isize = 34;
pub const OP_NEE: isize = 35;
pub const OP_EEE: isize = 36;
pub const OP_LEQ: isize = 37;
pub const OP_LLE: isize = 38;
pub const OP_LLL: isize = 39;
pub const OP_LL: isize = 40;
pub const OP_LT: isize = 41;
pub const OP_GEQ: isize = 42;
pub const OP_GGE: isize = 43;
pub const OP_GGG: isize = 44;
pub const OP_GG: isize = 45;
pub const OP_GT: isize = 46;
pub const OP_LEFT: isize = 47;
pub const OP_ARROW: isize = 48;
pub const OP_ARROW2: isize = 49;
pub const OP_ARROW3: isize = 50;
pub const OP_ASSIGN: isize = 51;
pub const OP_BIND: isize = 52;
pub const OP_MAY_ASSIGN: isize = 53;
pub const OP_ADD_ASSIGN: isize = 54;
pub const OP_SUB_ASSIGN: isize = 55;
pub const OP_MUL_ASSIGN: isize = 56;
pub const OP_DIV_ASSIGN: isize = 57;
pub const OP_BANG: isize = 58;
pub const OP_NOT: isize = 59;
pub const KW_NOT: isize = 60;
pub const LOGIC_AND: isize = 61;
pub const LOGIC_XAND: isize = 62;
pub const LOGIC_NAND: isize = 63;
pub const LOGIC_OR: isize = 64;
pub const LOGIC_XOR: isize = 65;
pub const LOGIC_NOR: isize = 66;
pub const SET_INTERSECTION: isize = 67;
pub const SET_UNION: isize = 68;
pub const OP_AND: isize = 69;
pub const OP_OR: isize = 70;
pub const OP_IMPL: isize = 71;
pub const OP_IFF: isize = 72;
pub const OP_MAP: isize = 73;
pub const OP_APPLY2: isize = 74;
pub const OP_APPLY3: isize = 75;
pub const OP_AT: isize = 76;
pub const OP_HASH: isize = 77;
pub const LAMBDA_SLOT: isize = 78;
pub const MACRO_SLOT: isize = 79;
pub const OP_UNIMPLEMENTED: isize = 80;
pub const OP_OR_DEFAULT: isize = 81;
pub const OP_OR_ELSE: isize = 82;
pub const OP_AND_THEN: isize = 83;
pub const OP_IN: isize = 84;
pub const KW_IN: isize = 85;
pub const OP_NOT_IN: isize = 86;
pub const OP_CONTINUES: isize = 87;
pub const OP_PRIME: isize = 88;
pub const KW_IS: isize = 89;
pub const OP_IS: isize = 90;
pub const OP_IS_NOT: isize = 91;
pub const KW_AS: isize = 92;
pub const OP_DOT3: isize = 93;
pub const OP_DOT2: isize = 94;
pub const OP_UNTIL: isize = 95;
pub const OP_POW: isize = 96;
pub const OP_INVERSE: isize = 97;
pub const OP_ROOT2: isize = 98;
pub const OP_ROOT3: isize = 99;
pub const OP_ROOT4: isize = 100;
pub const OP_TEMPERATURE: isize = 101;
pub const OP_TRANSPOSE: isize = 102;
pub const OP_PERCENT: isize = 103;
pub const OP_PERCENT2: isize = 104;
pub const OP_REFERENCE: isize = 105;
pub const OP_LABEL: isize = 106;
pub const OP_OUTPUT: isize = 107;
pub const OP_LAST: isize = 108;
pub const KW_NAMESPACE: isize = 109;
pub const KW_IMPORT: isize = 110;
pub const KW_EXTENSION: isize = 111;
pub const KW_CLASS: isize = 112;
pub const KW_TRAIT: isize = 113;
pub const KW_UNION: isize = 114;
pub const KW_BITFLAGS: isize = 115;
pub const KW_TYPE: isize = 116;
pub const KW_TEMPLATE: isize = 117;
pub const KW_EXTENDS: isize = 118;
pub const KW_IMPLEMENTS: isize = 119;
pub const KW_WHILE: isize = 120;
pub const KW_FOR: isize = 121;
pub const KW_LET: isize = 122;
pub const KW_NEW: isize = 123;
pub const KW_OBJECT: isize = 124;
pub const KW_LAMBDA: isize = 125;
pub const KW_FUNCTION: isize = 126;
pub const KW_TRY: isize = 127;
pub const KW_MATCH: isize = 128;
pub const KW_CATCH: isize = 129;
pub const KW_WITH: isize = 130;
pub const KW_CASE: isize = 131;
pub const KW_WHEN: isize = 132;
pub const KW_WHERE: isize = 133;
pub const INTEGER: isize = 134;
pub const DECIMAL: isize = 135;
pub const STRING_START: isize = 136;
pub const KW_IF: isize = 137;
pub const KW_ELSE: isize = 138;
pub const KW_OTHERWISE: isize = 139;
pub const RETURN: isize = 140;
pub const RESUME: isize = 141;
pub const YIELD: isize = 142;
pub const BREAK: isize = 143;
pub const CONTINUE: isize = 144;
pub const FALL_THROUGH: isize = 145;
pub const RAISE: isize = 146;
pub const SPECIAL: isize = 147;
pub const RAW_ID: isize = 148;
pub const UNICODE_ID: isize = 149;
pub const LINE_COMMENT: isize = 150;
pub const BLOCK_COMMENT: isize = 151;
pub const WHITE_SPACE: isize = 152;
pub const ERROR_CHARACTAR: isize = 153;
pub const STRING_TEXT: isize = 154;
pub const STRING_END: isize = 155;
pub const STRING_OUT2: isize = 156;
pub const STRING_OUT3: isize = 157;
pub const STRING_OUT6: isize = 158;
pub const RULE_program: usize = 0;
pub const RULE_eos: usize = 1;
pub const RULE_eos_free: usize = 2;
pub const RULE_define_namespace: usize = 3;
pub const RULE_import_statement: usize = 4;
pub const RULE_import_as: usize = 5;
pub const RULE_import_term: usize = 6;
pub const RULE_import_name: usize = 7;
pub const RULE_import_block: usize = 8;
pub const RULE_define_extension: usize = 9;
pub const RULE_define_class: usize = 10;
pub const RULE_class_block: usize = 11;
pub const RULE_class_inherit: usize = 12;
pub const RULE_class_inherit_item: usize = 13;
pub const RULE_class_field: usize = 14;
pub const RULE_class_method: usize = 15;
pub const RULE_class_dsl: usize = 16;
pub const RULE_define_trait: usize = 17;
pub const RULE_trait_block: usize = 18;
pub const RULE_define_trait_type: usize = 19;
pub const RULE_define_extends: usize = 20;
pub const RULE_extends_block: usize = 21;
pub const RULE_with_implements: usize = 22;
pub const RULE_define_union: usize = 23;
pub const RULE_base_layout: usize = 24;
pub const RULE_union_block: usize = 25;
pub const RULE_define_variant: usize = 26;
pub const RULE_variant_block: usize = 27;
pub const RULE_define_bitflags: usize = 28;
pub const RULE_bitflags_block: usize = 29;
pub const RULE_bitflags_item: usize = 30;
pub const RULE_define_function: usize = 31;
pub const RULE_function_parameters: usize = 32;
pub const RULE_parameter_item: usize = 33;
pub const RULE_parameter_special: usize = 34;
pub const RULE_return_type: usize = 35;
pub const RULE_parameter_default: usize = 36;
pub const RULE_function_call: usize = 37;
pub const RULE_closure_call: usize = 38;
pub const RULE_tuple_call_body: usize = 39;
pub const RULE_tuple_call_item: usize = 40;
pub const RULE_define_lambda: usize = 41;
pub const RULE_function_block: usize = 42;
pub const RULE_let_binding: usize = 43;
pub const RULE_let_pattern: usize = 44;
pub const RULE_let_pattern_plain: usize = 45;
pub const RULE_let_pattern_tuple: usize = 46;
pub const RULE_let_pattern_item: usize = 47;
pub const RULE_define_type: usize = 48;
pub const RULE_type_hint: usize = 49;
pub const RULE_if_statement: usize = 50;
pub const RULE_guard_statement: usize = 51;
pub const RULE_else_if_statement: usize = 52;
pub const RULE_loop_statement: usize = 53;
pub const RULE_if_guard: usize = 54;
pub const RULE_expression_root: usize = 55;
pub const RULE_expression: usize = 56;
pub const RULE_inline_expression: usize = 57;
pub const RULE_type_expression: usize = 58;
pub const RULE_atomic: usize = 59;
pub const RULE_control_expression: usize = 60;
pub const RULE_op_prefix: usize = 61;
pub const RULE_op_suffix: usize = 62;
pub const RULE_op_compare: usize = 63;
pub const RULE_op_pattern: usize = 64;
pub const RULE_infix_map: usize = 65;
pub const RULE_infix_pow: usize = 66;
pub const RULE_infix_range: usize = 67;
pub const RULE_infix_arrows: usize = 68;
pub const RULE_op_multiple: usize = 69;
pub const RULE_op_plus: usize = 70;
pub const RULE_op_logic: usize = 71;
pub const RULE_op_pipeline: usize = 72;
pub const RULE_infix_assign: usize = 73;
pub const RULE_infix_is: usize = 74;
pub const RULE_infix_as: usize = 75;
pub const RULE_infix_in: usize = 76;
pub const RULE_define_generic: usize = 77;
pub const RULE_generic_item: usize = 78;
pub const RULE_generic_call: usize = 79;
pub const RULE_generic_call_in_type: usize = 80;
pub const RULE_generic_pair: usize = 81;
pub const RULE_define_label: usize = 82;
pub const RULE_template_call: usize = 83;
pub const RULE_template_block: usize = 84;
pub const RULE_template_statements: usize = 85;
pub const RULE_template_implements: usize = 86;
pub const RULE_where_block: usize = 87;
pub const RULE_where_bound: usize = 88;
pub const RULE_require_block: usize = 89;
pub const RULE_macro_call: usize = 90;
pub const RULE_annotation: usize = 91;
pub const RULE_annotation_call_item: usize = 92;
pub const RULE_try_statement: usize = 93;
pub const RULE_match_statement: usize = 94;
pub const RULE_match_block: usize = 95;
pub const RULE_match_terms: usize = 96;
pub const RULE_match_case_block: usize = 97;
pub const RULE_case_pattern: usize = 98;
pub const RULE_case_pattern_item: usize = 99;
pub const RULE_case_pattern_tuple: usize = 100;
pub const RULE_object_statement: usize = 101;
pub const RULE_new_statement: usize = 102;
pub const RULE_new_block: usize = 103;
pub const RULE_new_call_item: usize = 104;
pub const RULE_new_call_key: usize = 105;
pub const RULE_tuple_literal: usize = 106;
pub const RULE_collection_pair: usize = 107;
pub const RULE_collection_key: usize = 108;
pub const RULE_slice_call: usize = 109;
pub const RULE_range_literal: usize = 110;
pub const RULE_range_axis: usize = 111;
pub const RULE_modifiers: usize = 112;
pub const RULE_modified_identifier: usize = 113;
pub const RULE_modified_namepath: usize = 114;
pub const RULE_lambda_name: usize = 115;
pub const RULE_output_name: usize = 116;
pub const RULE_namepath_free: usize = 117;
pub const RULE_namepath: usize = 118;
pub const RULE_identifier: usize = 119;
pub const RULE_number: usize = 120;
pub const RULE_number_literal: usize = 121;
pub const RULE_string: usize = 122;
pub const RULE_string_literal: usize = 123;
pub const ruleNames: [&'static str; 124] = [
    "program",
    "eos",
    "eos_free",
    "define_namespace",
    "import_statement",
    "import_as",
    "import_term",
    "import_name",
    "import_block",
    "define_extension",
    "define_class",
    "class_block",
    "class_inherit",
    "class_inherit_item",
    "class_field",
    "class_method",
    "class_dsl",
    "define_trait",
    "trait_block",
    "define_trait_type",
    "define_extends",
    "extends_block",
    "with_implements",
    "define_union",
    "base_layout",
    "union_block",
    "define_variant",
    "variant_block",
    "define_bitflags",
    "bitflags_block",
    "bitflags_item",
    "define_function",
    "function_parameters",
    "parameter_item",
    "parameter_special",
    "return_type",
    "parameter_default",
    "function_call",
    "closure_call",
    "tuple_call_body",
    "tuple_call_item",
    "define_lambda",
    "function_block",
    "let_binding",
    "let_pattern",
    "let_pattern_plain",
    "let_pattern_tuple",
    "let_pattern_item",
    "define_type",
    "type_hint",
    "if_statement",
    "guard_statement",
    "else_if_statement",
    "loop_statement",
    "if_guard",
    "expression_root",
    "expression",
    "inline_expression",
    "type_expression",
    "atomic",
    "control_expression",
    "op_prefix",
    "op_suffix",
    "op_compare",
    "op_pattern",
    "infix_map",
    "infix_pow",
    "infix_range",
    "infix_arrows",
    "op_multiple",
    "op_plus",
    "op_logic",
    "op_pipeline",
    "infix_assign",
    "infix_is",
    "infix_as",
    "infix_in",
    "define_generic",
    "generic_item",
    "generic_call",
    "generic_call_in_type",
    "generic_pair",
    "define_label",
    "template_call",
    "template_block",
    "template_statements",
    "template_implements",
    "where_block",
    "where_bound",
    "require_block",
    "macro_call",
    "annotation",
    "annotation_call_item",
    "try_statement",
    "match_statement",
    "match_block",
    "match_terms",
    "match_case_block",
    "case_pattern",
    "case_pattern_item",
    "case_pattern_tuple",
    "object_statement",
    "new_statement",
    "new_block",
    "new_call_item",
    "new_call_key",
    "tuple_literal",
    "collection_pair",
    "collection_key",
    "slice_call",
    "range_literal",
    "range_axis",
    "modifiers",
    "modified_identifier",
    "modified_namepath",
    "lambda_name",
    "output_name",
    "namepath_free",
    "namepath",
    "identifier",
    "number",
    "number_literal",
    "string",
    "string_literal",
];

pub const _LITERAL_NAMES: [Option<&'static str>; 159] = [
    None,
    Some("'.'"),
    None,
    Some("';'"),
    None,
    None,
    None,
    Some("'('"),
    Some("')'"),
    Some("'['"),
    Some("']'"),
    Some("'{'"),
    Some("'}'"),
    Some("'\u{27E8}'"),
    Some("'\u{27E9}'"),
    Some("'\u{2045}'"),
    Some("'\u{2046}'"),
    Some("'\u{27E6}'"),
    Some("'\u{27E7}'"),
    Some("'\u{2308}'"),
    Some("'\u{2309}'"),
    Some("'\u{230A}'"),
    Some("'\u{230B}'"),
    Some("'\u{2983}'"),
    Some("'\u{2984}'"),
    Some("'+'"),
    Some("'-'"),
    Some("'++'"),
    Some("'--'"),
    Some("'*'"),
    None,
    Some("'\u{2052}'"),
    None,
    Some("'=='"),
    None,
    None,
    None,
    None,
    Some("'<<='"),
    None,
    None,
    Some("'<'"),
    None,
    Some("'>>='"),
    None,
    None,
    Some("'>'"),
    None,
    None,
    None,
    Some("'==>'"),
    Some("'='"),
    None,
    Some("'?='"),
    Some("'+='"),
    Some("'-='"),
    Some("'*='"),
    Some("'/='"),
    Some("'!'"),
    Some("'\u{00AC}'"),
    Some("'not'"),
    None,
    Some("'\u{2A5F}'"),
    Some("'\u{22BC}'"),
    None,
    Some("'\u{22BB}'"),
    Some("'\u{22BD}'"),
    Some("'\u{2229}'"),
    Some("'\u{222A}'"),
    Some("'&'"),
    Some("'|'"),
    Some("'\u{203D}'"),
    Some("'\u{21D4}'"),
    None,
    None,
    None,
    Some("'@'"),
    None,
    None,
    None,
    None,
    Some("'??'"),
    Some("'?:'"),
    Some("'?'"),
    None,
    Some("'in'"),
    Some("'\u{2209}'"),
    None,
    None,
    Some("'is'"),
    None,
    None,
    None,
    None,
    None,
    None,
    Some("'^'"),
    Some("'\u{215F}'"),
    Some("'\u{221A}'"),
    Some("'\u{221B}'"),
    Some("'\u{221C}'"),
    None,
    None,
    Some("'%'"),
    None,
    Some("'\u{203B}'"),
    Some("'\u{00B6}'"),
    None,
    None,
    None,
    None,
    Some("'extension'"),
    None,
    None,
    Some("'union'"),
    Some("'flags'"),
    Some("'type'"),
    None,
    Some("'extends'"),
    Some("'implements'"),
    None,
    Some("'for'"),
    Some("'let'"),
    Some("'new'"),
    Some("'object'"),
    Some("'lambda'"),
    None,
    Some("'try'"),
    Some("'match'"),
    Some("'catch'"),
    Some("'with'"),
    Some("'case'"),
    Some("'when'"),
    Some("'where'"),
    None,
    None,
    None,
    Some("'if'"),
    Some("'else'"),
    Some("'otherwise'"),
    Some("'return'"),
    Some("'resume'"),
    Some("'yield'"),
    Some("'break'"),
    Some("'continue'"),
    Some("'fallthrough'"),
    Some("'raise'"),
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    None,
    Some("'''''"),
    Some("'\"\"\"'"),
];
pub const _SYMBOLIC_NAMES: [Option<&'static str>; 159] = [
    None,
    Some("DOT"),
    Some("COMMA"),
    Some("SEMICOLON"),
    Some("FAKE_COLON"),
    Some("OP_PROPORTION"),
    Some("COLON"),
    Some("PARENTHESES_L"),
    Some("PARENTHESES_R"),
    Some("BRACKET_L"),
    Some("BRACKET_R"),
    Some("BRACE_L"),
    Some("BRACE_R"),
    Some("GENERIC_L"),
    Some("GENERIC_R"),
    Some("OFFSET_L"),
    Some("OFFSET_R"),
    Some("RANGE_L"),
    Some("RANGE_R"),
    Some("CEILING_L"),
    Some("CEILING_R"),
    Some("FLOOR_L"),
    Some("FLOOR_R"),
    Some("COLLECTION_L"),
    Some("COLLECTION_R"),
    Some("OP_ADD"),
    Some("OP_SUB"),
    Some("OP_INC"),
    Some("OP_DEC"),
    Some("OP_MUL"),
    Some("OP_DIV"),
    Some("OP_REM"),
    Some("OP_DIV_REM"),
    Some("OP_EQ"),
    Some("OP_NE"),
    Some("OP_NEE"),
    Some("OP_EEE"),
    Some("OP_LEQ"),
    Some("OP_LLE"),
    Some("OP_LLL"),
    Some("OP_LL"),
    Some("OP_LT"),
    Some("OP_GEQ"),
    Some("OP_GGE"),
    Some("OP_GGG"),
    Some("OP_GG"),
    Some("OP_GT"),
    Some("OP_LEFT"),
    Some("OP_ARROW"),
    Some("OP_ARROW2"),
    Some("OP_ARROW3"),
    Some("OP_ASSIGN"),
    Some("OP_BIND"),
    Some("OP_MAY_ASSIGN"),
    Some("OP_ADD_ASSIGN"),
    Some("OP_SUB_ASSIGN"),
    Some("OP_MUL_ASSIGN"),
    Some("OP_DIV_ASSIGN"),
    Some("OP_BANG"),
    Some("OP_NOT"),
    Some("KW_NOT"),
    Some("LOGIC_AND"),
    Some("LOGIC_XAND"),
    Some("LOGIC_NAND"),
    Some("LOGIC_OR"),
    Some("LOGIC_XOR"),
    Some("LOGIC_NOR"),
    Some("SET_INTERSECTION"),
    Some("SET_UNION"),
    Some("OP_AND"),
    Some("OP_OR"),
    Some("OP_IMPL"),
    Some("OP_IFF"),
    Some("OP_MAP"),
    Some("OP_APPLY2"),
    Some("OP_APPLY3"),
    Some("OP_AT"),
    Some("OP_HASH"),
    Some("LAMBDA_SLOT"),
    Some("MACRO_SLOT"),
    Some("OP_UNIMPLEMENTED"),
    Some("OP_OR_DEFAULT"),
    Some("OP_OR_ELSE"),
    Some("OP_AND_THEN"),
    Some("OP_IN"),
    Some("KW_IN"),
    Some("OP_NOT_IN"),
    Some("OP_CONTINUES"),
    Some("OP_PRIME"),
    Some("KW_IS"),
    Some("OP_IS"),
    Some("OP_IS_NOT"),
    Some("KW_AS"),
    Some("OP_DOT3"),
    Some("OP_DOT2"),
    Some("OP_UNTIL"),
    Some("OP_POW"),
    Some("OP_INVERSE"),
    Some("OP_ROOT2"),
    Some("OP_ROOT3"),
    Some("OP_ROOT4"),
    Some("OP_TEMPERATURE"),
    Some("OP_TRANSPOSE"),
    Some("OP_PERCENT"),
    Some("OP_PERCENT2"),
    Some("OP_REFERENCE"),
    Some("OP_LABEL"),
    Some("OP_OUTPUT"),
    Some("OP_LAST"),
    Some("KW_NAMESPACE"),
    Some("KW_IMPORT"),
    Some("KW_EXTENSION"),
    Some("KW_CLASS"),
    Some("KW_TRAIT"),
    Some("KW_UNION"),
    Some("KW_BITFLAGS"),
    Some("KW_TYPE"),
    Some("KW_TEMPLATE"),
    Some("KW_EXTENDS"),
    Some("KW_IMPLEMENTS"),
    Some("KW_WHILE"),
    Some("KW_FOR"),
    Some("KW_LET"),
    Some("KW_NEW"),
    Some("KW_OBJECT"),
    Some("KW_LAMBDA"),
    Some("KW_FUNCTION"),
    Some("KW_TRY"),
    Some("KW_MATCH"),
    Some("KW_CATCH"),
    Some("KW_WITH"),
    Some("KW_CASE"),
    Some("KW_WHEN"),
    Some("KW_WHERE"),
    Some("INTEGER"),
    Some("DECIMAL"),
    Some("STRING_START"),
    Some("KW_IF"),
    Some("KW_ELSE"),
    Some("KW_OTHERWISE"),
    Some("RETURN"),
    Some("RESUME"),
    Some("YIELD"),
    Some("BREAK"),
    Some("CONTINUE"),
    Some("FALL_THROUGH"),
    Some("RAISE"),
    Some("SPECIAL"),
    Some("RAW_ID"),
    Some("UNICODE_ID"),
    Some("LINE_COMMENT"),
    Some("BLOCK_COMMENT"),
    Some("WHITE_SPACE"),
    Some("ERROR_CHARACTAR"),
    Some("STRING_TEXT"),
    Some("STRING_END"),
    Some("STRING_OUT2"),
    Some("STRING_OUT3"),
    Some("STRING_OUT6"),
];
lazy_static! {
    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
    static ref VOCABULARY: Box<dyn Vocabulary> =
        Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
}

type BaseParserType<'input, I> = BaseParser<
    'input,
    ValkyrieAntlrParserExt<'input>,
    I,
    ValkyrieAntlrParserContextType,
    dyn ValkyrieAntlrListener<'input> + 'input,
>;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type ValkyrieAntlrTreeWalker<'input, 'a> =
    ParseTreeWalker<'input, 'a, ValkyrieAntlrParserContextType, dyn ValkyrieAntlrListener<'input> + 'a>;

/// Parser for ValkyrieAntlr grammar
pub struct ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    base: BaseParserType<'input, I>,
    interpreter: Arc<ParserATNSimulator>,
    _shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn get_serialized_atn() -> &'static str {
        _serializedATN
    }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
        antlr_rust::recognizer::check_version("0", "3");
        let interpreter =
            Arc::new(ParserATNSimulator::new(_ATN.clone(), _decision_to_DFA.clone(), _shared_context_cache.clone()));
        Self {
            base: BaseParser::new_base_parser(
                input,
                Arc::clone(&interpreter),
                ValkyrieAntlrParserExt { _pd: Default::default() },
            ),
            interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }
}

type DynStrategy<'input, I> = Box<dyn ErrorStrategy<'input, BaseParserType<'input, I>> + 'input>;

impl<'input, I> ValkyrieAntlrParser<'input, I, DynStrategy<'input, I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self {
        Self::with_strategy(input, Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn new(input: I) -> Self {
        Self::with_strategy(input, DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for ValkyrieAntlrParser
pub trait ValkyrieAntlrParserContext<'input>:
    for<'x> Listenable<dyn ValkyrieAntlrListener<'input> + 'x>
    + for<'x> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'x>
    + ParserRuleContext<'input, TF = LocalTokenFactory<'input>, Ctx = ValkyrieAntlrParserContextType>
{
}

antlr_rust::coerce_from! { 'input : ValkyrieAntlrParserContext<'input> }

impl<'input, 'x, T> VisitableDyn<T> for dyn ValkyrieAntlrParserContext<'input> + 'input
where
    T: ValkyrieAntlrVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn ValkyrieAntlrVisitor<'input> + 'x))
    }
}

impl<'input> ValkyrieAntlrParserContext<'input> for TerminalNode<'input, ValkyrieAntlrParserContextType> {}
impl<'input> ValkyrieAntlrParserContext<'input> for ErrorNode<'input, ValkyrieAntlrParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrListener<'input> + 'input }

pub struct ValkyrieAntlrParserContextType;
antlr_rust::tid! {ValkyrieAntlrParserContextType}

impl<'input> ParserNodeType<'input> for ValkyrieAntlrParserContextType {
    type TF = LocalTokenFactory<'input>;
    type Type = dyn ValkyrieAntlrParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    type Target = BaseParserType<'input, I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct ValkyrieAntlrParserExt<'input> {
    _pd: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserExt<'input> {}
antlr_rust::tid! { ValkyrieAntlrParserExt<'a> }

impl<'input> TokenAware<'input> for ValkyrieAntlrParserExt<'input> {
    type TF = LocalTokenFactory<'input>;
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    ParserRecog<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    Actions<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
    fn get_grammar_file_name(&self) -> &str {
        "ValkyrieAntlr.g4"
    }

    fn get_rule_names(&self) -> &[&str] {
        &ruleNames
    }

    fn get_vocabulary(&self) -> &dyn Vocabulary {
        &**VOCABULARY
    }
    fn sempred(
        _localctx: Option<&(dyn ValkyrieAntlrParserContext<'input> + 'input)>,
        rule_index: isize,
        pred_index: isize,
        recog: &mut BaseParserType<'input, I>,
    ) -> bool {
        match rule_index {
            56 => ValkyrieAntlrParser::<'input, I, _>::expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            57 => ValkyrieAntlrParser::<'input, I, _>::inline_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            58 => ValkyrieAntlrParser::<'input, I, _>::type_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            98 => ValkyrieAntlrParser::<'input, I, _>::case_pattern_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            _ => true,
        }
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    fn expression_sempred(
        _localctx: Option<&ExpressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            0 => recog.precpred(None, 29),
            1 => recog.precpred(None, 28),
            2 => recog.precpred(None, 27),
            3 => recog.precpred(None, 26),
            4 => recog.precpred(None, 25),
            5 => recog.precpred(None, 24),
            6 => recog.precpred(None, 23),
            7 => recog.precpred(None, 20),
            8 => recog.precpred(None, 19),
            9 => recog.precpred(None, 18),
            10 => recog.precpred(None, 17),
            11 => recog.precpred(None, 35),
            12 => recog.precpred(None, 34),
            13 => recog.precpred(None, 33),
            14 => recog.precpred(None, 32),
            15 => recog.precpred(None, 31),
            16 => recog.precpred(None, 22),
            17 => recog.precpred(None, 21),
            _ => true,
        }
    }
    fn inline_expression_sempred(
        _localctx: Option<&Inline_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            18 => recog.precpred(None, 14),
            19 => recog.precpred(None, 13),
            20 => recog.precpred(None, 12),
            21 => recog.precpred(None, 11),
            22 => recog.precpred(None, 10),
            23 => recog.precpred(None, 7),
            24 => recog.precpred(None, 17),
            25 => recog.precpred(None, 16),
            26 => recog.precpred(None, 15),
            27 => recog.precpred(None, 9),
            28 => recog.precpred(None, 8),
            _ => true,
        }
    }
    fn type_expression_sempred(
        _localctx: Option<&Type_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            29 => recog.precpred(None, 6),
            30 => recog.precpred(None, 5),
            31 => recog.precpred(None, 4),
            32 => recog.precpred(None, 9),
            33 => recog.precpred(None, 8),
            34 => recog.precpred(None, 7),
            35 => recog.precpred(None, 3),
            _ => true,
        }
    }
    fn case_pattern_sempred(
        _localctx: Option<&Case_patternContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            36 => recog.precpred(None, 3),
            37 => recog.precpred(None, 2),
            _ => true,
        }
    }
}
//------------------- program ----------------
pub type ProgramContextAll<'input> = ProgramContext<'input>;

pub type ProgramContext<'input> = BaseParserRuleContext<'input, ProgramContextExt<'input>>;

#[derive(Clone)]
pub struct ProgramContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ProgramContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ProgramContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_program(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_program(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ProgramContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_program(self);
    }
}

impl<'input> CustomRuleContext<'input> for ProgramContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_program
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_program }
}
antlr_rust::tid! {ProgramContextExt<'a>}

impl<'input> ProgramContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ProgramContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, ProgramContextExt { ph: PhantomData }))
    }
}

pub trait ProgramContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ProgramContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
    fn define_namespace_all(&self) -> Vec<Rc<Define_namespaceContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_namespace(&self, i: usize) -> Option<Rc<Define_namespaceContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn import_statement_all(&self) -> Vec<Rc<Import_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn import_statement(&self, i: usize) -> Option<Rc<Import_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_extension_all(&self) -> Vec<Rc<Define_extensionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_extension(&self, i: usize) -> Option<Rc<Define_extensionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_class_all(&self) -> Vec<Rc<Define_classContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_class(&self, i: usize) -> Option<Rc<Define_classContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_union_all(&self) -> Vec<Rc<Define_unionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_union(&self, i: usize) -> Option<Rc<Define_unionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_bitflags_all(&self) -> Vec<Rc<Define_bitflagsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_bitflags(&self, i: usize) -> Option<Rc<Define_bitflagsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_trait_all(&self) -> Vec<Rc<Define_traitContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait(&self, i: usize) -> Option<Rc<Define_traitContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_extends_all(&self) -> Vec<Rc<Define_extendsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_extends(&self, i: usize) -> Option<Rc<Define_extendsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_function_all(&self) -> Vec<Rc<Define_functionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_function(&self, i: usize) -> Option<Rc<Define_functionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_type_all(&self) -> Vec<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_type(&self, i: usize) -> Option<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn let_binding_all(&self) -> Vec<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_binding(&self, i: usize) -> Option<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn loop_statement_all(&self) -> Vec<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn loop_statement(&self, i: usize) -> Option<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn guard_statement_all(&self) -> Vec<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn guard_statement(&self, i: usize) -> Option<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn expression_root_all(&self) -> Vec<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression_root(&self, i: usize) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_all(&self) -> Vec<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos(&self, i: usize) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ProgramContextAttrs<'input> for ProgramContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn program(&mut self) -> Result<Rc<ProgramContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ProgramContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_program);
        let mut _localctx: Rc<ProgramContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(265);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << SEMICOLON)
                            | (1usize << FAKE_COLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << BRACE_L)
                            | (1usize << OFFSET_L)
                            | (1usize << CEILING_L)
                            | (1usize << FLOOR_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 58) & !0x3f) == 0
                        && ((1usize << (_la - 58))
                            & ((1usize << (OP_BANG - 58))
                                | (1usize << (OP_NOT - 58))
                                | (1usize << (OP_AND - 58))
                                | (1usize << (OP_AT - 58))
                                | (1usize << (OP_HASH - 58))
                                | (1usize << (LAMBDA_SLOT - 58))))
                            != 0)
                    || (((_la - 93) & !0x3f) == 0
                        && ((1usize << (_la - 93))
                            & ((1usize << (OP_DOT3 - 93))
                                | (1usize << (OP_DOT2 - 93))
                                | (1usize << (OP_INVERSE - 93))
                                | (1usize << (OP_ROOT2 - 93))
                                | (1usize << (OP_ROOT3 - 93))
                                | (1usize << (OP_ROOT4 - 93))
                                | (1usize << (OP_PERCENT - 93))
                                | (1usize << (OP_REFERENCE - 93))
                                | (1usize << (OP_LABEL - 93))
                                | (1usize << (OP_OUTPUT - 93))
                                | (1usize << (OP_LAST - 93))
                                | (1usize << (KW_NAMESPACE - 93))
                                | (1usize << (KW_IMPORT - 93))
                                | (1usize << (KW_EXTENSION - 93))
                                | (1usize << (KW_CLASS - 93))
                                | (1usize << (KW_TRAIT - 93))
                                | (1usize << (KW_UNION - 93))
                                | (1usize << (KW_BITFLAGS - 93))
                                | (1usize << (KW_TYPE - 93))
                                | (1usize << (KW_TEMPLATE - 93))
                                | (1usize << (KW_EXTENDS - 93))
                                | (1usize << (KW_WHILE - 93))
                                | (1usize << (KW_FOR - 93))
                                | (1usize << (KW_LET - 93))
                                | (1usize << (KW_NEW - 93))
                                | (1usize << (KW_OBJECT - 93))))
                            != 0)
                    || (((_la - 125) & !0x3f) == 0
                        && ((1usize << (_la - 125))
                            & ((1usize << (KW_LAMBDA - 125))
                                | (1usize << (KW_FUNCTION - 125))
                                | (1usize << (KW_TRY - 125))
                                | (1usize << (KW_MATCH - 125))
                                | (1usize << (KW_CATCH - 125))
                                | (1usize << (INTEGER - 125))
                                | (1usize << (DECIMAL - 125))
                                | (1usize << (STRING_START - 125))
                                | (1usize << (KW_IF - 125))
                                | (1usize << (RETURN - 125))
                                | (1usize << (RESUME - 125))
                                | (1usize << (YIELD - 125))
                                | (1usize << (BREAK - 125))
                                | (1usize << (CONTINUE - 125))
                                | (1usize << (FALL_THROUGH - 125))
                                | (1usize << (RAISE - 125))
                                | (1usize << (SPECIAL - 125))
                                | (1usize << (RAW_ID - 125))
                                | (1usize << (UNICODE_ID - 125))))
                            != 0)
                {
                    {
                        recog.base.set_state(263);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(0, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_namespace */
                                    recog.base.set_state(248);
                                    recog.define_namespace()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule import_statement */
                                    recog.base.set_state(249);
                                    recog.import_statement()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule define_extension */
                                    recog.base.set_state(250);
                                    recog.define_extension()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule define_class */
                                    recog.base.set_state(251);
                                    recog.define_class()?;
                                }
                            }
                            5 => {
                                {
                                    /* InvokeRule define_union */
                                    recog.base.set_state(252);
                                    recog.define_union()?;
                                }
                            }
                            6 => {
                                {
                                    /* InvokeRule define_bitflags */
                                    recog.base.set_state(253);
                                    recog.define_bitflags()?;
                                }
                            }
                            7 => {
                                {
                                    /* InvokeRule define_trait */
                                    recog.base.set_state(254);
                                    recog.define_trait()?;
                                }
                            }
                            8 => {
                                {
                                    /* InvokeRule define_extends */
                                    recog.base.set_state(255);
                                    recog.define_extends()?;
                                }
                            }
                            9 => {
                                {
                                    /* InvokeRule define_function */
                                    recog.base.set_state(256);
                                    recog.define_function()?;
                                }
                            }
                            10 => {
                                {
                                    /* InvokeRule define_type */
                                    recog.base.set_state(257);
                                    recog.define_type()?;
                                }
                            }
                            11 => {
                                {
                                    /* InvokeRule let_binding */
                                    recog.base.set_state(258);
                                    recog.let_binding()?;
                                }
                            }
                            12 => {
                                {
                                    /* InvokeRule loop_statement */
                                    recog.base.set_state(259);
                                    recog.loop_statement()?;
                                }
                            }
                            13 => {
                                {
                                    /* InvokeRule guard_statement */
                                    recog.base.set_state(260);
                                    recog.guard_statement()?;
                                }
                            }
                            14 => {
                                {
                                    /* InvokeRule expression_root */
                                    recog.base.set_state(261);
                                    recog.expression_root()?;
                                }
                            }
                            15 => {
                                {
                                    /* InvokeRule eos */
                                    recog.base.set_state(262);
                                    recog.eos()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(267);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(268);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos ----------------
pub type EosContextAll<'input> = EosContext<'input>;

pub type EosContext<'input> = BaseParserRuleContext<'input, EosContextExt<'input>>;

#[derive(Clone)]
pub struct EosContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for EosContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EosContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EosContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos(self);
    }
}

impl<'input> CustomRuleContext<'input> for EosContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos }
}
antlr_rust::tid! {EosContextExt<'a>}

impl<'input> EosContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<EosContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, EosContextExt { ph: PhantomData }))
    }
}

pub trait EosContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<EosContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FAKE_COLON
    /// Returns `None` if there is no child corresponding to token FAKE_COLON
    fn FAKE_COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FAKE_COLON, 0)
    }
}

impl<'input> EosContextAttrs<'input> for EosContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos(&mut self) -> Result<Rc<EosContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = EosContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_eos);
        let mut _localctx: Rc<EosContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(270);
                _la = recog.base.input.la(1);
                if { !(_la == SEMICOLON || _la == FAKE_COLON) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos_free ----------------
pub type Eos_freeContextAll<'input> = Eos_freeContext<'input>;

pub type Eos_freeContext<'input> = BaseParserRuleContext<'input, Eos_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Eos_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Eos_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Eos_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Eos_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Eos_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos_free }
}
antlr_rust::tid! {Eos_freeContextExt<'a>}

impl<'input> Eos_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Eos_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Eos_freeContextExt { ph: PhantomData }))
    }
}

pub trait Eos_freeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Eos_freeContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FAKE_COLON
    /// Returns `None` if there is no child corresponding to token FAKE_COLON
    fn FAKE_COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FAKE_COLON, 0)
    }
}

impl<'input> Eos_freeContextAttrs<'input> for Eos_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos_free(&mut self) -> Result<Rc<Eos_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Eos_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_eos_free);
        let mut _localctx: Rc<Eos_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(272);
                _la = recog.base.input.la(1);
                if {
                    !(((_la) & !0x3f) == 0
                        && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_namespace ----------------
pub type Define_namespaceContextAll<'input> = Define_namespaceContext<'input>;

pub type Define_namespaceContext<'input> = BaseParserRuleContext<'input, Define_namespaceContextExt<'input>>;

#[derive(Clone)]
pub struct Define_namespaceContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_namespaceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_namespaceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_namespace(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_namespace(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_namespaceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_namespace(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_namespaceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_namespace
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_namespace }
}
antlr_rust::tid! {Define_namespaceContextExt<'a>}

impl<'input> Define_namespaceContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_namespaceContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_namespaceContextExt { ph: PhantomData }))
    }
}

pub trait Define_namespaceContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_namespaceContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NAMESPACE
    /// Returns `None` if there is no child corresponding to token KW_NAMESPACE
    fn KW_NAMESPACE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NAMESPACE, 0)
    }
    fn namepath_free(&self) -> Option<Rc<Namepath_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_namespaceContextAttrs<'input> for Define_namespaceContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_namespace(&mut self) -> Result<Rc<Define_namespaceContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_namespaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_define_namespace);
        let mut _localctx: Rc<Define_namespaceContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(274);
                recog.base.match_token(KW_NAMESPACE, &mut recog.err_handler)?;

                /* InvokeRule namepath_free */
                recog.base.set_state(275);
                recog.namepath_free()?;

                recog.base.set_state(277);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(2, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(276);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_statement ----------------
pub type Import_statementContextAll<'input> = Import_statementContext<'input>;

pub type Import_statementContext<'input> = BaseParserRuleContext<'input, Import_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Import_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_statement }
}
antlr_rust::tid! {Import_statementContextExt<'a>}

impl<'input> Import_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_statementContextExt { ph: PhantomData }))
    }
}

pub trait Import_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IMPORT
    /// Returns `None` if there is no child corresponding to token KW_IMPORT
    fn KW_IMPORT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPORT, 0)
    }
    fn import_term(&self) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_statementContextAttrs<'input> for Import_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_statement(&mut self) -> Result<Rc<Import_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_import_statement);
        let mut _localctx: Rc<Import_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(279);
                recog.base.match_token(KW_IMPORT, &mut recog.err_handler)?;

                /* InvokeRule import_term */
                recog.base.set_state(280);
                recog.import_term()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_as ----------------
pub type Import_asContextAll<'input> = Import_asContext<'input>;

pub type Import_asContext<'input> = BaseParserRuleContext<'input, Import_asContextExt<'input>>;

#[derive(Clone)]
pub struct Import_asContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_asContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_asContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_as(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_as(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_asContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_as(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_asContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_as
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_as }
}
antlr_rust::tid! {Import_asContextExt<'a>}

impl<'input> Import_asContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_asContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_asContextExt { ph: PhantomData }))
    }
}

pub trait Import_asContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Import_asContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
}

impl<'input> Import_asContextAttrs<'input> for Import_asContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_as(&mut self) -> Result<Rc<Import_asContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_asContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_import_as);
        let mut _localctx: Rc<Import_asContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(282);
                recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                recog.base.set_state(284);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AT || _la == OP_HASH {
                    {
                        recog.base.set_state(283);
                        _la = recog.base.input.la(1);
                        if { !(_la == OP_AT || _la == OP_HASH) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                /* InvokeRule identifier */
                recog.base.set_state(286);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_term ----------------
pub type Import_termContextAll<'input> = Import_termContext<'input>;

pub type Import_termContext<'input> = BaseParserRuleContext<'input, Import_termContextExt<'input>>;

#[derive(Clone)]
pub struct Import_termContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_termContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_termContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_term(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_term(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_termContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_term(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_termContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_term
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_term }
}
antlr_rust::tid! {Import_termContextExt<'a>}

impl<'input> Import_termContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_termContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_termContextExt { ph: PhantomData }))
    }
}

pub trait Import_termContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_termContextExt<'input>>
{
    fn import_block(&self) -> Option<Rc<Import_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn import_name(&self) -> Option<Rc<Import_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn import_as(&self) -> Option<Rc<Import_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_termContextAttrs<'input> for Import_termContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_term(&mut self) -> Result<Rc<Import_termContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_termContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_import_term);
        let mut _localctx: Rc<Import_termContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(327);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(13, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule import_block */
                        recog.base.set_state(288);
                        recog.import_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(289);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(290);
                        recog.import_name()?;

                        recog.base.set_state(292);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(291);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(294);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(295);
                        recog.import_name()?;

                        recog.base.set_state(300);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(6, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(297);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(296);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(299);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(302);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(303);
                        recog.import_name()?;

                        recog.base.set_state(305);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(304);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(307);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(308);
                        recog.import_name()?;

                        recog.base.set_state(313);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(9, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(310);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(309);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(312);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(315);
                        recog.import_name()?;

                        recog.base.set_state(317);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(316);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(319);
                        recog.import_name()?;

                        recog.base.set_state(324);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(12, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(321);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(320);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(323);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(326);
                        recog.eos_free()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_name ----------------
pub type Import_nameContextAll<'input> = Import_nameContext<'input>;

pub type Import_nameContext<'input> = BaseParserRuleContext<'input, Import_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Import_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_name }
}
antlr_rust::tid! {Import_nameContextExt<'a>}

impl<'input> Import_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_nameContextExt { ph: PhantomData }))
    }
}

pub trait Import_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_nameContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Import_nameContextAttrs<'input> for Import_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_name(&mut self) -> Result<Rc<Import_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_import_name);
        let mut _localctx: Rc<Import_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(329);
                recog.identifier()?;

                recog.base.set_state(334);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(14, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(330);
                                _la = recog.base.input.la(1);
                                if { !(_la == DOT || _la == OP_PROPORTION) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                }
                                else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /* InvokeRule identifier */
                                recog.base.set_state(331);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(336);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(14, &mut recog.base)?;
                }
                {
                    recog.base.set_state(337);
                    _la = recog.base.input.la(1);
                    if { !(_la == DOT || _la == OP_PROPORTION) } {
                        recog.err_handler.recover_inline(&mut recog.base)?;
                    }
                    else {
                        if recog.base.input.la(1) == TOKEN_EOF {
                            recog.base.matched_eof = true
                        };
                        recog.err_handler.report_match(&mut recog.base);
                        recog.base.consume(&mut recog.err_handler);
                    }
                    {
                        recog.base.set_state(338);
                        recog.base.match_token(OP_MUL, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_block ----------------
pub type Import_blockContextAll<'input> = Import_blockContext<'input>;

pub type Import_blockContext<'input> = BaseParserRuleContext<'input, Import_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Import_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_block }
}
antlr_rust::tid! {Import_blockContextExt<'a>}

impl<'input> Import_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_blockContextExt { ph: PhantomData }))
    }
}

pub trait Import_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn import_term_all(&self) -> Vec<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn import_term(&self, i: usize) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Import_blockContextAttrs<'input> for Import_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_block(&mut self) -> Result<Rc<Import_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_import_block);
        let mut _localctx: Rc<Import_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(350);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(16, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(340);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(341);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(342);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(346);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_AT
                            || _la == OP_HASH
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                {
                                    /* InvokeRule import_term */
                                    recog.base.set_state(343);
                                    recog.import_term()?;
                                }
                            }
                            recog.base.set_state(348);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(349);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extension ----------------
pub type Define_extensionContextAll<'input> = Define_extensionContext<'input>;

pub type Define_extensionContext<'input> = BaseParserRuleContext<'input, Define_extensionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extensionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extensionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extensionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extension(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extension(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extensionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extension(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extensionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extension
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extension }
}
antlr_rust::tid! {Define_extensionContextExt<'a>}

impl<'input> Define_extensionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extensionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extensionContextExt { ph: PhantomData }))
    }
}

pub trait Define_extensionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extensionContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_EXTENSION
    /// Returns `None` if there is no child corresponding to token KW_EXTENSION
    fn KW_EXTENSION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENSION, 0)
    }
}

impl<'input> Define_extensionContextAttrs<'input> for Define_extensionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extension(&mut self) -> Result<Rc<Define_extensionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extensionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_define_extension);
        let mut _localctx: Rc<Define_extensionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(352);
                recog.base.match_token(KW_EXTENSION, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_class ----------------
pub type Define_classContextAll<'input> = Define_classContext<'input>;

pub type Define_classContext<'input> = BaseParserRuleContext<'input, Define_classContextExt<'input>>;

#[derive(Clone)]
pub struct Define_classContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_classContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_classContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_class(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_class(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_classContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_class(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_classContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_class
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_class }
}
antlr_rust::tid! {Define_classContextExt<'a>}

impl<'input> Define_classContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_classContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_classContextExt { ph: PhantomData }))
    }
}

pub trait Define_classContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_classContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CLASS
    /// Returns `None` if there is no child corresponding to token KW_CLASS
    fn KW_CLASS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CLASS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_classContextAttrs<'input> for Define_classContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_class(&mut self) -> Result<Rc<Define_classContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_classContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_define_class);
        let mut _localctx: Rc<Define_classContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(355);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(17, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(354);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(360);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(357);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(362);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(363);
                recog.modifiers()?;

                recog.base.set_state(364);
                recog.base.match_token(KW_CLASS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(365);
                recog.identifier()?;

                recog.base.set_state(367);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(366);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(370);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(369);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(373);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(372);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(375);
                recog.class_block()?;

                recog.base.set_state(377);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(22, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(376);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_block ----------------
pub type Class_blockContextAll<'input> = Class_blockContext<'input>;

pub type Class_blockContext<'input> = BaseParserRuleContext<'input, Class_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Class_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_block }
}
antlr_rust::tid! {Class_blockContextExt<'a>}

impl<'input> Class_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_blockContextExt { ph: PhantomData }))
    }
}

pub trait Class_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_dsl_all(&self) -> Vec<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_dsl(&self, i: usize) -> Option<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_blockContextAttrs<'input> for Class_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_block(&mut self) -> Result<Rc<Class_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_class_block);
        let mut _localctx: Rc<Class_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(379);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(386);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(384);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(23, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_dsl */
                                    recog.base.set_state(380);
                                    recog.class_dsl()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(381);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(382);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(383);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(388);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(389);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit ----------------
pub type Class_inheritContextAll<'input> = Class_inheritContext<'input>;

pub type Class_inheritContext<'input> = BaseParserRuleContext<'input, Class_inheritContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inheritContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inheritContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inheritContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inheritContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inheritContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit }
}
antlr_rust::tid! {Class_inheritContextExt<'a>}

impl<'input> Class_inheritContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inheritContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inheritContextExt { ph: PhantomData }))
    }
}

pub trait Class_inheritContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inheritContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn class_inherit_item_all(&self) -> Vec<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_inherit_item(&self, i: usize) -> Option<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Class_inheritContextAttrs<'input> for Class_inheritContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit(&mut self) -> Result<Rc<Class_inheritContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inheritContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_class_inherit);
        let mut _localctx: Rc<Class_inheritContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(407);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(27, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(391);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(392);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(393);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule class_inherit_item */
                        recog.base.set_state(394);
                        recog.class_inherit_item()?;

                        recog.base.set_state(399);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(25, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(395);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule class_inherit_item */
                                        recog.base.set_state(396);
                                        recog.class_inherit_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(401);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(25, &mut recog.base)?;
                        }
                        recog.base.set_state(403);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(402);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(405);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit_item ----------------
pub type Class_inherit_itemContextAll<'input> = Class_inherit_itemContext<'input>;

pub type Class_inherit_itemContext<'input> = BaseParserRuleContext<'input, Class_inherit_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inherit_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inherit_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inherit_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit_item }
}
antlr_rust::tid! {Class_inherit_itemContextExt<'a>}

impl<'input> Class_inherit_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inherit_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inherit_itemContextExt { ph: PhantomData }))
    }
}

pub trait Class_inherit_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inherit_itemContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_inherit_itemContextAttrs<'input> for Class_inherit_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit_item(&mut self) -> Result<Rc<Class_inherit_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inherit_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_class_inherit_item);
        let mut _localctx: Rc<Class_inherit_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_namepath */
                recog.base.set_state(409);
                recog.modified_namepath()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_field ----------------
pub type Class_fieldContextAll<'input> = Class_fieldContext<'input>;

pub type Class_fieldContext<'input> = BaseParserRuleContext<'input, Class_fieldContextExt<'input>>;

#[derive(Clone)]
pub struct Class_fieldContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_fieldContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_fieldContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_field(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_field(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_fieldContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_field(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_fieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_field
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_field }
}
antlr_rust::tid! {Class_fieldContextExt<'a>}

impl<'input> Class_fieldContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_fieldContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_fieldContextExt { ph: PhantomData }))
    }
}

pub trait Class_fieldContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_fieldContextExt<'input>>
{
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_fieldContextAttrs<'input> for Class_fieldContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_field(&mut self) -> Result<Rc<Class_fieldContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_fieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_class_field);
        let mut _localctx: Rc<Class_fieldContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(414);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(411);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(416);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(417);
                recog.modified_identifier()?;

                recog.base.set_state(419);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(418);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(422);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        /* InvokeRule parameter_default */
                        recog.base.set_state(421);
                        recog.parameter_default()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_method ----------------
pub type Class_methodContextAll<'input> = Class_methodContext<'input>;

pub type Class_methodContext<'input> = BaseParserRuleContext<'input, Class_methodContextExt<'input>>;

#[derive(Clone)]
pub struct Class_methodContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_methodContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_methodContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_method(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_method(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_methodContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_method(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_methodContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_method
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_method }
}
antlr_rust::tid! {Class_methodContextExt<'a>}

impl<'input> Class_methodContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_methodContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_methodContextExt { ph: PhantomData }))
    }
}

pub trait Class_methodContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_methodContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn return_type(&self) -> Option<Rc<Return_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_methodContextAttrs<'input> for Class_methodContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_method(&mut self) -> Result<Rc<Class_methodContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_methodContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_class_method);
        let mut _localctx: Rc<Class_methodContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(427);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(424);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(429);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_namepath */
                recog.base.set_state(430);
                recog.modified_namepath()?;

                recog.base.set_state(432);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(431);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(434);
                recog.function_parameters()?;

                recog.base.set_state(436);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_DIV || _la == OP_ARROW {
                    {
                        /* InvokeRule return_type */
                        recog.base.set_state(435);
                        recog.return_type()?;
                    }
                }

                recog.base.set_state(439);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule function_block */
                        recog.base.set_state(438);
                        recog.function_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_dsl ----------------
pub type Class_dslContextAll<'input> = Class_dslContext<'input>;

pub type Class_dslContext<'input> = BaseParserRuleContext<'input, Class_dslContextExt<'input>>;

#[derive(Clone)]
pub struct Class_dslContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_dslContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_dslContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_dsl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_dsl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_dslContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_dsl(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_dslContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_dsl
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_dsl }
}
antlr_rust::tid! {Class_dslContextExt<'a>}

impl<'input> Class_dslContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_dslContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_dslContextExt { ph: PhantomData }))
    }
}

pub trait Class_dslContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Class_dslContextExt<'input>> {
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_dslContextAttrs<'input> for Class_dslContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_dsl(&mut self) -> Result<Rc<Class_dslContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_dslContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_class_dsl);
        let mut _localctx: Rc<Class_dslContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(444);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(441);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(446);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(447);
                recog.modified_identifier()?;

                /* InvokeRule class_block */
                recog.base.set_state(448);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait ----------------
pub type Define_traitContextAll<'input> = Define_traitContext<'input>;

pub type Define_traitContext<'input> = BaseParserRuleContext<'input, Define_traitContextExt<'input>>;

#[derive(Clone)]
pub struct Define_traitContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_traitContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_traitContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_traitContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_traitContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait }
}
antlr_rust::tid! {Define_traitContextExt<'a>}

impl<'input> Define_traitContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_traitContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_traitContextExt { ph: PhantomData }))
    }
}

pub trait Define_traitContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_traitContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TRAIT
    /// Returns `None` if there is no child corresponding to token KW_TRAIT
    fn KW_TRAIT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRAIT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn trait_block(&self) -> Option<Rc<Trait_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn with_implements(&self) -> Option<Rc<With_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_traitContextAttrs<'input> for Define_traitContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait(&mut self) -> Result<Rc<Define_traitContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_traitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_define_trait);
        let mut _localctx: Rc<Define_traitContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(451);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(36, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(450);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(456);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(453);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(458);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(459);
                recog.modifiers()?;

                recog.base.set_state(460);
                recog.base.match_token(KW_TRAIT, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(461);
                recog.identifier()?;

                recog.base.set_state(463);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(462);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(466);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule with_implements */
                        recog.base.set_state(465);
                        recog.with_implements()?;
                    }
                }

                /* InvokeRule trait_block */
                recog.base.set_state(468);
                recog.trait_block()?;

                recog.base.set_state(470);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(40, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(469);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- trait_block ----------------
pub type Trait_blockContextAll<'input> = Trait_blockContext<'input>;

pub type Trait_blockContext<'input> = BaseParserRuleContext<'input, Trait_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Trait_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Trait_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Trait_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_trait_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_trait_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Trait_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_trait_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Trait_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_trait_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_trait_block }
}
antlr_rust::tid! {Trait_blockContextExt<'a>}

impl<'input> Trait_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Trait_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Trait_blockContextExt { ph: PhantomData }))
    }
}

pub trait Trait_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Trait_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_trait_type_all(&self) -> Vec<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait_type(&self, i: usize) -> Option<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_dsl_all(&self) -> Vec<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_dsl(&self, i: usize) -> Option<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Trait_blockContextAttrs<'input> for Trait_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn trait_block(&mut self) -> Result<Rc<Trait_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Trait_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_trait_block);
        let mut _localctx: Rc<Trait_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(472);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(480);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == KW_TYPE
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(478);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(41, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_trait_type */
                                    recog.base.set_state(473);
                                    recog.define_trait_type()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(474);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(475);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule class_dsl */
                                    recog.base.set_state(476);
                                    recog.class_dsl()?;
                                }
                            }
                            5 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(477);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(482);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(483);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait_type ----------------
pub type Define_trait_typeContextAll<'input> = Define_trait_typeContext<'input>;

pub type Define_trait_typeContext<'input> = BaseParserRuleContext<'input, Define_trait_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_trait_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_trait_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_trait_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_trait_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_trait_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait_type }
}
antlr_rust::tid! {Define_trait_typeContextExt<'a>}

impl<'input> Define_trait_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_trait_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_trait_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_trait_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_trait_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_trait_typeContextAttrs<'input> for Define_trait_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait_type(&mut self) -> Result<Rc<Define_trait_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_trait_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_define_trait_type);
        let mut _localctx: Rc<Define_trait_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(485);
                recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(486);
                recog.identifier()?;

                recog.base.set_state(489);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(487);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(488);
                        recog.type_expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extends ----------------
pub type Define_extendsContextAll<'input> = Define_extendsContext<'input>;

pub type Define_extendsContext<'input> = BaseParserRuleContext<'input, Define_extendsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extendsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extendsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extendsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extends(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extends(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extendsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extends(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extendsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extends
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extends }
}
antlr_rust::tid! {Define_extendsContextExt<'a>}

impl<'input> Define_extendsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extendsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extendsContextExt { ph: PhantomData }))
    }
}

pub trait Define_extendsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extendsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_EXTENDS
    /// Returns `None` if there is no child corresponding to token KW_EXTENDS
    fn KW_EXTENDS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENDS, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn extends_block(&self) -> Option<Rc<Extends_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn with_implements(&self) -> Option<Rc<With_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_extendsContextAttrs<'input> for Define_extendsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extends(&mut self) -> Result<Rc<Define_extendsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extendsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_define_extends);
        let mut _localctx: Rc<Define_extendsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(492);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(44, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(491);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(497);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(494);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(499);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(500);
                recog.modifiers()?;

                recog.base.set_state(501);
                recog.base.match_token(KW_EXTENDS, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(502);
                recog.namepath()?;

                recog.base.set_state(504);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(503);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(507);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule with_implements */
                        recog.base.set_state(506);
                        recog.with_implements()?;
                    }
                }

                /* InvokeRule extends_block */
                recog.base.set_state(509);
                recog.extends_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- extends_block ----------------
pub type Extends_blockContextAll<'input> = Extends_blockContext<'input>;

pub type Extends_blockContext<'input> = BaseParserRuleContext<'input, Extends_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Extends_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Extends_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Extends_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_extends_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_extends_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Extends_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_extends_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Extends_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_extends_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_extends_block }
}
antlr_rust::tid! {Extends_blockContextExt<'a>}

impl<'input> Extends_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Extends_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Extends_blockContextExt { ph: PhantomData }))
    }
}

pub trait Extends_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Extends_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_trait_type_all(&self) -> Vec<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait_type(&self, i: usize) -> Option<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Extends_blockContextAttrs<'input> for Extends_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn extends_block(&mut self) -> Result<Rc<Extends_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Extends_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_extends_block);
        let mut _localctx: Rc<Extends_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(511);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(517);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == KW_TYPE
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(515);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            KW_TYPE => {
                                {
                                    /* InvokeRule define_trait_type */
                                    recog.base.set_state(512);
                                    recog.define_trait_type()?;
                                }
                            }

                            OP_HASH | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(513);
                                    recog.class_method()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(514);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(519);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(520);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- with_implements ----------------
pub type With_implementsContextAll<'input> = With_implementsContext<'input>;

pub type With_implementsContext<'input> = BaseParserRuleContext<'input, With_implementsContextExt<'input>>;

#[derive(Clone)]
pub struct With_implementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for With_implementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for With_implementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_with_implements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_with_implements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for With_implementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_with_implements(self);
    }
}

impl<'input> CustomRuleContext<'input> for With_implementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_with_implements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_with_implements }
}
antlr_rust::tid! {With_implementsContextExt<'a>}

impl<'input> With_implementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<With_implementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, With_implementsContextExt { ph: PhantomData }))
    }
}

pub trait With_implementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<With_implementsContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IMPLEMENTS
    /// Returns `None` if there is no child corresponding to token KW_IMPLEMENTS
    fn KW_IMPLEMENTS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPLEMENTS, 0)
    }
}

impl<'input> With_implementsContextAttrs<'input> for With_implementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn with_implements(&mut self) -> Result<Rc<With_implementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = With_implementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_with_implements);
        let mut _localctx: Rc<With_implementsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(522);
                _la = recog.base.input.la(1);
                if { !(_la == COLON || _la == KW_IMPLEMENTS) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                /* InvokeRule type_expression */
                recog.base.set_state(523);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_union ----------------
pub type Define_unionContextAll<'input> = Define_unionContext<'input>;

pub type Define_unionContext<'input> = BaseParserRuleContext<'input, Define_unionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_unionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_unionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_unionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_union(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_union(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_unionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_union(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_unionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_union
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_union }
}
antlr_rust::tid! {Define_unionContextExt<'a>}

impl<'input> Define_unionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_unionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_unionContextExt { ph: PhantomData }))
    }
}

pub trait Define_unionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_unionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_UNION
    /// Returns `None` if there is no child corresponding to token KW_UNION
    fn KW_UNION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_UNION, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn union_block(&self) -> Option<Rc<Union_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_unionContextAttrs<'input> for Define_unionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_union(&mut self) -> Result<Rc<Define_unionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_unionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_define_union);
        let mut _localctx: Rc<Define_unionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(526);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(50, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(525);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(531);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(528);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(533);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(534);
                recog.modifiers()?;

                recog.base.set_state(535);
                recog.base.match_token(KW_UNION, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(536);
                recog.identifier()?;

                recog.base.set_state(538);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(537);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(541);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(540);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(544);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(543);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule union_block */
                recog.base.set_state(546);
                recog.union_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- base_layout ----------------
pub type Base_layoutContextAll<'input> = Base_layoutContext<'input>;

pub type Base_layoutContext<'input> = BaseParserRuleContext<'input, Base_layoutContextExt<'input>>;

#[derive(Clone)]
pub struct Base_layoutContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Base_layoutContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Base_layoutContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_base_layout(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_base_layout(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Base_layoutContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_base_layout(self);
    }
}

impl<'input> CustomRuleContext<'input> for Base_layoutContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_base_layout
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_base_layout }
}
antlr_rust::tid! {Base_layoutContextExt<'a>}

impl<'input> Base_layoutContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Base_layoutContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Base_layoutContextExt { ph: PhantomData }))
    }
}

pub trait Base_layoutContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Base_layoutContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Base_layoutContextAttrs<'input> for Base_layoutContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn base_layout(&mut self) -> Result<Rc<Base_layoutContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Base_layoutContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_base_layout);
        let mut _localctx: Rc<Base_layoutContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(548);
                recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                recog.base.set_state(550);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << PARENTHESES_L) | (1usize << OP_ADD) | (1usize << OP_SUB) | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 58) & !0x3f) == 0
                        && ((1usize << (_la - 58))
                            & ((1usize << (OP_BANG - 58))
                                | (1usize << (OP_NOT - 58))
                                | (1usize << (OP_AND - 58))
                                | (1usize << (LAMBDA_SLOT - 58))))
                            != 0)
                    || (((_la - 93) & !0x3f) == 0
                        && ((1usize << (_la - 93))
                            & ((1usize << (OP_DOT3 - 93))
                                | (1usize << (OP_DOT2 - 93))
                                | (1usize << (OP_INVERSE - 93))
                                | (1usize << (OP_ROOT2 - 93))
                                | (1usize << (OP_ROOT3 - 93))
                                | (1usize << (OP_ROOT4 - 93))
                                | (1usize << (OP_PERCENT - 93))
                                | (1usize << (OP_REFERENCE - 93))
                                | (1usize << (OP_OUTPUT - 93))
                                | (1usize << (OP_LAST - 93))))
                            != 0)
                    || (((_la - 134) & !0x3f) == 0
                        && ((1usize << (_la - 134))
                            & ((1usize << (INTEGER - 134))
                                | (1usize << (DECIMAL - 134))
                                | (1usize << (STRING_START - 134))
                                | (1usize << (SPECIAL - 134))
                                | (1usize << (RAW_ID - 134))
                                | (1usize << (UNICODE_ID - 134))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(549);
                        recog.type_expression_rec(0)?;
                    }
                }

                recog.base.set_state(552);
                recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- union_block ----------------
pub type Union_blockContextAll<'input> = Union_blockContext<'input>;

pub type Union_blockContext<'input> = BaseParserRuleContext<'input, Union_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Union_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Union_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Union_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_union_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_union_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Union_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_union_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Union_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_union_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_union_block }
}
antlr_rust::tid! {Union_blockContextExt<'a>}

impl<'input> Union_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Union_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Union_blockContextExt { ph: PhantomData }))
    }
}

pub trait Union_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Union_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_variant_all(&self) -> Vec<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_variant(&self, i: usize) -> Option<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Union_blockContextAttrs<'input> for Union_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn union_block(&mut self) -> Result<Rc<Union_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Union_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_union_block);
        let mut _localctx: Rc<Union_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(554);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(560);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(558);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(56, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(555);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule define_variant */
                                    recog.base.set_state(556);
                                    recog.define_variant()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(557);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(562);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(563);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_variant ----------------
pub type Define_variantContextAll<'input> = Define_variantContext<'input>;

pub type Define_variantContext<'input> = BaseParserRuleContext<'input, Define_variantContextExt<'input>>;

#[derive(Clone)]
pub struct Define_variantContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_variantContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_variantContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_variant(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_variant(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_variantContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_variant(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_variantContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_variant
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_variant }
}
antlr_rust::tid! {Define_variantContextExt<'a>}

impl<'input> Define_variantContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_variantContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_variantContextExt { ph: PhantomData }))
    }
}

pub trait Define_variantContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_variantContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn variant_block(&self) -> Option<Rc<Variant_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_variantContextAttrs<'input> for Define_variantContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_variant(&mut self) -> Result<Rc<Define_variantContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_variantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_define_variant);
        let mut _localctx: Rc<Define_variantContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(565);
                recog.identifier()?;

                recog.base.set_state(567);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule variant_block */
                        recog.base.set_state(566);
                        recog.variant_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- variant_block ----------------
pub type Variant_blockContextAll<'input> = Variant_blockContext<'input>;

pub type Variant_blockContext<'input> = BaseParserRuleContext<'input, Variant_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Variant_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Variant_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Variant_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_variant_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_variant_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Variant_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_variant_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Variant_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_variant_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_variant_block }
}
antlr_rust::tid! {Variant_blockContextExt<'a>}

impl<'input> Variant_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Variant_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Variant_blockContextExt { ph: PhantomData }))
    }
}

pub trait Variant_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Variant_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Variant_blockContextAttrs<'input> for Variant_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn variant_block(&mut self) -> Result<Rc<Variant_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Variant_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_variant_block);
        let mut _localctx: Rc<Variant_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(569);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(574);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(572);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_HASH | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(570);
                                    recog.class_field()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(571);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(576);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(577);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_bitflags ----------------
pub type Define_bitflagsContextAll<'input> = Define_bitflagsContext<'input>;

pub type Define_bitflagsContext<'input> = BaseParserRuleContext<'input, Define_bitflagsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_bitflagsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_bitflagsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_bitflagsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_bitflags(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_bitflags(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_bitflagsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_bitflags(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_bitflagsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_bitflags
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_bitflags }
}
antlr_rust::tid! {Define_bitflagsContextExt<'a>}

impl<'input> Define_bitflagsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_bitflagsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_bitflagsContextExt { ph: PhantomData }))
    }
}

pub trait Define_bitflagsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_bitflagsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_BITFLAGS
    /// Returns `None` if there is no child corresponding to token KW_BITFLAGS
    fn KW_BITFLAGS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_BITFLAGS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn bitflags_block(&self) -> Option<Rc<Bitflags_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_bitflagsContextAttrs<'input> for Define_bitflagsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_bitflags(&mut self) -> Result<Rc<Define_bitflagsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_bitflagsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_define_bitflags);
        let mut _localctx: Rc<Define_bitflagsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(582);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(579);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(584);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(585);
                recog.modifiers()?;

                recog.base.set_state(586);
                recog.base.match_token(KW_BITFLAGS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(587);
                recog.identifier()?;

                recog.base.set_state(589);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(588);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(592);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(591);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule bitflags_block */
                recog.base.set_state(594);
                recog.bitflags_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_block ----------------
pub type Bitflags_blockContextAll<'input> = Bitflags_blockContext<'input>;

pub type Bitflags_blockContext<'input> = BaseParserRuleContext<'input, Bitflags_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_block }
}
antlr_rust::tid! {Bitflags_blockContextExt<'a>}

impl<'input> Bitflags_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_blockContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn bitflags_item_all(&self) -> Vec<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn bitflags_item(&self, i: usize) -> Option<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Bitflags_blockContextAttrs<'input> for Bitflags_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_block(&mut self) -> Result<Rc<Bitflags_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_bitflags_block);
        let mut _localctx: Rc<Bitflags_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(596);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(602);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(600);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(64, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(597);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule bitflags_item */
                                    recog.base.set_state(598);
                                    recog.bitflags_item()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(599);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(604);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(605);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_item ----------------
pub type Bitflags_itemContextAll<'input> = Bitflags_itemContext<'input>;

pub type Bitflags_itemContext<'input> = BaseParserRuleContext<'input, Bitflags_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_item }
}
antlr_rust::tid! {Bitflags_itemContextExt<'a>}

impl<'input> Bitflags_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_itemContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_itemContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Bitflags_itemContextAttrs<'input> for Bitflags_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_item(&mut self) -> Result<Rc<Bitflags_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_bitflags_item);
        let mut _localctx: Rc<Bitflags_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(610);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(607);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(612);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule identifier */
                recog.base.set_state(613);
                recog.identifier()?;

                recog.base.set_state(616);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(614);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(615);
                        recog.expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_function ----------------
pub type Define_functionContextAll<'input> = Define_functionContext<'input>;

pub type Define_functionContext<'input> = BaseParserRuleContext<'input, Define_functionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_functionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_functionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_functionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_function(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_function(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_functionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_function(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_functionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_function
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_function }
}
antlr_rust::tid! {Define_functionContextExt<'a>}

impl<'input> Define_functionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_functionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_functionContextExt { ph: PhantomData }))
    }
}

pub trait Define_functionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_functionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_FUNCTION
    /// Returns `None` if there is no child corresponding to token KW_FUNCTION
    fn KW_FUNCTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FUNCTION, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn return_type(&self) -> Option<Rc<Return_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_functionContextAttrs<'input> for Define_functionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_function(&mut self) -> Result<Rc<Define_functionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_functionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_define_function);
        let mut _localctx: Rc<Define_functionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(619);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(68, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(618);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(624);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(621);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(626);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(627);
                recog.modifiers()?;

                recog.base.set_state(628);
                recog.base.match_token(KW_FUNCTION, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(629);
                recog.namepath()?;

                recog.base.set_state(631);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(630);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(633);
                recog.function_parameters()?;

                recog.base.set_state(635);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_DIV || _la == OP_ARROW {
                    {
                        /* InvokeRule return_type */
                        recog.base.set_state(634);
                        recog.return_type()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(637);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_parameters ----------------
pub type Function_parametersContextAll<'input> = Function_parametersContext<'input>;

pub type Function_parametersContext<'input> = BaseParserRuleContext<'input, Function_parametersContextExt<'input>>;

#[derive(Clone)]
pub struct Function_parametersContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_parametersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_parametersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_parameters(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_parameters(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_parametersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_parameters(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_parametersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_parameters
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_parameters }
}
antlr_rust::tid! {Function_parametersContextExt<'a>}

impl<'input> Function_parametersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_parametersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Function_parametersContextExt { ph: PhantomData },
        ))
    }
}

pub trait Function_parametersContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_parametersContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn parameter_item_all(&self) -> Vec<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn parameter_item(&self, i: usize) -> Option<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Function_parametersContextAttrs<'input> for Function_parametersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_parameters(&mut self) -> Result<Rc<Function_parametersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_parametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_function_parameters);
        let mut _localctx: Rc<Function_parametersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(652);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(73, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(639);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(640);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(641);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule parameter_item */
                        recog.base.set_state(642);
                        recog.parameter_item()?;

                        recog.base.set_state(647);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(643);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule parameter_item */
                                    recog.base.set_state(644);
                                    recog.parameter_item()?;
                                }
                            }
                            recog.base.set_state(649);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(650);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_item ----------------
pub type Parameter_itemContextAll<'input> = Parameter_itemContext<'input>;

pub type Parameter_itemContext<'input> = BaseParserRuleContext<'input, Parameter_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_itemContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub id: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_item }
}
antlr_rust::tid! {Parameter_itemContextExt<'a>}

impl<'input> Parameter_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Parameter_itemContextExt { identifier: None, id: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Parameter_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_itemContextExt<'input>>
{
    fn parameter_special(&self) -> Option<Rc<Parameter_specialContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
}

impl<'input> Parameter_itemContextAttrs<'input> for Parameter_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_item(&mut self) -> Result<Rc<Parameter_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_parameter_item);
        let mut _localctx: Rc<Parameter_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(697);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(83, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(657);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(654);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(659);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(663);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == RAW_ID || _la == UNICODE_ID {
                            {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(660);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier = Some(tmp.clone());

                                    let temp = cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier.clone().unwrap();
                                    cast_mut::<_, Parameter_itemContext>(&mut _localctx).mods.push(temp);
                                }
                            }
                            recog.base.set_state(665);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule parameter_special */
                        recog.base.set_state(666);
                        recog.parameter_special()?;

                        recog.base.set_state(668);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(667);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Parameter_itemContext>(&mut _localctx).id = Some(tmp.clone());
                            }
                        }

                        recog.base.set_state(671);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON {
                            {
                                /* InvokeRule type_hint */
                                recog.base.set_state(670);
                                recog.type_hint()?;
                            }
                        }

                        recog.base.set_state(674);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_ASSIGN {
                            {
                                /* InvokeRule parameter_default */
                                recog.base.set_state(673);
                                recog.parameter_default()?;
                            }
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(679);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(676);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(681);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(685);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(80, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        /* InvokeRule identifier */
                                        recog.base.set_state(682);
                                        let tmp = recog.identifier()?;
                                        cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier = Some(tmp.clone());

                                        let temp =
                                            cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier.clone().unwrap();
                                        cast_mut::<_, Parameter_itemContext>(&mut _localctx).mods.push(temp);
                                    }
                                }
                            }
                            recog.base.set_state(687);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(80, &mut recog.base)?;
                        }
                        /* InvokeRule identifier */
                        recog.base.set_state(688);
                        let tmp = recog.identifier()?;
                        cast_mut::<_, Parameter_itemContext>(&mut _localctx).id = Some(tmp.clone());

                        recog.base.set_state(690);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON {
                            {
                                /* InvokeRule type_hint */
                                recog.base.set_state(689);
                                recog.type_hint()?;
                            }
                        }

                        recog.base.set_state(693);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_ASSIGN {
                            {
                                /* InvokeRule parameter_default */
                                recog.base.set_state(692);
                                recog.parameter_default()?;
                            }
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(695);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(696);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_special ----------------
#[derive(Debug)]
pub enum Parameter_specialContextAll<'input> {
    DictParametersContext(DictParametersContext<'input>),
    ListParametersContext(ListParametersContext<'input>),
    ContextParameterContext(ContextParameterContext<'input>),
    Error(Parameter_specialContext<'input>),
}
antlr_rust::tid! {Parameter_specialContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Parameter_specialContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_specialContextAll<'input> {}

impl<'input> Deref for Parameter_specialContextAll<'input> {
    type Target = dyn Parameter_specialContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Parameter_specialContextAll::*;
        match self {
            DictParametersContext(inner) => inner,
            ListParametersContext(inner) => inner,
            ContextParameterContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_specialContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_specialContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Parameter_specialContext<'input> = BaseParserRuleContext<'input, Parameter_specialContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_specialContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_specialContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_specialContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_specialContext<'input> {}

impl<'input> CustomRuleContext<'input> for Parameter_specialContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_special
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_special }
}
antlr_rust::tid! {Parameter_specialContextExt<'a>}

impl<'input> Parameter_specialContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_specialContextAll<'input>> {
        Rc::new(Parameter_specialContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Parameter_specialContextExt { ph: PhantomData },
        )))
    }
}

pub trait Parameter_specialContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_specialContextExt<'input>>
{
}

impl<'input> Parameter_specialContextAttrs<'input> for Parameter_specialContext<'input> {}

pub type DictParametersContext<'input> = BaseParserRuleContext<'input, DictParametersContextExt<'input>>;

pub trait DictParametersContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_DOT3
    /// Returns `None` if there is no child corresponding to token OP_DOT3
    fn OP_DOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT3, 0)
    }
}

impl<'input> DictParametersContextAttrs<'input> for DictParametersContext<'input> {}

pub struct DictParametersContextExt<'input> {
    base: Parameter_specialContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {DictParametersContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for DictParametersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for DictParametersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_DictParameters(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_DictParameters(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for DictParametersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_DictParameters(self);
    }
}

impl<'input> CustomRuleContext<'input> for DictParametersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_special
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_special }
}

impl<'input> Borrow<Parameter_specialContextExt<'input>> for DictParametersContext<'input> {
    fn borrow(&self) -> &Parameter_specialContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Parameter_specialContextExt<'input>> for DictParametersContext<'input> {
    fn borrow_mut(&mut self) -> &mut Parameter_specialContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Parameter_specialContextAttrs<'input> for DictParametersContext<'input> {}

impl<'input> DictParametersContextExt<'input> {
    fn new(ctx: &dyn Parameter_specialContextAttrs<'input>) -> Rc<Parameter_specialContextAll<'input>> {
        Rc::new(Parameter_specialContextAll::DictParametersContext(BaseParserRuleContext::copy_from(
            ctx,
            DictParametersContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ListParametersContext<'input> = BaseParserRuleContext<'input, ListParametersContextExt<'input>>;

pub trait ListParametersContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_DOT2
    /// Returns `None` if there is no child corresponding to token OP_DOT2
    fn OP_DOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT2, 0)
    }
}

impl<'input> ListParametersContextAttrs<'input> for ListParametersContext<'input> {}

pub struct ListParametersContextExt<'input> {
    base: Parameter_specialContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ListParametersContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ListParametersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ListParametersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ListParameters(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ListParameters(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ListParametersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ListParameters(self);
    }
}

impl<'input> CustomRuleContext<'input> for ListParametersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_special
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_special }
}

impl<'input> Borrow<Parameter_specialContextExt<'input>> for ListParametersContext<'input> {
    fn borrow(&self) -> &Parameter_specialContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Parameter_specialContextExt<'input>> for ListParametersContext<'input> {
    fn borrow_mut(&mut self) -> &mut Parameter_specialContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Parameter_specialContextAttrs<'input> for ListParametersContext<'input> {}

impl<'input> ListParametersContextExt<'input> {
    fn new(ctx: &dyn Parameter_specialContextAttrs<'input>) -> Rc<Parameter_specialContextAll<'input>> {
        Rc::new(Parameter_specialContextAll::ListParametersContext(BaseParserRuleContext::copy_from(
            ctx,
            ListParametersContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ContextParameterContext<'input> = BaseParserRuleContext<'input, ContextParameterContextExt<'input>>;

pub trait ContextParameterContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_POW
    /// Returns `None` if there is no child corresponding to token OP_POW
    fn OP_POW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_POW, 0)
    }
}

impl<'input> ContextParameterContextAttrs<'input> for ContextParameterContext<'input> {}

pub struct ContextParameterContextExt<'input> {
    base: Parameter_specialContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ContextParameterContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ContextParameterContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ContextParameterContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ContextParameter(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ContextParameter(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ContextParameterContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ContextParameter(self);
    }
}

impl<'input> CustomRuleContext<'input> for ContextParameterContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_special
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_special }
}

impl<'input> Borrow<Parameter_specialContextExt<'input>> for ContextParameterContext<'input> {
    fn borrow(&self) -> &Parameter_specialContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Parameter_specialContextExt<'input>> for ContextParameterContext<'input> {
    fn borrow_mut(&mut self) -> &mut Parameter_specialContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Parameter_specialContextAttrs<'input> for ContextParameterContext<'input> {}

impl<'input> ContextParameterContextExt<'input> {
    fn new(ctx: &dyn Parameter_specialContextAttrs<'input>) -> Rc<Parameter_specialContextAll<'input>> {
        Rc::new(Parameter_specialContextAll::ContextParameterContext(BaseParserRuleContext::copy_from(
            ctx,
            ContextParameterContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_special(&mut self) -> Result<Rc<Parameter_specialContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_specialContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_parameter_special);
        let mut _localctx: Rc<Parameter_specialContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(702);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_DOT3 => {
                    let tmp = DictParametersContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(699);
                        recog.base.match_token(OP_DOT3, &mut recog.err_handler)?;
                    }
                }

                OP_DOT2 => {
                    let tmp = ListParametersContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(700);
                        recog.base.match_token(OP_DOT2, &mut recog.err_handler)?;
                    }
                }

                OP_POW => {
                    let tmp = ContextParameterContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(701);
                        recog.base.match_token(OP_POW, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- return_type ----------------
pub type Return_typeContextAll<'input> = Return_typeContext<'input>;

pub type Return_typeContext<'input> = BaseParserRuleContext<'input, Return_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Return_typeContextExt<'input> {
    pub ret: Option<Rc<Type_expressionContextAll<'input>>>,
    pub type_expression: Option<Rc<Type_expressionContextAll<'input>>>,
    pub eff: Vec<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Return_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Return_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_return_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_return_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Return_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_return_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Return_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_return_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_return_type }
}
antlr_rust::tid! {Return_typeContextExt<'a>}

impl<'input> Return_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Return_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Return_typeContextExt { ret: None, type_expression: None, eff: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Return_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Return_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Return_typeContextAttrs<'input> for Return_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn return_type(&mut self) -> Result<Rc<Return_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Return_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_return_type);
        let mut _localctx: Rc<Return_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(732);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(90, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(704);
                        _la = recog.base.input.la(1);
                        if { !(_la == COLON || _la == OP_ARROW) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        /* InvokeRule type_expression */
                        recog.base.set_state(705);
                        let tmp = recog.type_expression_rec(0)?;
                        cast_mut::<_, Return_typeContext>(&mut _localctx).ret = Some(tmp.clone());
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(708);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON || _la == OP_ARROW {
                            {
                                recog.base.set_state(706);
                                _la = recog.base.input.la(1);
                                if { !(_la == COLON || _la == OP_ARROW) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                }
                                else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /* InvokeRule type_expression */
                                recog.base.set_state(707);
                                let tmp = recog.type_expression_rec(0)?;
                                cast_mut::<_, Return_typeContext>(&mut _localctx).ret = Some(tmp.clone());
                            }
                        }

                        recog.base.set_state(710);
                        recog.base.match_token(OP_DIV, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(711);
                        let tmp = recog.type_expression_rec(0)?;
                        cast_mut::<_, Return_typeContext>(&mut _localctx).type_expression = Some(tmp.clone());

                        let temp = cast_mut::<_, Return_typeContext>(&mut _localctx).type_expression.clone().unwrap();
                        cast_mut::<_, Return_typeContext>(&mut _localctx).eff.push(temp);
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(714);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON || _la == OP_ARROW {
                            {
                                recog.base.set_state(712);
                                _la = recog.base.input.la(1);
                                if { !(_la == COLON || _la == OP_ARROW) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                }
                                else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /* InvokeRule type_expression */
                                recog.base.set_state(713);
                                let tmp = recog.type_expression_rec(0)?;
                                cast_mut::<_, Return_typeContext>(&mut _localctx).ret = Some(tmp.clone());
                            }
                        }

                        recog.base.set_state(716);
                        recog.base.match_token(OP_DIV, &mut recog.err_handler)?;

                        recog.base.set_state(717);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(729);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << PARENTHESES_L) | (1usize << OP_ADD) | (1usize << OP_SUB) | (1usize << OP_MUL)))
                                != 0)
                            || (((_la - 58) & !0x3f) == 0
                                && ((1usize << (_la - 58))
                                    & ((1usize << (OP_BANG - 58))
                                        | (1usize << (OP_NOT - 58))
                                        | (1usize << (OP_AND - 58))
                                        | (1usize << (LAMBDA_SLOT - 58))))
                                    != 0)
                            || (((_la - 93) & !0x3f) == 0
                                && ((1usize << (_la - 93))
                                    & ((1usize << (OP_DOT3 - 93))
                                        | (1usize << (OP_DOT2 - 93))
                                        | (1usize << (OP_INVERSE - 93))
                                        | (1usize << (OP_ROOT2 - 93))
                                        | (1usize << (OP_ROOT3 - 93))
                                        | (1usize << (OP_ROOT4 - 93))
                                        | (1usize << (OP_PERCENT - 93))
                                        | (1usize << (OP_REFERENCE - 93))
                                        | (1usize << (OP_OUTPUT - 93))
                                        | (1usize << (OP_LAST - 93))))
                                    != 0)
                            || (((_la - 134) & !0x3f) == 0
                                && ((1usize << (_la - 134))
                                    & ((1usize << (INTEGER - 134))
                                        | (1usize << (DECIMAL - 134))
                                        | (1usize << (STRING_START - 134))
                                        | (1usize << (SPECIAL - 134))
                                        | (1usize << (RAW_ID - 134))
                                        | (1usize << (UNICODE_ID - 134))))
                                    != 0)
                        {
                            {
                                /* InvokeRule type_expression */
                                recog.base.set_state(718);
                                let tmp = recog.type_expression_rec(0)?;
                                cast_mut::<_, Return_typeContext>(&mut _localctx).type_expression = Some(tmp.clone());

                                let temp = cast_mut::<_, Return_typeContext>(&mut _localctx).type_expression.clone().unwrap();
                                cast_mut::<_, Return_typeContext>(&mut _localctx).eff.push(temp);

                                recog.base.set_state(723);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(87, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(719);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule type_expression */
                                                recog.base.set_state(720);
                                                let tmp = recog.type_expression_rec(0)?;
                                                cast_mut::<_, Return_typeContext>(&mut _localctx).type_expression =
                                                    Some(tmp.clone());

                                                let temp = cast_mut::<_, Return_typeContext>(&mut _localctx)
                                                    .type_expression
                                                    .clone()
                                                    .unwrap();
                                                cast_mut::<_, Return_typeContext>(&mut _localctx).eff.push(temp);
                                            }
                                        }
                                    }
                                    recog.base.set_state(725);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(87, &mut recog.base)?;
                                }
                                recog.base.set_state(727);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(726);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(731);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_default ----------------
pub type Parameter_defaultContextAll<'input> = Parameter_defaultContext<'input>;

pub type Parameter_defaultContext<'input> = BaseParserRuleContext<'input, Parameter_defaultContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_defaultContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_defaultContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_defaultContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_default(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_default(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_defaultContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_default(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_defaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_default
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_default }
}
antlr_rust::tid! {Parameter_defaultContextExt<'a>}

impl<'input> Parameter_defaultContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_defaultContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Parameter_defaultContextExt { ph: PhantomData }))
    }
}

pub trait Parameter_defaultContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_defaultContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Parameter_defaultContextAttrs<'input> for Parameter_defaultContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_default(&mut self) -> Result<Rc<Parameter_defaultContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_defaultContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_parameter_default);
        let mut _localctx: Rc<Parameter_defaultContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(734);
                recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                /* InvokeRule expression */
                recog.base.set_state(735);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_call ----------------
pub type Function_callContextAll<'input> = Function_callContext<'input>;

pub type Function_callContext<'input> = BaseParserRuleContext<'input, Function_callContextExt<'input>>;

#[derive(Clone)]
pub struct Function_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_call }
}
antlr_rust::tid! {Function_callContextExt<'a>}

impl<'input> Function_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_callContextExt { ph: PhantomData }))
    }
}

pub trait Function_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_callContextExt<'input>>
{
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
}

impl<'input> Function_callContextAttrs<'input> for Function_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_call(&mut self) -> Result<Rc<Function_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_function_call);
        let mut _localctx: Rc<Function_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(760);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(97, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(738);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(737);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(740);
                        recog.tuple_call_body()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(742);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(741);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(744);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(745);
                        recog.base.match_token(INTEGER, &mut recog.err_handler)?;

                        recog.base.set_state(747);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(93, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(746);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(750);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(749);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(752);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(754);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AT {
                            {
                                recog.base.set_state(753);
                                recog.base.match_token(OP_AT, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule identifier */
                        recog.base.set_state(756);
                        recog.identifier()?;

                        recog.base.set_state(758);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(96, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(757);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- closure_call ----------------
#[derive(Debug)]
pub enum Closure_callContextAll<'input> {
    SlotClosureContext(SlotClosureContext<'input>),
    IntegerClosureContext(IntegerClosureContext<'input>),
    InternalClosureContext(InternalClosureContext<'input>),
    NormalClosureContext(NormalClosureContext<'input>),
    Error(Closure_callContext<'input>),
}
antlr_rust::tid! {Closure_callContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Closure_callContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Closure_callContextAll<'input> {}

impl<'input> Deref for Closure_callContextAll<'input> {
    type Target = dyn Closure_callContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Closure_callContextAll::*;
        match self {
            SlotClosureContext(inner) => inner,
            IntegerClosureContext(inner) => inner,
            InternalClosureContext(inner) => inner,
            NormalClosureContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Closure_callContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Closure_callContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Closure_callContext<'input> = BaseParserRuleContext<'input, Closure_callContextExt<'input>>;

#[derive(Clone)]
pub struct Closure_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Closure_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Closure_callContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Closure_callContext<'input> {}

impl<'input> CustomRuleContext<'input> for Closure_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_closure_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_closure_call }
}
antlr_rust::tid! {Closure_callContextExt<'a>}

impl<'input> Closure_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Closure_callContextAll<'input>> {
        Rc::new(Closure_callContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Closure_callContextExt { ph: PhantomData },
        )))
    }
}

pub trait Closure_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Closure_callContextExt<'input>>
{
}

impl<'input> Closure_callContextAttrs<'input> for Closure_callContext<'input> {}

pub type SlotClosureContext<'input> = BaseParserRuleContext<'input, SlotClosureContextExt<'input>>;

pub trait SlotClosureContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
}

impl<'input> SlotClosureContextAttrs<'input> for SlotClosureContext<'input> {}

pub struct SlotClosureContextExt<'input> {
    base: Closure_callContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {SlotClosureContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for SlotClosureContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for SlotClosureContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_SlotClosure(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_SlotClosure(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for SlotClosureContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_SlotClosure(self);
    }
}

impl<'input> CustomRuleContext<'input> for SlotClosureContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_closure_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_closure_call }
}

impl<'input> Borrow<Closure_callContextExt<'input>> for SlotClosureContext<'input> {
    fn borrow(&self) -> &Closure_callContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Closure_callContextExt<'input>> for SlotClosureContext<'input> {
    fn borrow_mut(&mut self) -> &mut Closure_callContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Closure_callContextAttrs<'input> for SlotClosureContext<'input> {}

impl<'input> SlotClosureContextExt<'input> {
    fn new(ctx: &dyn Closure_callContextAttrs<'input>) -> Rc<Closure_callContextAll<'input>> {
        Rc::new(Closure_callContextAll::SlotClosureContext(BaseParserRuleContext::copy_from(
            ctx,
            SlotClosureContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IntegerClosureContext<'input> = BaseParserRuleContext<'input, IntegerClosureContextExt<'input>>;

pub trait IntegerClosureContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IntegerClosureContextAttrs<'input> for IntegerClosureContext<'input> {}

pub struct IntegerClosureContextExt<'input> {
    base: Closure_callContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IntegerClosureContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IntegerClosureContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IntegerClosureContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IntegerClosure(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IntegerClosure(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IntegerClosureContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IntegerClosure(self);
    }
}

impl<'input> CustomRuleContext<'input> for IntegerClosureContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_closure_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_closure_call }
}

impl<'input> Borrow<Closure_callContextExt<'input>> for IntegerClosureContext<'input> {
    fn borrow(&self) -> &Closure_callContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Closure_callContextExt<'input>> for IntegerClosureContext<'input> {
    fn borrow_mut(&mut self) -> &mut Closure_callContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Closure_callContextAttrs<'input> for IntegerClosureContext<'input> {}

impl<'input> IntegerClosureContextExt<'input> {
    fn new(ctx: &dyn Closure_callContextAttrs<'input>) -> Rc<Closure_callContextAll<'input>> {
        Rc::new(Closure_callContextAll::IntegerClosureContext(BaseParserRuleContext::copy_from(
            ctx,
            IntegerClosureContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type InternalClosureContext<'input> = BaseParserRuleContext<'input, InternalClosureContextExt<'input>>;

pub trait InternalClosureContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> InternalClosureContextAttrs<'input> for InternalClosureContext<'input> {}

pub struct InternalClosureContextExt<'input> {
    base: Closure_callContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {InternalClosureContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for InternalClosureContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for InternalClosureContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_InternalClosure(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_InternalClosure(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for InternalClosureContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_InternalClosure(self);
    }
}

impl<'input> CustomRuleContext<'input> for InternalClosureContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_closure_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_closure_call }
}

impl<'input> Borrow<Closure_callContextExt<'input>> for InternalClosureContext<'input> {
    fn borrow(&self) -> &Closure_callContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Closure_callContextExt<'input>> for InternalClosureContext<'input> {
    fn borrow_mut(&mut self) -> &mut Closure_callContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Closure_callContextAttrs<'input> for InternalClosureContext<'input> {}

impl<'input> InternalClosureContextExt<'input> {
    fn new(ctx: &dyn Closure_callContextAttrs<'input>) -> Rc<Closure_callContextAll<'input>> {
        Rc::new(Closure_callContextAll::InternalClosureContext(BaseParserRuleContext::copy_from(
            ctx,
            InternalClosureContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type NormalClosureContext<'input> = BaseParserRuleContext<'input, NormalClosureContextExt<'input>>;

pub trait NormalClosureContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
}

impl<'input> NormalClosureContextAttrs<'input> for NormalClosureContext<'input> {}

pub struct NormalClosureContextExt<'input> {
    base: Closure_callContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NormalClosureContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for NormalClosureContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NormalClosureContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_NormalClosure(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_NormalClosure(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NormalClosureContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_NormalClosure(self);
    }
}

impl<'input> CustomRuleContext<'input> for NormalClosureContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_closure_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_closure_call }
}

impl<'input> Borrow<Closure_callContextExt<'input>> for NormalClosureContext<'input> {
    fn borrow(&self) -> &Closure_callContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Closure_callContextExt<'input>> for NormalClosureContext<'input> {
    fn borrow_mut(&mut self) -> &mut Closure_callContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Closure_callContextAttrs<'input> for NormalClosureContext<'input> {}

impl<'input> NormalClosureContextExt<'input> {
    fn new(ctx: &dyn Closure_callContextAttrs<'input>) -> Rc<Closure_callContextAll<'input>> {
        Rc::new(Closure_callContextAll::NormalClosureContext(BaseParserRuleContext::copy_from(
            ctx,
            NormalClosureContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn closure_call(&mut self) -> Result<Rc<Closure_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Closure_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_closure_call);
        let mut _localctx: Rc<Closure_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(802);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(109, &mut recog.base)? {
                1 => {
                    let tmp = NormalClosureContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(763);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(762);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(770);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            BRACE_L => {
                                {
                                    /* InvokeRule function_block */
                                    recog.base.set_state(765);
                                    recog.function_block()?;
                                }
                            }

                            PARENTHESES_L => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(766);
                                    recog.tuple_call_body()?;

                                    recog.base.set_state(768);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    match recog.interpreter.adaptive_predict(99, &mut recog.base)? {
                                        x if x == 1 => {
                                            {
                                                /* InvokeRule function_block */
                                                recog.base.set_state(767);
                                                recog.function_block()?;
                                            }
                                        }

                                        _ => {}
                                    }
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                2 => {
                    let tmp = SlotClosureContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(773);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(772);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(775);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(776);
                        recog.function_block()?;
                    }
                }
                3 => {
                    let tmp = IntegerClosureContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(778);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(777);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(780);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(781);
                        recog.base.match_token(INTEGER, &mut recog.err_handler)?;

                        recog.base.set_state(783);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(103, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(782);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(786);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(104, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule function_block */
                                    recog.base.set_state(785);
                                    recog.function_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    let tmp = InternalClosureContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(789);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(788);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(791);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(793);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AT {
                            {
                                recog.base.set_state(792);
                                recog.base.match_token(OP_AT, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule identifier */
                        recog.base.set_state(795);
                        recog.identifier()?;

                        recog.base.set_state(797);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(107, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(796);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(800);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(108, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule function_block */
                                    recog.base.set_state(799);
                                    recog.function_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_body ----------------
pub type Tuple_call_bodyContextAll<'input> = Tuple_call_bodyContext<'input>;

pub type Tuple_call_bodyContext<'input> = BaseParserRuleContext<'input, Tuple_call_bodyContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_bodyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_body(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_body(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_body(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_bodyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_body
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_body }
}
antlr_rust::tid! {Tuple_call_bodyContextExt<'a>}

impl<'input> Tuple_call_bodyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_bodyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_call_bodyContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_call_bodyContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_bodyContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn tuple_call_item_all(&self) -> Vec<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tuple_call_item(&self, i: usize) -> Option<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Tuple_call_bodyContextAttrs<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_body(&mut self) -> Result<Rc<Tuple_call_bodyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_bodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_tuple_call_body);
        let mut _localctx: Rc<Tuple_call_bodyContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(820);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(112, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(804);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(805);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(806);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule tuple_call_item */
                        recog.base.set_state(807);
                        recog.tuple_call_item()?;

                        recog.base.set_state(812);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(110, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(808);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule tuple_call_item */
                                        recog.base.set_state(809);
                                        recog.tuple_call_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(814);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(110, &mut recog.base)?;
                        }
                        recog.base.set_state(816);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(815);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(818);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_item ----------------
pub type Tuple_call_itemContextAll<'input> = Tuple_call_itemContext<'input>;

pub type Tuple_call_itemContext<'input> = BaseParserRuleContext<'input, Tuple_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_itemContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub field: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_item }
}
antlr_rust::tid! {Tuple_call_itemContextExt<'a>}

impl<'input> Tuple_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Tuple_call_itemContextExt { identifier: None, field: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Tuple_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_itemContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Tuple_call_itemContextAttrs<'input> for Tuple_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_item(&mut self) -> Result<Rc<Tuple_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_tuple_call_item);
        let mut _localctx: Rc<Tuple_call_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(845);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(116, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(825);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(822);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(827);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(831);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(114, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        /* InvokeRule identifier */
                                        recog.base.set_state(828);
                                        let tmp = recog.identifier()?;
                                        cast_mut::<_, Tuple_call_itemContext>(&mut _localctx).identifier = Some(tmp.clone());

                                        let temp =
                                            cast_mut::<_, Tuple_call_itemContext>(&mut _localctx).identifier.clone().unwrap();
                                        cast_mut::<_, Tuple_call_itemContext>(&mut _localctx).mods.push(temp);
                                    }
                                }
                            }
                            recog.base.set_state(833);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(114, &mut recog.base)?;
                        }
                        /* InvokeRule identifier */
                        recog.base.set_state(834);
                        let tmp = recog.identifier()?;
                        cast_mut::<_, Tuple_call_itemContext>(&mut _localctx).field = Some(tmp.clone());

                        recog.base.set_state(835);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(836);
                        recog.expression_rec(0)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(841);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(115, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        /* InvokeRule annotation */
                                        recog.base.set_state(838);
                                        recog.annotation()?;
                                    }
                                }
                            }
                            recog.base.set_state(843);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(115, &mut recog.base)?;
                        }
                        /* InvokeRule expression */
                        recog.base.set_state(844);
                        recog.expression_rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_lambda ----------------
pub type Define_lambdaContextAll<'input> = Define_lambdaContext<'input>;

pub type Define_lambdaContext<'input> = BaseParserRuleContext<'input, Define_lambdaContextExt<'input>>;

#[derive(Clone)]
pub struct Define_lambdaContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_lambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_lambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_lambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_lambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_lambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_lambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_lambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_lambda
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_lambda }
}
antlr_rust::tid! {Define_lambdaContextExt<'a>}

impl<'input> Define_lambdaContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_lambdaContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_lambdaContextExt { ph: PhantomData }))
    }
}

pub trait Define_lambdaContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_lambdaContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LAMBDA
    /// Returns `None` if there is no child corresponding to token KW_LAMBDA
    fn KW_LAMBDA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LAMBDA, 0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn return_type(&self) -> Option<Rc<Return_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_lambdaContextAttrs<'input> for Define_lambdaContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_lambda(&mut self) -> Result<Rc<Define_lambdaContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_lambdaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_define_lambda);
        let mut _localctx: Rc<Define_lambdaContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(850);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(847);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(852);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(853);
                recog.base.match_token(KW_LAMBDA, &mut recog.err_handler)?;

                /* InvokeRule function_parameters */
                recog.base.set_state(854);
                recog.function_parameters()?;

                recog.base.set_state(856);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_DIV || _la == OP_ARROW {
                    {
                        /* InvokeRule return_type */
                        recog.base.set_state(855);
                        recog.return_type()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(858);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_block ----------------
pub type Function_blockContextAll<'input> = Function_blockContext<'input>;

pub type Function_blockContext<'input> = BaseParserRuleContext<'input, Function_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Function_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_block }
}
antlr_rust::tid! {Function_blockContextExt<'a>}

impl<'input> Function_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_blockContextExt { ph: PhantomData }))
    }
}

pub trait Function_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_type_all(&self) -> Vec<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_type(&self, i: usize) -> Option<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn let_binding_all(&self) -> Vec<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_binding(&self, i: usize) -> Option<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn loop_statement_all(&self) -> Vec<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn loop_statement(&self, i: usize) -> Option<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn guard_statement_all(&self) -> Vec<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn guard_statement(&self, i: usize) -> Option<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn expression_root_all(&self) -> Vec<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression_root(&self, i: usize) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_all(&self) -> Vec<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos(&self, i: usize) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Function_blockContextAttrs<'input> for Function_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_block(&mut self) -> Result<Rc<Function_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_function_block);
        let mut _localctx: Rc<Function_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(860);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(869);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << SEMICOLON)
                            | (1usize << FAKE_COLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << BRACE_L)
                            | (1usize << OFFSET_L)
                            | (1usize << CEILING_L)
                            | (1usize << FLOOR_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 58) & !0x3f) == 0
                        && ((1usize << (_la - 58))
                            & ((1usize << (OP_BANG - 58))
                                | (1usize << (OP_NOT - 58))
                                | (1usize << (OP_AND - 58))
                                | (1usize << (OP_AT - 58))
                                | (1usize << (OP_HASH - 58))
                                | (1usize << (LAMBDA_SLOT - 58))))
                            != 0)
                    || (((_la - 93) & !0x3f) == 0
                        && ((1usize << (_la - 93))
                            & ((1usize << (OP_DOT3 - 93))
                                | (1usize << (OP_DOT2 - 93))
                                | (1usize << (OP_INVERSE - 93))
                                | (1usize << (OP_ROOT2 - 93))
                                | (1usize << (OP_ROOT3 - 93))
                                | (1usize << (OP_ROOT4 - 93))
                                | (1usize << (OP_PERCENT - 93))
                                | (1usize << (OP_REFERENCE - 93))
                                | (1usize << (OP_LABEL - 93))
                                | (1usize << (OP_OUTPUT - 93))
                                | (1usize << (OP_LAST - 93))
                                | (1usize << (KW_TYPE - 93))
                                | (1usize << (KW_WHILE - 93))
                                | (1usize << (KW_FOR - 93))
                                | (1usize << (KW_LET - 93))
                                | (1usize << (KW_NEW - 93))
                                | (1usize << (KW_OBJECT - 93))))
                            != 0)
                    || (((_la - 125) & !0x3f) == 0
                        && ((1usize << (_la - 125))
                            & ((1usize << (KW_LAMBDA - 125))
                                | (1usize << (KW_TRY - 125))
                                | (1usize << (KW_MATCH - 125))
                                | (1usize << (KW_CATCH - 125))
                                | (1usize << (INTEGER - 125))
                                | (1usize << (DECIMAL - 125))
                                | (1usize << (STRING_START - 125))
                                | (1usize << (KW_IF - 125))
                                | (1usize << (RETURN - 125))
                                | (1usize << (RESUME - 125))
                                | (1usize << (YIELD - 125))
                                | (1usize << (BREAK - 125))
                                | (1usize << (CONTINUE - 125))
                                | (1usize << (FALL_THROUGH - 125))
                                | (1usize << (RAISE - 125))
                                | (1usize << (SPECIAL - 125))
                                | (1usize << (RAW_ID - 125))
                                | (1usize << (UNICODE_ID - 125))))
                            != 0)
                {
                    {
                        recog.base.set_state(867);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(119, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_type */
                                    recog.base.set_state(861);
                                    recog.define_type()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule let_binding */
                                    recog.base.set_state(862);
                                    recog.let_binding()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule loop_statement */
                                    recog.base.set_state(863);
                                    recog.loop_statement()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule guard_statement */
                                    recog.base.set_state(864);
                                    recog.guard_statement()?;
                                }
                            }
                            5 => {
                                {
                                    /* InvokeRule expression_root */
                                    recog.base.set_state(865);
                                    recog.expression_root()?;
                                }
                            }
                            6 => {
                                {
                                    /* InvokeRule eos */
                                    recog.base.set_state(866);
                                    recog.eos()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(871);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(872);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_binding ----------------
pub type Let_bindingContextAll<'input> = Let_bindingContext<'input>;

pub type Let_bindingContext<'input> = BaseParserRuleContext<'input, Let_bindingContextExt<'input>>;

#[derive(Clone)]
pub struct Let_bindingContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_bindingContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_bindingContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_binding(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_binding(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_bindingContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_binding(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_bindingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_binding
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_binding }
}
antlr_rust::tid! {Let_bindingContextExt<'a>}

impl<'input> Let_bindingContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_bindingContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_bindingContextExt { ph: PhantomData }))
    }
}

pub trait Let_bindingContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_bindingContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression_root(&self) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Let_bindingContextAttrs<'input> for Let_bindingContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_binding(&mut self) -> Result<Rc<Let_bindingContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_bindingContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_let_binding);
        let mut _localctx: Rc<Let_bindingContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(877);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(874);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(879);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(880);
                recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                /* InvokeRule let_pattern */
                recog.base.set_state(881);
                recog.let_pattern()?;

                recog.base.set_state(883);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(882);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(887);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(885);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression_root */
                        recog.base.set_state(886);
                        recog.expression_root()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern ----------------
pub type Let_patternContextAll<'input> = Let_patternContext<'input>;

pub type Let_patternContext<'input> = BaseParserRuleContext<'input, Let_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Let_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern }
}
antlr_rust::tid! {Let_patternContextExt<'a>}

impl<'input> Let_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_patternContextExt { ph: PhantomData }))
    }
}

pub trait Let_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_patternContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_plain(&self) -> Option<Rc<Let_pattern_plainContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Let_patternContextAttrs<'input> for Let_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern(&mut self) -> Result<Rc<Let_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_let_pattern);
        let mut _localctx: Rc<Let_patternContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(891);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(124, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(889);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule let_pattern_plain */
                        recog.base.set_state(890);
                        recog.let_pattern_plain()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_plain ----------------
pub type Let_pattern_plainContextAll<'input> = Let_pattern_plainContext<'input>;

pub type Let_pattern_plainContext<'input> = BaseParserRuleContext<'input, Let_pattern_plainContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_plainContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_plainContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_plain(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_plain(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_plain(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_plainContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_plain
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_plain }
}
antlr_rust::tid! {Let_pattern_plainContextExt<'a>}

impl<'input> Let_pattern_plainContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_plainContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_plainContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_plainContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_plainContextExt<'input>>
{
    fn modified_identifier_all(&self) -> Vec<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn modified_identifier(&self, i: usize) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Let_pattern_plainContextAttrs<'input> for Let_pattern_plainContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_plain(&mut self) -> Result<Rc<Let_pattern_plainContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_plainContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_let_pattern_plain);
        let mut _localctx: Rc<Let_pattern_plainContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_identifier */
                recog.base.set_state(893);
                recog.modified_identifier()?;

                recog.base.set_state(898);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(125, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(894);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                /* InvokeRule modified_identifier */
                                recog.base.set_state(895);
                                recog.modified_identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(900);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(125, &mut recog.base)?;
                }
                recog.base.set_state(902);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COMMA {
                    {
                        recog.base.set_state(901);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_tuple ----------------
pub type Let_pattern_tupleContextAll<'input> = Let_pattern_tupleContext<'input>;

pub type Let_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Let_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_tuple }
}
antlr_rust::tid! {Let_pattern_tupleContextExt<'a>}

impl<'input> Let_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn let_pattern_item_all(&self) -> Vec<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_pattern_item(&self, i: usize) -> Option<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
}

impl<'input> Let_pattern_tupleContextAttrs<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_tuple(&mut self) -> Result<Rc<Let_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_let_pattern_tuple);
        let mut _localctx: Rc<Let_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(974);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(141, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(904);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(918);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(129, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(905);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(906);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                }
                            }

                            x if x == 2 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(908);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(911);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = 1;
                                    loop {
                                        match _alt {
                                            x if x == 1 => {
                                                {
                                                    recog.base.set_state(909);
                                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                    /* InvokeRule let_pattern_item */
                                                    recog.base.set_state(910);
                                                    recog.let_pattern_item()?;
                                                }
                                            }

                                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                        }
                                        recog.base.set_state(913);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = recog.interpreter.adaptive_predict(127, &mut recog.base)?;
                                        if _alt == 2 || _alt == INVALID_ALT {
                                            break;
                                        }
                                    }
                                    recog.base.set_state(916);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == COMMA {
                                        {
                                            recog.base.set_state(915);
                                            recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                        }
                                    }
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(920);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(921);
                        recog.namepath()?;

                        recog.base.set_state(922);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(934);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DOT3
                            || _la == OP_DOT2
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(923);
                                recog.let_pattern_item()?;

                                recog.base.set_state(928);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(130, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(924);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(925);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(930);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(130, &mut recog.base)?;
                                }
                                recog.base.set_state(932);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(931);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(936);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(939);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(938);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(941);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(953);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DOT3
                            || _la == OP_DOT2
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(942);
                                recog.let_pattern_item()?;

                                recog.base.set_state(947);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(134, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(943);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(944);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(949);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(134, &mut recog.base)?;
                                }
                                recog.base.set_state(951);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(950);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(955);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(957);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(956);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(959);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(971);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DOT3
                            || _la == OP_DOT2
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(960);
                                recog.let_pattern_item()?;

                                recog.base.set_state(965);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(138, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(961);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(962);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(967);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(138, &mut recog.base)?;
                                }
                                recog.base.set_state(969);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(968);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(973);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_item ----------------
pub type Let_pattern_itemContextAll<'input> = Let_pattern_itemContext<'input>;

pub type Let_pattern_itemContext<'input> = BaseParserRuleContext<'input, Let_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_item }
}
antlr_rust::tid! {Let_pattern_itemContextExt<'a>}

impl<'input> Let_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Let_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Let_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_itemContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT2
    /// Returns `None` if there is no child corresponding to token OP_DOT2
    fn OP_DOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT3
    /// Returns `None` if there is no child corresponding to token OP_DOT3
    fn OP_DOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT3, 0)
    }
}

impl<'input> Let_pattern_itemContextAttrs<'input> for Let_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_item(&mut self) -> Result<Rc<Let_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_let_pattern_item);
        let mut _localctx: Rc<Let_pattern_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1013);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(150, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(979);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(142, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(976);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(977);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(984);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(143, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(981);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(982);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(986);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(990);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(144, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(987);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(988);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(995);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(145, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(992);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(993);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule identifier */
                        recog.base.set_state(997);
                        recog.identifier()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(999);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule modified_identifier */
                                recog.base.set_state(998);
                                recog.modified_identifier()?;
                            }
                        }

                        recog.base.set_state(1001);
                        recog.base.match_token(OP_DOT2, &mut recog.err_handler)?;

                        recog.base.set_state(1003);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1002);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());
                            }
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1006);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule modified_identifier */
                                recog.base.set_state(1005);
                                recog.modified_identifier()?;
                            }
                        }

                        recog.base.set_state(1008);
                        recog.base.match_token(OP_DOT3, &mut recog.err_handler)?;

                        recog.base.set_state(1010);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1009);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());
                            }
                        }
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1012);
                        recog.modified_identifier()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_type ----------------
pub type Define_typeContextAll<'input> = Define_typeContext<'input>;

pub type Define_typeContext<'input> = BaseParserRuleContext<'input, Define_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_type }
}
antlr_rust::tid! {Define_typeContextExt<'a>}

impl<'input> Define_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_typeContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_block(&self) -> Option<Rc<Template_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_typeContextAttrs<'input> for Define_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_type(&mut self) -> Result<Rc<Define_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_define_type);
        let mut _localctx: Rc<Define_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1044);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(155, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1018);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1015);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1020);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1021);
                        recog.modifiers()?;

                        recog.base.set_state(1022);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1023);
                        recog.identifier()?;

                        recog.base.set_state(1025);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule define_generic */
                                recog.base.set_state(1024);
                                recog.define_generic()?;
                            }
                        }

                        recog.base.set_state(1027);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1028);
                        recog.type_expression_rec(0)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1033);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1030);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1035);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1036);
                        recog.modifiers()?;

                        recog.base.set_state(1037);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1038);
                        recog.identifier()?;

                        recog.base.set_state(1040);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule define_generic */
                                recog.base.set_state(1039);
                                recog.define_generic()?;
                            }
                        }

                        /* InvokeRule template_block */
                        recog.base.set_state(1042);
                        recog.template_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- type_hint ----------------
pub type Type_hintContextAll<'input> = Type_hintContext<'input>;

pub type Type_hintContext<'input> = BaseParserRuleContext<'input, Type_hintContextExt<'input>>;

#[derive(Clone)]
pub struct Type_hintContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_hintContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_hintContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_type_hint(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_type_hint(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_hintContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_type_hint(self);
    }
}

impl<'input> CustomRuleContext<'input> for Type_hintContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_hint
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_hint }
}
antlr_rust::tid! {Type_hintContextExt<'a>}

impl<'input> Type_hintContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_hintContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Type_hintContextExt { ph: PhantomData }))
    }
}

pub trait Type_hintContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Type_hintContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Type_hintContextAttrs<'input> for Type_hintContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_hint(&mut self) -> Result<Rc<Type_hintContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Type_hintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_type_hint);
        let mut _localctx: Rc<Type_hintContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1046);
                recog.base.match_token(COLON, &mut recog.err_handler)?;

                /* InvokeRule type_expression */
                recog.base.set_state(1047);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_statement ----------------
pub type If_statementContextAll<'input> = If_statementContext<'input>;

pub type If_statementContext<'input> = BaseParserRuleContext<'input, If_statementContextExt<'input>>;

#[derive(Clone)]
pub struct If_statementContextExt<'input> {
    pub then_block: Option<Rc<Function_blockContextAll<'input>>>,
    pub else_block: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_statement }
}
antlr_rust::tid! {If_statementContextExt<'a>}

impl<'input> If_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            If_statementContextExt { then_block: None, else_block: None, ph: PhantomData },
        ))
    }
}

pub trait If_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<If_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block_all(&self) -> Vec<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn function_block(&self, i: usize) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn else_if_statement_all(&self) -> Vec<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn else_if_statement(&self, i: usize) -> Option<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
}

impl<'input> If_statementContextAttrs<'input> for If_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_statement(&mut self) -> Result<Rc<If_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_if_statement);
        let mut _localctx: Rc<If_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1052);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1049);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1054);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1055);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(1056);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(1057);
                let tmp = recog.function_block()?;
                cast_mut::<_, If_statementContext>(&mut _localctx).then_block = Some(tmp.clone());

                recog.base.set_state(1061);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(157, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule else_if_statement */
                                recog.base.set_state(1058);
                                recog.else_if_statement()?;
                            }
                        }
                    }
                    recog.base.set_state(1063);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(157, &mut recog.base)?;
                }
                recog.base.set_state(1066);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(158, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(1064);
                            recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                            /* InvokeRule function_block */
                            recog.base.set_state(1065);
                            let tmp = recog.function_block()?;
                            cast_mut::<_, If_statementContext>(&mut _localctx).else_block = Some(tmp.clone());
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- guard_statement ----------------
pub type Guard_statementContextAll<'input> = Guard_statementContext<'input>;

pub type Guard_statementContext<'input> = BaseParserRuleContext<'input, Guard_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Guard_statementContextExt<'input> {
    pub then: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Guard_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Guard_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_guard_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_guard_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Guard_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_guard_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Guard_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_guard_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_guard_statement }
}
antlr_rust::tid! {Guard_statementContextExt<'a>}

impl<'input> Guard_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Guard_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Guard_statementContextExt { then: None, ph: PhantomData },
        ))
    }
}

pub trait Guard_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Guard_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Guard_statementContextAttrs<'input> for Guard_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn guard_statement(&mut self) -> Result<Rc<Guard_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Guard_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_guard_statement);
        let mut _localctx: Rc<Guard_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1096);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(162, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1071);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1068);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1073);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1074);
                        recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                        recog.base.set_state(1075);
                        _la = recog.base.input.la(1);
                        if { !(_la == KW_NOT || _la == KW_LET) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        recog.base.set_state(1079);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(160, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule let_pattern_tuple */
                                    recog.base.set_state(1076);
                                    recog.let_pattern_tuple()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(1077);
                                    recog.identifier()?;
                                }
                            }
                            3 => {
                                recog.base.set_state(1078);
                                recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        recog.base.set_state(1081);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1082);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(1083);
                        let tmp = recog.function_block()?;
                        cast_mut::<_, Guard_statementContext>(&mut _localctx).then = Some(tmp.clone());
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1088);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1085);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1090);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1091);
                        recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                        recog.base.set_state(1092);
                        _la = recog.base.input.la(1);
                        if { !(_la == KW_NOT || _la == KW_LET) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        /* InvokeRule inline_expression */
                        recog.base.set_state(1093);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(1094);
                        let tmp = recog.function_block()?;
                        cast_mut::<_, Guard_statementContext>(&mut _localctx).then = Some(tmp.clone());
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- else_if_statement ----------------
pub type Else_if_statementContextAll<'input> = Else_if_statementContext<'input>;

pub type Else_if_statementContext<'input> = BaseParserRuleContext<'input, Else_if_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Else_if_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Else_if_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Else_if_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_else_if_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_else_if_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Else_if_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_else_if_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Else_if_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_else_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_else_if_statement }
}
antlr_rust::tid! {Else_if_statementContextExt<'a>}

impl<'input> Else_if_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Else_if_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Else_if_statementContextExt { ph: PhantomData }))
    }
}

pub trait Else_if_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Else_if_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Else_if_statementContextAttrs<'input> for Else_if_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn else_if_statement(&mut self) -> Result<Rc<Else_if_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Else_if_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_else_if_statement);
        let mut _localctx: Rc<Else_if_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1098);
                recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                recog.base.set_state(1099);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(1100);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(1101);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- loop_statement ----------------
#[derive(Debug)]
pub enum Loop_statementContextAll<'input> {
    ForLoopContext(ForLoopContext<'input>),
    WhileLetContext(WhileLetContext<'input>),
    WhileLoopContext(WhileLoopContext<'input>),
    Error(Loop_statementContext<'input>),
}
antlr_rust::tid! {Loop_statementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Loop_statementContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Loop_statementContextAll<'input> {}

impl<'input> Deref for Loop_statementContextAll<'input> {
    type Target = dyn Loop_statementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Loop_statementContextAll::*;
        match self {
            ForLoopContext(inner) => inner,
            WhileLetContext(inner) => inner,
            WhileLoopContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Loop_statementContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Loop_statementContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Loop_statementContext<'input> = BaseParserRuleContext<'input, Loop_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Loop_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Loop_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Loop_statementContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Loop_statementContext<'input> {}

impl<'input> CustomRuleContext<'input> for Loop_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}
antlr_rust::tid! {Loop_statementContextExt<'a>}

impl<'input> Loop_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Loop_statementContextExt { ph: PhantomData },
        )))
    }
}

pub trait Loop_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Loop_statementContextExt<'input>>
{
}

impl<'input> Loop_statementContextAttrs<'input> for Loop_statementContext<'input> {}

pub type ForLoopContext<'input> = BaseParserRuleContext<'input, ForLoopContextExt<'input>>;

pub trait ForLoopContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_FOR
    /// Returns `None` if there is no child corresponding to token KW_FOR
    fn KW_FOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FOR, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn infix_in(&self) -> Option<Rc<Infix_inContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
}

impl<'input> ForLoopContextAttrs<'input> for ForLoopContext<'input> {}

pub struct ForLoopContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    pub cond: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub guard: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ForLoopContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ForLoopContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ForLoopContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ForLoop(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ForLoop(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ForLoopContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ForLoop(self);
    }
}

impl<'input> CustomRuleContext<'input> for ForLoopContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for ForLoopContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for ForLoopContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for ForLoopContext<'input> {}

impl<'input> ForLoopContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::ForLoopContext(BaseParserRuleContext::copy_from(
            ctx,
            ForLoopContextExt { cond: None, guard: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type WhileLetContext<'input> = BaseParserRuleContext<'input, WhileLetContextExt<'input>>;

pub trait WhileLetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileLetContextAttrs<'input> for WhileLetContext<'input> {}

pub struct WhileLetContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileLetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileLetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileLetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileLet(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileLet(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileLetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileLet(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileLetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for WhileLetContext<'input> {}

impl<'input> WhileLetContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::WhileLetContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileLetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type WhileLoopContext<'input> = BaseParserRuleContext<'input, WhileLoopContextExt<'input>>;

pub trait WhileLoopContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileLoopContextAttrs<'input> for WhileLoopContext<'input> {}

pub struct WhileLoopContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    pub cond: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileLoopContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileLoopContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileLoopContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileLoop(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileLoop(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileLoopContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileLoop(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileLoopContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for WhileLoopContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for WhileLoopContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for WhileLoopContext<'input> {}

impl<'input> WhileLoopContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::WhileLoopContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileLoopContextExt { cond: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn loop_statement(&mut self) -> Result<Rc<Loop_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Loop_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_loop_statement);
        let mut _localctx: Rc<Loop_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1142);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(167, &mut recog.base)? {
                1 => {
                    let tmp = WhileLoopContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1106);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1103);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1108);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1109);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1110);
                        let tmp = recog.inline_expression_rec(0)?;
                        if let Loop_statementContextAll::WhileLoopContext(ctx) =
                            cast_mut::<_, Loop_statementContextAll>(&mut _localctx)
                        {
                            ctx.cond = Some(tmp.clone());
                        }
                        else {
                            unreachable!("cant cast");
                        }

                        /* InvokeRule function_block */
                        recog.base.set_state(1111);
                        recog.function_block()?;
                    }
                }
                2 => {
                    let tmp = WhileLetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1116);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1113);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1118);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1119);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        recog.base.set_state(1120);
                        recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                        /* InvokeRule let_pattern */
                        recog.base.set_state(1121);
                        recog.let_pattern()?;

                        recog.base.set_state(1122);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1123);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(1124);
                        recog.function_block()?;
                    }
                }
                3 => {
                    let tmp = ForLoopContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1129);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1126);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1131);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1132);
                        recog.base.match_token(KW_FOR, &mut recog.err_handler)?;

                        /* InvokeRule let_pattern */
                        recog.base.set_state(1133);
                        recog.let_pattern()?;

                        /* InvokeRule infix_in */
                        recog.base.set_state(1134);
                        recog.infix_in()?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1135);
                        let tmp = recog.inline_expression_rec(0)?;
                        if let Loop_statementContextAll::ForLoopContext(ctx) =
                            cast_mut::<_, Loop_statementContextAll>(&mut _localctx)
                        {
                            ctx.cond = Some(tmp.clone());
                        }
                        else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(1138);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1136);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1137);
                                let tmp = recog.inline_expression_rec(0)?;
                                if let Loop_statementContextAll::ForLoopContext(ctx) =
                                    cast_mut::<_, Loop_statementContextAll>(&mut _localctx)
                                {
                                    ctx.guard = Some(tmp.clone());
                                }
                                else {
                                    unreachable!("cant cast");
                                }
                            }
                        }

                        /* InvokeRule function_block */
                        recog.base.set_state(1140);
                        recog.function_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_guard ----------------
pub type If_guardContextAll<'input> = If_guardContext<'input>;

pub type If_guardContext<'input> = BaseParserRuleContext<'input, If_guardContextExt<'input>>;

#[derive(Clone)]
pub struct If_guardContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_guardContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_guardContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_guard(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_guard(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_guardContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_guard(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_guardContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_guard
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_guard }
}
antlr_rust::tid! {If_guardContextExt<'a>}

impl<'input> If_guardContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_guardContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, If_guardContextExt { ph: PhantomData }))
    }
}

pub trait If_guardContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<If_guardContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> If_guardContextAttrs<'input> for If_guardContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_guard(&mut self) -> Result<Rc<If_guardContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_guardContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_if_guard);
        let mut _localctx: Rc<If_guardContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1144);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(1145);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression_root ----------------
pub type Expression_rootContextAll<'input> = Expression_rootContext<'input>;

pub type Expression_rootContext<'input> = BaseParserRuleContext<'input, Expression_rootContextExt<'input>>;

#[derive(Clone)]
pub struct Expression_rootContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Expression_rootContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Expression_rootContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_expression_root(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_expression_root(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Expression_rootContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_expression_root(self);
    }
}

impl<'input> CustomRuleContext<'input> for Expression_rootContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression_root
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression_root }
}
antlr_rust::tid! {Expression_rootContextExt<'a>}

impl<'input> Expression_rootContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Expression_rootContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Expression_rootContextExt { ph: PhantomData }))
    }
}

pub trait Expression_rootContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Expression_rootContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Expression_rootContextAttrs<'input> for Expression_rootContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression_root(&mut self) -> Result<Rc<Expression_rootContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Expression_rootContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_expression_root);
        let mut _localctx: Rc<Expression_rootContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1150);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(168, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule annotation */
                                recog.base.set_state(1147);
                                recog.annotation()?;
                            }
                        }
                    }
                    recog.base.set_state(1152);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(168, &mut recog.base)?;
                }
                /* InvokeRule expression */
                recog.base.set_state(1153);
                recog.expression_rec(0)?;

                recog.base.set_state(1155);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AND_THEN {
                    {
                        recog.base.set_state(1154);
                        recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                    }
                }

                recog.base.set_state(1158);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(170, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(1157);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression ----------------
#[derive(Debug)]
pub enum ExpressionContextAll<'input> {
    EIfContext(EIfContext<'input>),
    EUntilContext(EUntilContext<'input>),
    EInContext(EInContext<'input>),
    EFloorContext(EFloorContext<'input>),
    EPlusContext(EPlusContext<'input>),
    ESliceContext(ESliceContext<'input>),
    EDotMatchContext(EDotMatchContext<'input>),
    ETryContext(ETryContext<'input>),
    EAsContext(EAsContext<'input>),
    EObjectContext(EObjectContext<'input>),
    ETupleContext(ETupleContext<'input>),
    ERangeContext(ERangeContext<'input>),
    EAssignContext(EAssignContext<'input>),
    EAtomContext(EAtomContext<'input>),
    EMulContext(EMulContext<'input>),
    EPipeContext(EPipeContext<'input>),
    ELambdaContext(ELambdaContext<'input>),
    EOrElseContext(EOrElseContext<'input>),
    EGroupContext(EGroupContext<'input>),
    EFunctionContext(EFunctionContext<'input>),
    ESuffixContext(ESuffixContext<'input>),
    EClosureContext(EClosureContext<'input>),
    EMatchContext(EMatchContext<'input>),
    EMacroContext(EMacroContext<'input>),
    EPrefixContext(EPrefixContext<'input>),
    ECompareContext(ECompareContext<'input>),
    EGenericContext(EGenericContext<'input>),
    EIsAContext(EIsAContext<'input>),
    EPowContext(EPowContext<'input>),
    EDefineContext(EDefineContext<'input>),
    EMapContext(EMapContext<'input>),
    ELogicContext(ELogicContext<'input>),
    EControlContext(EControlContext<'input>),
    ENewContext(ENewContext<'input>),
    ECeilingContext(ECeilingContext<'input>),
    Error(ExpressionContext<'input>),
}
antlr_rust::tid! {ExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ExpressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContextAll<'input> {}

impl<'input> Deref for ExpressionContextAll<'input> {
    type Target = dyn ExpressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use ExpressionContextAll::*;
        match self {
            EIfContext(inner) => inner,
            EUntilContext(inner) => inner,
            EInContext(inner) => inner,
            EFloorContext(inner) => inner,
            EPlusContext(inner) => inner,
            ESliceContext(inner) => inner,
            EDotMatchContext(inner) => inner,
            ETryContext(inner) => inner,
            EAsContext(inner) => inner,
            EObjectContext(inner) => inner,
            ETupleContext(inner) => inner,
            ERangeContext(inner) => inner,
            EAssignContext(inner) => inner,
            EAtomContext(inner) => inner,
            EMulContext(inner) => inner,
            EPipeContext(inner) => inner,
            ELambdaContext(inner) => inner,
            EOrElseContext(inner) => inner,
            EGroupContext(inner) => inner,
            EFunctionContext(inner) => inner,
            ESuffixContext(inner) => inner,
            EClosureContext(inner) => inner,
            EMatchContext(inner) => inner,
            EMacroContext(inner) => inner,
            EPrefixContext(inner) => inner,
            ECompareContext(inner) => inner,
            EGenericContext(inner) => inner,
            EIsAContext(inner) => inner,
            EPowContext(inner) => inner,
            EDefineContext(inner) => inner,
            EMapContext(inner) => inner,
            ELogicContext(inner) => inner,
            EControlContext(inner) => inner,
            ENewContext(inner) => inner,
            ECeilingContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type ExpressionContext<'input> = BaseParserRuleContext<'input, ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid! {ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ExpressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait ExpressionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ExpressionContextExt<'input>> {}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input> {}

pub type EIfContext<'input> = BaseParserRuleContext<'input, EIfContextExt<'input>>;

pub trait EIfContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn if_statement(&self) -> Option<Rc<If_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EIfContextAttrs<'input> for EIfContext<'input> {}

pub struct EIfContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EIfContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EIfContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EIfContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIf(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIf(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EIfContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIf(self);
    }
}

impl<'input> CustomRuleContext<'input> for EIfContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EIfContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EIfContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EIfContext<'input> {}

impl<'input> EIfContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EIfContext(BaseParserRuleContext::copy_from(
            ctx,
            EIfContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EUntilContext<'input> = BaseParserRuleContext<'input, EUntilContextExt<'input>>;

pub trait EUntilContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_range(&self) -> Option<Rc<Infix_rangeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EUntilContextAttrs<'input> for EUntilContext<'input> {}

pub struct EUntilContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EUntilContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EUntilContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EUntilContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EUntil(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EUntil(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EUntilContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EUntil(self);
    }
}

impl<'input> CustomRuleContext<'input> for EUntilContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EUntilContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EUntilContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EUntilContext<'input> {}

impl<'input> EUntilContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EUntilContext(BaseParserRuleContext::copy_from(
            ctx,
            EUntilContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EInContext<'input> = BaseParserRuleContext<'input, EInContextExt<'input>>;

pub trait EInContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_in(&self) -> Option<Rc<Infix_inContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EInContextAttrs<'input> for EInContext<'input> {}

pub struct EInContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EInContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EInContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EInContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIn(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIn(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EInContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIn(self);
    }
}

impl<'input> CustomRuleContext<'input> for EInContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EInContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EInContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EInContext<'input> {}

impl<'input> EInContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EInContext(BaseParserRuleContext::copy_from(
            ctx,
            EInContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EFloorContext<'input> = BaseParserRuleContext<'input, EFloorContextExt<'input>>;

pub trait EFloorContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token FLOOR_L
    /// Returns `None` if there is no child corresponding to token FLOOR_L
    fn FLOOR_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FLOOR_R
    /// Returns `None` if there is no child corresponding to token FLOOR_R
    fn FLOOR_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_R, 0)
    }
}

impl<'input> EFloorContextAttrs<'input> for EFloorContext<'input> {}

pub struct EFloorContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EFloorContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EFloorContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EFloorContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EFloor(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EFloor(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EFloorContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EFloor(self);
    }
}

impl<'input> CustomRuleContext<'input> for EFloorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EFloorContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EFloorContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EFloorContext<'input> {}

impl<'input> EFloorContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EFloorContext(BaseParserRuleContext::copy_from(
            ctx,
            EFloorContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPlusContext<'input> = BaseParserRuleContext<'input, EPlusContextExt<'input>>;

pub trait EPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPlusContextAttrs<'input> for EPlusContext<'input> {}

pub struct EPlusContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPlusContext<'input> {}

impl<'input> EPlusContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            EPlusContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESliceContext<'input> = BaseParserRuleContext<'input, ESliceContextExt<'input>>;

pub trait ESliceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ESliceContextAttrs<'input> for ESliceContext<'input> {}

pub struct ESliceContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESliceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESliceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESliceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESlice(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESlice(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESliceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESlice(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESliceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESliceContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESliceContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESliceContext<'input> {}

impl<'input> ESliceContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESliceContext(BaseParserRuleContext::copy_from(
            ctx,
            ESliceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDotMatchContext<'input> = BaseParserRuleContext<'input, EDotMatchContextExt<'input>>;

pub trait EDotMatchContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDotMatchContextAttrs<'input> for EDotMatchContext<'input> {}

pub struct EDotMatchContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDotMatchContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDotMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDotMatchContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDotMatch(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDotMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDotMatchContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDotMatch(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDotMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDotMatchContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDotMatchContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDotMatchContext<'input> {}

impl<'input> EDotMatchContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDotMatchContext(BaseParserRuleContext::copy_from(
            ctx,
            EDotMatchContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ETryContext<'input> = BaseParserRuleContext<'input, ETryContextExt<'input>>;

pub trait ETryContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn try_statement(&self) -> Option<Rc<Try_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ETryContextAttrs<'input> for ETryContext<'input> {}

pub struct ETryContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ETryContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ETryContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ETryContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ETry(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ETry(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ETryContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ETry(self);
    }
}

impl<'input> CustomRuleContext<'input> for ETryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ETryContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ETryContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ETryContext<'input> {}

impl<'input> ETryContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ETryContext(BaseParserRuleContext::copy_from(
            ctx,
            ETryContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAsContext<'input> = BaseParserRuleContext<'input, EAsContextExt<'input>>;

pub trait EAsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_as(&self) -> Option<Rc<Infix_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EAsContextAttrs<'input> for EAsContext<'input> {}

pub struct EAsContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAs(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAsContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAsContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAsContext<'input> {}

impl<'input> EAsContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAsContext(BaseParserRuleContext::copy_from(
            ctx,
            EAsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EObjectContext<'input> = BaseParserRuleContext<'input, EObjectContextExt<'input>>;

pub trait EObjectContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn object_statement(&self) -> Option<Rc<Object_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EObjectContextAttrs<'input> for EObjectContext<'input> {}

pub struct EObjectContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EObjectContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EObjectContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EObjectContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EObject(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EObject(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EObjectContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EObject(self);
    }
}

impl<'input> CustomRuleContext<'input> for EObjectContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EObjectContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EObjectContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EObjectContext<'input> {}

impl<'input> EObjectContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EObjectContext(BaseParserRuleContext::copy_from(
            ctx,
            EObjectContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ETupleContext<'input> = BaseParserRuleContext<'input, ETupleContextExt<'input>>;

pub trait ETupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn tuple_literal(&self) -> Option<Rc<Tuple_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ETupleContextAttrs<'input> for ETupleContext<'input> {}

pub struct ETupleContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ETupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ETupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ETupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ETuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ETuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ETupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ETuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for ETupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ETupleContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ETupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ETupleContext<'input> {}

impl<'input> ETupleContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ETupleContext(BaseParserRuleContext::copy_from(
            ctx,
            ETupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ERangeContext<'input> = BaseParserRuleContext<'input, ERangeContextExt<'input>>;

pub trait ERangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ERangeContextAttrs<'input> for ERangeContext<'input> {}

pub struct ERangeContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ERangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ERangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ERangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ERange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ERange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ERangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ERange(self);
    }
}

impl<'input> CustomRuleContext<'input> for ERangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ERangeContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ERangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ERangeContext<'input> {}

impl<'input> ERangeContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ERangeContext(BaseParserRuleContext::copy_from(
            ctx,
            ERangeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAssignContext<'input> = BaseParserRuleContext<'input, EAssignContextExt<'input>>;

pub trait EAssignContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_assign(&self) -> Option<Rc<Infix_assignContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EAssignContextAttrs<'input> for EAssignContext<'input> {}

pub struct EAssignContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAssignContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAssignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAssignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAssign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAssign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAssignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAssign(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAssignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAssignContext<'input> {}

impl<'input> EAssignContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAssignContext(BaseParserRuleContext::copy_from(
            ctx,
            EAssignContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAtomContext<'input> = BaseParserRuleContext<'input, EAtomContextExt<'input>>;

pub trait EAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EAtomContextAttrs<'input> for EAtomContext<'input> {}

pub struct EAtomContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAtomContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAtomContext<'input> {}

impl<'input> EAtomContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            EAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMulContext<'input> = BaseParserRuleContext<'input, EMulContextExt<'input>>;

pub trait EMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EMulContextAttrs<'input> for EMulContext<'input> {}

pub struct EMulContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMulContext<'input> {}

impl<'input> EMulContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMulContext(BaseParserRuleContext::copy_from(
            ctx,
            EMulContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPipeContext<'input> = BaseParserRuleContext<'input, EPipeContextExt<'input>>;

pub trait EPipeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_pipeline(&self) -> Option<Rc<Op_pipelineContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPipeContextAttrs<'input> for EPipeContext<'input> {}

pub struct EPipeContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPipeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPipeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPipeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPipe(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPipe(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPipeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPipe(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPipeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPipeContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPipeContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPipeContext<'input> {}

impl<'input> EPipeContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPipeContext(BaseParserRuleContext::copy_from(
            ctx,
            EPipeContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELambdaContext<'input> = BaseParserRuleContext<'input, ELambdaContextExt<'input>>;

pub trait ELambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_lambda(&self) -> Option<Rc<Define_lambdaContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ELambdaContextAttrs<'input> for ELambdaContext<'input> {}

pub struct ELambdaContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELambdaContext<'input> {}

impl<'input> ELambdaContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            ELambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EOrElseContext<'input> = BaseParserRuleContext<'input, EOrElseContextExt<'input>>;

pub trait EOrElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_OR_ELSE
    /// Returns `None` if there is no child corresponding to token OP_OR_ELSE
    fn OP_OR_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR_ELSE, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EOrElseContextAttrs<'input> for EOrElseContext<'input> {}

pub struct EOrElseContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EOrElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EOrElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EOrElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EOrElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EOrElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EOrElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EOrElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for EOrElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EOrElseContext<'input> {}

impl<'input> EOrElseContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EOrElseContext(BaseParserRuleContext::copy_from(
            ctx,
            EOrElseContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EGroupContext<'input> = BaseParserRuleContext<'input, EGroupContextExt<'input>>;

pub trait EGroupContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
}

impl<'input> EGroupContextAttrs<'input> for EGroupContext<'input> {}

pub struct EGroupContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EGroupContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EGroupContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EGroupContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EGroup(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EGroup(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EGroupContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EGroup(self);
    }
}

impl<'input> CustomRuleContext<'input> for EGroupContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EGroupContext<'input> {}

impl<'input> EGroupContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EGroupContext(BaseParserRuleContext::copy_from(
            ctx,
            EGroupContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EFunctionContext<'input> = BaseParserRuleContext<'input, EFunctionContextExt<'input>>;

pub trait EFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EFunctionContextAttrs<'input> for EFunctionContext<'input> {}

pub struct EFunctionContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for EFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EFunctionContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EFunctionContext<'input> {}

impl<'input> EFunctionContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            EFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESuffixContext<'input> = BaseParserRuleContext<'input, ESuffixContextExt<'input>>;

pub trait ESuffixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn op_suffix(&self) -> Option<Rc<Op_suffixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ESuffixContextAttrs<'input> for ESuffixContext<'input> {}

pub struct ESuffixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESuffixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESuffixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESuffixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESuffix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESuffix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESuffixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESuffix(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESuffixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESuffixContext<'input> {}

impl<'input> ESuffixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESuffixContext(BaseParserRuleContext::copy_from(
            ctx,
            ESuffixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EClosureContext<'input> = BaseParserRuleContext<'input, EClosureContextExt<'input>>;

pub trait EClosureContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn closure_call(&self) -> Option<Rc<Closure_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EClosureContextAttrs<'input> for EClosureContext<'input> {}

pub struct EClosureContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EClosureContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EClosureContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EClosureContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EClosure(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EClosure(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EClosureContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EClosure(self);
    }
}

impl<'input> CustomRuleContext<'input> for EClosureContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EClosureContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EClosureContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EClosureContext<'input> {}

impl<'input> EClosureContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EClosureContext(BaseParserRuleContext::copy_from(
            ctx,
            EClosureContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMatchContext<'input> = BaseParserRuleContext<'input, EMatchContextExt<'input>>;

pub trait EMatchContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn match_statement(&self) -> Option<Rc<Match_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMatchContextAttrs<'input> for EMatchContext<'input> {}

pub struct EMatchContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMatchContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMatchContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMatch(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMatchContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMatch(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMatchContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMatchContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMatchContext<'input> {}

impl<'input> EMatchContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMatchContext(BaseParserRuleContext::copy_from(
            ctx,
            EMatchContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMacroContext<'input> = BaseParserRuleContext<'input, EMacroContextExt<'input>>;

pub trait EMacroContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn macro_call(&self) -> Option<Rc<Macro_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMacroContextAttrs<'input> for EMacroContext<'input> {}

pub struct EMacroContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMacroContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMacroContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMacroContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMacro(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMacro(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMacroContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMacro(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMacroContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMacroContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMacroContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMacroContext<'input> {}

impl<'input> EMacroContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMacroContext(BaseParserRuleContext::copy_from(
            ctx,
            EMacroContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPrefixContext<'input> = BaseParserRuleContext<'input, EPrefixContextExt<'input>>;

pub trait EPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EPrefixContextAttrs<'input> for EPrefixContext<'input> {}

pub struct EPrefixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPrefixContext<'input> {}

impl<'input> EPrefixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            EPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ECompareContext<'input> = BaseParserRuleContext<'input, ECompareContextExt<'input>>;

pub trait ECompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ECompareContextAttrs<'input> for ECompareContext<'input> {}

pub struct ECompareContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ECompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ECompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ECompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ECompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ECompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ECompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ECompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ECompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ECompareContext<'input> {}

impl<'input> ECompareContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ECompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ECompareContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EGenericContext<'input> = BaseParserRuleContext<'input, EGenericContextExt<'input>>;

pub trait EGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call(&self) -> Option<Rc<Generic_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EGenericContextAttrs<'input> for EGenericContext<'input> {}

pub struct EGenericContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for EGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EGenericContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EGenericContext<'input> {}

impl<'input> EGenericContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            EGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EIsAContext<'input> = BaseParserRuleContext<'input, EIsAContextExt<'input>>;

pub trait EIsAContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_is(&self) -> Option<Rc<Infix_isContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EIsAContextAttrs<'input> for EIsAContext<'input> {}

pub struct EIsAContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EIsAContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EIsAContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EIsAContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIsA(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIsA(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EIsAContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIsA(self);
    }
}

impl<'input> CustomRuleContext<'input> for EIsAContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EIsAContext<'input> {}

impl<'input> EIsAContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EIsAContext(BaseParserRuleContext::copy_from(
            ctx,
            EIsAContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPowContext<'input> = BaseParserRuleContext<'input, EPowContextExt<'input>>;

pub trait EPowContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_pow(&self) -> Option<Rc<Infix_powContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPowContextAttrs<'input> for EPowContext<'input> {}

pub struct EPowContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPowContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPowContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPowContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPow(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPow(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPowContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPow(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPowContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPowContext<'input> {}

impl<'input> EPowContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPowContext(BaseParserRuleContext::copy_from(
            ctx,
            EPowContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDefineContext<'input> = BaseParserRuleContext<'input, EDefineContextExt<'input>>;

pub trait EDefineContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_label(&self) -> Option<Rc<Define_labelContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDefineContextAttrs<'input> for EDefineContext<'input> {}

pub struct EDefineContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDefineContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDefineContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDefineContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDefine(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDefine(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDefineContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDefine(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDefineContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDefineContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDefineContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDefineContext<'input> {}

impl<'input> EDefineContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDefineContext(BaseParserRuleContext::copy_from(
            ctx,
            EDefineContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMapContext<'input> = BaseParserRuleContext<'input, EMapContextExt<'input>>;

pub trait EMapContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_map(&self) -> Option<Rc<Infix_mapContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EMapContextAttrs<'input> for EMapContext<'input> {}

pub struct EMapContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMapContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMapContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMapContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMap(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMap(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMapContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMap(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMapContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMapContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMapContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMapContext<'input> {}

impl<'input> EMapContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMapContext(BaseParserRuleContext::copy_from(
            ctx,
            EMapContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELogicContext<'input> = BaseParserRuleContext<'input, ELogicContextExt<'input>>;

pub trait ELogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ELogicContextAttrs<'input> for ELogicContext<'input> {}

pub struct ELogicContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELogicContext<'input> {}

impl<'input> ELogicContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ELogicContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EControlContext<'input> = BaseParserRuleContext<'input, EControlContextExt<'input>>;

pub trait EControlContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn control_expression(&self) -> Option<Rc<Control_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EControlContextAttrs<'input> for EControlContext<'input> {}

pub struct EControlContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EControlContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EControlContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EControlContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EControl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EControl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EControlContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EControl(self);
    }
}

impl<'input> CustomRuleContext<'input> for EControlContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EControlContext<'input> {}

impl<'input> EControlContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EControlContext(BaseParserRuleContext::copy_from(
            ctx,
            EControlContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ENewContext<'input> = BaseParserRuleContext<'input, ENewContextExt<'input>>;

pub trait ENewContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn new_statement(&self) -> Option<Rc<New_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ENewContextAttrs<'input> for ENewContext<'input> {}

pub struct ENewContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ENewContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ENewContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ENewContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ENew(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ENew(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ENewContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ENew(self);
    }
}

impl<'input> CustomRuleContext<'input> for ENewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ENewContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ENewContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ENewContext<'input> {}

impl<'input> ENewContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ENewContext(BaseParserRuleContext::copy_from(
            ctx,
            ENewContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ECeilingContext<'input> = BaseParserRuleContext<'input, ECeilingContextExt<'input>>;

pub trait ECeilingContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CEILING_L
    /// Returns `None` if there is no child corresponding to token CEILING_L
    fn CEILING_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token CEILING_R
    /// Returns `None` if there is no child corresponding to token CEILING_R
    fn CEILING_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_R, 0)
    }
}

impl<'input> ECeilingContextAttrs<'input> for ECeilingContext<'input> {}

pub struct ECeilingContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ECeilingContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ECeilingContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ECeilingContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ECeiling(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ECeiling(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ECeilingContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ECeiling(self);
    }
}

impl<'input> CustomRuleContext<'input> for ECeilingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ECeilingContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ECeilingContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ECeilingContext<'input> {}

impl<'input> ECeilingContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ECeilingContext(BaseParserRuleContext::copy_from(
            ctx,
            ECeilingContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression(&mut self) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        self.expression_rec(0)
    }

    fn expression_rec(&mut self, _p: isize) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 112, RULE_expression, _p);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 112;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1189);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(171, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = EPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(1161);
                            recog.op_prefix()?;

                            /* InvokeRule expression */
                            recog.base.set_state(1162);
                            recog.expression_rec(30)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = EGroupContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1164);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1165);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1166);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = EFloorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1168);
                            recog.base.match_token(FLOOR_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1169);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1170);
                            recog.base.match_token(FLOOR_R, &mut recog.err_handler)?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = ECeilingContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1172);
                            recog.base.match_token(CEILING_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1173);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1174);
                            recog.base.match_token(CEILING_R, &mut recog.err_handler)?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = EControlContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule control_expression */
                            recog.base.set_state(1176);
                            recog.control_expression()?;
                        }
                    }
                    6 => {
                        {
                            let mut tmp = EIfContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule if_statement */
                            recog.base.set_state(1177);
                            recog.if_statement()?;
                        }
                    }
                    7 => {
                        {
                            let mut tmp = ENewContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule new_statement */
                            recog.base.set_state(1178);
                            recog.new_statement()?;
                        }
                    }
                    8 => {
                        {
                            let mut tmp = ETryContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule try_statement */
                            recog.base.set_state(1179);
                            recog.try_statement()?;
                        }
                    }
                    9 => {
                        {
                            let mut tmp = EMatchContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule match_statement */
                            recog.base.set_state(1180);
                            recog.match_statement()?;
                        }
                    }
                    10 => {
                        {
                            let mut tmp = EObjectContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule object_statement */
                            recog.base.set_state(1181);
                            recog.object_statement()?;
                        }
                    }
                    11 => {
                        {
                            let mut tmp = EMacroContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule macro_call */
                            recog.base.set_state(1182);
                            recog.macro_call()?;
                        }
                    }
                    12 => {
                        {
                            let mut tmp = ELambdaContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule define_lambda */
                            recog.base.set_state(1183);
                            recog.define_lambda()?;
                        }
                    }
                    13 => {
                        {
                            let mut tmp = EFunctionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule function_block */
                            recog.base.set_state(1184);
                            recog.function_block()?;
                        }
                    }
                    14 => {
                        {
                            let mut tmp = EDefineContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule define_label */
                            recog.base.set_state(1185);
                            recog.define_label()?;
                        }
                    }
                    15 => {
                        {
                            let mut tmp = ETupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule tuple_literal */
                            recog.base.set_state(1186);
                            recog.tuple_literal()?;
                        }
                    }
                    16 => {
                        {
                            let mut tmp = ERangeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule range_literal */
                            recog.base.set_state(1187);
                            recog.range_literal()?;
                        }
                    }
                    17 => {
                        {
                            let mut tmp = EAtomContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1188);
                            recog.atomic()?;
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1266);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(176, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1264);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(175, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EPowContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EPowContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1191);
                                        if !({ recog.precpred(None, 29) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 29)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_pow */
                                        recog.base.set_state(1192);
                                        recog.infix_pow()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1193);
                                        let tmp = recog.expression_rec(29)?;
                                        if let ExpressionContextAll::EPowContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EMulContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EMulContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1195);
                                        if !({ recog.precpred(None, 28) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 28)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(1196);
                                        recog.op_multiple()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1197);
                                        let tmp = recog.expression_rec(29)?;
                                        if let ExpressionContextAll::EMulContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EPlusContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EPlusContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1199);
                                        if !({ recog.precpred(None, 27) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 27)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(1200);
                                        recog.op_plus()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1201);
                                        let tmp = recog.expression_rec(28)?;
                                        if let ExpressionContextAll::EPlusContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ECompareContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::ECompareContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1203);
                                        if !({ recog.precpred(None, 26) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 26)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1204);
                                        recog.op_compare()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1205);
                                        let tmp = recog.expression_rec(27)?;
                                        if let ExpressionContextAll::ECompareContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ELogicContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::ELogicContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1207);
                                        if !({ recog.precpred(None, 25) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 25)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(1208);
                                        recog.op_logic()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1209);
                                        let tmp = recog.expression_rec(26)?;
                                        if let ExpressionContextAll::ELogicContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EUntilContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EUntilContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1211);
                                        if !({ recog.precpred(None, 24) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 24)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_range */
                                        recog.base.set_state(1212);
                                        recog.infix_range()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1213);
                                        let tmp = recog.expression_rec(25)?;
                                        if let ExpressionContextAll::EUntilContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EMapContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EMapContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1215);
                                        if !({ recog.precpred(None, 23) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 23)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_map */
                                        recog.base.set_state(1216);
                                        recog.infix_map()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1217);
                                        let tmp = recog.expression_rec(24)?;
                                        if let ExpressionContextAll::EMapContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EInContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EInContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1219);
                                        if !({ recog.precpred(None, 20) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 20)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_in */
                                        recog.base.set_state(1220);
                                        recog.infix_in()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1221);
                                        let tmp = recog.expression_rec(21)?;
                                        if let ExpressionContextAll::EInContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EOrElseContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EOrElseContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1223);
                                        if !({ recog.precpred(None, 19) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 19)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1224);
                                        recog.base.match_token(OP_OR_ELSE, &mut recog.err_handler)?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1225);
                                        let tmp = recog.expression_rec(20)?;
                                        if let ExpressionContextAll::EOrElseContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                10 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EPipeContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EPipeContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1226);
                                        if !({ recog.precpred(None, 18) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 18)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_pipeline */
                                        recog.base.set_state(1227);
                                        recog.op_pipeline()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1228);
                                        let tmp = recog.expression_rec(19)?;
                                        if let ExpressionContextAll::EPipeContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                11 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EAssignContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EAssignContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1230);
                                        if !({ recog.precpred(None, 17) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 17)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_assign */
                                        recog.base.set_state(1231);
                                        recog.infix_assign()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1232);
                                        let tmp = recog.expression_rec(17)?;
                                        if let ExpressionContextAll::EAssignContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                12 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ESuffixContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1234);
                                        if !({ recog.precpred(None, 35) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 35)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_suffix */
                                        recog.base.set_state(1235);
                                        recog.op_suffix()?;
                                    }
                                }
                                13 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ESliceContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1236);
                                        if !({ recog.precpred(None, 34) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 34)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule slice_call */
                                        recog.base.set_state(1237);
                                        recog.slice_call()?;
                                    }
                                }
                                14 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EGenericContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1238);
                                        if !({ recog.precpred(None, 33) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 33)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call */
                                        recog.base.set_state(1239);
                                        recog.generic_call()?;
                                    }
                                }
                                15 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EClosureContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1240);
                                        if !({ recog.precpred(None, 32) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 32)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule closure_call */
                                        recog.base.set_state(1241);
                                        recog.closure_call()?;
                                    }
                                }
                                16 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EDotMatchContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1242);
                                        if !({ recog.precpred(None, 31) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 31)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1244);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == OP_AND_THEN {
                                            {
                                                recog.base.set_state(1243);
                                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                                            }
                                        }

                                        recog.base.set_state(1246);
                                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                                        recog.base.set_state(1247);
                                        _la = recog.base.input.la(1);
                                        if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                                            recog.err_handler.recover_inline(&mut recog.base)?;
                                        }
                                        else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog.err_handler.report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        recog.base.set_state(1253);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == KW_AS {
                                            {
                                                recog.base.set_state(1248);
                                                recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                                                /* InvokeRule identifier */
                                                recog.base.set_state(1249);
                                                recog.identifier()?;

                                                recog.base.set_state(1251);
                                                recog.err_handler.sync(&mut recog.base)?;
                                                _la = recog.base.input.la(1);
                                                if _la == COLON {
                                                    {
                                                        /* InvokeRule type_hint */
                                                        recog.base.set_state(1250);
                                                        recog.type_hint()?;
                                                    }
                                                }
                                            }
                                        }

                                        /* InvokeRule match_block */
                                        recog.base.set_state(1255);
                                        recog.match_block()?;
                                    }
                                }
                                17 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EIsAContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EIsAContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1256);
                                        if !({ recog.precpred(None, 22) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 22)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_is */
                                        recog.base.set_state(1257);
                                        recog.infix_is()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1258);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EIsAContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                18 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EAsContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EAsContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1260);
                                        if !({ recog.precpred(None, 21) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 21)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_as */
                                        recog.base.set_state(1261);
                                        recog.infix_as()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1262);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EAsContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1268);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(176, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- inline_expression ----------------
#[derive(Debug)]
pub enum Inline_expressionContextAll<'input> {
    ILogicContext(ILogicContext<'input>),
    IPlusContext(IPlusContext<'input>),
    ICompareContext(ICompareContext<'input>),
    IGenericContext(IGenericContext<'input>),
    IFunctionContext(IFunctionContext<'input>),
    IMapContext(IMapContext<'input>),
    IIsContext(IIsContext<'input>),
    ITupleContext(ITupleContext<'input>),
    IRangeContext(IRangeContext<'input>),
    IGroupContext(IGroupContext<'input>),
    IMulContext(IMulContext<'input>),
    IAsContext(IAsContext<'input>),
    IPrefixContext(IPrefixContext<'input>),
    IFloorContext(IFloorContext<'input>),
    IAtomContext(IAtomContext<'input>),
    ICeilingContext(ICeilingContext<'input>),
    ISliceContext(ISliceContext<'input>),
    Error(Inline_expressionContext<'input>),
}
antlr_rust::tid! {Inline_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Inline_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContextAll<'input> {}

impl<'input> Deref for Inline_expressionContextAll<'input> {
    type Target = dyn Inline_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Inline_expressionContextAll::*;
        match self {
            ILogicContext(inner) => inner,
            IPlusContext(inner) => inner,
            ICompareContext(inner) => inner,
            IGenericContext(inner) => inner,
            IFunctionContext(inner) => inner,
            IMapContext(inner) => inner,
            IIsContext(inner) => inner,
            ITupleContext(inner) => inner,
            IRangeContext(inner) => inner,
            IGroupContext(inner) => inner,
            IMulContext(inner) => inner,
            IAsContext(inner) => inner,
            IPrefixContext(inner) => inner,
            IFloorContext(inner) => inner,
            IAtomContext(inner) => inner,
            ICeilingContext(inner) => inner,
            ISliceContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Inline_expressionContext<'input> = BaseParserRuleContext<'input, Inline_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Inline_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Inline_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}
antlr_rust::tid! {Inline_expressionContextExt<'a>}

impl<'input> Inline_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Inline_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Inline_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Inline_expressionContextExt<'input>>
{
}

impl<'input> Inline_expressionContextAttrs<'input> for Inline_expressionContext<'input> {}

pub type ILogicContext<'input> = BaseParserRuleContext<'input, ILogicContextExt<'input>>;

pub trait ILogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ILogicContextAttrs<'input> for ILogicContext<'input> {}

pub struct ILogicContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ILogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ILogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ILogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ILogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ILogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ILogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ILogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ILogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ILogicContext<'input> {}

impl<'input> ILogicContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ILogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ILogicContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPlusContext<'input> = BaseParserRuleContext<'input, IPlusContextExt<'input>>;

pub trait IPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IPlusContextAttrs<'input> for IPlusContext<'input> {}

pub struct IPlusContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPlusContext<'input> {}

impl<'input> IPlusContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            IPlusContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ICompareContext<'input> = BaseParserRuleContext<'input, ICompareContextExt<'input>>;

pub trait ICompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ICompareContextAttrs<'input> for ICompareContext<'input> {}

pub struct ICompareContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ICompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ICompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ICompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ICompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ICompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ICompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ICompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ICompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ICompareContext<'input> {}

impl<'input> ICompareContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ICompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ICompareContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IGenericContext<'input> = BaseParserRuleContext<'input, IGenericContextExt<'input>>;

pub trait IGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call(&self) -> Option<Rc<Generic_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IGenericContextAttrs<'input> for IGenericContext<'input> {}

pub struct IGenericContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for IGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IGenericContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IGenericContext<'input> {}

impl<'input> IGenericContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            IGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IFunctionContext<'input> = BaseParserRuleContext<'input, IFunctionContextExt<'input>>;

pub trait IFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IFunctionContextAttrs<'input> for IFunctionContext<'input> {}

pub struct IFunctionContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for IFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IFunctionContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IFunctionContext<'input> {}

impl<'input> IFunctionContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            IFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IMapContext<'input> = BaseParserRuleContext<'input, IMapContextExt<'input>>;

pub trait IMapContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_map(&self) -> Option<Rc<Infix_mapContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IMapContextAttrs<'input> for IMapContext<'input> {}

pub struct IMapContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IMapContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IMapContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IMapContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IMap(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IMap(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IMapContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IMap(self);
    }
}

impl<'input> CustomRuleContext<'input> for IMapContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IMapContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IMapContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IMapContext<'input> {}

impl<'input> IMapContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IMapContext(BaseParserRuleContext::copy_from(
            ctx,
            IMapContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IIsContext<'input> = BaseParserRuleContext<'input, IIsContextExt<'input>>;

pub trait IIsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_is(&self) -> Option<Rc<Infix_isContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IIsContextAttrs<'input> for IIsContext<'input> {}

pub struct IIsContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IIsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IIsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IIsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IIs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IIs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IIsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IIs(self);
    }
}

impl<'input> CustomRuleContext<'input> for IIsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IIsContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IIsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IIsContext<'input> {}

impl<'input> IIsContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IIsContext(BaseParserRuleContext::copy_from(
            ctx,
            IIsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ITupleContext<'input> = BaseParserRuleContext<'input, ITupleContextExt<'input>>;

pub trait ITupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn tuple_literal(&self) -> Option<Rc<Tuple_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ITupleContextAttrs<'input> for ITupleContext<'input> {}

pub struct ITupleContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ITupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ITupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ITupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ITuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ITuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ITupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ITuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for ITupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ITupleContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ITupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ITupleContext<'input> {}

impl<'input> ITupleContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ITupleContext(BaseParserRuleContext::copy_from(
            ctx,
            ITupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IRangeContext<'input> = BaseParserRuleContext<'input, IRangeContextExt<'input>>;

pub trait IRangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn infix_range(&self) -> Option<Rc<Infix_rangeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IRangeContextAttrs<'input> for IRangeContext<'input> {}

pub struct IRangeContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IRangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IRangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IRangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IRange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IRange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IRangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IRange(self);
    }
}

impl<'input> CustomRuleContext<'input> for IRangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IRangeContext<'input> {}

impl<'input> IRangeContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IRangeContext(BaseParserRuleContext::copy_from(
            ctx,
            IRangeContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IGroupContext<'input> = BaseParserRuleContext<'input, IGroupContextExt<'input>>;

pub trait IGroupContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
}

impl<'input> IGroupContextAttrs<'input> for IGroupContext<'input> {}

pub struct IGroupContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IGroupContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IGroupContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IGroupContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IGroup(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IGroup(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IGroupContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IGroup(self);
    }
}

impl<'input> CustomRuleContext<'input> for IGroupContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IGroupContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IGroupContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IGroupContext<'input> {}

impl<'input> IGroupContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IGroupContext(BaseParserRuleContext::copy_from(
            ctx,
            IGroupContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IMulContext<'input> = BaseParserRuleContext<'input, IMulContextExt<'input>>;

pub trait IMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IMulContextAttrs<'input> for IMulContext<'input> {}

pub struct IMulContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for IMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IMulContext<'input> {}

impl<'input> IMulContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IMulContext(BaseParserRuleContext::copy_from(
            ctx,
            IMulContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IAsContext<'input> = BaseParserRuleContext<'input, IAsContextExt<'input>>;

pub trait IAsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_as(&self) -> Option<Rc<Infix_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IAsContextAttrs<'input> for IAsContext<'input> {}

pub struct IAsContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IAsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IAsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IAsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IAs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IAs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IAsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IAs(self);
    }
}

impl<'input> CustomRuleContext<'input> for IAsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IAsContext<'input> {}

impl<'input> IAsContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IAsContext(BaseParserRuleContext::copy_from(
            ctx,
            IAsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPrefixContext<'input> = BaseParserRuleContext<'input, IPrefixContextExt<'input>>;

pub trait IPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IPrefixContextAttrs<'input> for IPrefixContext<'input> {}

pub struct IPrefixContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPrefixContext<'input> {}

impl<'input> IPrefixContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            IPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IFloorContext<'input> = BaseParserRuleContext<'input, IFloorContextExt<'input>>;

pub trait IFloorContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token FLOOR_L
    /// Returns `None` if there is no child corresponding to token FLOOR_L
    fn FLOOR_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FLOOR_R
    /// Returns `None` if there is no child corresponding to token FLOOR_R
    fn FLOOR_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_R, 0)
    }
}

impl<'input> IFloorContextAttrs<'input> for IFloorContext<'input> {}

pub struct IFloorContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IFloorContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IFloorContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IFloorContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IFloor(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IFloor(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IFloorContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IFloor(self);
    }
}

impl<'input> CustomRuleContext<'input> for IFloorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IFloorContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IFloorContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IFloorContext<'input> {}

impl<'input> IFloorContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IFloorContext(BaseParserRuleContext::copy_from(
            ctx,
            IFloorContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IAtomContext<'input> = BaseParserRuleContext<'input, IAtomContextExt<'input>>;

pub trait IAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IAtomContextAttrs<'input> for IAtomContext<'input> {}

pub struct IAtomContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for IAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IAtomContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IAtomContext<'input> {}

impl<'input> IAtomContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            IAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ICeilingContext<'input> = BaseParserRuleContext<'input, ICeilingContextExt<'input>>;

pub trait ICeilingContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CEILING_L
    /// Returns `None` if there is no child corresponding to token CEILING_L
    fn CEILING_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token CEILING_R
    /// Returns `None` if there is no child corresponding to token CEILING_R
    fn CEILING_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_R, 0)
    }
}

impl<'input> ICeilingContextAttrs<'input> for ICeilingContext<'input> {}

pub struct ICeilingContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ICeilingContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ICeilingContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ICeilingContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ICeiling(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ICeiling(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ICeilingContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ICeiling(self);
    }
}

impl<'input> CustomRuleContext<'input> for ICeilingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ICeilingContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ICeilingContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ICeilingContext<'input> {}

impl<'input> ICeilingContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ICeilingContext(BaseParserRuleContext::copy_from(
            ctx,
            ICeilingContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ISliceContext<'input> = BaseParserRuleContext<'input, ISliceContextExt<'input>>;

pub trait ISliceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ISliceContextAttrs<'input> for ISliceContext<'input> {}

pub struct ISliceContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ISliceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ISliceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ISliceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ISlice(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ISlice(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ISliceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ISlice(self);
    }
}

impl<'input> CustomRuleContext<'input> for ISliceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ISliceContext<'input> {}

impl<'input> ISliceContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ISliceContext(BaseParserRuleContext::copy_from(
            ctx,
            ISliceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn inline_expression(&mut self) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        self.inline_expression_rec(0)
    }

    fn inline_expression_rec(&mut self, _p: isize) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Inline_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 114, RULE_inline_expression, _p);
        let mut _localctx: Rc<Inline_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 114;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1288);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(177, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = IPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(1270);
                            recog.op_prefix()?;

                            /* InvokeRule inline_expression */
                            recog.base.set_state(1271);
                            recog.inline_expression_rec(18)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = IGroupContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1273);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1274);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1275);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = IFloorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1277);
                            recog.base.match_token(FLOOR_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1278);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1279);
                            recog.base.match_token(FLOOR_R, &mut recog.err_handler)?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = ICeilingContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1281);
                            recog.base.match_token(CEILING_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1282);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1283);
                            recog.base.match_token(CEILING_R, &mut recog.err_handler)?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = ITupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule tuple_literal */
                            recog.base.set_state(1285);
                            recog.tuple_literal()?;
                        }
                    }
                    6 => {
                        {
                            let mut tmp = IRangeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule range_literal */
                            recog.base.set_state(1286);
                            recog.range_literal()?;
                        }
                    }
                    7 => {
                        {
                            let mut tmp = IAtomContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1287);
                            recog.atomic()?;
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1330);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(179, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1328);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(178, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IMulContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IMulContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1290);
                                        if !({ recog.precpred(None, 14) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 14)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(1291);
                                        recog.op_multiple()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1292);
                                        let tmp = recog.inline_expression_rec(15)?;
                                        if let Inline_expressionContextAll::IMulContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IPlusContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IPlusContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1294);
                                        if !({ recog.precpred(None, 13) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 13)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(1295);
                                        recog.op_plus()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1296);
                                        let tmp = recog.inline_expression_rec(14)?;
                                        if let Inline_expressionContextAll::IPlusContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ILogicContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::ILogicContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1298);
                                        if !({ recog.precpred(None, 12) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 12)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(1299);
                                        recog.op_logic()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1300);
                                        let tmp = recog.inline_expression_rec(13)?;
                                        if let Inline_expressionContextAll::ILogicContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IMapContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IMapContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1302);
                                        if !({ recog.precpred(None, 11) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 11)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_map */
                                        recog.base.set_state(1303);
                                        recog.infix_map()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1304);
                                        let tmp = recog.inline_expression_rec(12)?;
                                        if let Inline_expressionContextAll::IMapContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ICompareContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::ICompareContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1306);
                                        if !({ recog.precpred(None, 10) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 10)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1307);
                                        recog.op_compare()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1308);
                                        let tmp = recog.inline_expression_rec(11)?;
                                        if let Inline_expressionContextAll::ICompareContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IRangeContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IRangeContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1310);
                                        if !({ recog.precpred(None, 7) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 7)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_range */
                                        recog.base.set_state(1311);
                                        recog.infix_range()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1312);
                                        let tmp = recog.inline_expression_rec(8)?;
                                        if let Inline_expressionContextAll::IRangeContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IFunctionContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1314);
                                        if !({ recog.precpred(None, 17) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 17)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule function_call */
                                        recog.base.set_state(1315);
                                        recog.function_call()?;
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IGenericContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1316);
                                        if !({ recog.precpred(None, 16) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 16)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call */
                                        recog.base.set_state(1317);
                                        recog.generic_call()?;
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ISliceContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1318);
                                        if !({ recog.precpred(None, 15) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 15)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule slice_call */
                                        recog.base.set_state(1319);
                                        recog.slice_call()?;
                                    }
                                }
                                10 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IIsContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IIsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1320);
                                        if !({ recog.precpred(None, 9) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 9)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_is */
                                        recog.base.set_state(1321);
                                        recog.infix_is()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1322);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let Inline_expressionContextAll::IIsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                11 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IAsContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IAsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1324);
                                        if !({ recog.precpred(None, 8) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 8)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_as */
                                        recog.base.set_state(1325);
                                        recog.infix_as()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1326);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let Inline_expressionContextAll::IAsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1332);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(179, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- type_expression ----------------
#[derive(Debug)]
pub enum Type_expressionContextAll<'input> {
    TPrefixContext(TPrefixContext<'input>),
    TGenericContext(TGenericContext<'input>),
    TPatternContext(TPatternContext<'input>),
    TTupleContext(TTupleContext<'input>),
    TMustContext(TMustContext<'input>),
    TAtomContext(TAtomContext<'input>),
    TAddContext(TAddContext<'input>),
    TArrowsContext(TArrowsContext<'input>),
    TOptionalContext(TOptionalContext<'input>),
    Error(Type_expressionContext<'input>),
}
antlr_rust::tid! {Type_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Type_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContextAll<'input> {}

impl<'input> Deref for Type_expressionContextAll<'input> {
    type Target = dyn Type_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Type_expressionContextAll::*;
        match self {
            TPrefixContext(inner) => inner,
            TGenericContext(inner) => inner,
            TPatternContext(inner) => inner,
            TTupleContext(inner) => inner,
            TMustContext(inner) => inner,
            TAtomContext(inner) => inner,
            TAddContext(inner) => inner,
            TArrowsContext(inner) => inner,
            TOptionalContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Type_expressionContext<'input> = BaseParserRuleContext<'input, Type_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Type_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Type_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}
antlr_rust::tid! {Type_expressionContextExt<'a>}

impl<'input> Type_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Type_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Type_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Type_expressionContextExt<'input>>
{
}

impl<'input> Type_expressionContextAttrs<'input> for Type_expressionContext<'input> {}

pub type TPrefixContext<'input> = BaseParserRuleContext<'input, TPrefixContextExt<'input>>;

pub trait TPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TPrefixContextAttrs<'input> for TPrefixContext<'input> {}

pub struct TPrefixContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for TPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TPrefixContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TPrefixContext<'input> {}

impl<'input> TPrefixContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            TPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TGenericContext<'input> = BaseParserRuleContext<'input, TGenericContextExt<'input>>;

pub trait TGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TGenericContextAttrs<'input> for TGenericContext<'input> {}

pub struct TGenericContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for TGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TGenericContext<'input> {}

impl<'input> TGenericContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            TGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TPatternContext<'input> = BaseParserRuleContext<'input, TPatternContextExt<'input>>;

pub trait TPatternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_pattern(&self) -> Option<Rc<Op_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TPatternContextAttrs<'input> for TPatternContext<'input> {}

pub struct TPatternContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TPatternContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TPatternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TPattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TPattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TPatternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TPattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for TPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TPatternContext<'input> {}

impl<'input> TPatternContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TPatternContext(BaseParserRuleContext::copy_from(
            ctx,
            TPatternContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TTupleContext<'input> = BaseParserRuleContext<'input, TTupleContextExt<'input>>;

pub trait TTupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> TTupleContextAttrs<'input> for TTupleContext<'input> {}

pub struct TTupleContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TTupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TTupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TTupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TTuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TTuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TTupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TTuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for TTupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TTupleContext<'input> {}

impl<'input> TTupleContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TTupleContext(BaseParserRuleContext::copy_from(
            ctx,
            TTupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TMustContext<'input> = BaseParserRuleContext<'input, TMustContextExt<'input>>;

pub trait TMustContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BANG
    /// Returns `None` if there is no child corresponding to token OP_BANG
    fn OP_BANG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BANG, 0)
    }
}

impl<'input> TMustContextAttrs<'input> for TMustContext<'input> {}

pub struct TMustContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TMustContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TMustContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TMustContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TMust(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TMust(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TMustContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TMust(self);
    }
}

impl<'input> CustomRuleContext<'input> for TMustContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TMustContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TMustContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TMustContext<'input> {}

impl<'input> TMustContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TMustContext(BaseParserRuleContext::copy_from(
            ctx,
            TMustContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TAtomContext<'input> = BaseParserRuleContext<'input, TAtomContextExt<'input>>;

pub trait TAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TAtomContextAttrs<'input> for TAtomContext<'input> {}

pub struct TAtomContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for TAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TAtomContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TAtomContext<'input> {}

impl<'input> TAtomContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            TAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TAddContext<'input> = BaseParserRuleContext<'input, TAddContextExt<'input>>;

pub trait TAddContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> TAddContextAttrs<'input> for TAddContext<'input> {}

pub struct TAddContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TAddContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TAddContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TAddContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TAdd(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TAdd(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TAddContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TAdd(self);
    }
}

impl<'input> CustomRuleContext<'input> for TAddContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TAddContext<'input> {}

impl<'input> TAddContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TAddContext(BaseParserRuleContext::copy_from(
            ctx,
            TAddContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TArrowsContext<'input> = BaseParserRuleContext<'input, TArrowsContextExt<'input>>;

pub trait TArrowsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn infix_arrows(&self) -> Option<Rc<Infix_arrowsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TArrowsContextAttrs<'input> for TArrowsContext<'input> {}

pub struct TArrowsContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TArrowsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TArrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TArrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TArrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TArrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TArrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TArrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for TArrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TArrowsContext<'input> {}

impl<'input> TArrowsContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TArrowsContext(BaseParserRuleContext::copy_from(
            ctx,
            TArrowsContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TOptionalContext<'input> = BaseParserRuleContext<'input, TOptionalContextExt<'input>>;

pub trait TOptionalContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
}

impl<'input> TOptionalContextAttrs<'input> for TOptionalContext<'input> {}

pub struct TOptionalContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TOptionalContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TOptionalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TOptionalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TOptional(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TOptional(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TOptionalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TOptional(self);
    }
}

impl<'input> CustomRuleContext<'input> for TOptionalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TOptionalContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TOptionalContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TOptionalContext<'input> {}

impl<'input> TOptionalContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TOptionalContext(BaseParserRuleContext::copy_from(
            ctx,
            TOptionalContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_expression(&mut self) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        self.type_expression_rec(0)
    }

    fn type_expression_rec(&mut self, _p: isize) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Type_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 116, RULE_type_expression, _p);
        let mut _localctx: Rc<Type_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 116;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1355);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    OP_ADD | OP_SUB | OP_MUL | OP_BANG | OP_NOT | OP_AND | OP_DOT3 | OP_DOT2 | OP_INVERSE | OP_ROOT2
                    | OP_ROOT3 | OP_ROOT4 | OP_REFERENCE => {
                        {
                            let mut tmp = TPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(1334);
                            recog.op_prefix()?;

                            /* InvokeRule type_expression */
                            recog.base.set_state(1335);
                            recog.type_expression_rec(10)?;
                        }
                    }

                    PARENTHESES_L => {
                        {
                            let mut tmp = TTupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1337);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            recog.base.set_state(1351);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(182, &mut recog.base)? {
                                x if x == 1 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1338);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1339);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }

                                x if x == 2 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1341);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1344);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = 1;
                                        loop {
                                            match _alt {
                                                x if x == 1 => {
                                                    {
                                                        recog.base.set_state(1342);
                                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                        /* InvokeRule type_expression */
                                                        recog.base.set_state(1343);
                                                        recog.type_expression_rec(0)?;
                                                    }
                                                }

                                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                            }
                                            recog.base.set_state(1346);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _alt = recog.interpreter.adaptive_predict(180, &mut recog.base)?;
                                            if _alt == 2 || _alt == INVALID_ALT {
                                                break;
                                            }
                                        }
                                        recog.base.set_state(1349);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == COMMA {
                                            {
                                                recog.base.set_state(1348);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                            }
                                        }
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(1353);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }

                    LAMBDA_SLOT | OP_PERCENT | OP_OUTPUT | OP_LAST | INTEGER | DECIMAL | STRING_START | SPECIAL | RAW_ID
                    | UNICODE_ID => {
                        {
                            let mut tmp = TAtomContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1354);
                            recog.atomic()?;
                        }
                    }

                    _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1378);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(185, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1376);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(184, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TPatternContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1357);
                                        if !({ recog.precpred(None, 6) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 6)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_pattern */
                                        recog.base.set_state(1358);
                                        recog.op_pattern()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1359);
                                        recog.type_expression_rec(7)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TArrowsContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1361);
                                        if !({ recog.precpred(None, 5) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 5)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_arrows */
                                        recog.base.set_state(1362);
                                        recog.infix_arrows()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1363);
                                        recog.type_expression_rec(6)?;
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TAddContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1365);
                                        if !({ recog.precpred(None, 4) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 4)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1366);
                                        recog.base.match_token(OP_ADD, &mut recog.err_handler)?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1367);
                                        recog.type_expression_rec(5)?;
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TOptionalContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1368);
                                        if !({ recog.precpred(None, 9) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 9)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1369);
                                        recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TMustContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1370);
                                        if !({ recog.precpred(None, 8) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 8)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1371);
                                        recog.base.match_token(OP_BANG, &mut recog.err_handler)?;
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TGenericContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1372);
                                        if !({ recog.precpred(None, 7) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 7)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call_in_type */
                                        recog.base.set_state(1373);
                                        recog.generic_call_in_type()?;
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TGenericContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1374);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call_in_type */
                                        recog.base.set_state(1375);
                                        recog.generic_call_in_type()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1380);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(185, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- atomic ----------------
#[derive(Debug)]
pub enum AtomicContextAll<'input> {
    ASpecialContext(ASpecialContext<'input>),
    ALambdaContext(ALambdaContext<'input>),
    ANumberContext(ANumberContext<'input>),
    AOutputContext(AOutputContext<'input>),
    AStringContext(AStringContext<'input>),
    ANamepathContext(ANamepathContext<'input>),
    Error(AtomicContext<'input>),
}
antlr_rust::tid! {AtomicContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for AtomicContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for AtomicContextAll<'input> {}

impl<'input> Deref for AtomicContextAll<'input> {
    type Target = dyn AtomicContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use AtomicContextAll::*;
        match self {
            ASpecialContext(inner) => inner,
            ALambdaContext(inner) => inner,
            ANumberContext(inner) => inner,
            AOutputContext(inner) => inner,
            AStringContext(inner) => inner,
            ANamepathContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AtomicContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AtomicContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type AtomicContext<'input> = BaseParserRuleContext<'input, AtomicContextExt<'input>>;

#[derive(Clone)]
pub struct AtomicContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for AtomicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AtomicContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AtomicContext<'input> {}

impl<'input> CustomRuleContext<'input> for AtomicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}
antlr_rust::tid! {AtomicContextExt<'a>}

impl<'input> AtomicContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            AtomicContextExt { ph: PhantomData },
        )))
    }
}

pub trait AtomicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<AtomicContextExt<'input>> {}

impl<'input> AtomicContextAttrs<'input> for AtomicContext<'input> {}

pub type ASpecialContext<'input> = BaseParserRuleContext<'input, ASpecialContextExt<'input>>;

pub trait ASpecialContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> ASpecialContextAttrs<'input> for ASpecialContext<'input> {}

pub struct ASpecialContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ASpecialContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ASpecialContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ASpecialContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ASpecial(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ASpecial(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ASpecialContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ASpecial(self);
    }
}

impl<'input> CustomRuleContext<'input> for ASpecialContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ASpecialContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ASpecialContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ASpecialContext<'input> {}

impl<'input> ASpecialContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ASpecialContext(BaseParserRuleContext::copy_from(
            ctx,
            ASpecialContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ALambdaContext<'input> = BaseParserRuleContext<'input, ALambdaContextExt<'input>>;

pub trait ALambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn lambda_name(&self) -> Option<Rc<Lambda_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ALambdaContextAttrs<'input> for ALambdaContext<'input> {}

pub struct ALambdaContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ALambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ALambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ALambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ALambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ALambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ALambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ALambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for ALambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ALambdaContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ALambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ALambdaContext<'input> {}

impl<'input> ALambdaContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ALambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            ALambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ANumberContext<'input> = BaseParserRuleContext<'input, ANumberContextExt<'input>>;

pub trait ANumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ANumberContextAttrs<'input> for ANumberContext<'input> {}

pub struct ANumberContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ANumberContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ANumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ANumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ANumber(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ANumber(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ANumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ANumber(self);
    }
}

impl<'input> CustomRuleContext<'input> for ANumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ANumberContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ANumberContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ANumberContext<'input> {}

impl<'input> ANumberContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ANumberContext(BaseParserRuleContext::copy_from(
            ctx,
            ANumberContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type AOutputContext<'input> = BaseParserRuleContext<'input, AOutputContextExt<'input>>;

pub trait AOutputContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn output_name(&self) -> Option<Rc<Output_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AOutputContextAttrs<'input> for AOutputContext<'input> {}

pub struct AOutputContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AOutputContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for AOutputContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AOutputContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_AOutput(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_AOutput(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AOutputContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_AOutput(self);
    }
}

impl<'input> CustomRuleContext<'input> for AOutputContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for AOutputContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for AOutputContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for AOutputContext<'input> {}

impl<'input> AOutputContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::AOutputContext(BaseParserRuleContext::copy_from(
            ctx,
            AOutputContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type AStringContext<'input> = BaseParserRuleContext<'input, AStringContextExt<'input>>;

pub trait AStringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AStringContextAttrs<'input> for AStringContext<'input> {}

pub struct AStringContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AStringContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for AStringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AStringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_AString(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_AString(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AStringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_AString(self);
    }
}

impl<'input> CustomRuleContext<'input> for AStringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for AStringContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for AStringContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for AStringContext<'input> {}

impl<'input> AStringContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::AStringContext(BaseParserRuleContext::copy_from(
            ctx,
            AStringContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ANamepathContext<'input> = BaseParserRuleContext<'input, ANamepathContextExt<'input>>;

pub trait ANamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ANamepathContextAttrs<'input> for ANamepathContext<'input> {}

pub struct ANamepathContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ANamepathContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ANamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ANamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ANamepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ANamepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ANamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ANamepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for ANamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ANamepathContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ANamepathContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ANamepathContext<'input> {}

impl<'input> ANamepathContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ANamepathContext(BaseParserRuleContext::copy_from(
            ctx,
            ANamepathContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn atomic(&mut self) -> Result<Rc<AtomicContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = AtomicContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_atomic);
        let mut _localctx: Rc<AtomicContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1387);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(186, &mut recog.base)? {
                1 => {
                    let tmp = AStringContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule string_literal */
                        recog.base.set_state(1381);
                        recog.string_literal()?;
                    }
                }
                2 => {
                    let tmp = ANumberContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /* InvokeRule number_literal */
                        recog.base.set_state(1382);
                        recog.number_literal()?;
                    }
                }
                3 => {
                    let tmp = ALambdaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule lambda_name */
                        recog.base.set_state(1383);
                        recog.lambda_name()?;
                    }
                }
                4 => {
                    let tmp = AOutputContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /* InvokeRule output_name */
                        recog.base.set_state(1384);
                        recog.output_name()?;
                    }
                }
                5 => {
                    let tmp = ANamepathContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1385);
                        recog.namepath()?;
                    }
                }
                6 => {
                    let tmp = ASpecialContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1386);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- control_expression ----------------
#[derive(Debug)]
pub enum Control_expressionContextAll<'input> {
    CBreakContext(CBreakContext<'input>),
    CWithContext(CWithContext<'input>),
    CYieldContext(CYieldContext<'input>),
    CReturnContext(CReturnContext<'input>),
    CRaiseContext(CRaiseContext<'input>),
    CContinueContext(CContinueContext<'input>),
    CFallContext(CFallContext<'input>),
    Error(Control_expressionContext<'input>),
}
antlr_rust::tid! {Control_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Control_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Control_expressionContextAll<'input> {}

impl<'input> Deref for Control_expressionContextAll<'input> {
    type Target = dyn Control_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Control_expressionContextAll::*;
        match self {
            CBreakContext(inner) => inner,
            CWithContext(inner) => inner,
            CYieldContext(inner) => inner,
            CReturnContext(inner) => inner,
            CRaiseContext(inner) => inner,
            CContinueContext(inner) => inner,
            CFallContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Control_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Control_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Control_expressionContext<'input> = BaseParserRuleContext<'input, Control_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Control_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Control_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Control_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Control_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Control_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}
antlr_rust::tid! {Control_expressionContextExt<'a>}

impl<'input> Control_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Control_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Control_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Control_expressionContextExt<'input>>
{
}

impl<'input> Control_expressionContextAttrs<'input> for Control_expressionContext<'input> {}

pub type CBreakContext<'input> = BaseParserRuleContext<'input, CBreakContextExt<'input>>;

pub trait CBreakContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BREAK
    /// Returns `None` if there is no child corresponding to token BREAK
    fn BREAK(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BREAK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
}

impl<'input> CBreakContextAttrs<'input> for CBreakContext<'input> {}

pub struct CBreakContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CBreakContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CBreakContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CBreakContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CBreak(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CBreak(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CBreakContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CBreak(self);
    }
}

impl<'input> CustomRuleContext<'input> for CBreakContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CBreakContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CBreakContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CBreakContext<'input> {}

impl<'input> CBreakContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CBreakContext(BaseParserRuleContext::copy_from(
            ctx,
            CBreakContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CWithContext<'input> = BaseParserRuleContext<'input, CWithContextExt<'input>>;

pub trait CWithContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CWithContextAttrs<'input> for CWithContext<'input> {}

pub struct CWithContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CWithContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CWithContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CWithContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CWith(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CWithContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CWith(self);
    }
}

impl<'input> CustomRuleContext<'input> for CWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CWithContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CWithContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CWithContext<'input> {}

impl<'input> CWithContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CWithContext(BaseParserRuleContext::copy_from(
            ctx,
            CWithContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CYieldContext<'input> = BaseParserRuleContext<'input, CYieldContextExt<'input>>;

pub trait CYieldContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CYieldContextAttrs<'input> for CYieldContext<'input> {}

pub struct CYieldContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CYieldContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CYieldContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CYieldContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CYield(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CYield(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CYieldContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CYield(self);
    }
}

impl<'input> CustomRuleContext<'input> for CYieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CYieldContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CYieldContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CYieldContext<'input> {}

impl<'input> CYieldContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CYieldContext(BaseParserRuleContext::copy_from(
            ctx,
            CYieldContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CReturnContext<'input> = BaseParserRuleContext<'input, CReturnContextExt<'input>>;

pub trait CReturnContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token RETURN
    /// Returns `None` if there is no child corresponding to token RETURN
    fn RETURN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESUME
    /// Returns `None` if there is no child corresponding to token RESUME
    fn RESUME(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESUME, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CReturnContextAttrs<'input> for CReturnContext<'input> {}

pub struct CReturnContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CReturnContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CReturnContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CReturnContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CReturn(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CReturn(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CReturnContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CReturn(self);
    }
}

impl<'input> CustomRuleContext<'input> for CReturnContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CReturnContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CReturnContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CReturnContext<'input> {}

impl<'input> CReturnContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CReturnContext(BaseParserRuleContext::copy_from(
            ctx,
            CReturnContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CRaiseContext<'input> = BaseParserRuleContext<'input, CRaiseContextExt<'input>>;

pub trait CRaiseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token RAISE
    /// Returns `None` if there is no child corresponding to token RAISE
    fn RAISE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAISE, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CRaiseContextAttrs<'input> for CRaiseContext<'input> {}

pub struct CRaiseContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CRaiseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CRaiseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CRaiseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CRaise(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CRaise(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CRaiseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CRaise(self);
    }
}

impl<'input> CustomRuleContext<'input> for CRaiseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CRaiseContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CRaiseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CRaiseContext<'input> {}

impl<'input> CRaiseContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CRaiseContext(BaseParserRuleContext::copy_from(
            ctx,
            CRaiseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CContinueContext<'input> = BaseParserRuleContext<'input, CContinueContextExt<'input>>;

pub trait CContinueContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CONTINUE
    /// Returns `None` if there is no child corresponding to token CONTINUE
    fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CONTINUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CContinueContextAttrs<'input> for CContinueContext<'input> {}

pub struct CContinueContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CContinueContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CContinueContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CContinueContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CContinue(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CContinue(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CContinueContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CContinue(self);
    }
}

impl<'input> CustomRuleContext<'input> for CContinueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CContinueContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CContinueContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CContinueContext<'input> {}

impl<'input> CContinueContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CContinueContext(BaseParserRuleContext::copy_from(
            ctx,
            CContinueContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CFallContext<'input> = BaseParserRuleContext<'input, CFallContextExt<'input>>;

pub trait CFallContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token FALL_THROUGH
    /// Returns `None` if there is no child corresponding to token FALL_THROUGH
    fn FALL_THROUGH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FALL_THROUGH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CFallContextAttrs<'input> for CFallContext<'input> {}

pub struct CFallContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CFallContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CFallContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CFallContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CFall(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CFall(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CFallContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CFall(self);
    }
}

impl<'input> CustomRuleContext<'input> for CFallContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CFallContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CFallContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CFallContext<'input> {}

impl<'input> CFallContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CFallContext(BaseParserRuleContext::copy_from(
            ctx,
            CFallContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn control_expression(&mut self) -> Result<Rc<Control_expressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Control_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_control_expression);
        let mut _localctx: Rc<Control_expressionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1428);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(195, &mut recog.base)? {
                1 => {
                    let tmp = CReturnContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1394);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            RETURN => {
                                recog.base.set_state(1389);
                                recog.base.match_token(RETURN, &mut recog.err_handler)?;
                            }

                            RESUME => {
                                {
                                    recog.base.set_state(1390);
                                    recog.base.match_token(RESUME, &mut recog.err_handler)?;

                                    recog.base.set_state(1392);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    match recog.interpreter.adaptive_predict(187, &mut recog.base)? {
                                        x if x == 1 => {
                                            {
                                                /* InvokeRule expression */
                                                recog.base.set_state(1391);
                                                recog.expression_rec(0)?;
                                            }
                                        }

                                        _ => {}
                                    }
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                2 => {
                    let tmp = CBreakContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1396);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;

                        recog.base.set_state(1399);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(189, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1397);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1398);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                3 => {
                    let tmp = CContinueContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1401);
                        recog.base.match_token(CONTINUE, &mut recog.err_handler)?;

                        recog.base.set_state(1404);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(190, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1402);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1403);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    let tmp = CRaiseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1406);
                        recog.base.match_token(RAISE, &mut recog.err_handler)?;

                        recog.base.set_state(1408);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(191, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule expression */
                                    recog.base.set_state(1407);
                                    recog.expression_rec(0)?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                5 => {
                    let tmp = CYieldContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1410);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1413);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(192, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1411);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1412);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(1416);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(193, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule expression */
                                    recog.base.set_state(1415);
                                    recog.expression_rec(0)?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                6 => {
                    let tmp = CBreakContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1418);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1419);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    let tmp = CWithContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1420);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1421);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1422);
                        recog.expression_rec(0)?;
                    }
                }
                8 => {
                    let tmp = CFallContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 8);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1423);
                        recog.base.match_token(FALL_THROUGH, &mut recog.err_handler)?;

                        recog.base.set_state(1426);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(194, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1424);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1425);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_prefix ----------------
pub type Op_prefixContextAll<'input> = Op_prefixContext<'input>;

pub type Op_prefixContext<'input> = BaseParserRuleContext<'input, Op_prefixContextExt<'input>>;

#[derive(Clone)]
pub struct Op_prefixContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_prefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_prefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_prefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_prefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_prefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_prefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_prefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_prefix
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_prefix }
}
antlr_rust::tid! {Op_prefixContextExt<'a>}

impl<'input> Op_prefixContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_prefixContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_prefixContextExt { ph: PhantomData }))
    }
}

pub trait Op_prefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_prefixContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_NOT
    /// Returns `None` if there is no child corresponding to token OP_NOT
    fn OP_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BANG
    /// Returns `None` if there is no child corresponding to token OP_BANG
    fn OP_BANG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BANG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REFERENCE
    /// Returns `None` if there is no child corresponding to token OP_REFERENCE
    fn OP_REFERENCE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REFERENCE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT2
    /// Returns `None` if there is no child corresponding to token OP_DOT2
    fn OP_DOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT3
    /// Returns `None` if there is no child corresponding to token OP_DOT3
    fn OP_DOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT3, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_INVERSE
    /// Returns `None` if there is no child corresponding to token OP_INVERSE
    fn OP_INVERSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_INVERSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT2
    /// Returns `None` if there is no child corresponding to token OP_ROOT2
    fn OP_ROOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT3
    /// Returns `None` if there is no child corresponding to token OP_ROOT3
    fn OP_ROOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT3, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT4
    /// Returns `None` if there is no child corresponding to token OP_ROOT4
    fn OP_ROOT4(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT4, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Op_prefixContextAttrs<'input> for Op_prefixContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_prefix(&mut self) -> Result<Rc<Op_prefixContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_prefixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_op_prefix);
        let mut _localctx: Rc<Op_prefixContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1430);
                _la = recog.base.input.la(1);
                if {
                    !((((_la) & !0x3f) == 0
                        && ((1usize << _la) & ((1usize << OP_ADD) | (1usize << OP_SUB) | (1usize << OP_MUL))) != 0)
                        || (((_la - 58) & !0x3f) == 0
                            && ((1usize << (_la - 58))
                                & ((1usize << (OP_BANG - 58)) | (1usize << (OP_NOT - 58)) | (1usize << (OP_AND - 58))))
                                != 0)
                        || (((_la - 93) & !0x3f) == 0
                            && ((1usize << (_la - 93))
                                & ((1usize << (OP_DOT3 - 93))
                                    | (1usize << (OP_DOT2 - 93))
                                    | (1usize << (OP_INVERSE - 93))
                                    | (1usize << (OP_ROOT2 - 93))
                                    | (1usize << (OP_ROOT3 - 93))
                                    | (1usize << (OP_ROOT4 - 93))
                                    | (1usize << (OP_REFERENCE - 93))))
                                != 0))
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_suffix ----------------
pub type Op_suffixContextAll<'input> = Op_suffixContext<'input>;

pub type Op_suffixContext<'input> = BaseParserRuleContext<'input, Op_suffixContextExt<'input>>;

#[derive(Clone)]
pub struct Op_suffixContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_suffixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_suffixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_suffix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_suffix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_suffixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_suffix(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_suffixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_suffix
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_suffix }
}
antlr_rust::tid! {Op_suffixContextExt<'a>}

impl<'input> Op_suffixContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_suffixContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_suffixContextExt { ph: PhantomData }))
    }
}

pub trait Op_suffixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_suffixContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_BANG
    /// Returns `None` if there is no child corresponding to token OP_BANG
    fn OP_BANG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BANG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TEMPERATURE
    /// Returns `None` if there is no child corresponding to token OP_TEMPERATURE
    fn OP_TEMPERATURE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TEMPERATURE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TRANSPOSE
    /// Returns `None` if there is no child corresponding to token OP_TRANSPOSE
    fn OP_TRANSPOSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TRANSPOSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PERCENT
    /// Returns `None` if there is no child corresponding to token OP_PERCENT
    fn OP_PERCENT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PERCENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PERCENT2
    /// Returns `None` if there is no child corresponding to token OP_PERCENT2
    fn OP_PERCENT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PERCENT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REM
    /// Returns `None` if there is no child corresponding to token OP_REM
    fn OP_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR_DEFAULT
    /// Returns `None` if there is no child corresponding to token OP_OR_DEFAULT
    fn OP_OR_DEFAULT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR_DEFAULT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PRIME
    /// Returns `None` if there is no child corresponding to token OP_PRIME
    fn OP_PRIME(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PRIME, 0)
    }
}

impl<'input> Op_suffixContextAttrs<'input> for Op_suffixContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_suffix(&mut self) -> Result<Rc<Op_suffixContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_suffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_op_suffix);
        let mut _localctx: Rc<Op_suffixContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1432);
                _la = recog.base.input.la(1);
                if {
                    !(_la == OP_REM
                        || _la == OP_BANG
                        || (((_la - 81) & !0x3f) == 0
                            && ((1usize << (_la - 81))
                                & ((1usize << (OP_OR_DEFAULT - 81))
                                    | (1usize << (OP_PRIME - 81))
                                    | (1usize << (OP_TEMPERATURE - 81))
                                    | (1usize << (OP_TRANSPOSE - 81))
                                    | (1usize << (OP_PERCENT - 81))
                                    | (1usize << (OP_PERCENT2 - 81))))
                                != 0))
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_compare ----------------
pub type Op_compareContextAll<'input> = Op_compareContext<'input>;

pub type Op_compareContext<'input> = BaseParserRuleContext<'input, Op_compareContextExt<'input>>;

#[derive(Clone)]
pub struct Op_compareContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_compareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_compareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_compare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_compare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_compareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_compare(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_compareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_compare
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_compare }
}
antlr_rust::tid! {Op_compareContextExt<'a>}

impl<'input> Op_compareContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_compareContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_compareContextExt { ph: PhantomData }))
    }
}

pub trait Op_compareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_compareContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LEQ
    /// Returns `None` if there is no child corresponding to token OP_LEQ
    fn OP_LEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GEQ
    /// Returns `None` if there is no child corresponding to token OP_GEQ
    fn OP_GEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_EQ
    /// Returns `None` if there is no child corresponding to token OP_EQ
    fn OP_EQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_EQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NE
    /// Returns `None` if there is no child corresponding to token OP_NE
    fn OP_NE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_EEE
    /// Returns `None` if there is no child corresponding to token OP_EEE
    fn OP_EEE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_EEE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NEE
    /// Returns `None` if there is no child corresponding to token OP_NEE
    fn OP_NEE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NEE, 0)
    }
}

impl<'input> Op_compareContextAttrs<'input> for Op_compareContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_compare(&mut self) -> Result<Rc<Op_compareContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_compareContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_op_compare);
        let mut _localctx: Rc<Op_compareContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1434);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 33) & !0x3f) == 0
                        && ((1usize << (_la - 33))
                            & ((1usize << (OP_EQ - 33))
                                | (1usize << (OP_NE - 33))
                                | (1usize << (OP_NEE - 33))
                                | (1usize << (OP_EEE - 33))
                                | (1usize << (OP_LEQ - 33))
                                | (1usize << (OP_LT - 33))
                                | (1usize << (OP_GEQ - 33))
                                | (1usize << (OP_GT - 33))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_pattern ----------------
pub type Op_patternContextAll<'input> = Op_patternContext<'input>;

pub type Op_patternContext<'input> = BaseParserRuleContext<'input, Op_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Op_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_pattern }
}
antlr_rust::tid! {Op_patternContextExt<'a>}

impl<'input> Op_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_patternContextExt { ph: PhantomData }))
    }
}

pub trait Op_patternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_patternContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
}

impl<'input> Op_patternContextAttrs<'input> for Op_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_pattern(&mut self) -> Result<Rc<Op_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_op_pattern);
        let mut _localctx: Rc<Op_patternContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1436);
                _la = recog.base.input.la(1);
                if { !(_la == OP_AND || _la == OP_OR) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_map ----------------
pub type Infix_mapContextAll<'input> = Infix_mapContext<'input>;

pub type Infix_mapContext<'input> = BaseParserRuleContext<'input, Infix_mapContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_mapContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_mapContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_mapContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_map(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_map(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_mapContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_map(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_mapContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_map
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_map }
}
antlr_rust::tid! {Infix_mapContextExt<'a>}

impl<'input> Infix_mapContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_mapContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_mapContextExt { ph: PhantomData }))
    }
}

pub trait Infix_mapContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_mapContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_MAP
    /// Returns `None` if there is no child corresponding to token OP_MAP
    fn OP_MAP(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MAP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_APPLY2
    /// Returns `None` if there is no child corresponding to token OP_APPLY2
    fn OP_APPLY2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_APPLY2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_APPLY3
    /// Returns `None` if there is no child corresponding to token OP_APPLY3
    fn OP_APPLY3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_APPLY3, 0)
    }
}

impl<'input> Infix_mapContextAttrs<'input> for Infix_mapContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_map(&mut self) -> Result<Rc<Infix_mapContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_mapContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_infix_map);
        let mut _localctx: Rc<Infix_mapContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1438);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 73) & !0x3f) == 0
                        && ((1usize << (_la - 73))
                            & ((1usize << (OP_MAP - 73)) | (1usize << (OP_APPLY2 - 73)) | (1usize << (OP_APPLY3 - 73))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_pow ----------------
pub type Infix_powContextAll<'input> = Infix_powContext<'input>;

pub type Infix_powContext<'input> = BaseParserRuleContext<'input, Infix_powContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_powContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_powContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_powContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_pow(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_pow(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_powContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_pow(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_powContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_pow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_pow }
}
antlr_rust::tid! {Infix_powContextExt<'a>}

impl<'input> Infix_powContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_powContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_powContextExt { ph: PhantomData }))
    }
}

pub trait Infix_powContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_powContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_POW
    /// Returns `None` if there is no child corresponding to token OP_POW
    fn OP_POW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_POW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT2
    /// Returns `None` if there is no child corresponding to token OP_ROOT2
    fn OP_ROOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT2, 0)
    }
}

impl<'input> Infix_powContextAttrs<'input> for Infix_powContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_pow(&mut self) -> Result<Rc<Infix_powContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_powContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_infix_pow);
        let mut _localctx: Rc<Infix_powContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1440);
                _la = recog.base.input.la(1);
                if { !(_la == OP_POW || _la == OP_ROOT2) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_range ----------------
pub type Infix_rangeContextAll<'input> = Infix_rangeContext<'input>;

pub type Infix_rangeContext<'input> = BaseParserRuleContext<'input, Infix_rangeContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_rangeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_rangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_rangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_range(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_range(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_rangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_range(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_rangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_range
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_range }
}
antlr_rust::tid! {Infix_rangeContextExt<'a>}

impl<'input> Infix_rangeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_rangeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_rangeContextExt { ph: PhantomData }))
    }
}

pub trait Infix_rangeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_rangeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> Infix_rangeContextAttrs<'input> for Infix_rangeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_range(&mut self) -> Result<Rc<Infix_rangeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_rangeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_infix_range);
        let mut _localctx: Rc<Infix_rangeContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1442);
                recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_arrows ----------------
pub type Infix_arrowsContextAll<'input> = Infix_arrowsContext<'input>;

pub type Infix_arrowsContext<'input> = BaseParserRuleContext<'input, Infix_arrowsContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_arrowsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_arrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_arrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_arrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_arrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_arrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_arrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_arrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_arrows
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_arrows }
}
antlr_rust::tid! {Infix_arrowsContextExt<'a>}

impl<'input> Infix_arrowsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_arrowsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_arrowsContextExt { ph: PhantomData }))
    }
}

pub trait Infix_arrowsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_arrowsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW2
    /// Returns `None` if there is no child corresponding to token OP_ARROW2
    fn OP_ARROW2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW2, 0)
    }
}

impl<'input> Infix_arrowsContextAttrs<'input> for Infix_arrowsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_arrows(&mut self) -> Result<Rc<Infix_arrowsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_arrowsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_infix_arrows);
        let mut _localctx: Rc<Infix_arrowsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1444);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ARROW || _la == OP_ARROW2) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_multiple ----------------
pub type Op_multipleContextAll<'input> = Op_multipleContext<'input>;

pub type Op_multipleContext<'input> = BaseParserRuleContext<'input, Op_multipleContextExt<'input>>;

#[derive(Clone)]
pub struct Op_multipleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_multipleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_multipleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_multiple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_multiple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_multipleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_multiple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_multipleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_multiple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_multiple }
}
antlr_rust::tid! {Op_multipleContextExt<'a>}

impl<'input> Op_multipleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_multipleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_multipleContextExt { ph: PhantomData }))
    }
}

pub trait Op_multipleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Op_multipleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REM
    /// Returns `None` if there is no child corresponding to token OP_REM
    fn OP_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV_REM
    /// Returns `None` if there is no child corresponding to token OP_DIV_REM
    fn OP_DIV_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV_REM, 0)
    }
}

impl<'input> Op_multipleContextAttrs<'input> for Op_multipleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_multiple(&mut self) -> Result<Rc<Op_multipleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_multipleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_op_multiple);
        let mut _localctx: Rc<Op_multipleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1446);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 29) & !0x3f) == 0
                        && ((1usize << (_la - 29))
                            & ((1usize << (OP_MUL - 29))
                                | (1usize << (OP_DIV - 29))
                                | (1usize << (OP_REM - 29))
                                | (1usize << (OP_DIV_REM - 29))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_plus ----------------
pub type Op_plusContextAll<'input> = Op_plusContext<'input>;

pub type Op_plusContext<'input> = BaseParserRuleContext<'input, Op_plusContextExt<'input>>;

#[derive(Clone)]
pub struct Op_plusContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_plusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_plusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_plus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_plus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_plusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_plus(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_plusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_plus
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_plus }
}
antlr_rust::tid! {Op_plusContextExt<'a>}

impl<'input> Op_plusContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_plusContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_plusContextExt { ph: PhantomData }))
    }
}

pub trait Op_plusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_plusContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
}

impl<'input> Op_plusContextAttrs<'input> for Op_plusContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_plus(&mut self) -> Result<Rc<Op_plusContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_plusContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_op_plus);
        let mut _localctx: Rc<Op_plusContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1448);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ADD || _la == OP_SUB) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_logic ----------------
pub type Op_logicContextAll<'input> = Op_logicContext<'input>;

pub type Op_logicContext<'input> = BaseParserRuleContext<'input, Op_logicContextExt<'input>>;

#[derive(Clone)]
pub struct Op_logicContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_logicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_logicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_logic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_logic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_logicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_logic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_logicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_logic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_logic }
}
antlr_rust::tid! {Op_logicContextExt<'a>}

impl<'input> Op_logicContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_logicContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_logicContextExt { ph: PhantomData }))
    }
}

pub trait Op_logicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_logicContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token LOGIC_OR
    /// Returns `None` if there is no child corresponding to token LOGIC_OR
    fn LOGIC_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_AND
    /// Returns `None` if there is no child corresponding to token LOGIC_AND
    fn LOGIC_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_XOR
    /// Returns `None` if there is no child corresponding to token LOGIC_XOR
    fn LOGIC_XOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_XOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NOR
    /// Returns `None` if there is no child corresponding to token LOGIC_NOR
    fn LOGIC_NOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NAND
    /// Returns `None` if there is no child corresponding to token LOGIC_NAND
    fn LOGIC_NAND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NAND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_XAND
    /// Returns `None` if there is no child corresponding to token LOGIC_XAND
    fn LOGIC_XAND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_XAND, 0)
    }
}

impl<'input> Op_logicContextAttrs<'input> for Op_logicContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_logic(&mut self) -> Result<Rc<Op_logicContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_logicContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_op_logic);
        let mut _localctx: Rc<Op_logicContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1450);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 61) & !0x3f) == 0
                        && ((1usize << (_la - 61))
                            & ((1usize << (LOGIC_AND - 61))
                                | (1usize << (LOGIC_XAND - 61))
                                | (1usize << (LOGIC_NAND - 61))
                                | (1usize << (LOGIC_OR - 61))
                                | (1usize << (LOGIC_XOR - 61))
                                | (1usize << (LOGIC_NOR - 61))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_pipeline ----------------
pub type Op_pipelineContextAll<'input> = Op_pipelineContext<'input>;

pub type Op_pipelineContext<'input> = BaseParserRuleContext<'input, Op_pipelineContextExt<'input>>;

#[derive(Clone)]
pub struct Op_pipelineContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_pipelineContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_pipelineContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_pipeline(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_pipeline(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_pipelineContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_pipeline(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_pipelineContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_pipeline
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_pipeline }
}
antlr_rust::tid! {Op_pipelineContextExt<'a>}

impl<'input> Op_pipelineContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_pipelineContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_pipelineContextExt { ph: PhantomData }))
    }
}

pub trait Op_pipelineContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Op_pipelineContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LL
    /// Returns `None` if there is no child corresponding to token OP_LL
    fn OP_LL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LLE
    /// Returns `None` if there is no child corresponding to token OP_LLE
    fn OP_LLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LLL
    /// Returns `None` if there is no child corresponding to token OP_LLL
    fn OP_LLL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LLL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GG
    /// Returns `None` if there is no child corresponding to token OP_GG
    fn OP_GG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GGG
    /// Returns `None` if there is no child corresponding to token OP_GGG
    fn OP_GGG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GGG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW3
    /// Returns `None` if there is no child corresponding to token OP_ARROW3
    fn OP_ARROW3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW3, 0)
    }
}

impl<'input> Op_pipelineContextAttrs<'input> for Op_pipelineContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_pipeline(&mut self) -> Result<Rc<Op_pipelineContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_pipelineContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_op_pipeline);
        let mut _localctx: Rc<Op_pipelineContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1452);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 38) & !0x3f) == 0
                        && ((1usize << (_la - 38))
                            & ((1usize << (OP_LLE - 38))
                                | (1usize << (OP_LLL - 38))
                                | (1usize << (OP_LL - 38))
                                | (1usize << (OP_GGG - 38))
                                | (1usize << (OP_GG - 38))
                                | (1usize << (OP_ARROW3 - 38))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_assign ----------------
pub type Infix_assignContextAll<'input> = Infix_assignContext<'input>;

pub type Infix_assignContext<'input> = BaseParserRuleContext<'input, Infix_assignContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_assignContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_assignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_assignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_assign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_assign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_assignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_assign(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_assignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_assign
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_assign }
}
antlr_rust::tid! {Infix_assignContextExt<'a>}

impl<'input> Infix_assignContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_assignContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_assignContextExt { ph: PhantomData }))
    }
}

pub trait Infix_assignContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_assignContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ADD_ASSIGN
    fn OP_ADD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_SUB_ASSIGN
    fn OP_SUB_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MUL_ASSIGN
    fn OP_MUL_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_DIV_ASSIGN
    fn OP_DIV_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MAY_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MAY_ASSIGN
    fn OP_MAY_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MAY_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GGE
    /// Returns `None` if there is no child corresponding to token OP_GGE
    fn OP_GGE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GGE, 0)
    }
}

impl<'input> Infix_assignContextAttrs<'input> for Infix_assignContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_assign(&mut self) -> Result<Rc<Infix_assignContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_assignContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_infix_assign);
        let mut _localctx: Rc<Infix_assignContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1454);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 43) & !0x3f) == 0
                        && ((1usize << (_la - 43))
                            & ((1usize << (OP_GGE - 43))
                                | (1usize << (OP_ASSIGN - 43))
                                | (1usize << (OP_MAY_ASSIGN - 43))
                                | (1usize << (OP_ADD_ASSIGN - 43))
                                | (1usize << (OP_SUB_ASSIGN - 43))
                                | (1usize << (OP_MUL_ASSIGN - 43))
                                | (1usize << (OP_DIV_ASSIGN - 43))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_is ----------------
pub type Infix_isContextAll<'input> = Infix_isContext<'input>;

pub type Infix_isContext<'input> = BaseParserRuleContext<'input, Infix_isContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_isContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_isContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_isContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_is(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_is(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_isContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_is(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_isContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_is
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_is }
}
antlr_rust::tid! {Infix_isContextExt<'a>}

impl<'input> Infix_isContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_isContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_isContextExt { ph: PhantomData }))
    }
}

pub trait Infix_isContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_isContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IS
    /// Returns `None` if there is no child corresponding to token KW_IS
    fn KW_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IS
    /// Returns `None` if there is no child corresponding to token OP_IS
    fn OP_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IS_NOT
    /// Returns `None` if there is no child corresponding to token OP_IS_NOT
    fn OP_IS_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IS_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_CONTINUES
    /// Returns `None` if there is no child corresponding to token OP_CONTINUES
    fn OP_CONTINUES(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_CONTINUES, 0)
    }
}

impl<'input> Infix_isContextAttrs<'input> for Infix_isContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_is(&mut self) -> Result<Rc<Infix_isContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_isContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_infix_is);
        let mut _localctx: Rc<Infix_isContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1462);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(196, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1456);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1457);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;

                        recog.base.set_state(1458);
                        recog.base.match_token(KW_NOT, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1459);
                        recog.base.match_token(OP_IS, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1460);
                        recog.base.match_token(OP_IS_NOT, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1461);
                        recog.base.match_token(OP_CONTINUES, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_as ----------------
pub type Infix_asContextAll<'input> = Infix_asContext<'input>;

pub type Infix_asContext<'input> = BaseParserRuleContext<'input, Infix_asContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_asContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_asContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_asContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_as(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_as(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_asContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_as(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_asContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_as
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_as }
}
antlr_rust::tid! {Infix_asContextExt<'a>}

impl<'input> Infix_asContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_asContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_asContextExt { ph: PhantomData }))
    }
}

pub trait Infix_asContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_asContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
}

impl<'input> Infix_asContextAttrs<'input> for Infix_asContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_as(&mut self) -> Result<Rc<Infix_asContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_asContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_infix_as);
        let mut _localctx: Rc<Infix_asContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1464);
                recog.base.match_token(KW_AS, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_in ----------------
pub type Infix_inContextAll<'input> = Infix_inContext<'input>;

pub type Infix_inContext<'input> = BaseParserRuleContext<'input, Infix_inContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_inContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_inContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_inContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_in(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_in(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_inContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_in(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_inContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_in
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_in }
}
antlr_rust::tid! {Infix_inContextExt<'a>}

impl<'input> Infix_inContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_inContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_inContextExt { ph: PhantomData }))
    }
}

pub trait Infix_inContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_inContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IN
    /// Returns `None` if there is no child corresponding to token KW_IN
    fn KW_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IN
    /// Returns `None` if there is no child corresponding to token OP_IN
    fn OP_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NOT_IN
    /// Returns `None` if there is no child corresponding to token OP_NOT_IN
    fn OP_NOT_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT_IN, 0)
    }
}

impl<'input> Infix_inContextAttrs<'input> for Infix_inContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_in(&mut self) -> Result<Rc<Infix_inContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_inContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_infix_in);
        let mut _localctx: Rc<Infix_inContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1471);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                KW_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1466);
                        recog.base.match_token(KW_IN, &mut recog.err_handler)?;
                    }
                }

                KW_NOT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1467);
                        recog.base.match_token(KW_NOT, &mut recog.err_handler)?;

                        recog.base.set_state(1468);
                        recog.base.match_token(KW_IN, &mut recog.err_handler)?;
                    }
                }

                OP_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1469);
                        recog.base.match_token(OP_IN, &mut recog.err_handler)?;
                    }
                }

                OP_NOT_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1470);
                        recog.base.match_token(OP_NOT_IN, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_generic ----------------
pub type Define_genericContextAll<'input> = Define_genericContext<'input>;

pub type Define_genericContext<'input> = BaseParserRuleContext<'input, Define_genericContextExt<'input>>;

#[derive(Clone)]
pub struct Define_genericContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_genericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_genericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_generic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_generic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_genericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_generic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_genericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_generic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_generic }
}
antlr_rust::tid! {Define_genericContextExt<'a>}

impl<'input> Define_genericContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_genericContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_genericContextExt { ph: PhantomData }))
    }
}

pub trait Define_genericContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_genericContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
    fn generic_item_all(&self) -> Vec<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_item(&self, i: usize) -> Option<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
}

impl<'input> Define_genericContextAttrs<'input> for Define_genericContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_generic(&mut self) -> Result<Rc<Define_genericContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_genericContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_define_generic);
        let mut _localctx: Rc<Define_genericContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1511);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(204, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1473);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1474);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1475);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1476);
                        recog.generic_item()?;

                        recog.base.set_state(1481);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(198, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1477);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1478);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1483);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(198, &mut recog.base)?;
                        }
                        recog.base.set_state(1485);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1484);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1487);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1490);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1489);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1492);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1493);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1495);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1494);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1497);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1498);
                        recog.generic_item()?;

                        recog.base.set_state(1503);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(202, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1499);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1500);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1505);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(202, &mut recog.base)?;
                        }
                        recog.base.set_state(1507);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1506);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1509);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_item ----------------
pub type Generic_itemContextAll<'input> = Generic_itemContext<'input>;

pub type Generic_itemContext<'input> = BaseParserRuleContext<'input, Generic_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_item }
}
antlr_rust::tid! {Generic_itemContextExt<'a>}

impl<'input> Generic_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_itemContextExt { ph: PhantomData }))
    }
}

pub trait Generic_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_itemContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_itemContextAttrs<'input> for Generic_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_item(&mut self) -> Result<Rc<Generic_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_generic_item);
        let mut _localctx: Rc<Generic_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1516);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(205, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1513);
                            recog.identifier()?;

                            recog.base.set_state(1514);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1518);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call ----------------
pub type Generic_callContextAll<'input> = Generic_callContext<'input>;

pub type Generic_callContext<'input> = BaseParserRuleContext<'input, Generic_callContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call }
}
antlr_rust::tid! {Generic_callContextExt<'a>}

impl<'input> Generic_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_callContextExt { ph: PhantomData }))
    }
}

pub trait Generic_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_callContextAttrs<'input> for Generic_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call(&mut self) -> Result<Rc<Generic_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_generic_call);
        let mut _localctx: Rc<Generic_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1554);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(210, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1520);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1521);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1522);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1523);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1524);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1525);
                        recog.generic_pair()?;

                        recog.base.set_state(1530);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(206, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1526);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1527);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1532);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(206, &mut recog.base)?;
                        }
                        recog.base.set_state(1534);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1533);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1536);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1538);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1539);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1540);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1541);
                        recog.generic_pair()?;

                        recog.base.set_state(1546);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(208, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1542);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1543);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1548);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(208, &mut recog.base)?;
                        }
                        recog.base.set_state(1550);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1549);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1552);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call_in_type ----------------
pub type Generic_call_in_typeContextAll<'input> = Generic_call_in_typeContext<'input>;

pub type Generic_call_in_typeContext<'input> = BaseParserRuleContext<'input, Generic_call_in_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_call_in_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call_in_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call_in_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call_in_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_call_in_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call_in_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call_in_type }
}
antlr_rust::tid! {Generic_call_in_typeContextExt<'a>}

impl<'input> Generic_call_in_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_call_in_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Generic_call_in_typeContextExt { ph: PhantomData },
        ))
    }
}

pub trait Generic_call_in_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_call_in_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_call_in_typeContextAttrs<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call_in_type(&mut self) -> Result<Rc<Generic_call_in_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_call_in_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_generic_call_in_type);
        let mut _localctx: Rc<Generic_call_in_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1581);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_PROPORTION | OP_LT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1557);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1556);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1559);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1560);
                        recog.generic_pair()?;

                        recog.base.set_state(1565);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1561);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1562);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1567);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1568);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                GENERIC_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1570);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1571);
                        recog.generic_pair()?;

                        recog.base.set_state(1576);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1572);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1573);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1578);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1579);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_pair ----------------
pub type Generic_pairContextAll<'input> = Generic_pairContext<'input>;

pub type Generic_pairContext<'input> = BaseParserRuleContext<'input, Generic_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_pair }
}
antlr_rust::tid! {Generic_pairContextExt<'a>}

impl<'input> Generic_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_pairContextExt { ph: PhantomData }))
    }
}

pub trait Generic_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_pairContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_pairContextAttrs<'input> for Generic_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_pair(&mut self) -> Result<Rc<Generic_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_generic_pair);
        let mut _localctx: Rc<Generic_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1586);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(215, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1583);
                            recog.identifier()?;

                            recog.base.set_state(1584);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1588);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_label ----------------
pub type Define_labelContextAll<'input> = Define_labelContext<'input>;

pub type Define_labelContext<'input> = BaseParserRuleContext<'input, Define_labelContextExt<'input>>;

#[derive(Clone)]
pub struct Define_labelContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_labelContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_labelContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_label(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_label(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_labelContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_label(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_labelContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_label
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_label }
}
antlr_rust::tid! {Define_labelContextExt<'a>}

impl<'input> Define_labelContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_labelContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_labelContextExt { ph: PhantomData }))
    }
}

pub trait Define_labelContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_labelContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_labelContextAttrs<'input> for Define_labelContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_label(&mut self) -> Result<Rc<Define_labelContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_labelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_define_label);
        let mut _localctx: Rc<Define_labelContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1590);
                recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(1591);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_call ----------------
pub type Template_callContextAll<'input> = Template_callContext<'input>;

pub type Template_callContext<'input> = BaseParserRuleContext<'input, Template_callContextExt<'input>>;

#[derive(Clone)]
pub struct Template_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_call }
}
antlr_rust::tid! {Template_callContextExt<'a>}

impl<'input> Template_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_callContextExt { ph: PhantomData }))
    }
}

pub trait Template_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_callContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TEMPLATE
    /// Returns `None` if there is no child corresponding to token KW_TEMPLATE
    fn KW_TEMPLATE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TEMPLATE, 0)
    }
    fn template_block(&self) -> Option<Rc<Template_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Template_callContextAttrs<'input> for Template_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_call(&mut self) -> Result<Rc<Template_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_template_call);
        let mut _localctx: Rc<Template_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1596);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1593);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1598);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(1599);
                recog.modifiers()?;

                recog.base.set_state(1600);
                recog.base.match_token(KW_TEMPLATE, &mut recog.err_handler)?;

                recog.base.set_state(1640);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    RAW_ID | UNICODE_ID => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1601);
                            recog.identifier()?;

                            recog.base.set_state(1606);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(217, &mut recog.base)?;
                            while { _alt != 2 && _alt != INVALID_ALT } {
                                if _alt == 1 {
                                    {
                                        {
                                            recog.base.set_state(1602);
                                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                            /* InvokeRule identifier */
                                            recog.base.set_state(1603);
                                            recog.identifier()?;
                                        }
                                    }
                                }
                                recog.base.set_state(1608);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(217, &mut recog.base)?;
                            }
                            recog.base.set_state(1610);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == COMMA {
                                {
                                    recog.base.set_state(1609);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                }
                            }
                        }
                    }

                    OP_LT => {
                        {
                            recog.base.set_state(1612);
                            recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                            /* InvokeRule identifier */
                            recog.base.set_state(1613);
                            recog.identifier()?;

                            recog.base.set_state(1618);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(219, &mut recog.base)?;
                            while { _alt != 2 && _alt != INVALID_ALT } {
                                if _alt == 1 {
                                    {
                                        {
                                            recog.base.set_state(1614);
                                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                            /* InvokeRule identifier */
                                            recog.base.set_state(1615);
                                            recog.identifier()?;
                                        }
                                    }
                                }
                                recog.base.set_state(1620);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(219, &mut recog.base)?;
                            }
                            recog.base.set_state(1622);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == COMMA {
                                {
                                    recog.base.set_state(1621);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(1624);
                            recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                        }
                    }

                    GENERIC_L => {
                        {
                            recog.base.set_state(1626);
                            recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                            /* InvokeRule identifier */
                            recog.base.set_state(1627);
                            recog.identifier()?;

                            recog.base.set_state(1632);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(221, &mut recog.base)?;
                            while { _alt != 2 && _alt != INVALID_ALT } {
                                if _alt == 1 {
                                    {
                                        {
                                            recog.base.set_state(1628);
                                            recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                            /* InvokeRule identifier */
                                            recog.base.set_state(1629);
                                            recog.identifier()?;
                                        }
                                    }
                                }
                                recog.base.set_state(1634);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(221, &mut recog.base)?;
                            }
                            recog.base.set_state(1636);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                            if _la == COMMA {
                                {
                                    recog.base.set_state(1635);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                }
                            }

                            recog.base.set_state(1638);
                            recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                        }
                    }

                    BRACE_L => {}

                    _ => {}
                }
                /* InvokeRule template_block */
                recog.base.set_state(1642);
                recog.template_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_block ----------------
pub type Template_blockContextAll<'input> = Template_blockContext<'input>;

pub type Template_blockContext<'input> = BaseParserRuleContext<'input, Template_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Template_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_block }
}
antlr_rust::tid! {Template_blockContextExt<'a>}

impl<'input> Template_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_blockContextExt { ph: PhantomData }))
    }
}

pub trait Template_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn template_statements_all(&self) -> Vec<Rc<Template_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn template_statements(&self, i: usize) -> Option<Rc<Template_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn template_implements_all(&self) -> Vec<Rc<Template_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn template_implements(&self, i: usize) -> Option<Rc<Template_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Template_blockContextAttrs<'input> for Template_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_block(&mut self) -> Result<Rc<Template_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_template_block);
        let mut _localctx: Rc<Template_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1644);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1650);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || (((_la - 119) & !0x3f) == 0
                        && ((1usize << (_la - 119))
                            & ((1usize << (KW_IMPLEMENTS - 119))
                                | (1usize << (KW_WHERE - 119))
                                | (1usize << (RETURN - 119))
                                | (1usize << (RAW_ID - 119))
                                | (1usize << (UNICODE_ID - 119))))
                            != 0)
                {
                    {
                        recog.base.set_state(1648);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            KW_WHERE | RETURN | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule template_statements */
                                    recog.base.set_state(1645);
                                    recog.template_statements()?;
                                }
                            }

                            KW_IMPLEMENTS => {
                                {
                                    /* InvokeRule template_implements */
                                    recog.base.set_state(1646);
                                    recog.template_implements()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1647);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1652);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1653);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_statements ----------------
pub type Template_statementsContextAll<'input> = Template_statementsContext<'input>;

pub type Template_statementsContext<'input> = BaseParserRuleContext<'input, Template_statementsContextExt<'input>>;

#[derive(Clone)]
pub struct Template_statementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_statementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_statementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_statements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_statements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_statementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_statements(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_statementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_statements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_statements }
}
antlr_rust::tid! {Template_statementsContextExt<'a>}

impl<'input> Template_statementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_statementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Template_statementsContextExt { ph: PhantomData },
        ))
    }
}

pub trait Template_statementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_statementsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_WHERE
    /// Returns `None` if there is no child corresponding to token KW_WHERE
    fn KW_WHERE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHERE, 0)
    }
    fn where_block(&self) -> Option<Rc<Where_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token RETURN
    /// Returns `None` if there is no child corresponding to token RETURN
    fn RETURN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn require_block(&self) -> Option<Rc<Require_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Template_statementsContextAttrs<'input> for Template_statementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_statements(&mut self) -> Result<Rc<Template_statementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_statementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_template_statements);
        let mut _localctx: Rc<Template_statementsContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1662);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                KW_WHERE => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1655);
                        recog.base.match_token(KW_WHERE, &mut recog.err_handler)?;

                        /* InvokeRule where_block */
                        recog.base.set_state(1656);
                        recog.where_block()?;
                    }
                }

                RETURN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1657);
                        recog.base.match_token(RETURN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1658);
                        recog.type_expression_rec(0)?;
                    }
                }

                RAW_ID | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1659);
                        recog.identifier()?;

                        /* InvokeRule require_block */
                        recog.base.set_state(1660);
                        recog.require_block()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_implements ----------------
pub type Template_implementsContextAll<'input> = Template_implementsContext<'input>;

pub type Template_implementsContext<'input> = BaseParserRuleContext<'input, Template_implementsContextExt<'input>>;

#[derive(Clone)]
pub struct Template_implementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_implementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_implementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_implements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_implements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_implementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_implements(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_implementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_implements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_implements }
}
antlr_rust::tid! {Template_implementsContextExt<'a>}

impl<'input> Template_implementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_implementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Template_implementsContextExt { ph: PhantomData },
        ))
    }
}

pub trait Template_implementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_implementsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IMPLEMENTS
    /// Returns `None` if there is no child corresponding to token KW_IMPLEMENTS
    fn KW_IMPLEMENTS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPLEMENTS, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Template_implementsContextAttrs<'input> for Template_implementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_implements(&mut self) -> Result<Rc<Template_implementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_implementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_template_implements);
        let mut _localctx: Rc<Template_implementsContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1664);
                recog.base.match_token(KW_IMPLEMENTS, &mut recog.err_handler)?;

                /* InvokeRule type_expression */
                recog.base.set_state(1665);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_block ----------------
pub type Where_blockContextAll<'input> = Where_blockContext<'input>;

pub type Where_blockContext<'input> = BaseParserRuleContext<'input, Where_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Where_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_block }
}
antlr_rust::tid! {Where_blockContextExt<'a>}

impl<'input> Where_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_blockContextExt { ph: PhantomData }))
    }
}

pub trait Where_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn where_bound_all(&self) -> Vec<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn where_bound(&self, i: usize) -> Option<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Where_blockContextAttrs<'input> for Where_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_block(&mut self) -> Result<Rc<Where_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_where_block);
        let mut _localctx: Rc<Where_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1667);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1671);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        {
                            /* InvokeRule where_bound */
                            recog.base.set_state(1668);
                            recog.where_bound()?;
                        }
                    }
                    recog.base.set_state(1673);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1674);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_bound ----------------
pub type Where_boundContextAll<'input> = Where_boundContext<'input>;

pub type Where_boundContext<'input> = BaseParserRuleContext<'input, Where_boundContextExt<'input>>;

#[derive(Clone)]
pub struct Where_boundContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_boundContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_boundContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_bound(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_bound(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_boundContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_bound(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_boundContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_bound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_bound }
}
antlr_rust::tid! {Where_boundContextExt<'a>}

impl<'input> Where_boundContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_boundContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_boundContextExt { ph: PhantomData }))
    }
}

pub trait Where_boundContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_boundContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Where_boundContextAttrs<'input> for Where_boundContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_bound(&mut self) -> Result<Rc<Where_boundContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_boundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_where_bound);
        let mut _localctx: Rc<Where_boundContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1681);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                RAW_ID | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1676);
                        recog.identifier()?;

                        recog.base.set_state(1677);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1678);
                        recog.type_expression_rec(0)?;
                    }
                }

                COMMA | SEMICOLON | FAKE_COLON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(1680);
                        recog.eos_free()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- require_block ----------------
pub type Require_blockContextAll<'input> = Require_blockContext<'input>;

pub type Require_blockContext<'input> = BaseParserRuleContext<'input, Require_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Require_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Require_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Require_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_require_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_require_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Require_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_require_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Require_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_require_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_require_block }
}
antlr_rust::tid! {Require_blockContextExt<'a>}

impl<'input> Require_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Require_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Require_blockContextExt { ph: PhantomData }))
    }
}

pub trait Require_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Require_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn expression_root_all(&self) -> Vec<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression_root(&self, i: usize) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Require_blockContextAttrs<'input> for Require_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn require_block(&mut self) -> Result<Rc<Require_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Require_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_require_block);
        let mut _localctx: Rc<Require_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1683);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1688);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << COMMA)
                            | (1usize << SEMICOLON)
                            | (1usize << FAKE_COLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << BRACE_L)
                            | (1usize << OFFSET_L)
                            | (1usize << CEILING_L)
                            | (1usize << FLOOR_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 58) & !0x3f) == 0
                        && ((1usize << (_la - 58))
                            & ((1usize << (OP_BANG - 58))
                                | (1usize << (OP_NOT - 58))
                                | (1usize << (OP_AND - 58))
                                | (1usize << (OP_AT - 58))
                                | (1usize << (OP_HASH - 58))
                                | (1usize << (LAMBDA_SLOT - 58))))
                            != 0)
                    || (((_la - 93) & !0x3f) == 0
                        && ((1usize << (_la - 93))
                            & ((1usize << (OP_DOT3 - 93))
                                | (1usize << (OP_DOT2 - 93))
                                | (1usize << (OP_INVERSE - 93))
                                | (1usize << (OP_ROOT2 - 93))
                                | (1usize << (OP_ROOT3 - 93))
                                | (1usize << (OP_ROOT4 - 93))
                                | (1usize << (OP_PERCENT - 93))
                                | (1usize << (OP_REFERENCE - 93))
                                | (1usize << (OP_LABEL - 93))
                                | (1usize << (OP_OUTPUT - 93))
                                | (1usize << (OP_LAST - 93))
                                | (1usize << (KW_NEW - 93))
                                | (1usize << (KW_OBJECT - 93))))
                            != 0)
                    || (((_la - 125) & !0x3f) == 0
                        && ((1usize << (_la - 125))
                            & ((1usize << (KW_LAMBDA - 125))
                                | (1usize << (KW_TRY - 125))
                                | (1usize << (KW_MATCH - 125))
                                | (1usize << (KW_CATCH - 125))
                                | (1usize << (INTEGER - 125))
                                | (1usize << (DECIMAL - 125))
                                | (1usize << (STRING_START - 125))
                                | (1usize << (KW_IF - 125))
                                | (1usize << (RETURN - 125))
                                | (1usize << (RESUME - 125))
                                | (1usize << (YIELD - 125))
                                | (1usize << (BREAK - 125))
                                | (1usize << (CONTINUE - 125))
                                | (1usize << (FALL_THROUGH - 125))
                                | (1usize << (RAISE - 125))
                                | (1usize << (SPECIAL - 125))
                                | (1usize << (RAW_ID - 125))
                                | (1usize << (UNICODE_ID - 125))))
                            != 0)
                {
                    {
                        recog.base.set_state(1686);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | BRACE_L | OFFSET_L | CEILING_L | FLOOR_L | OP_ADD | OP_SUB | OP_MUL
                            | OP_BANG | OP_NOT | OP_AND | OP_AT | OP_HASH | LAMBDA_SLOT | OP_DOT3 | OP_DOT2 | OP_INVERSE
                            | OP_ROOT2 | OP_ROOT3 | OP_ROOT4 | OP_PERCENT | OP_REFERENCE | OP_LABEL | OP_OUTPUT | OP_LAST
                            | KW_NEW | KW_OBJECT | KW_LAMBDA | KW_TRY | KW_MATCH | KW_CATCH | INTEGER | DECIMAL
                            | STRING_START | KW_IF | RETURN | RESUME | YIELD | BREAK | CONTINUE | FALL_THROUGH | RAISE
                            | SPECIAL | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule expression_root */
                                    recog.base.set_state(1684);
                                    recog.expression_root()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1685);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1690);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1691);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- macro_call ----------------
pub type Macro_callContextAll<'input> = Macro_callContext<'input>;

pub type Macro_callContext<'input> = BaseParserRuleContext<'input, Macro_callContextExt<'input>>;

#[derive(Clone)]
pub struct Macro_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Macro_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Macro_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_macro_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_macro_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Macro_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_macro_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Macro_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_macro_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_macro_call }
}
antlr_rust::tid! {Macro_callContextExt<'a>}

impl<'input> Macro_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Macro_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Macro_callContextExt { ph: PhantomData }))
    }
}

pub trait Macro_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Macro_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn annotation_call_item_all(&self) -> Vec<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation_call_item(&self, i: usize) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Macro_callContextAttrs<'input> for Macro_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn macro_call(&mut self) -> Result<Rc<Macro_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Macro_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_macro_call);
        let mut _localctx: Rc<Macro_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1712);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(234, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1693);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1694);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1696);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(231, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1695);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1698);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        recog.base.set_state(1699);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1700);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1705);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1701);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule annotation_call_item */
                                    recog.base.set_state(1702);
                                    recog.annotation_call_item()?;
                                }
                            }
                            recog.base.set_state(1707);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1708);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;

                        recog.base.set_state(1710);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(233, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1709);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;

pub type AnnotationContext<'input> = BaseParserRuleContext<'input, AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for AnnotationContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AnnotationContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AnnotationContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation(self);
    }
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::tid! {AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AnnotationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, AnnotationContextExt { ph: PhantomData }))
    }
}

pub trait AnnotationContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<AnnotationContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn annotation_call_item_all(&self) -> Vec<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation_call_item(&self, i: usize) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation(&mut self) -> Result<Rc<AnnotationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1731);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(237, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1714);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1715);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1717);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(235, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1716);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1719);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        recog.base.set_state(1720);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1721);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1726);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1722);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule annotation_call_item */
                                    recog.base.set_state(1723);
                                    recog.annotation_call_item()?;
                                }
                            }
                            recog.base.set_state(1728);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1729);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation_call_item ----------------
pub type Annotation_call_itemContextAll<'input> = Annotation_call_itemContext<'input>;

pub type Annotation_call_itemContext<'input> = BaseParserRuleContext<'input, Annotation_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Annotation_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Annotation_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Annotation_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation_call_item }
}
antlr_rust::tid! {Annotation_call_itemContextExt<'a>}

impl<'input> Annotation_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Annotation_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Annotation_call_itemContextExt { ph: PhantomData },
        ))
    }
}

pub trait Annotation_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Annotation_call_itemContextExt<'input>>
{
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Annotation_call_itemContextAttrs<'input> for Annotation_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation_call_item(&mut self) -> Result<Rc<Annotation_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Annotation_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_annotation_call_item);
        let mut _localctx: Rc<Annotation_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule namepath */
                recog.base.set_state(1733);
                recog.namepath()?;

                recog.base.set_state(1735);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(238, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule tuple_call_body */
                            recog.base.set_state(1734);
                            recog.tuple_call_body()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1738);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(239, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule class_block */
                            recog.base.set_state(1737);
                            recog.class_block()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- try_statement ----------------
pub type Try_statementContextAll<'input> = Try_statementContext<'input>;

pub type Try_statementContext<'input> = BaseParserRuleContext<'input, Try_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Try_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Try_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Try_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_try_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_try_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Try_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_try_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Try_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_try_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_try_statement }
}
antlr_rust::tid! {Try_statementContextExt<'a>}

impl<'input> Try_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Try_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Try_statementContextExt { ph: PhantomData }))
    }
}

pub trait Try_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Try_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TRY
    /// Returns `None` if there is no child corresponding to token KW_TRY
    fn KW_TRY(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRY, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Try_statementContextAttrs<'input> for Try_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn try_statement(&mut self) -> Result<Rc<Try_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Try_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_try_statement);
        let mut _localctx: Rc<Try_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1743);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1740);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1745);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1746);
                recog.base.match_token(KW_TRY, &mut recog.err_handler)?;

                recog.base.set_state(1748);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << PARENTHESES_L) | (1usize << OP_ADD) | (1usize << OP_SUB) | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 58) & !0x3f) == 0
                        && ((1usize << (_la - 58))
                            & ((1usize << (OP_BANG - 58))
                                | (1usize << (OP_NOT - 58))
                                | (1usize << (OP_AND - 58))
                                | (1usize << (LAMBDA_SLOT - 58))))
                            != 0)
                    || (((_la - 93) & !0x3f) == 0
                        && ((1usize << (_la - 93))
                            & ((1usize << (OP_DOT3 - 93))
                                | (1usize << (OP_DOT2 - 93))
                                | (1usize << (OP_INVERSE - 93))
                                | (1usize << (OP_ROOT2 - 93))
                                | (1usize << (OP_ROOT3 - 93))
                                | (1usize << (OP_ROOT4 - 93))
                                | (1usize << (OP_PERCENT - 93))
                                | (1usize << (OP_REFERENCE - 93))
                                | (1usize << (OP_OUTPUT - 93))
                                | (1usize << (OP_LAST - 93))))
                            != 0)
                    || (((_la - 134) & !0x3f) == 0
                        && ((1usize << (_la - 134))
                            & ((1usize << (INTEGER - 134))
                                | (1usize << (DECIMAL - 134))
                                | (1usize << (STRING_START - 134))
                                | (1usize << (SPECIAL - 134))
                                | (1usize << (RAW_ID - 134))
                                | (1usize << (UNICODE_ID - 134))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(1747);
                        recog.type_expression_rec(0)?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(1750);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_statement ----------------
pub type Match_statementContextAll<'input> = Match_statementContext<'input>;

pub type Match_statementContext<'input> = BaseParserRuleContext<'input, Match_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Match_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_statement }
}
antlr_rust::tid! {Match_statementContextExt<'a>}

impl<'input> Match_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_statementContextExt { ph: PhantomData }))
    }
}

pub trait Match_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_statementContextExt<'input>>
{
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
}

impl<'input> Match_statementContextAttrs<'input> for Match_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_statement(&mut self) -> Result<Rc<Match_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_match_statement);
        let mut _localctx: Rc<Match_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1755);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1752);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1757);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1758);
                _la = recog.base.input.la(1);
                if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(1762);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(243, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1759);
                            recog.identifier()?;

                            recog.base.set_state(1760);
                            recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule inline_expression */
                recog.base.set_state(1764);
                recog.inline_expression_rec(0)?;

                recog.base.set_state(1766);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AND_THEN {
                    {
                        recog.base.set_state(1765);
                        recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule match_block */
                recog.base.set_state(1768);
                recog.match_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_block ----------------
pub type Match_blockContextAll<'input> = Match_blockContext<'input>;

pub type Match_blockContext<'input> = BaseParserRuleContext<'input, Match_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_block }
}
antlr_rust::tid! {Match_blockContextExt<'a>}

impl<'input> Match_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn match_terms_all(&self) -> Vec<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn match_terms(&self, i: usize) -> Option<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_blockContextAttrs<'input> for Match_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_block(&mut self) -> Result<Rc<Match_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_match_block);
        let mut _localctx: Rc<Match_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1770);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1775);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || (((_la - 116) & !0x3f) == 0
                        && ((1usize << (_la - 116))
                            & ((1usize << (KW_TYPE - 116))
                                | (1usize << (KW_WITH - 116))
                                | (1usize << (KW_CASE - 116))
                                | (1usize << (KW_WHEN - 116))
                                | (1usize << (KW_ELSE - 116))))
                            != 0)
                {
                    {
                        recog.base.set_state(1773);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_HASH | KW_TYPE | KW_WITH | KW_CASE | KW_WHEN | KW_ELSE => {
                                {
                                    /* InvokeRule match_terms */
                                    recog.base.set_state(1771);
                                    recog.match_terms()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1772);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1777);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1778);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_terms ----------------
#[derive(Debug)]
pub enum Match_termsContextAll<'input> {
    MatchWhenContext(MatchWhenContext<'input>),
    MatchTypeContext(MatchTypeContext<'input>),
    MatchCaseContext(MatchCaseContext<'input>),
    MatchWithContext(MatchWithContext<'input>),
    MatchWithManyContext(MatchWithManyContext<'input>),
    MatchElseContext(MatchElseContext<'input>),
    Error(Match_termsContext<'input>),
}
antlr_rust::tid! {Match_termsContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Match_termsContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContextAll<'input> {}

impl<'input> Deref for Match_termsContextAll<'input> {
    type Target = dyn Match_termsContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Match_termsContextAll::*;
        match self {
            MatchWhenContext(inner) => inner,
            MatchTypeContext(inner) => inner,
            MatchCaseContext(inner) => inner,
            MatchWithContext(inner) => inner,
            MatchWithManyContext(inner) => inner,
            MatchElseContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Match_termsContext<'input> = BaseParserRuleContext<'input, Match_termsContextExt<'input>>;

#[derive(Clone)]
pub struct Match_termsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContext<'input> {}

impl<'input> CustomRuleContext<'input> for Match_termsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}
antlr_rust::tid! {Match_termsContextExt<'a>}

impl<'input> Match_termsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Match_termsContextExt { ph: PhantomData },
        )))
    }
}

pub trait Match_termsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_termsContextExt<'input>>
{
}

impl<'input> Match_termsContextAttrs<'input> for Match_termsContext<'input> {}

pub type MatchWhenContext<'input> = BaseParserRuleContext<'input, MatchWhenContextExt<'input>>;

pub trait MatchWhenContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHEN
    /// Returns `None` if there is no child corresponding to token KW_WHEN
    fn KW_WHEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHEN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWhenContextAttrs<'input> for MatchWhenContext<'input> {}

pub struct MatchWhenContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWhenContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWhenContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWhenContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWhen(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWhen(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWhenContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWhen(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWhenContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWhenContext<'input> {}

impl<'input> MatchWhenContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWhenContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWhenContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchTypeContext<'input> = BaseParserRuleContext<'input, MatchTypeContextExt<'input>>;

pub trait MatchTypeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchTypeContextAttrs<'input> for MatchTypeContext<'input> {}

pub struct MatchTypeContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchTypeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchTypeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchType(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchTypeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchType(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchTypeContext<'input> {}

impl<'input> MatchTypeContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchTypeContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchTypeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchCaseContext<'input> = BaseParserRuleContext<'input, MatchCaseContextExt<'input>>;

pub trait MatchCaseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_CASE
    /// Returns `None` if there is no child corresponding to token KW_CASE
    fn KW_CASE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CASE, 0)
    }
    fn case_pattern(&self) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchCaseContextAttrs<'input> for MatchCaseContext<'input> {}

pub struct MatchCaseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchCaseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchCaseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchCaseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchCase(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchCase(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchCaseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchCase(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchCaseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchCaseContext<'input> {}

impl<'input> MatchCaseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchCaseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchCaseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithContext<'input> = BaseParserRuleContext<'input, MatchWithContextExt<'input>>;

pub trait MatchWithContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWithContextAttrs<'input> for MatchWithContext<'input> {}

pub struct MatchWithContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWith(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWith(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithContext<'input> {}

impl<'input> MatchWithContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithManyContext<'input> = BaseParserRuleContext<'input, MatchWithManyContextExt<'input>>;

pub trait MatchWithManyContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> MatchWithManyContextAttrs<'input> for MatchWithManyContext<'input> {}

pub struct MatchWithManyContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithManyContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithManyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithManyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWithMany(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWithMany(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithManyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWithMany(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithManyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithManyContext<'input> {}

impl<'input> MatchWithManyContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithManyContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithManyContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchElseContext<'input> = BaseParserRuleContext<'input, MatchElseContextExt<'input>>;

pub trait MatchElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchElseContextAttrs<'input> for MatchElseContext<'input> {}

pub struct MatchElseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchElseContext<'input> {}

impl<'input> MatchElseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchElseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchElseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_terms(&mut self) -> Result<Rc<Match_termsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_termsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_match_terms);
        let mut _localctx: Rc<Match_termsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1856);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(258, &mut recog.base)? {
                1 => {
                    let tmp = MatchWithContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1783);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1780);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1785);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1786);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1787);
                        recog.identifier()?;
                    }
                }
                2 => {
                    let tmp = MatchWithManyContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1791);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1788);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1793);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1794);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        recog.base.set_state(1795);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1807);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1796);
                                recog.identifier()?;

                                recog.base.set_state(1801);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(249, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1797);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule identifier */
                                                recog.base.set_state(1798);
                                                recog.identifier()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1803);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(249, &mut recog.base)?;
                                }
                                recog.base.set_state(1805);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1804);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1809);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = MatchTypeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1813);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1810);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1815);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1816);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1817);
                        recog.type_expression_rec(0)?;

                        recog.base.set_state(1820);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1818);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1819);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1822);
                        recog.match_case_block()?;
                    }
                }
                4 => {
                    let tmp = MatchWhenContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1827);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1824);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1829);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1830);
                        recog.base.match_token(KW_WHEN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1831);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1832);
                        recog.match_case_block()?;
                    }
                }
                5 => {
                    let tmp = MatchElseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1837);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1834);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1839);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1840);
                        recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1841);
                        recog.match_case_block()?;
                    }
                }
                6 => {
                    let tmp = MatchCaseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1845);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1842);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1847);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1848);
                        recog.base.match_token(KW_CASE, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern */
                        recog.base.set_state(1849);
                        recog.case_pattern_rec(0)?;

                        recog.base.set_state(1852);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1850);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1851);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1854);
                        recog.match_case_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_case_block ----------------
pub type Match_case_blockContextAll<'input> = Match_case_blockContext<'input>;

pub type Match_case_blockContext<'input> = BaseParserRuleContext<'input, Match_case_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_case_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_case_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_case_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_case_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_case_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_case_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_case_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_case_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_case_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_case_block }
}
antlr_rust::tid! {Match_case_blockContextExt<'a>}

impl<'input> Match_case_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_case_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_case_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_case_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_case_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_case_blockContextAttrs<'input> for Match_case_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_case_block(&mut self) -> Result<Rc<Match_case_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_case_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_match_case_block);
        let mut _localctx: Rc<Match_case_blockContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1858);
                recog.base.match_token(COLON, &mut recog.err_handler)?;

                recog.base.set_state(1862);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(259, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule expression */
                                recog.base.set_state(1859);
                                recog.expression_rec(0)?;
                            }
                        }
                    }
                    recog.base.set_state(1864);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(259, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern ----------------
#[derive(Debug)]
pub enum Case_patternContextAll<'input> {
    CaseORContext(CaseORContext<'input>),
    CaseAtomContext(CaseAtomContext<'input>),
    CaseUntilContext(CaseUntilContext<'input>),
    Error(Case_patternContext<'input>),
}
antlr_rust::tid! {Case_patternContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Case_patternContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContextAll<'input> {}

impl<'input> Deref for Case_patternContextAll<'input> {
    type Target = dyn Case_patternContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Case_patternContextAll::*;
        match self {
            CaseORContext(inner) => inner,
            CaseAtomContext(inner) => inner,
            CaseUntilContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Case_patternContext<'input> = BaseParserRuleContext<'input, Case_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Case_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContext<'input> {}

impl<'input> CustomRuleContext<'input> for Case_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}
antlr_rust::tid! {Case_patternContextExt<'a>}

impl<'input> Case_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_patternContextExt { ph: PhantomData },
        )))
    }
}

pub trait Case_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_patternContextExt<'input>>
{
}

impl<'input> Case_patternContextAttrs<'input> for Case_patternContext<'input> {}

pub type CaseORContext<'input> = BaseParserRuleContext<'input, CaseORContextExt<'input>>;

pub trait CaseORContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> CaseORContextAttrs<'input> for CaseORContext<'input> {}

pub struct CaseORContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseORContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseORContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseORContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseOR(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseOR(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseORContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseOR(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseORContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseORContext<'input> {}

impl<'input> CaseORContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseORContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseORContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseAtomContext<'input> = BaseParserRuleContext<'input, CaseAtomContextExt<'input>>;

pub trait CaseAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CaseAtomContextAttrs<'input> for CaseAtomContext<'input> {}

pub struct CaseAtomContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseAtomContext<'input> {}

impl<'input> CaseAtomContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseUntilContext<'input> = BaseParserRuleContext<'input, CaseUntilContextExt<'input>>;

pub trait CaseUntilContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> CaseUntilContextAttrs<'input> for CaseUntilContext<'input> {}

pub struct CaseUntilContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseUntilContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseUntilContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseUntilContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseUntil(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseUntil(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseUntilContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseUntil(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseUntilContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseUntilContext<'input> {}

impl<'input> CaseUntilContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseUntilContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseUntilContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern(&mut self) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        self.case_pattern_rec(0)
    }

    fn case_pattern_rec(&mut self, _p: isize) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Case_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 196, RULE_case_pattern, _p);
        let mut _localctx: Rc<Case_patternContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 196;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                {
                    let mut tmp = CaseAtomContextExt::new(&**_localctx);
                    recog.ctx = Some(tmp.clone());
                    _localctx = tmp;
                    _prevctx = _localctx.clone();

                    /* InvokeRule case_pattern_item */
                    recog.base.set_state(1866);
                    recog.case_pattern_item()?;
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1876);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(261, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1874);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(260, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseORContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1868);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1869);
                                        _la = recog.base.input.la(1);
                                        if { !(_la == OP_ADD || _la == OP_OR) } {
                                            recog.err_handler.recover_inline(&mut recog.base)?;
                                        }
                                        else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog.err_handler.report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1870);
                                        recog.case_pattern_rec(4)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseUntilContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1871);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 2)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        {
                                            recog.base.set_state(1872);
                                            recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1873);
                                        recog.case_pattern_rec(3)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1878);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(261, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- case_pattern_item ----------------
pub type Case_pattern_itemContextAll<'input> = Case_pattern_itemContext<'input>;

pub type Case_pattern_itemContext<'input> = BaseParserRuleContext<'input, Case_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_item }
}
antlr_rust::tid! {Case_pattern_itemContextExt<'a>}

impl<'input> Case_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Case_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_itemContextExt<'input>>
{
    fn case_pattern_tuple(&self) -> Option<Rc<Case_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT2
    /// Returns `None` if there is no child corresponding to token OP_DOT2
    fn OP_DOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT3
    /// Returns `None` if there is no child corresponding to token OP_DOT3
    fn OP_DOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT3, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> Case_pattern_itemContextAttrs<'input> for Case_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_item(&mut self) -> Result<Rc<Case_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_case_pattern_item);
        let mut _localctx: Rc<Case_pattern_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1901);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(264, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule case_pattern_tuple */
                        recog.base.set_state(1879);
                        recog.case_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1880);
                        let tmp = recog.identifier()?;
                        cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                        recog.base.set_state(1881);
                        recog.base.match_token(OP_BIND, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1882);
                        recog.case_pattern_item()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1884);
                        recog.modified_identifier()?;

                        recog.base.set_state(1885);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        recog.base.set_state(1889);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(262, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(1886);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(1887);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1891);
                        recog.case_pattern_item()?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1893);
                        _la = recog.base.input.la(1);
                        if { !(_la == OP_DOT3 || _la == OP_DOT2) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        recog.base.set_state(1895);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(263, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(1894);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1897);
                        recog.namepath()?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule number_literal */
                        recog.base.set_state(1898);
                        recog.number_literal()?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule string_literal */
                        recog.base.set_state(1899);
                        recog.string_literal()?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1900);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern_tuple ----------------
pub type Case_pattern_tupleContextAll<'input> = Case_pattern_tupleContext<'input>;

pub type Case_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Case_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_tuple }
}
antlr_rust::tid! {Case_pattern_tupleContextExt<'a>}

impl<'input> Case_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Case_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Case_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn case_pattern_item_all(&self) -> Vec<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern_item(&self, i: usize) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Case_pattern_tupleContextAttrs<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_tuple(&mut self) -> Result<Rc<Case_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_case_pattern_tuple);
        let mut _localctx: Rc<Case_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1985);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(278, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1904);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1903);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1906);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(1907);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1909);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1908);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1911);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1912);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1914);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1913);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1916);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(1917);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1918);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1919);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1920);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(1921);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1923);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1924);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1927);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1925);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1926);
                                        recog.case_pattern_item()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(1929);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(268, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(1932);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1931);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1934);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1936);
                        recog.namepath()?;

                        recog.base.set_state(1937);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1938);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1943);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(270, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1939);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1940);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1945);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(270, &mut recog.base)?;
                        }
                        recog.base.set_state(1947);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1946);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1949);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        recog.base.set_state(1952);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1951);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1954);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1955);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1960);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(273, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1956);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1957);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1962);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(273, &mut recog.base)?;
                        }
                        recog.base.set_state(1964);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1963);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1966);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1969);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1968);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1971);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1972);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1977);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(276, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1973);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1974);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1979);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(276, &mut recog.base)?;
                        }
                        recog.base.set_state(1981);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1980);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1983);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- object_statement ----------------
pub type Object_statementContextAll<'input> = Object_statementContext<'input>;

pub type Object_statementContext<'input> = BaseParserRuleContext<'input, Object_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Object_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Object_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Object_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_object_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_object_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Object_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_object_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Object_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_object_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_object_statement }
}
antlr_rust::tid! {Object_statementContextExt<'a>}

impl<'input> Object_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Object_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Object_statementContextExt { ph: PhantomData }))
    }
}

pub trait Object_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Object_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_OBJECT
    /// Returns `None` if there is no child corresponding to token KW_OBJECT
    fn KW_OBJECT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_OBJECT, 0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Object_statementContextAttrs<'input> for Object_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn object_statement(&mut self) -> Result<Rc<Object_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Object_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_object_statement);
        let mut _localctx: Rc<Object_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1987);
                recog.base.match_token(KW_OBJECT, &mut recog.err_handler)?;

                recog.base.set_state(1989);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(1988);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(1992);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(1991);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(1995);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(1994);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(1997);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_statement ----------------
pub type New_statementContextAll<'input> = New_statementContext<'input>;

pub type New_statementContext<'input> = BaseParserRuleContext<'input, New_statementContextExt<'input>>;

#[derive(Clone)]
pub struct New_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_statement }
}
antlr_rust::tid! {New_statementContextExt<'a>}

impl<'input> New_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_statementContextExt { ph: PhantomData }))
    }
}

pub trait New_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<New_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NEW
    /// Returns `None` if there is no child corresponding to token KW_NEW
    fn KW_NEW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NEW, 0)
    }
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn new_block(&self) -> Option<Rc<New_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_statementContextAttrs<'input> for New_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_statement(&mut self) -> Result<Rc<New_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_new_statement);
        let mut _localctx: Rc<New_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2016);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(285, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1999);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(2000);
                        recog.modified_namepath()?;

                        recog.base.set_state(2002);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(2001);
                                recog.generic_call_in_type()?;
                            }
                        }

                        recog.base.set_state(2005);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == PARENTHESES_L {
                            {
                                /* InvokeRule tuple_call_body */
                                recog.base.set_state(2004);
                                recog.tuple_call_body()?;
                            }
                        }

                        /* InvokeRule new_block */
                        recog.base.set_state(2007);
                        recog.new_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2009);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(2010);
                        recog.modified_namepath()?;

                        recog.base.set_state(2012);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(2011);
                                recog.generic_call_in_type()?;
                            }
                        }

                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(2014);
                        recog.tuple_call_body()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_block ----------------
pub type New_blockContextAll<'input> = New_blockContext<'input>;

pub type New_blockContext<'input> = BaseParserRuleContext<'input, New_blockContextExt<'input>>;

#[derive(Clone)]
pub struct New_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_block }
}
antlr_rust::tid! {New_blockContextExt<'a>}

impl<'input> New_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_blockContextExt { ph: PhantomData }))
    }
}

pub trait New_blockContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<New_blockContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn new_call_item_all(&self) -> Vec<Rc<New_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn new_call_item(&self, i: usize) -> Option<Rc<New_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> New_blockContextAttrs<'input> for New_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_block(&mut self) -> Result<Rc<New_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_new_block);
        let mut _localctx: Rc<New_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2018);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(2023);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << COMMA)
                            | (1usize << SEMICOLON)
                            | (1usize << FAKE_COLON)
                            | (1usize << PARENTHESES_L)
                            | (1usize << BRACKET_L)
                            | (1usize << BRACE_L)
                            | (1usize << OFFSET_L)
                            | (1usize << CEILING_L)
                            | (1usize << FLOOR_L)
                            | (1usize << OP_ADD)
                            | (1usize << OP_SUB)
                            | (1usize << OP_MUL)))
                        != 0)
                    || (((_la - 58) & !0x3f) == 0
                        && ((1usize << (_la - 58))
                            & ((1usize << (OP_BANG - 58))
                                | (1usize << (OP_NOT - 58))
                                | (1usize << (OP_AND - 58))
                                | (1usize << (OP_AT - 58))
                                | (1usize << (OP_HASH - 58))
                                | (1usize << (LAMBDA_SLOT - 58))))
                            != 0)
                    || (((_la - 93) & !0x3f) == 0
                        && ((1usize << (_la - 93))
                            & ((1usize << (OP_DOT3 - 93))
                                | (1usize << (OP_DOT2 - 93))
                                | (1usize << (OP_INVERSE - 93))
                                | (1usize << (OP_ROOT2 - 93))
                                | (1usize << (OP_ROOT3 - 93))
                                | (1usize << (OP_ROOT4 - 93))
                                | (1usize << (OP_PERCENT - 93))
                                | (1usize << (OP_REFERENCE - 93))
                                | (1usize << (OP_LABEL - 93))
                                | (1usize << (OP_OUTPUT - 93))
                                | (1usize << (OP_LAST - 93))
                                | (1usize << (KW_NEW - 93))
                                | (1usize << (KW_OBJECT - 93))))
                            != 0)
                    || (((_la - 125) & !0x3f) == 0
                        && ((1usize << (_la - 125))
                            & ((1usize << (KW_LAMBDA - 125))
                                | (1usize << (KW_TRY - 125))
                                | (1usize << (KW_MATCH - 125))
                                | (1usize << (KW_CATCH - 125))
                                | (1usize << (INTEGER - 125))
                                | (1usize << (DECIMAL - 125))
                                | (1usize << (STRING_START - 125))
                                | (1usize << (KW_IF - 125))
                                | (1usize << (RETURN - 125))
                                | (1usize << (RESUME - 125))
                                | (1usize << (YIELD - 125))
                                | (1usize << (BREAK - 125))
                                | (1usize << (CONTINUE - 125))
                                | (1usize << (FALL_THROUGH - 125))
                                | (1usize << (RAISE - 125))
                                | (1usize << (SPECIAL - 125))
                                | (1usize << (RAW_ID - 125))
                                | (1usize << (UNICODE_ID - 125))))
                            != 0)
                {
                    {
                        recog.base.set_state(2021);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | BRACE_L | OFFSET_L | CEILING_L | FLOOR_L | OP_ADD | OP_SUB | OP_MUL
                            | OP_BANG | OP_NOT | OP_AND | OP_AT | OP_HASH | LAMBDA_SLOT | OP_DOT3 | OP_DOT2 | OP_INVERSE
                            | OP_ROOT2 | OP_ROOT3 | OP_ROOT4 | OP_PERCENT | OP_REFERENCE | OP_LABEL | OP_OUTPUT | OP_LAST
                            | KW_NEW | KW_OBJECT | KW_LAMBDA | KW_TRY | KW_MATCH | KW_CATCH | INTEGER | DECIMAL
                            | STRING_START | KW_IF | RETURN | RESUME | YIELD | BREAK | CONTINUE | FALL_THROUGH | RAISE
                            | SPECIAL | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule new_call_item */
                                    recog.base.set_state(2019);
                                    recog.new_call_item()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(2020);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(2025);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(2026);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_call_item ----------------
pub type New_call_itemContextAll<'input> = New_call_itemContext<'input>;

pub type New_call_itemContext<'input> = BaseParserRuleContext<'input, New_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct New_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_call_item }
}
antlr_rust::tid! {New_call_itemContextExt<'a>}

impl<'input> New_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_call_itemContextExt { ph: PhantomData }))
    }
}

pub trait New_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<New_call_itemContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn new_call_key(&self) -> Option<Rc<New_call_keyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_call_itemContextAttrs<'input> for New_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_call_item(&mut self) -> Result<Rc<New_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_new_call_item);
        let mut _localctx: Rc<New_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2029);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(288, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule new_call_key */
                            recog.base.set_state(2028);
                            recog.new_call_key()?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule expression */
                recog.base.set_state(2031);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_call_key ----------------
#[derive(Debug)]
pub enum New_call_keyContextAll<'input> {
    NK2Context(NK2Context<'input>),
    NK1Context(NK1Context<'input>),
    NK4Context(NK4Context<'input>),
    NK3Context(NK3Context<'input>),
    Error(New_call_keyContext<'input>),
}
antlr_rust::tid! {New_call_keyContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for New_call_keyContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for New_call_keyContextAll<'input> {}

impl<'input> Deref for New_call_keyContextAll<'input> {
    type Target = dyn New_call_keyContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use New_call_keyContextAll::*;
        match self {
            NK2Context(inner) => inner,
            NK1Context(inner) => inner,
            NK4Context(inner) => inner,
            NK3Context(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_call_keyContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_call_keyContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type New_call_keyContext<'input> = BaseParserRuleContext<'input, New_call_keyContextExt<'input>>;

#[derive(Clone)]
pub struct New_call_keyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_call_keyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_call_keyContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_call_keyContext<'input> {}

impl<'input> CustomRuleContext<'input> for New_call_keyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_call_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_call_key }
}
antlr_rust::tid! {New_call_keyContextExt<'a>}

impl<'input> New_call_keyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_call_keyContextAll<'input>> {
        Rc::new(New_call_keyContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            New_call_keyContextExt { ph: PhantomData },
        )))
    }
}

pub trait New_call_keyContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<New_call_keyContextExt<'input>>
{
}

impl<'input> New_call_keyContextAttrs<'input> for New_call_keyContext<'input> {}

pub type NK2Context<'input> = BaseParserRuleContext<'input, NK2ContextExt<'input>>;

pub trait NK2ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> NK2ContextAttrs<'input> for NK2Context<'input> {}

pub struct NK2ContextExt<'input> {
    base: New_call_keyContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NK2ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for NK2Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NK2Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_NK2(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_NK2(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NK2Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_NK2(self);
    }
}

impl<'input> CustomRuleContext<'input> for NK2ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_call_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_call_key }
}

impl<'input> Borrow<New_call_keyContextExt<'input>> for NK2Context<'input> {
    fn borrow(&self) -> &New_call_keyContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<New_call_keyContextExt<'input>> for NK2Context<'input> {
    fn borrow_mut(&mut self) -> &mut New_call_keyContextExt<'input> {
        &mut self.base
    }
}

impl<'input> New_call_keyContextAttrs<'input> for NK2Context<'input> {}

impl<'input> NK2ContextExt<'input> {
    fn new(ctx: &dyn New_call_keyContextAttrs<'input>) -> Rc<New_call_keyContextAll<'input>> {
        Rc::new(New_call_keyContextAll::NK2Context(BaseParserRuleContext::copy_from(
            ctx,
            NK2ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type NK1Context<'input> = BaseParserRuleContext<'input, NK1ContextExt<'input>>;

pub trait NK1ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> NK1ContextAttrs<'input> for NK1Context<'input> {}

pub struct NK1ContextExt<'input> {
    base: New_call_keyContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NK1ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for NK1Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NK1Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_NK1(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_NK1(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NK1Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_NK1(self);
    }
}

impl<'input> CustomRuleContext<'input> for NK1ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_call_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_call_key }
}

impl<'input> Borrow<New_call_keyContextExt<'input>> for NK1Context<'input> {
    fn borrow(&self) -> &New_call_keyContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<New_call_keyContextExt<'input>> for NK1Context<'input> {
    fn borrow_mut(&mut self) -> &mut New_call_keyContextExt<'input> {
        &mut self.base
    }
}

impl<'input> New_call_keyContextAttrs<'input> for NK1Context<'input> {}

impl<'input> NK1ContextExt<'input> {
    fn new(ctx: &dyn New_call_keyContextAttrs<'input>) -> Rc<New_call_keyContextAll<'input>> {
        Rc::new(New_call_keyContextAll::NK1Context(BaseParserRuleContext::copy_from(
            ctx,
            NK1ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type NK4Context<'input> = BaseParserRuleContext<'input, NK4ContextExt<'input>>;

pub trait NK4ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> NK4ContextAttrs<'input> for NK4Context<'input> {}

pub struct NK4ContextExt<'input> {
    base: New_call_keyContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NK4ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for NK4Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NK4Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_NK4(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_NK4(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NK4Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_NK4(self);
    }
}

impl<'input> CustomRuleContext<'input> for NK4ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_call_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_call_key }
}

impl<'input> Borrow<New_call_keyContextExt<'input>> for NK4Context<'input> {
    fn borrow(&self) -> &New_call_keyContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<New_call_keyContextExt<'input>> for NK4Context<'input> {
    fn borrow_mut(&mut self) -> &mut New_call_keyContextExt<'input> {
        &mut self.base
    }
}

impl<'input> New_call_keyContextAttrs<'input> for NK4Context<'input> {}

impl<'input> NK4ContextExt<'input> {
    fn new(ctx: &dyn New_call_keyContextAttrs<'input>) -> Rc<New_call_keyContextAll<'input>> {
        Rc::new(New_call_keyContextAll::NK4Context(BaseParserRuleContext::copy_from(
            ctx,
            NK4ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type NK3Context<'input> = BaseParserRuleContext<'input, NK3ContextExt<'input>>;

pub trait NK3ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> NK3ContextAttrs<'input> for NK3Context<'input> {}

pub struct NK3ContextExt<'input> {
    base: New_call_keyContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NK3ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for NK3Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NK3Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_NK3(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_NK3(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NK3Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_NK3(self);
    }
}

impl<'input> CustomRuleContext<'input> for NK3ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_call_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_call_key }
}

impl<'input> Borrow<New_call_keyContextExt<'input>> for NK3Context<'input> {
    fn borrow(&self) -> &New_call_keyContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<New_call_keyContextExt<'input>> for NK3Context<'input> {
    fn borrow_mut(&mut self) -> &mut New_call_keyContextExt<'input> {
        &mut self.base
    }
}

impl<'input> New_call_keyContextAttrs<'input> for NK3Context<'input> {}

impl<'input> NK3ContextExt<'input> {
    fn new(ctx: &dyn New_call_keyContextAttrs<'input>) -> Rc<New_call_keyContextAll<'input>> {
        Rc::new(New_call_keyContextAll::NK3Context(BaseParserRuleContext::copy_from(
            ctx,
            NK3ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_call_key(&mut self) -> Result<Rc<New_call_keyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_call_keyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_new_call_key);
        let mut _localctx: Rc<New_call_keyContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2044);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                RAW_ID | UNICODE_ID => {
                    let tmp = NK1ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(2033);
                        recog.identifier()?;

                        recog.base.set_state(2034);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                INTEGER => {
                    let tmp = NK2ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2036);
                        recog.base.match_token(INTEGER, &mut recog.err_handler)?;

                        recog.base.set_state(2037);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                STRING_START => {
                    let tmp = NK3ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule string */
                        recog.base.set_state(2038);
                        recog.string()?;

                        recog.base.set_state(2039);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                BRACKET_L | OFFSET_L => {
                    let tmp = NK4ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /* InvokeRule range_literal */
                        recog.base.set_state(2041);
                        recog.range_literal()?;

                        recog.base.set_state(2042);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_literal ----------------
pub type Tuple_literalContextAll<'input> = Tuple_literalContext<'input>;

pub type Tuple_literalContext<'input> = BaseParserRuleContext<'input, Tuple_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_literal }
}
antlr_rust::tid! {Tuple_literalContextExt<'a>}

impl<'input> Tuple_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_literalContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn collection_pair_all(&self) -> Vec<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn collection_pair(&self, i: usize) -> Option<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Tuple_literalContextAttrs<'input> for Tuple_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_literal(&mut self) -> Result<Rc<Tuple_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_tuple_literal);
        let mut _localctx: Rc<Tuple_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(2066);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(292, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2046);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(2047);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2048);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(2049);
                        recog.collection_pair()?;

                        recog.base.set_state(2052);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(2050);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule collection_pair */
                                        recog.base.set_state(2051);
                                        recog.collection_pair()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(2054);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(290, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(2057);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(2056);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(2059);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(2061);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(2062);
                        recog.collection_pair()?;

                        recog.base.set_state(2063);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(2064);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- collection_pair ----------------
pub type Collection_pairContextAll<'input> = Collection_pairContext<'input>;

pub type Collection_pairContext<'input> = BaseParserRuleContext<'input, Collection_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Collection_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Collection_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Collection_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_collection_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_collection_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Collection_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_collection_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Collection_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_pair }
}
antlr_rust::tid! {Collection_pairContextExt<'a>}

impl<'input> Collection_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Collection_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Collection_pairContextExt { ph: PhantomData }))
    }
}

pub trait Collection_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Collection_pairContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn collection_key(&self) -> Option<Rc<Collection_keyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Collection_pairContextAttrs<'input> for Collection_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn collection_pair(&mut self) -> Result<Rc<Collection_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Collection_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_collection_pair);
        let mut _localctx: Rc<Collection_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2069);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(293, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule collection_key */
                            recog.base.set_state(2068);
                            recog.collection_key()?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule expression */
                recog.base.set_state(2071);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- collection_key ----------------
#[derive(Debug)]
pub enum Collection_keyContextAll<'input> {
    CK1Context(CK1Context<'input>),
    CK3Context(CK3Context<'input>),
    CK2Context(CK2Context<'input>),
    Error(Collection_keyContext<'input>),
}
antlr_rust::tid! {Collection_keyContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Collection_keyContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Collection_keyContextAll<'input> {}

impl<'input> Deref for Collection_keyContextAll<'input> {
    type Target = dyn Collection_keyContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Collection_keyContextAll::*;
        match self {
            CK1Context(inner) => inner,
            CK3Context(inner) => inner,
            CK2Context(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Collection_keyContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Collection_keyContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Collection_keyContext<'input> = BaseParserRuleContext<'input, Collection_keyContextExt<'input>>;

#[derive(Clone)]
pub struct Collection_keyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Collection_keyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Collection_keyContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Collection_keyContext<'input> {}

impl<'input> CustomRuleContext<'input> for Collection_keyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_key }
}
antlr_rust::tid! {Collection_keyContextExt<'a>}

impl<'input> Collection_keyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Collection_keyContextAll<'input>> {
        Rc::new(Collection_keyContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Collection_keyContextExt { ph: PhantomData },
        )))
    }
}

pub trait Collection_keyContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Collection_keyContextExt<'input>>
{
}

impl<'input> Collection_keyContextAttrs<'input> for Collection_keyContext<'input> {}

pub type CK1Context<'input> = BaseParserRuleContext<'input, CK1ContextExt<'input>>;

pub trait CK1ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> CK1ContextAttrs<'input> for CK1Context<'input> {}

pub struct CK1ContextExt<'input> {
    base: Collection_keyContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CK1ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CK1Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CK1Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CK1(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CK1(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CK1Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CK1(self);
    }
}

impl<'input> CustomRuleContext<'input> for CK1ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_key }
}

impl<'input> Borrow<Collection_keyContextExt<'input>> for CK1Context<'input> {
    fn borrow(&self) -> &Collection_keyContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Collection_keyContextExt<'input>> for CK1Context<'input> {
    fn borrow_mut(&mut self) -> &mut Collection_keyContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Collection_keyContextAttrs<'input> for CK1Context<'input> {}

impl<'input> CK1ContextExt<'input> {
    fn new(ctx: &dyn Collection_keyContextAttrs<'input>) -> Rc<Collection_keyContextAll<'input>> {
        Rc::new(Collection_keyContextAll::CK1Context(BaseParserRuleContext::copy_from(
            ctx,
            CK1ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CK3Context<'input> = BaseParserRuleContext<'input, CK3ContextExt<'input>>;

pub trait CK3ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> CK3ContextAttrs<'input> for CK3Context<'input> {}

pub struct CK3ContextExt<'input> {
    base: Collection_keyContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CK3ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CK3Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CK3Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CK3(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CK3(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CK3Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CK3(self);
    }
}

impl<'input> CustomRuleContext<'input> for CK3ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_key }
}

impl<'input> Borrow<Collection_keyContextExt<'input>> for CK3Context<'input> {
    fn borrow(&self) -> &Collection_keyContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Collection_keyContextExt<'input>> for CK3Context<'input> {
    fn borrow_mut(&mut self) -> &mut Collection_keyContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Collection_keyContextAttrs<'input> for CK3Context<'input> {}

impl<'input> CK3ContextExt<'input> {
    fn new(ctx: &dyn Collection_keyContextAttrs<'input>) -> Rc<Collection_keyContextAll<'input>> {
        Rc::new(Collection_keyContextAll::CK3Context(BaseParserRuleContext::copy_from(
            ctx,
            CK3ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CK2Context<'input> = BaseParserRuleContext<'input, CK2ContextExt<'input>>;

pub trait CK2ContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> CK2ContextAttrs<'input> for CK2Context<'input> {}

pub struct CK2ContextExt<'input> {
    base: Collection_keyContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CK2ContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CK2Context<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CK2Context<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CK2(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CK2(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CK2Context<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CK2(self);
    }
}

impl<'input> CustomRuleContext<'input> for CK2ContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_key
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_key }
}

impl<'input> Borrow<Collection_keyContextExt<'input>> for CK2Context<'input> {
    fn borrow(&self) -> &Collection_keyContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Collection_keyContextExt<'input>> for CK2Context<'input> {
    fn borrow_mut(&mut self) -> &mut Collection_keyContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Collection_keyContextAttrs<'input> for CK2Context<'input> {}

impl<'input> CK2ContextExt<'input> {
    fn new(ctx: &dyn Collection_keyContextAttrs<'input>) -> Rc<Collection_keyContextAll<'input>> {
        Rc::new(Collection_keyContextAll::CK2Context(BaseParserRuleContext::copy_from(
            ctx,
            CK2ContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn collection_key(&mut self) -> Result<Rc<Collection_keyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Collection_keyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_collection_key);
        let mut _localctx: Rc<Collection_keyContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2081);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                RAW_ID | UNICODE_ID => {
                    let tmp = CK1ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(2073);
                        recog.identifier()?;

                        recog.base.set_state(2074);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                INTEGER => {
                    let tmp = CK2ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2076);
                        recog.base.match_token(INTEGER, &mut recog.err_handler)?;

                        recog.base.set_state(2077);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                STRING_START => {
                    let tmp = CK3ContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule string */
                        recog.base.set_state(2078);
                        recog.string()?;

                        recog.base.set_state(2079);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- slice_call ----------------
pub type Slice_callContextAll<'input> = Slice_callContext<'input>;

pub type Slice_callContext<'input> = BaseParserRuleContext<'input, Slice_callContextExt<'input>>;

#[derive(Clone)]
pub struct Slice_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Slice_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Slice_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_slice_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_slice_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Slice_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_slice_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Slice_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_slice_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_slice_call }
}
antlr_rust::tid! {Slice_callContextExt<'a>}

impl<'input> Slice_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Slice_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Slice_callContextExt { ph: PhantomData }))
    }
}

pub trait Slice_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Slice_callContextExt<'input>> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
}

impl<'input> Slice_callContextAttrs<'input> for Slice_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn slice_call(&mut self) -> Result<Rc<Slice_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Slice_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_slice_call);
        let mut _localctx: Rc<Slice_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2084);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AND_THEN {
                    {
                        recog.base.set_state(2083);
                        recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule range_literal */
                recog.base.set_state(2086);
                recog.range_literal()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_literal ----------------
pub type Range_literalContextAll<'input> = Range_literalContext<'input>;

pub type Range_literalContext<'input> = BaseParserRuleContext<'input, Range_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Range_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}
antlr_rust::tid! {Range_literalContextExt<'a>}

impl<'input> Range_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Range_literalContextExt { ph: PhantomData }))
    }
}

pub trait Range_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Range_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn range_axis_all(&self) -> Vec<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn range_axis(&self, i: usize) -> Option<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_L
    /// Returns `None` if there is no child corresponding to token OFFSET_L
    fn OFFSET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_R
    /// Returns `None` if there is no child corresponding to token OFFSET_R
    fn OFFSET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_R, 0)
    }
}

impl<'input> Range_literalContextAttrs<'input> for Range_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_literal(&mut self) -> Result<Rc<Range_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_range_literal);
        let mut _localctx: Rc<Range_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(2118);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                BRACKET_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2088);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(2100);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << OP_PROPORTION)
                                    | (1usize << COLON)
                                    | (1usize << PARENTHESES_L)
                                    | (1usize << BRACKET_L)
                                    | (1usize << BRACE_L)
                                    | (1usize << OFFSET_L)
                                    | (1usize << CEILING_L)
                                    | (1usize << FLOOR_L)
                                    | (1usize << OP_ADD)
                                    | (1usize << OP_SUB)
                                    | (1usize << OP_MUL)))
                                != 0)
                            || (((_la - 58) & !0x3f) == 0
                                && ((1usize << (_la - 58))
                                    & ((1usize << (OP_BANG - 58))
                                        | (1usize << (OP_NOT - 58))
                                        | (1usize << (OP_AND - 58))
                                        | (1usize << (OP_AT - 58))
                                        | (1usize << (OP_HASH - 58))
                                        | (1usize << (LAMBDA_SLOT - 58))))
                                    != 0)
                            || (((_la - 93) & !0x3f) == 0
                                && ((1usize << (_la - 93))
                                    & ((1usize << (OP_DOT3 - 93))
                                        | (1usize << (OP_DOT2 - 93))
                                        | (1usize << (OP_INVERSE - 93))
                                        | (1usize << (OP_ROOT2 - 93))
                                        | (1usize << (OP_ROOT3 - 93))
                                        | (1usize << (OP_ROOT4 - 93))
                                        | (1usize << (OP_PERCENT - 93))
                                        | (1usize << (OP_REFERENCE - 93))
                                        | (1usize << (OP_LABEL - 93))
                                        | (1usize << (OP_OUTPUT - 93))
                                        | (1usize << (OP_LAST - 93))
                                        | (1usize << (KW_NEW - 93))
                                        | (1usize << (KW_OBJECT - 93))))
                                    != 0)
                            || (((_la - 125) & !0x3f) == 0
                                && ((1usize << (_la - 125))
                                    & ((1usize << (KW_LAMBDA - 125))
                                        | (1usize << (KW_TRY - 125))
                                        | (1usize << (KW_MATCH - 125))
                                        | (1usize << (KW_CATCH - 125))
                                        | (1usize << (INTEGER - 125))
                                        | (1usize << (DECIMAL - 125))
                                        | (1usize << (STRING_START - 125))
                                        | (1usize << (KW_IF - 125))
                                        | (1usize << (RETURN - 125))
                                        | (1usize << (RESUME - 125))
                                        | (1usize << (YIELD - 125))
                                        | (1usize << (BREAK - 125))
                                        | (1usize << (CONTINUE - 125))
                                        | (1usize << (FALL_THROUGH - 125))
                                        | (1usize << (RAISE - 125))
                                        | (1usize << (SPECIAL - 125))
                                        | (1usize << (RAW_ID - 125))
                                        | (1usize << (UNICODE_ID - 125))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(2089);
                                recog.range_axis()?;

                                recog.base.set_state(2094);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(296, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(2090);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(2091);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(2096);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(296, &mut recog.base)?;
                                }
                                recog.base.set_state(2098);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(2097);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(2102);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                OFFSET_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2103);
                        recog.base.match_token(OFFSET_L, &mut recog.err_handler)?;

                        recog.base.set_state(2115);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << OP_PROPORTION)
                                    | (1usize << COLON)
                                    | (1usize << PARENTHESES_L)
                                    | (1usize << BRACKET_L)
                                    | (1usize << BRACE_L)
                                    | (1usize << OFFSET_L)
                                    | (1usize << CEILING_L)
                                    | (1usize << FLOOR_L)
                                    | (1usize << OP_ADD)
                                    | (1usize << OP_SUB)
                                    | (1usize << OP_MUL)))
                                != 0)
                            || (((_la - 58) & !0x3f) == 0
                                && ((1usize << (_la - 58))
                                    & ((1usize << (OP_BANG - 58))
                                        | (1usize << (OP_NOT - 58))
                                        | (1usize << (OP_AND - 58))
                                        | (1usize << (OP_AT - 58))
                                        | (1usize << (OP_HASH - 58))
                                        | (1usize << (LAMBDA_SLOT - 58))))
                                    != 0)
                            || (((_la - 93) & !0x3f) == 0
                                && ((1usize << (_la - 93))
                                    & ((1usize << (OP_DOT3 - 93))
                                        | (1usize << (OP_DOT2 - 93))
                                        | (1usize << (OP_INVERSE - 93))
                                        | (1usize << (OP_ROOT2 - 93))
                                        | (1usize << (OP_ROOT3 - 93))
                                        | (1usize << (OP_ROOT4 - 93))
                                        | (1usize << (OP_PERCENT - 93))
                                        | (1usize << (OP_REFERENCE - 93))
                                        | (1usize << (OP_LABEL - 93))
                                        | (1usize << (OP_OUTPUT - 93))
                                        | (1usize << (OP_LAST - 93))
                                        | (1usize << (KW_NEW - 93))
                                        | (1usize << (KW_OBJECT - 93))))
                                    != 0)
                            || (((_la - 125) & !0x3f) == 0
                                && ((1usize << (_la - 125))
                                    & ((1usize << (KW_LAMBDA - 125))
                                        | (1usize << (KW_TRY - 125))
                                        | (1usize << (KW_MATCH - 125))
                                        | (1usize << (KW_CATCH - 125))
                                        | (1usize << (INTEGER - 125))
                                        | (1usize << (DECIMAL - 125))
                                        | (1usize << (STRING_START - 125))
                                        | (1usize << (KW_IF - 125))
                                        | (1usize << (RETURN - 125))
                                        | (1usize << (RESUME - 125))
                                        | (1usize << (YIELD - 125))
                                        | (1usize << (BREAK - 125))
                                        | (1usize << (CONTINUE - 125))
                                        | (1usize << (FALL_THROUGH - 125))
                                        | (1usize << (RAISE - 125))
                                        | (1usize << (SPECIAL - 125))
                                        | (1usize << (RAW_ID - 125))
                                        | (1usize << (UNICODE_ID - 125))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(2104);
                                recog.range_axis()?;

                                recog.base.set_state(2109);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(299, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(2105);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(2106);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(2111);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(299, &mut recog.base)?;
                                }
                                recog.base.set_state(2113);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(2112);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(2117);
                        recog.base.match_token(OFFSET_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_axis ----------------
pub type Range_axisContextAll<'input> = Range_axisContext<'input>;

pub type Range_axisContext<'input> = BaseParserRuleContext<'input, Range_axisContextExt<'input>>;

#[derive(Clone)]
pub struct Range_axisContextExt<'input> {
    pub index: Option<Rc<ExpressionContextAll<'input>>>,
    pub head: Option<Rc<ExpressionContextAll<'input>>>,
    pub tail: Option<Rc<ExpressionContextAll<'input>>>,
    pub step: Option<Rc<ExpressionContextAll<'input>>>,
    pub setp: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_axisContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_axisContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_axis(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_axis(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_axisContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_axis(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_axisContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_axis
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_axis }
}
antlr_rust::tid! {Range_axisContextExt<'a>}

impl<'input> Range_axisContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_axisContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Range_axisContextExt { index: None, head: None, tail: None, step: None, setp: None, ph: PhantomData },
        ))
    }
}

pub trait Range_axisContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_axisContextExt<'input>> {
    /// Retrieves all `TerminalNode`s corresponding to token COLON in current rule
    fn COLON_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COLON, starting from 0.
    /// Returns `None` if number of children corresponding to token COLON is less or equal than `i`.
    fn COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, i)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
}

impl<'input> Range_axisContextAttrs<'input> for Range_axisContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_axis(&mut self) -> Result<Rc<Range_axisContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_axisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_range_axis);
        let mut _localctx: Rc<Range_axisContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2176);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(307, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2120);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2121);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).index = Some(tmp.clone());
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2122);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2123);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(2125);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2126);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2127);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2128);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2129);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        recog.base.set_state(2134);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(2131);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(2132);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(2133);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2136);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2140);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(2137);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(2138);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(2139);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(2142);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2143);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2144);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                9 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 9);
                    recog.base.enter_outer_alt(None, 9);
                    {
                        recog.base.set_state(2149);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(2146);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(2147);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(2148);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                        /* InvokeRule expression */
                        recog.base.set_state(2151);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).step = Some(tmp.clone());
                    }
                }
                10 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 10);
                    recog.base.enter_outer_alt(None, 10);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2152);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2153);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2154);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2155);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                11 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 11);
                    recog.base.enter_outer_alt(None, 11);
                    {
                        recog.base.set_state(2157);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2158);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2159);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2160);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).step = Some(tmp.clone());
                    }
                }
                12 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 12);
                    recog.base.enter_outer_alt(None, 12);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2162);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2166);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(2163);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(2164);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(2165);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                        /* InvokeRule expression */
                        recog.base.set_state(2168);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).setp = Some(tmp.clone());
                    }
                }
                13 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 13);
                    recog.base.enter_outer_alt(None, 13);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2170);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2171);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2172);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2173);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2174);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).step = Some(tmp.clone());
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modifiers ----------------
pub type ModifiersContextAll<'input> = ModifiersContext<'input>;

pub type ModifiersContext<'input> = BaseParserRuleContext<'input, ModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ModifiersContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ModifiersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ModifiersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modifiers(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modifiers(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ModifiersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modifiers(self);
    }
}

impl<'input> CustomRuleContext<'input> for ModifiersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modifiers
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modifiers }
}
antlr_rust::tid! {ModifiersContextExt<'a>}

impl<'input> ModifiersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ModifiersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ModifiersContextExt { identifier: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait ModifiersContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ModifiersContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ModifiersContextAttrs<'input> for ModifiersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modifiers(&mut self) -> Result<Rc<ModifiersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_modifiers);
        let mut _localctx: Rc<ModifiersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2181);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == RAW_ID || _la == UNICODE_ID {
                    {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(2178);
                            let tmp = recog.identifier()?;
                            cast_mut::<_, ModifiersContext>(&mut _localctx).identifier = Some(tmp.clone());

                            let temp = cast_mut::<_, ModifiersContext>(&mut _localctx).identifier.clone().unwrap();
                            cast_mut::<_, ModifiersContext>(&mut _localctx).mods.push(temp);
                        }
                    }
                    recog.base.set_state(2183);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_identifier ----------------
pub type Modified_identifierContextAll<'input> = Modified_identifierContext<'input>;

pub type Modified_identifierContext<'input> = BaseParserRuleContext<'input, Modified_identifierContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_identifierContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub id: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_identifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_identifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_identifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_identifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_identifier }
}
antlr_rust::tid! {Modified_identifierContextExt<'a>}

impl<'input> Modified_identifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_identifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_identifierContextExt { identifier: None, id: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_identifierContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_identifierContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Modified_identifierContextAttrs<'input> for Modified_identifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_identifier(&mut self) -> Result<Rc<Modified_identifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_identifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_modified_identifier);
        let mut _localctx: Rc<Modified_identifierContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2187);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(309, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(2184);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp =
                                    cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(2189);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(309, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(2190);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_identifierContext>(&mut _localctx).id = Some(tmp.clone());
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_namepath ----------------
pub type Modified_namepathContextAll<'input> = Modified_namepathContext<'input>;

pub type Modified_namepathContext<'input> = BaseParserRuleContext<'input, Modified_namepathContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_namepathContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub path: Vec<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_namepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_namepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_namepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_namepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_namepath }
}
antlr_rust::tid! {Modified_namepathContextExt<'a>}

impl<'input> Modified_namepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_namepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_namepathContextExt { identifier: None, mods: Vec::new(), path: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_namepathContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_namepathContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> Modified_namepathContextAttrs<'input> for Modified_namepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_namepath(&mut self) -> Result<Rc<Modified_namepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_namepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_modified_namepath);
        let mut _localctx: Rc<Modified_namepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2195);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(310, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(2192);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(2197);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(310, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(2198);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);

                recog.base.set_state(2203);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(311, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(2199);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(2200);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(2205);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(311, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- lambda_name ----------------
pub type Lambda_nameContextAll<'input> = Lambda_nameContext<'input>;

pub type Lambda_nameContext<'input> = BaseParserRuleContext<'input, Lambda_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Lambda_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Lambda_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Lambda_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lambda_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_lambda_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Lambda_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_lambda_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Lambda_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_lambda_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_lambda_name }
}
antlr_rust::tid! {Lambda_nameContextExt<'a>}

impl<'input> Lambda_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Lambda_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Lambda_nameContextExt { ph: PhantomData }))
    }
}

pub trait Lambda_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Lambda_nameContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token LAMBDA_SLOT
    /// Returns `None` if there is no child corresponding to token LAMBDA_SLOT
    fn LAMBDA_SLOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LAMBDA_SLOT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Lambda_nameContextAttrs<'input> for Lambda_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn lambda_name(&mut self) -> Result<Rc<Lambda_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Lambda_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_lambda_name);
        let mut _localctx: Rc<Lambda_nameContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2206);
                recog.base.match_token(LAMBDA_SLOT, &mut recog.err_handler)?;

                recog.base.set_state(2209);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(312, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(2207);
                            recog.identifier()?;
                        }
                    }

                    x if x == 2 => {
                        {
                            /* InvokeRule number */
                            recog.base.set_state(2208);
                            recog.number()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- output_name ----------------
#[derive(Debug)]
pub enum Output_nameContextAll<'input> {
    PositiveOutputContext(PositiveOutputContext<'input>),
    NegativeOutputContext(NegativeOutputContext<'input>),
    Error(Output_nameContext<'input>),
}
antlr_rust::tid! {Output_nameContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Output_nameContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Output_nameContextAll<'input> {}

impl<'input> Deref for Output_nameContextAll<'input> {
    type Target = dyn Output_nameContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Output_nameContextAll::*;
        match self {
            PositiveOutputContext(inner) => inner,
            NegativeOutputContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Output_nameContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Output_nameContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Output_nameContext<'input> = BaseParserRuleContext<'input, Output_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Output_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Output_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Output_nameContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Output_nameContext<'input> {}

impl<'input> CustomRuleContext<'input> for Output_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_output_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_output_name }
}
antlr_rust::tid! {Output_nameContextExt<'a>}

impl<'input> Output_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Output_nameContextAll<'input>> {
        Rc::new(Output_nameContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Output_nameContextExt { ph: PhantomData },
        )))
    }
}

pub trait Output_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Output_nameContextExt<'input>>
{
}

impl<'input> Output_nameContextAttrs<'input> for Output_nameContext<'input> {}

pub type PositiveOutputContext<'input> = BaseParserRuleContext<'input, PositiveOutputContextExt<'input>>;

pub trait PositiveOutputContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PERCENT
    /// Returns `None` if there is no child corresponding to token OP_PERCENT
    fn OP_PERCENT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PERCENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OUTPUT
    /// Returns `None` if there is no child corresponding to token OP_OUTPUT
    fn OP_OUTPUT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OUTPUT, 0)
    }
}

impl<'input> PositiveOutputContextAttrs<'input> for PositiveOutputContext<'input> {}

pub struct PositiveOutputContextExt<'input> {
    base: Output_nameContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {PositiveOutputContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for PositiveOutputContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for PositiveOutputContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_PositiveOutput(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_PositiveOutput(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for PositiveOutputContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_PositiveOutput(self);
    }
}

impl<'input> CustomRuleContext<'input> for PositiveOutputContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_output_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_output_name }
}

impl<'input> Borrow<Output_nameContextExt<'input>> for PositiveOutputContext<'input> {
    fn borrow(&self) -> &Output_nameContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Output_nameContextExt<'input>> for PositiveOutputContext<'input> {
    fn borrow_mut(&mut self) -> &mut Output_nameContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Output_nameContextAttrs<'input> for PositiveOutputContext<'input> {}

impl<'input> PositiveOutputContextExt<'input> {
    fn new(ctx: &dyn Output_nameContextAttrs<'input>) -> Rc<Output_nameContextAll<'input>> {
        Rc::new(Output_nameContextAll::PositiveOutputContext(BaseParserRuleContext::copy_from(
            ctx,
            PositiveOutputContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type NegativeOutputContext<'input> = BaseParserRuleContext<'input, NegativeOutputContextExt<'input>>;

pub trait NegativeOutputContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_LAST
    /// Returns `None` if there is no child corresponding to token OP_LAST
    fn OP_LAST(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LAST, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
}

impl<'input> NegativeOutputContextAttrs<'input> for NegativeOutputContext<'input> {}

pub struct NegativeOutputContextExt<'input> {
    base: Output_nameContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {NegativeOutputContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for NegativeOutputContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NegativeOutputContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_NegativeOutput(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_NegativeOutput(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NegativeOutputContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_NegativeOutput(self);
    }
}

impl<'input> CustomRuleContext<'input> for NegativeOutputContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_output_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_output_name }
}

impl<'input> Borrow<Output_nameContextExt<'input>> for NegativeOutputContext<'input> {
    fn borrow(&self) -> &Output_nameContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Output_nameContextExt<'input>> for NegativeOutputContext<'input> {
    fn borrow_mut(&mut self) -> &mut Output_nameContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Output_nameContextAttrs<'input> for NegativeOutputContext<'input> {}

impl<'input> NegativeOutputContextExt<'input> {
    fn new(ctx: &dyn Output_nameContextAttrs<'input>) -> Rc<Output_nameContextAll<'input>> {
        Rc::new(Output_nameContextAll::NegativeOutputContext(BaseParserRuleContext::copy_from(
            ctx,
            NegativeOutputContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn output_name(&mut self) -> Result<Rc<Output_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Output_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_output_name);
        let mut _localctx: Rc<Output_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2217);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_PERCENT | OP_OUTPUT => {
                    let tmp = PositiveOutputContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2211);
                        _la = recog.base.input.la(1);
                        if { !(_la == OP_PERCENT || _la == OP_OUTPUT) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        recog.base.set_state(2212);
                        recog.base.match_token(INTEGER, &mut recog.err_handler)?;
                    }
                }

                OP_LAST => {
                    let tmp = NegativeOutputContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(2213);
                        recog.base.match_token(OP_LAST, &mut recog.err_handler)?;

                        recog.base.set_state(2215);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(313, &mut recog.base)? {
                            x if x == 1 => {
                                recog.base.set_state(2214);
                                recog.base.match_token(INTEGER, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath_free ----------------
pub type Namepath_freeContextAll<'input> = Namepath_freeContext<'input>;

pub type Namepath_freeContext<'input> = BaseParserRuleContext<'input, Namepath_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Namepath_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Namepath_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Namepath_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Namepath_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Namepath_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath_free }
}
antlr_rust::tid! {Namepath_freeContextExt<'a>}

impl<'input> Namepath_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Namepath_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Namepath_freeContextExt { ph: PhantomData }))
    }
}

pub trait Namepath_freeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Namepath_freeContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
}

impl<'input> Namepath_freeContextAttrs<'input> for Namepath_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath_free(&mut self) -> Result<Rc<Namepath_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Namepath_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_namepath_free);
        let mut _localctx: Rc<Namepath_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(2219);
                recog.identifier()?;

                recog.base.set_state(2224);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == DOT || _la == OP_PROPORTION {
                    {
                        {
                            recog.base.set_state(2220);
                            _la = recog.base.input.la(1);
                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            }
                            else {
                                if recog.base.input.la(1) == TOKEN_EOF {
                                    recog.base.matched_eof = true
                                };
                                recog.err_handler.report_match(&mut recog.base);
                                recog.base.consume(&mut recog.err_handler);
                            }
                            /* InvokeRule identifier */
                            recog.base.set_state(2221);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(2226);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath ----------------
pub type NamepathContextAll<'input> = NamepathContext<'input>;

pub type NamepathContext<'input> = BaseParserRuleContext<'input, NamepathContextExt<'input>>;

#[derive(Clone)]
pub struct NamepathContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for NamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath }
}
antlr_rust::tid! {NamepathContextExt<'a>}

impl<'input> NamepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NamepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NamepathContextExt { ph: PhantomData }))
    }
}

pub trait NamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NamepathContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> NamepathContextAttrs<'input> for NamepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath(&mut self) -> Result<Rc<NamepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NamepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_namepath);
        let mut _localctx: Rc<NamepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(2227);
                recog.identifier()?;

                recog.base.set_state(2232);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(316, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(2228);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(2229);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(2234);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(316, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;

pub type IdentifierContext<'input> = BaseParserRuleContext<'input, IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for IdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IdentifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IdentifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid! {IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, IdentifierContextExt { ph: PhantomData }))
    }
}

pub trait IdentifierContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<IdentifierContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token UNICODE_ID
    /// Returns `None` if there is no child corresponding to token UNICODE_ID
    fn UNICODE_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNICODE_ID, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RAW_ID
    /// Returns `None` if there is no child corresponding to token RAW_ID
    fn RAW_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAW_ID, 0)
    }
}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn identifier(&mut self) -> Result<Rc<IdentifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2235);
                _la = recog.base.input.la(1);
                if { !(_la == RAW_ID || _la == UNICODE_ID) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number ----------------
pub type NumberContextAll<'input> = NumberContext<'input>;

pub type NumberContext<'input> = BaseParserRuleContext<'input, NumberContextExt<'input>>;

#[derive(Clone)]
pub struct NumberContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number(self);
    }
}

impl<'input> CustomRuleContext<'input> for NumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}
antlr_rust::tid! {NumberContextExt<'a>}

impl<'input> NumberContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NumberContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NumberContextExt { ph: PhantomData }))
    }
}

pub trait NumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NumberContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DECIMAL
    /// Returns `None` if there is no child corresponding to token DECIMAL
    fn DECIMAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DECIMAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
}

impl<'input> NumberContextAttrs<'input> for NumberContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number(&mut self) -> Result<Rc<NumberContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NumberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_number);
        let mut _localctx: Rc<NumberContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2237);
                _la = recog.base.input.la(1);
                if { !(_la == INTEGER || _la == DECIMAL) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number_literal ----------------
pub type Number_literalContextAll<'input> = Number_literalContext<'input>;

pub type Number_literalContext<'input> = BaseParserRuleContext<'input, Number_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Number_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Number_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Number_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Number_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Number_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number_literal }
}
antlr_rust::tid! {Number_literalContextExt<'a>}

impl<'input> Number_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Number_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Number_literalContextExt { ph: PhantomData }))
    }
}

pub trait Number_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Number_literalContextExt<'input>>
{
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Number_literalContextAttrs<'input> for Number_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number_literal(&mut self) -> Result<Rc<Number_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Number_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_number_literal);
        let mut _localctx: Rc<Number_literalContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule number */
                recog.base.set_state(2239);
                recog.number()?;

                recog.base.set_state(2241);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(317, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(2240);
                            recog.identifier()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string ----------------
pub type StringContextAll<'input> = StringContext<'input>;

pub type StringContext<'input> = BaseParserRuleContext<'input, StringContextExt<'input>>;

#[derive(Clone)]
pub struct StringContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for StringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for StringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for StringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string(self);
    }
}

impl<'input> CustomRuleContext<'input> for StringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string }
}
antlr_rust::tid! {StringContextExt<'a>}

impl<'input> StringContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StringContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, StringContextExt { ph: PhantomData }))
    }
}

pub trait StringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<StringContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token STRING_START
    /// Returns `None` if there is no child corresponding to token STRING_START
    fn STRING_START(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_START, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_END
    /// Returns `None` if there is no child corresponding to token STRING_END
    fn STRING_END(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_END, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token STRING_TEXT in current rule
    fn STRING_TEXT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token STRING_TEXT, starting from 0.
    /// Returns `None` if number of children corresponding to token STRING_TEXT is less or equal than `i`.
    fn STRING_TEXT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_TEXT, i)
    }
}

impl<'input> StringContextAttrs<'input> for StringContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string(&mut self) -> Result<Rc<StringContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = StringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_string);
        let mut _localctx: Rc<StringContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2243);
                recog.base.match_token(STRING_START, &mut recog.err_handler)?;

                recog.base.set_state(2247);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == STRING_TEXT {
                    {
                        {
                            recog.base.set_state(2244);
                            recog.base.match_token(STRING_TEXT, &mut recog.err_handler)?;
                        }
                    }
                    recog.base.set_state(2249);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(2250);
                recog.base.match_token(STRING_END, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string_literal ----------------
pub type String_literalContextAll<'input> = String_literalContext<'input>;

pub type String_literalContext<'input> = BaseParserRuleContext<'input, String_literalContextExt<'input>>;

#[derive(Clone)]
pub struct String_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for String_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for String_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for String_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for String_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string_literal }
}
antlr_rust::tid! {String_literalContextExt<'a>}

impl<'input> String_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<String_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, String_literalContextExt { ph: PhantomData }))
    }
}

pub trait String_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<String_literalContextExt<'input>>
{
    fn string(&self) -> Option<Rc<StringContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> String_literalContextAttrs<'input> for String_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string_literal(&mut self) -> Result<Rc<String_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = String_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_string_literal);
        let mut _localctx: Rc<String_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2253);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == RAW_ID || _la == UNICODE_ID {
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(2252);
                        recog.identifier()?;
                    }
                }

                /* InvokeRule string */
                recog.base.set_state(2255);
                recog.string()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}

lazy_static! {
    static ref _ATN: Arc<ATN> = Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(_ATN.clone(), _ATN.get_decision_state(i), i as isize).into())
        }
        Arc::new(dfa)
    };
}

const _serializedATN: &'static str = "\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{a0}\u{8d4}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x03\x02\x03\x02\x03\
	\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\
	\x02\x03\x02\x03\x02\x03\x02\x07\x02\u{10a}\x0a\x02\x0c\x02\x0e\x02\u{10d}\
	\x0b\x02\x03\x02\x03\x02\x03\x03\x03\x03\x03\x04\x03\x04\x03\x05\x03\x05\
	\x03\x05\x05\x05\u{118}\x0a\x05\x03\x06\x03\x06\x03\x06\x03\x07\x03\x07\
	\x05\x07\u{11f}\x0a\x07\x03\x07\x03\x07\x03\x08\x03\x08\x03\x08\x03\x08\
	\x05\x08\u{127}\x0a\x08\x03\x08\x03\x08\x03\x08\x05\x08\u{12c}\x0a\x08\x03\
	\x08\x05\x08\u{12f}\x0a\x08\x03\x08\x03\x08\x03\x08\x05\x08\u{134}\x0a\x08\
	\x03\x08\x03\x08\x03\x08\x05\x08\u{139}\x0a\x08\x03\x08\x05\x08\u{13c}\x0a\
	\x08\x03\x08\x03\x08\x05\x08\u{140}\x0a\x08\x03\x08\x03\x08\x05\x08\u{144}\
	\x0a\x08\x03\x08\x05\x08\u{147}\x0a\x08\x03\x08\x05\x08\u{14a}\x0a\x08\x03\
	\x09\x03\x09\x03\x09\x07\x09\u{14f}\x0a\x09\x0c\x09\x0e\x09\u{152}\x0b\x09\
	\x03\x09\x03\x09\x03\x09\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x07\x0a\u{15b}\
	\x0a\x0a\x0c\x0a\x0e\x0a\u{15e}\x0b\x0a\x03\x0a\x05\x0a\u{161}\x0a\x0a\x03\
	\x0b\x03\x0b\x03\x0c\x05\x0c\u{166}\x0a\x0c\x03\x0c\x07\x0c\u{169}\x0a\x0c\
	\x0c\x0c\x0e\x0c\u{16c}\x0b\x0c\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x05\x0c\
	\u{172}\x0a\x0c\x03\x0c\x05\x0c\u{175}\x0a\x0c\x03\x0c\x05\x0c\u{178}\x0a\
	\x0c\x03\x0c\x03\x0c\x05\x0c\u{17c}\x0a\x0c\x03\x0d\x03\x0d\x03\x0d\x03\
	\x0d\x03\x0d\x07\x0d\u{183}\x0a\x0d\x0c\x0d\x0e\x0d\u{186}\x0b\x0d\x03\x0d\
	\x03\x0d\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x07\x0e\u{190}\
	\x0a\x0e\x0c\x0e\x0e\x0e\u{193}\x0b\x0e\x03\x0e\x05\x0e\u{196}\x0a\x0e\x03\
	\x0e\x03\x0e\x05\x0e\u{19a}\x0a\x0e\x03\x0f\x03\x0f\x03\x10\x07\x10\u{19f}\
	\x0a\x10\x0c\x10\x0e\x10\u{1a2}\x0b\x10\x03\x10\x03\x10\x05\x10\u{1a6}\x0a\
	\x10\x03\x10\x05\x10\u{1a9}\x0a\x10\x03\x11\x07\x11\u{1ac}\x0a\x11\x0c\x11\
	\x0e\x11\u{1af}\x0b\x11\x03\x11\x03\x11\x05\x11\u{1b3}\x0a\x11\x03\x11\x03\
	\x11\x05\x11\u{1b7}\x0a\x11\x03\x11\x05\x11\u{1ba}\x0a\x11\x03\x12\x07\x12\
	\u{1bd}\x0a\x12\x0c\x12\x0e\x12\u{1c0}\x0b\x12\x03\x12\x03\x12\x03\x12\x03\
	\x13\x05\x13\u{1c6}\x0a\x13\x03\x13\x07\x13\u{1c9}\x0a\x13\x0c\x13\x0e\x13\
	\u{1cc}\x0b\x13\x03\x13\x03\x13\x03\x13\x03\x13\x05\x13\u{1d2}\x0a\x13\x03\
	\x13\x05\x13\u{1d5}\x0a\x13\x03\x13\x03\x13\x05\x13\u{1d9}\x0a\x13\x03\x14\
	\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x07\x14\u{1e1}\x0a\x14\x0c\x14\
	\x0e\x14\u{1e4}\x0b\x14\x03\x14\x03\x14\x03\x15\x03\x15\x03\x15\x03\x15\
	\x05\x15\u{1ec}\x0a\x15\x03\x16\x05\x16\u{1ef}\x0a\x16\x03\x16\x07\x16\u{1f2}\
	\x0a\x16\x0c\x16\x0e\x16\u{1f5}\x0b\x16\x03\x16\x03\x16\x03\x16\x03\x16\
	\x05\x16\u{1fb}\x0a\x16\x03\x16\x05\x16\u{1fe}\x0a\x16\x03\x16\x03\x16\x03\
	\x17\x03\x17\x03\x17\x03\x17\x07\x17\u{206}\x0a\x17\x0c\x17\x0e\x17\u{209}\
	\x0b\x17\x03\x17\x03\x17\x03\x18\x03\x18\x03\x18\x03\x19\x05\x19\u{211}\
	\x0a\x19\x03\x19\x07\x19\u{214}\x0a\x19\x0c\x19\x0e\x19\u{217}\x0b\x19\x03\
	\x19\x03\x19\x03\x19\x03\x19\x05\x19\u{21d}\x0a\x19\x03\x19\x05\x19\u{220}\
	\x0a\x19\x03\x19\x05\x19\u{223}\x0a\x19\x03\x19\x03\x19\x03\x1a\x03\x1a\
	\x05\x1a\u{229}\x0a\x1a\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x03\x1b\x03\x1b\
	\x07\x1b\u{231}\x0a\x1b\x0c\x1b\x0e\x1b\u{234}\x0b\x1b\x03\x1b\x03\x1b\x03\
	\x1c\x03\x1c\x05\x1c\u{23a}\x0a\x1c\x03\x1d\x03\x1d\x03\x1d\x07\x1d\u{23f}\
	\x0a\x1d\x0c\x1d\x0e\x1d\u{242}\x0b\x1d\x03\x1d\x03\x1d\x03\x1e\x07\x1e\
	\u{247}\x0a\x1e\x0c\x1e\x0e\x1e\u{24a}\x0b\x1e\x03\x1e\x03\x1e\x03\x1e\x03\
	\x1e\x05\x1e\u{250}\x0a\x1e\x03\x1e\x05\x1e\u{253}\x0a\x1e\x03\x1e\x03\x1e\
	\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x07\x1f\u{25b}\x0a\x1f\x0c\x1f\x0e\x1f\
	\u{25e}\x0b\x1f\x03\x1f\x03\x1f\x03\x20\x07\x20\u{263}\x0a\x20\x0c\x20\x0e\
	\x20\u{266}\x0b\x20\x03\x20\x03\x20\x03\x20\x05\x20\u{26b}\x0a\x20\x03\x21\
	\x05\x21\u{26e}\x0a\x21\x03\x21\x07\x21\u{271}\x0a\x21\x0c\x21\x0e\x21\u{274}\
	\x0b\x21\x03\x21\x03\x21\x03\x21\x03\x21\x05\x21\u{27a}\x0a\x21\x03\x21\
	\x03\x21\x05\x21\u{27e}\x0a\x21\x03\x21\x03\x21\x03\x22\x03\x22\x03\x22\
	\x03\x22\x03\x22\x03\x22\x07\x22\u{288}\x0a\x22\x0c\x22\x0e\x22\u{28b}\x0b\
	\x22\x03\x22\x03\x22\x05\x22\u{28f}\x0a\x22\x03\x23\x07\x23\u{292}\x0a\x23\
	\x0c\x23\x0e\x23\u{295}\x0b\x23\x03\x23\x07\x23\u{298}\x0a\x23\x0c\x23\x0e\
	\x23\u{29b}\x0b\x23\x03\x23\x03\x23\x05\x23\u{29f}\x0a\x23\x03\x23\x05\x23\
	\u{2a2}\x0a\x23\x03\x23\x05\x23\u{2a5}\x0a\x23\x03\x23\x07\x23\u{2a8}\x0a\
	\x23\x0c\x23\x0e\x23\u{2ab}\x0b\x23\x03\x23\x07\x23\u{2ae}\x0a\x23\x0c\x23\
	\x0e\x23\u{2b1}\x0b\x23\x03\x23\x03\x23\x05\x23\u{2b5}\x0a\x23\x03\x23\x05\
	\x23\u{2b8}\x0a\x23\x03\x23\x03\x23\x05\x23\u{2bc}\x0a\x23\x03\x24\x03\x24\
	\x03\x24\x05\x24\u{2c1}\x0a\x24\x03\x25\x03\x25\x03\x25\x03\x25\x05\x25\
	\u{2c7}\x0a\x25\x03\x25\x03\x25\x03\x25\x03\x25\x05\x25\u{2cd}\x0a\x25\x03\
	\x25\x03\x25\x03\x25\x03\x25\x03\x25\x07\x25\u{2d4}\x0a\x25\x0c\x25\x0e\
	\x25\u{2d7}\x0b\x25\x03\x25\x05\x25\u{2da}\x0a\x25\x05\x25\u{2dc}\x0a\x25\
	\x03\x25\x05\x25\u{2df}\x0a\x25\x03\x26\x03\x26\x03\x26\x03\x27\x05\x27\
	\u{2e5}\x0a\x27\x03\x27\x03\x27\x05\x27\u{2e9}\x0a\x27\x03\x27\x03\x27\x03\
	\x27\x05\x27\u{2ee}\x0a\x27\x03\x27\x05\x27\u{2f1}\x0a\x27\x03\x27\x03\x27\
	\x05\x27\u{2f5}\x0a\x27\x03\x27\x03\x27\x05\x27\u{2f9}\x0a\x27\x05\x27\u{2fb}\
	\x0a\x27\x03\x28\x05\x28\u{2fe}\x0a\x28\x03\x28\x03\x28\x03\x28\x05\x28\
	\u{303}\x0a\x28\x05\x28\u{305}\x0a\x28\x03\x28\x05\x28\u{308}\x0a\x28\x03\
	\x28\x03\x28\x03\x28\x05\x28\u{30d}\x0a\x28\x03\x28\x03\x28\x03\x28\x05\
	\x28\u{312}\x0a\x28\x03\x28\x05\x28\u{315}\x0a\x28\x03\x28\x05\x28\u{318}\
	\x0a\x28\x03\x28\x03\x28\x05\x28\u{31c}\x0a\x28\x03\x28\x03\x28\x05\x28\
	\u{320}\x0a\x28\x03\x28\x05\x28\u{323}\x0a\x28\x05\x28\u{325}\x0a\x28\x03\
	\x29\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x07\x29\u{32d}\x0a\x29\x0c\
	\x29\x0e\x29\u{330}\x0b\x29\x03\x29\x05\x29\u{333}\x0a\x29\x03\x29\x03\x29\
	\x05\x29\u{337}\x0a\x29\x03\x2a\x07\x2a\u{33a}\x0a\x2a\x0c\x2a\x0e\x2a\u{33d}\
	\x0b\x2a\x03\x2a\x07\x2a\u{340}\x0a\x2a\x0c\x2a\x0e\x2a\u{343}\x0b\x2a\x03\
	\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x07\x2a\u{34a}\x0a\x2a\x0c\x2a\x0e\
	\x2a\u{34d}\x0b\x2a\x03\x2a\x05\x2a\u{350}\x0a\x2a\x03\x2b\x07\x2b\u{353}\
	\x0a\x2b\x0c\x2b\x0e\x2b\u{356}\x0b\x2b\x03\x2b\x03\x2b\x03\x2b\x05\x2b\
	\u{35b}\x0a\x2b\x03\x2b\x03\x2b\x03\x2c\x03\x2c\x03\x2c\x03\x2c\x03\x2c\
	\x03\x2c\x03\x2c\x07\x2c\u{366}\x0a\x2c\x0c\x2c\x0e\x2c\u{369}\x0b\x2c\x03\
	\x2c\x03\x2c\x03\x2d\x07\x2d\u{36e}\x0a\x2d\x0c\x2d\x0e\x2d\u{371}\x0b\x2d\
	\x03\x2d\x03\x2d\x03\x2d\x05\x2d\u{376}\x0a\x2d\x03\x2d\x03\x2d\x05\x2d\
	\u{37a}\x0a\x2d\x03\x2e\x03\x2e\x05\x2e\u{37e}\x0a\x2e\x03\x2f\x03\x2f\x03\
	\x2f\x07\x2f\u{383}\x0a\x2f\x0c\x2f\x0e\x2f\u{386}\x0b\x2f\x03\x2f\x05\x2f\
	\u{389}\x0a\x2f\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\
	\x06\x30\u{392}\x0a\x30\x0d\x30\x0e\x30\u{393}\x03\x30\x05\x30\u{397}\x0a\
	\x30\x05\x30\u{399}\x0a\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\x30\x03\
	\x30\x07\x30\u{3a1}\x0a\x30\x0c\x30\x0e\x30\u{3a4}\x0b\x30\x03\x30\x05\x30\
	\u{3a7}\x0a\x30\x05\x30\u{3a9}\x0a\x30\x03\x30\x03\x30\x03\x30\x05\x30\u{3ae}\
	\x0a\x30\x03\x30\x03\x30\x03\x30\x03\x30\x07\x30\u{3b4}\x0a\x30\x0c\x30\
	\x0e\x30\u{3b7}\x0b\x30\x03\x30\x05\x30\u{3ba}\x0a\x30\x05\x30\u{3bc}\x0a\
	\x30\x03\x30\x03\x30\x05\x30\u{3c0}\x0a\x30\x03\x30\x03\x30\x03\x30\x03\
	\x30\x07\x30\u{3c6}\x0a\x30\x0c\x30\x0e\x30\u{3c9}\x0b\x30\x03\x30\x05\x30\
	\u{3cc}\x0a\x30\x05\x30\u{3ce}\x0a\x30\x03\x30\x05\x30\u{3d1}\x0a\x30\x03\
	\x31\x03\x31\x03\x31\x05\x31\u{3d6}\x0a\x31\x03\x31\x03\x31\x03\x31\x05\
	\x31\u{3db}\x0a\x31\x03\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{3e1}\x0a\x31\
	\x03\x31\x03\x31\x03\x31\x05\x31\u{3e6}\x0a\x31\x03\x31\x03\x31\x05\x31\
	\u{3ea}\x0a\x31\x03\x31\x03\x31\x05\x31\u{3ee}\x0a\x31\x03\x31\x05\x31\u{3f1}\
	\x0a\x31\x03\x31\x03\x31\x05\x31\u{3f5}\x0a\x31\x03\x31\x05\x31\u{3f8}\x0a\
	\x31\x03\x32\x07\x32\u{3fb}\x0a\x32\x0c\x32\x0e\x32\u{3fe}\x0b\x32\x03\x32\
	\x03\x32\x03\x32\x03\x32\x05\x32\u{404}\x0a\x32\x03\x32\x03\x32\x03\x32\
	\x03\x32\x07\x32\u{40a}\x0a\x32\x0c\x32\x0e\x32\u{40d}\x0b\x32\x03\x32\x03\
	\x32\x03\x32\x03\x32\x05\x32\u{413}\x0a\x32\x03\x32\x03\x32\x05\x32\u{417}\
	\x0a\x32\x03\x33\x03\x33\x03\x33\x03\x34\x07\x34\u{41d}\x0a\x34\x0c\x34\
	\x0e\x34\u{420}\x0b\x34\x03\x34\x03\x34\x03\x34\x03\x34\x07\x34\u{426}\x0a\
	\x34\x0c\x34\x0e\x34\u{429}\x0b\x34\x03\x34\x03\x34\x05\x34\u{42d}\x0a\x34\
	\x03\x35\x07\x35\u{430}\x0a\x35\x0c\x35\x0e\x35\u{433}\x0b\x35\x03\x35\x03\
	\x35\x03\x35\x03\x35\x03\x35\x05\x35\u{43a}\x0a\x35\x03\x35\x03\x35\x03\
	\x35\x03\x35\x03\x35\x07\x35\u{441}\x0a\x35\x0c\x35\x0e\x35\u{444}\x0b\x35\
	\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x05\x35\u{44b}\x0a\x35\x03\x36\
	\x03\x36\x03\x36\x03\x36\x03\x36\x03\x37\x07\x37\u{453}\x0a\x37\x0c\x37\
	\x0e\x37\u{456}\x0b\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x07\x37\
	\u{45d}\x0a\x37\x0c\x37\x0e\x37\u{460}\x0b\x37\x03\x37\x03\x37\x03\x37\x03\
	\x37\x03\x37\x03\x37\x03\x37\x03\x37\x07\x37\u{46a}\x0a\x37\x0c\x37\x0e\
	\x37\u{46d}\x0b\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x05\
	\x37\u{475}\x0a\x37\x03\x37\x03\x37\x05\x37\u{479}\x0a\x37\x03\x38\x03\x38\
	\x03\x38\x03\x39\x07\x39\u{47f}\x0a\x39\x0c\x39\x0e\x39\u{482}\x0b\x39\x03\
	\x39\x03\x39\x05\x39\u{486}\x0a\x39\x03\x39\x05\x39\u{489}\x0a\x39\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x05\x3a\u{4a8}\x0a\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x05\x3a\u{4df}\x0a\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x05\x3a\u{4e6}\x0a\x3a\x05\x3a\u{4e8}\x0a\x3a\x03\x3a\x03\
	\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x07\x3a\u{4f3}\
	\x0a\x3a\x0c\x3a\x0e\x3a\u{4f6}\x0b\x3a\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x05\x3b\u{50b}\x0a\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x07\x3b\u{533}\x0a\x3b\x0c\x3b\x0e\x3b\u{536}\x0b\x3b\x03\
	\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\
	\x3c\x03\x3c\x06\x3c\u{543}\x0a\x3c\x0d\x3c\x0e\x3c\u{544}\x03\x3c\x05\x3c\
	\u{548}\x0a\x3c\x05\x3c\u{54a}\x0a\x3c\x03\x3c\x03\x3c\x05\x3c\u{54e}\x0a\
	\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\
	\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\
	\x3c\x03\x3c\x07\x3c\u{563}\x0a\x3c\x0c\x3c\x0e\x3c\u{566}\x0b\x3c\x03\x3d\
	\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x05\x3d\u{56e}\x0a\x3d\x03\x3e\
	\x03\x3e\x03\x3e\x05\x3e\u{573}\x0a\x3e\x05\x3e\u{575}\x0a\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x05\x3e\u{57a}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{57f}\
	\x0a\x3e\x03\x3e\x03\x3e\x05\x3e\u{583}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\
	\x05\x3e\u{588}\x0a\x3e\x03\x3e\x05\x3e\u{58b}\x0a\x3e\x03\x3e\x03\x3e\x03\
	\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x05\x3e\u{595}\x0a\x3e\x05\
	\x3e\u{597}\x0a\x3e\x03\x3f\x03\x3f\x03\x40\x03\x40\x03\x41\x03\x41\x03\
	\x42\x03\x42\x03\x43\x03\x43\x03\x44\x03\x44\x03\x45\x03\x45\x03\x46\x03\
	\x46\x03\x47\x03\x47\x03\x48\x03\x48\x03\x49\x03\x49\x03\x4a\x03\x4a\x03\
	\x4b\x03\x4b\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x05\x4c\u{5b9}\
	\x0a\x4c\x03\x4d\x03\x4d\x03\x4e\x03\x4e\x03\x4e\x03\x4e\x03\x4e\x05\x4e\
	\u{5c2}\x0a\x4e\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x07\x4f\
	\u{5ca}\x0a\x4f\x0c\x4f\x0e\x4f\u{5cd}\x0b\x4f\x03\x4f\x05\x4f\u{5d0}\x0a\
	\x4f\x03\x4f\x03\x4f\x03\x4f\x05\x4f\u{5d5}\x0a\x4f\x03\x4f\x03\x4f\x03\
	\x4f\x05\x4f\u{5da}\x0a\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x07\x4f\u{5e0}\
	\x0a\x4f\x0c\x4f\x0e\x4f\u{5e3}\x0b\x4f\x03\x4f\x05\x4f\u{5e6}\x0a\x4f\x03\
	\x4f\x03\x4f\x05\x4f\u{5ea}\x0a\x4f\x03\x50\x03\x50\x03\x50\x05\x50\u{5ef}\
	\x0a\x50\x03\x50\x03\x50\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\
	\x03\x51\x03\x51\x07\x51\u{5fb}\x0a\x51\x0c\x51\x0e\x51\u{5fe}\x0b\x51\x03\
	\x51\x05\x51\u{601}\x0a\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\
	\x51\x03\x51\x03\x51\x07\x51\u{60b}\x0a\x51\x0c\x51\x0e\x51\u{60e}\x0b\x51\
	\x03\x51\x05\x51\u{611}\x0a\x51\x03\x51\x03\x51\x05\x51\u{615}\x0a\x51\x03\
	\x52\x05\x52\u{618}\x0a\x52\x03\x52\x03\x52\x03\x52\x03\x52\x07\x52\u{61e}\
	\x0a\x52\x0c\x52\x0e\x52\u{621}\x0b\x52\x03\x52\x03\x52\x03\x52\x03\x52\
	\x03\x52\x03\x52\x07\x52\u{629}\x0a\x52\x0c\x52\x0e\x52\u{62c}\x0b\x52\x03\
	\x52\x03\x52\x05\x52\u{630}\x0a\x52\x03\x53\x03\x53\x03\x53\x05\x53\u{635}\
	\x0a\x53\x03\x53\x03\x53\x03\x54\x03\x54\x03\x54\x03\x55\x07\x55\u{63d}\
	\x0a\x55\x0c\x55\x0e\x55\u{640}\x0b\x55\x03\x55\x03\x55\x03\x55\x03\x55\
	\x03\x55\x07\x55\u{647}\x0a\x55\x0c\x55\x0e\x55\u{64a}\x0b\x55\x03\x55\x05\
	\x55\u{64d}\x0a\x55\x03\x55\x03\x55\x03\x55\x03\x55\x07\x55\u{653}\x0a\x55\
	\x0c\x55\x0e\x55\u{656}\x0b\x55\x03\x55\x05\x55\u{659}\x0a\x55\x03\x55\x03\
	\x55\x03\x55\x03\x55\x03\x55\x03\x55\x07\x55\u{661}\x0a\x55\x0c\x55\x0e\
	\x55\u{664}\x0b\x55\x03\x55\x05\x55\u{667}\x0a\x55\x03\x55\x03\x55\x05\x55\
	\u{66b}\x0a\x55\x03\x55\x03\x55\x03\x56\x03\x56\x03\x56\x03\x56\x07\x56\
	\u{673}\x0a\x56\x0c\x56\x0e\x56\u{676}\x0b\x56\x03\x56\x03\x56\x03\x57\x03\
	\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x05\x57\u{681}\x0a\x57\x03\
	\x58\x03\x58\x03\x58\x03\x59\x03\x59\x07\x59\u{688}\x0a\x59\x0c\x59\x0e\
	\x59\u{68b}\x0b\x59\x03\x59\x03\x59\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\
	\x5a\x05\x5a\u{694}\x0a\x5a\x03\x5b\x03\x5b\x03\x5b\x07\x5b\u{699}\x0a\x5b\
	\x0c\x5b\x0e\x5b\u{69c}\x0b\x5b\x03\x5b\x03\x5b\x03\x5c\x03\x5c\x03\x5c\
	\x05\x5c\u{6a3}\x0a\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x07\x5c\
	\u{6aa}\x0a\x5c\x0c\x5c\x0e\x5c\u{6ad}\x0b\x5c\x03\x5c\x03\x5c\x05\x5c\u{6b1}\
	\x0a\x5c\x05\x5c\u{6b3}\x0a\x5c\x03\x5d\x03\x5d\x03\x5d\x05\x5d\u{6b8}\x0a\
	\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x07\x5d\u{6bf}\x0a\x5d\x0c\
	\x5d\x0e\x5d\u{6c2}\x0b\x5d\x03\x5d\x03\x5d\x05\x5d\u{6c6}\x0a\x5d\x03\x5e\
	\x03\x5e\x05\x5e\u{6ca}\x0a\x5e\x03\x5e\x05\x5e\u{6cd}\x0a\x5e\x03\x5f\x07\
	\x5f\u{6d0}\x0a\x5f\x0c\x5f\x0e\x5f\u{6d3}\x0b\x5f\x03\x5f\x03\x5f\x05\x5f\
	\u{6d7}\x0a\x5f\x03\x5f\x03\x5f\x03\x60\x07\x60\u{6dc}\x0a\x60\x0c\x60\x0e\
	\x60\u{6df}\x0b\x60\x03\x60\x03\x60\x03\x60\x03\x60\x05\x60\u{6e5}\x0a\x60\
	\x03\x60\x03\x60\x05\x60\u{6e9}\x0a\x60\x03\x60\x03\x60\x03\x61\x03\x61\
	\x03\x61\x07\x61\u{6f0}\x0a\x61\x0c\x61\x0e\x61\u{6f3}\x0b\x61\x03\x61\x03\
	\x61\x03\x62\x07\x62\u{6f8}\x0a\x62\x0c\x62\x0e\x62\u{6fb}\x0b\x62\x03\x62\
	\x03\x62\x03\x62\x07\x62\u{700}\x0a\x62\x0c\x62\x0e\x62\u{703}\x0b\x62\x03\
	\x62\x03\x62\x03\x62\x03\x62\x03\x62\x07\x62\u{70a}\x0a\x62\x0c\x62\x0e\
	\x62\u{70d}\x0b\x62\x03\x62\x05\x62\u{710}\x0a\x62\x05\x62\u{712}\x0a\x62\
	\x03\x62\x03\x62\x07\x62\u{716}\x0a\x62\x0c\x62\x0e\x62\u{719}\x0b\x62\x03\
	\x62\x03\x62\x03\x62\x03\x62\x05\x62\u{71f}\x0a\x62\x03\x62\x03\x62\x03\
	\x62\x07\x62\u{724}\x0a\x62\x0c\x62\x0e\x62\u{727}\x0b\x62\x03\x62\x03\x62\
	\x03\x62\x03\x62\x03\x62\x07\x62\u{72e}\x0a\x62\x0c\x62\x0e\x62\u{731}\x0b\
	\x62\x03\x62\x03\x62\x03\x62\x07\x62\u{736}\x0a\x62\x0c\x62\x0e\x62\u{739}\
	\x0b\x62\x03\x62\x03\x62\x03\x62\x03\x62\x05\x62\u{73f}\x0a\x62\x03\x62\
	\x03\x62\x05\x62\u{743}\x0a\x62\x03\x63\x03\x63\x07\x63\u{747}\x0a\x63\x0c\
	\x63\x0e\x63\u{74a}\x0b\x63\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\
	\x64\x03\x64\x03\x64\x03\x64\x07\x64\u{755}\x0a\x64\x0c\x64\x0e\x64\u{758}\
	\x0b\x64\x03\x65\x03\x65\x03\x65\x03\x65\x03\x65\x03\x65\x03\x65\x03\x65\
	\x03\x65\x03\x65\x05\x65\u{764}\x0a\x65\x03\x65\x03\x65\x03\x65\x03\x65\
	\x05\x65\u{76a}\x0a\x65\x03\x65\x03\x65\x03\x65\x03\x65\x05\x65\u{770}\x0a\
	\x65\x03\x66\x05\x66\u{773}\x0a\x66\x03\x66\x03\x66\x03\x66\x05\x66\u{778}\
	\x0a\x66\x03\x66\x03\x66\x03\x66\x05\x66\u{77d}\x0a\x66\x03\x66\x03\x66\
	\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\
	\x06\x66\u{78a}\x0a\x66\x0d\x66\x0e\x66\u{78b}\x03\x66\x05\x66\u{78f}\x0a\
	\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x07\x66\u{798}\
	\x0a\x66\x0c\x66\x0e\x66\u{79b}\x0b\x66\x03\x66\x05\x66\u{79e}\x0a\x66\x03\
	\x66\x03\x66\x03\x66\x05\x66\u{7a3}\x0a\x66\x03\x66\x03\x66\x03\x66\x03\
	\x66\x07\x66\u{7a9}\x0a\x66\x0c\x66\x0e\x66\u{7ac}\x0b\x66\x03\x66\x05\x66\
	\u{7af}\x0a\x66\x03\x66\x03\x66\x03\x66\x05\x66\u{7b4}\x0a\x66\x03\x66\x03\
	\x66\x03\x66\x03\x66\x07\x66\u{7ba}\x0a\x66\x0c\x66\x0e\x66\u{7bd}\x0b\x66\
	\x03\x66\x05\x66\u{7c0}\x0a\x66\x03\x66\x03\x66\x05\x66\u{7c4}\x0a\x66\x03\
	\x67\x03\x67\x05\x67\u{7c8}\x0a\x67\x03\x67\x05\x67\u{7cb}\x0a\x67\x03\x67\
	\x05\x67\u{7ce}\x0a\x67\x03\x67\x03\x67\x03\x68\x03\x68\x03\x68\x05\x68\
	\u{7d5}\x0a\x68\x03\x68\x05\x68\u{7d8}\x0a\x68\x03\x68\x03\x68\x03\x68\x03\
	\x68\x03\x68\x05\x68\u{7df}\x0a\x68\x03\x68\x03\x68\x05\x68\u{7e3}\x0a\x68\
	\x03\x69\x03\x69\x03\x69\x07\x69\u{7e8}\x0a\x69\x0c\x69\x0e\x69\u{7eb}\x0b\
	\x69\x03\x69\x03\x69\x03\x6a\x05\x6a\u{7f0}\x0a\x6a\x03\x6a\x03\x6a\x03\
	\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\
	\x6b\x03\x6b\x05\x6b\u{7ff}\x0a\x6b\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\
	\x6c\x03\x6c\x06\x6c\u{807}\x0a\x6c\x0d\x6c\x0e\x6c\u{808}\x03\x6c\x05\x6c\
	\u{80c}\x0a\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\
	\x05\x6c\u{815}\x0a\x6c\x03\x6d\x05\x6d\u{818}\x0a\x6d\x03\x6d\x03\x6d\x03\
	\x6e\x03\x6e\x03\x6e\x03\x6e\x03\x6e\x03\x6e\x03\x6e\x03\x6e\x05\x6e\u{824}\
	\x0a\x6e\x03\x6f\x05\x6f\u{827}\x0a\x6f\x03\x6f\x03\x6f\x03\x70\x03\x70\
	\x03\x70\x03\x70\x07\x70\u{82f}\x0a\x70\x0c\x70\x0e\x70\u{832}\x0b\x70\x03\
	\x70\x05\x70\u{835}\x0a\x70\x05\x70\u{837}\x0a\x70\x03\x70\x03\x70\x03\x70\
	\x03\x70\x03\x70\x07\x70\u{83e}\x0a\x70\x0c\x70\x0e\x70\u{841}\x0b\x70\x03\
	\x70\x05\x70\u{844}\x0a\x70\x05\x70\u{846}\x0a\x70\x03\x70\x05\x70\u{849}\
	\x0a\x70\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\
	\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{859}\x0a\x71\
	\x03\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{85f}\x0a\x71\x03\x71\x03\x71\
	\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{868}\x0a\x71\x03\x71\
	\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\
	\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{879}\x0a\x71\x03\x71\
	\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{883}\
	\x0a\x71\x03\x72\x07\x72\u{886}\x0a\x72\x0c\x72\x0e\x72\u{889}\x0b\x72\x03\
	\x73\x07\x73\u{88c}\x0a\x73\x0c\x73\x0e\x73\u{88f}\x0b\x73\x03\x73\x03\x73\
	\x03\x74\x07\x74\u{894}\x0a\x74\x0c\x74\x0e\x74\u{897}\x0b\x74\x03\x74\x03\
	\x74\x03\x74\x07\x74\u{89c}\x0a\x74\x0c\x74\x0e\x74\u{89f}\x0b\x74\x03\x75\
	\x03\x75\x03\x75\x05\x75\u{8a4}\x0a\x75\x03\x76\x03\x76\x03\x76\x03\x76\
	\x05\x76\u{8aa}\x0a\x76\x05\x76\u{8ac}\x0a\x76\x03\x77\x03\x77\x03\x77\x07\
	\x77\u{8b1}\x0a\x77\x0c\x77\x0e\x77\u{8b4}\x0b\x77\x03\x78\x03\x78\x03\x78\
	\x07\x78\u{8b9}\x0a\x78\x0c\x78\x0e\x78\u{8bc}\x0b\x78\x03\x79\x03\x79\x03\
	\x7a\x03\x7a\x03\x7b\x03\x7b\x05\x7b\u{8c4}\x0a\x7b\x03\x7c\x03\x7c\x07\
	\x7c\u{8c8}\x0a\x7c\x0c\x7c\x0e\x7c\u{8cb}\x0b\x7c\x03\x7c\x03\x7c\x03\x7d\
	\x05\x7d\u{8d0}\x0a\x7d\x03\x7d\x03\x7d\x03\x7d\x02\x06\x72\x74\x76\u{c6}\
	\x7e\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\x20\x22\
	\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\x44\x46\
	\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\x68\x6a\
	\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\u{88}\u{8a}\
	\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\u{a0}\u{a2}\
	\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\u{b8}\u{ba}\
	\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\u{d0}\u{d2}\
	\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\u{e8}\u{ea}\
	\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\x02\x1b\x03\x02\x05\x06\x03\x02\
	\x04\x06\x03\x02\x4e\x4f\x04\x02\x03\x03\x07\x07\x04\x02\x08\x08\x79\x79\
	\x04\x02\x08\x08\x32\x32\x04\x02\x3e\x3e\x7c\x7c\x03\x02\u{82}\u{83}\x09\
	\x02\x1b\x1c\x1f\x1f\x3c\x3d\x47\x47\x5f\x60\x63\x66\x6b\x6b\x07\x02\x21\
	\x21\x3c\x3c\x53\x53\x5a\x5a\x67\x6a\x05\x02\x23\x27\x2b\x2c\x30\x30\x03\
	\x02\x47\x48\x03\x02\x4b\x4d\x04\x02\x62\x62\x64\x64\x03\x02\x32\x33\x03\
	\x02\x1f\x22\x03\x02\x1b\x1c\x03\x02\x3f\x44\x05\x02\x28\x2a\x2e\x2f\x34\
	\x34\x05\x02\x2d\x2d\x35\x35\x37\x3b\x04\x02\x1b\x1b\x48\x48\x03\x02\x5f\
	\x60\x04\x02\x69\x69\x6d\x6d\x03\x02\u{96}\u{97}\x03\x02\u{88}\u{89}\x02\
	\u{a30}\x02\u{10b}\x03\x02\x02\x02\x04\u{110}\x03\x02\x02\x02\x06\u{112}\
	\x03\x02\x02\x02\x08\u{114}\x03\x02\x02\x02\x0a\u{119}\x03\x02\x02\x02\x0c\
	\u{11c}\x03\x02\x02\x02\x0e\u{149}\x03\x02\x02\x02\x10\u{14b}\x03\x02\x02\
	\x02\x12\u{160}\x03\x02\x02\x02\x14\u{162}\x03\x02\x02\x02\x16\u{165}\x03\
	\x02\x02\x02\x18\u{17d}\x03\x02\x02\x02\x1a\u{199}\x03\x02\x02\x02\x1c\u{19b}\
	\x03\x02\x02\x02\x1e\u{1a0}\x03\x02\x02\x02\x20\u{1ad}\x03\x02\x02\x02\x22\
	\u{1be}\x03\x02\x02\x02\x24\u{1c5}\x03\x02\x02\x02\x26\u{1da}\x03\x02\x02\
	\x02\x28\u{1e7}\x03\x02\x02\x02\x2a\u{1ee}\x03\x02\x02\x02\x2c\u{201}\x03\
	\x02\x02\x02\x2e\u{20c}\x03\x02\x02\x02\x30\u{210}\x03\x02\x02\x02\x32\u{226}\
	\x03\x02\x02\x02\x34\u{22c}\x03\x02\x02\x02\x36\u{237}\x03\x02\x02\x02\x38\
	\u{23b}\x03\x02\x02\x02\x3a\u{248}\x03\x02\x02\x02\x3c\u{256}\x03\x02\x02\
	\x02\x3e\u{264}\x03\x02\x02\x02\x40\u{26d}\x03\x02\x02\x02\x42\u{28e}\x03\
	\x02\x02\x02\x44\u{2bb}\x03\x02\x02\x02\x46\u{2c0}\x03\x02\x02\x02\x48\u{2de}\
	\x03\x02\x02\x02\x4a\u{2e0}\x03\x02\x02\x02\x4c\u{2fa}\x03\x02\x02\x02\x4e\
	\u{324}\x03\x02\x02\x02\x50\u{336}\x03\x02\x02\x02\x52\u{34f}\x03\x02\x02\
	\x02\x54\u{354}\x03\x02\x02\x02\x56\u{35e}\x03\x02\x02\x02\x58\u{36f}\x03\
	\x02\x02\x02\x5a\u{37d}\x03\x02\x02\x02\x5c\u{37f}\x03\x02\x02\x02\x5e\u{3d0}\
	\x03\x02\x02\x02\x60\u{3f7}\x03\x02\x02\x02\x62\u{416}\x03\x02\x02\x02\x64\
	\u{418}\x03\x02\x02\x02\x66\u{41e}\x03\x02\x02\x02\x68\u{44a}\x03\x02\x02\
	\x02\x6a\u{44c}\x03\x02\x02\x02\x6c\u{478}\x03\x02\x02\x02\x6e\u{47a}\x03\
	\x02\x02\x02\x70\u{480}\x03\x02\x02\x02\x72\u{4a7}\x03\x02\x02\x02\x74\u{50a}\
	\x03\x02\x02\x02\x76\u{54d}\x03\x02\x02\x02\x78\u{56d}\x03\x02\x02\x02\x7a\
	\u{596}\x03\x02\x02\x02\x7c\u{598}\x03\x02\x02\x02\x7e\u{59a}\x03\x02\x02\
	\x02\u{80}\u{59c}\x03\x02\x02\x02\u{82}\u{59e}\x03\x02\x02\x02\u{84}\u{5a0}\
	\x03\x02\x02\x02\u{86}\u{5a2}\x03\x02\x02\x02\u{88}\u{5a4}\x03\x02\x02\x02\
	\u{8a}\u{5a6}\x03\x02\x02\x02\u{8c}\u{5a8}\x03\x02\x02\x02\u{8e}\u{5aa}\
	\x03\x02\x02\x02\u{90}\u{5ac}\x03\x02\x02\x02\u{92}\u{5ae}\x03\x02\x02\x02\
	\u{94}\u{5b0}\x03\x02\x02\x02\u{96}\u{5b8}\x03\x02\x02\x02\u{98}\u{5ba}\
	\x03\x02\x02\x02\u{9a}\u{5c1}\x03\x02\x02\x02\u{9c}\u{5e9}\x03\x02\x02\x02\
	\u{9e}\u{5ee}\x03\x02\x02\x02\u{a0}\u{614}\x03\x02\x02\x02\u{a2}\u{62f}\
	\x03\x02\x02\x02\u{a4}\u{634}\x03\x02\x02\x02\u{a6}\u{638}\x03\x02\x02\x02\
	\u{a8}\u{63e}\x03\x02\x02\x02\u{aa}\u{66e}\x03\x02\x02\x02\u{ac}\u{680}\
	\x03\x02\x02\x02\u{ae}\u{682}\x03\x02\x02\x02\u{b0}\u{685}\x03\x02\x02\x02\
	\u{b2}\u{693}\x03\x02\x02\x02\u{b4}\u{695}\x03\x02\x02\x02\u{b6}\u{6b2}\
	\x03\x02\x02\x02\u{b8}\u{6c5}\x03\x02\x02\x02\u{ba}\u{6c7}\x03\x02\x02\x02\
	\u{bc}\u{6d1}\x03\x02\x02\x02\u{be}\u{6dd}\x03\x02\x02\x02\u{c0}\u{6ec}\
	\x03\x02\x02\x02\u{c2}\u{742}\x03\x02\x02\x02\u{c4}\u{744}\x03\x02\x02\x02\
	\u{c6}\u{74b}\x03\x02\x02\x02\u{c8}\u{76f}\x03\x02\x02\x02\u{ca}\u{7c3}\
	\x03\x02\x02\x02\u{cc}\u{7c5}\x03\x02\x02\x02\u{ce}\u{7e2}\x03\x02\x02\x02\
	\u{d0}\u{7e4}\x03\x02\x02\x02\u{d2}\u{7ef}\x03\x02\x02\x02\u{d4}\u{7fe}\
	\x03\x02\x02\x02\u{d6}\u{814}\x03\x02\x02\x02\u{d8}\u{817}\x03\x02\x02\x02\
	\u{da}\u{823}\x03\x02\x02\x02\u{dc}\u{826}\x03\x02\x02\x02\u{de}\u{848}\
	\x03\x02\x02\x02\u{e0}\u{882}\x03\x02\x02\x02\u{e2}\u{887}\x03\x02\x02\x02\
	\u{e4}\u{88d}\x03\x02\x02\x02\u{e6}\u{895}\x03\x02\x02\x02\u{e8}\u{8a0}\
	\x03\x02\x02\x02\u{ea}\u{8ab}\x03\x02\x02\x02\u{ec}\u{8ad}\x03\x02\x02\x02\
	\u{ee}\u{8b5}\x03\x02\x02\x02\u{f0}\u{8bd}\x03\x02\x02\x02\u{f2}\u{8bf}\
	\x03\x02\x02\x02\u{f4}\u{8c1}\x03\x02\x02\x02\u{f6}\u{8c5}\x03\x02\x02\x02\
	\u{f8}\u{8cf}\x03\x02\x02\x02\u{fa}\u{10a}\x05\x08\x05\x02\u{fb}\u{10a}\
	\x05\x0a\x06\x02\u{fc}\u{10a}\x05\x14\x0b\x02\u{fd}\u{10a}\x05\x16\x0c\x02\
	\u{fe}\u{10a}\x05\x30\x19\x02\u{ff}\u{10a}\x05\x3a\x1e\x02\u{100}\u{10a}\
	\x05\x24\x13\x02\u{101}\u{10a}\x05\x2a\x16\x02\u{102}\u{10a}\x05\x40\x21\
	\x02\u{103}\u{10a}\x05\x62\x32\x02\u{104}\u{10a}\x05\x58\x2d\x02\u{105}\
	\u{10a}\x05\x6c\x37\x02\u{106}\u{10a}\x05\x68\x35\x02\u{107}\u{10a}\x05\
	\x70\x39\x02\u{108}\u{10a}\x05\x04\x03\x02\u{109}\u{fa}\x03\x02\x02\x02\
	\u{109}\u{fb}\x03\x02\x02\x02\u{109}\u{fc}\x03\x02\x02\x02\u{109}\u{fd}\
	\x03\x02\x02\x02\u{109}\u{fe}\x03\x02\x02\x02\u{109}\u{ff}\x03\x02\x02\x02\
	\u{109}\u{100}\x03\x02\x02\x02\u{109}\u{101}\x03\x02\x02\x02\u{109}\u{102}\
	\x03\x02\x02\x02\u{109}\u{103}\x03\x02\x02\x02\u{109}\u{104}\x03\x02\x02\
	\x02\u{109}\u{105}\x03\x02\x02\x02\u{109}\u{106}\x03\x02\x02\x02\u{109}\
	\u{107}\x03\x02\x02\x02\u{109}\u{108}\x03\x02\x02\x02\u{10a}\u{10d}\x03\
	\x02\x02\x02\u{10b}\u{109}\x03\x02\x02\x02\u{10b}\u{10c}\x03\x02\x02\x02\
	\u{10c}\u{10e}\x03\x02\x02\x02\u{10d}\u{10b}\x03\x02\x02\x02\u{10e}\u{10f}\
	\x07\x02\x02\x03\u{10f}\x03\x03\x02\x02\x02\u{110}\u{111}\x09\x02\x02\x02\
	\u{111}\x05\x03\x02\x02\x02\u{112}\u{113}\x09\x03\x02\x02\u{113}\x07\x03\
	\x02\x02\x02\u{114}\u{115}\x07\x6f\x02\x02\u{115}\u{117}\x05\u{ec}\x77\x02\
	\u{116}\u{118}\x05\x04\x03\x02\u{117}\u{116}\x03\x02\x02\x02\u{117}\u{118}\
	\x03\x02\x02\x02\u{118}\x09\x03\x02\x02\x02\u{119}\u{11a}\x07\x70\x02\x02\
	\u{11a}\u{11b}\x05\x0e\x08\x02\u{11b}\x0b\x03\x02\x02\x02\u{11c}\u{11e}\
	\x07\x5e\x02\x02\u{11d}\u{11f}\x09\x04\x02\x02\u{11e}\u{11d}\x03\x02\x02\
	\x02\u{11e}\u{11f}\x03\x02\x02\x02\u{11f}\u{120}\x03\x02\x02\x02\u{120}\
	\u{121}\x05\u{f0}\x79\x02\u{121}\x0d\x03\x02\x02\x02\u{122}\u{14a}\x05\x12\
	\x0a\x02\u{123}\u{124}\x07\x4e\x02\x02\u{124}\u{126}\x05\x10\x09\x02\u{125}\
	\u{127}\x05\x0c\x07\x02\u{126}\u{125}\x03\x02\x02\x02\u{126}\u{127}\x03\
	\x02\x02\x02\u{127}\u{14a}\x03\x02\x02\x02\u{128}\u{129}\x07\x4e\x02\x02\
	\u{129}\u{12e}\x05\x10\x09\x02\u{12a}\u{12c}\x09\x05\x02\x02\u{12b}\u{12a}\
	\x03\x02\x02\x02\u{12b}\u{12c}\x03\x02\x02\x02\u{12c}\u{12d}\x03\x02\x02\
	\x02\u{12d}\u{12f}\x05\x12\x0a\x02\u{12e}\u{12b}\x03\x02\x02\x02\u{12e}\
	\u{12f}\x03\x02\x02\x02\u{12f}\u{14a}\x03\x02\x02\x02\u{130}\u{131}\x07\
	\x4f\x02\x02\u{131}\u{133}\x05\x10\x09\x02\u{132}\u{134}\x05\x0c\x07\x02\
	\u{133}\u{132}\x03\x02\x02\x02\u{133}\u{134}\x03\x02\x02\x02\u{134}\u{14a}\
	\x03\x02\x02\x02\u{135}\u{136}\x07\x4f\x02\x02\u{136}\u{13b}\x05\x10\x09\
	\x02\u{137}\u{139}\x09\x05\x02\x02\u{138}\u{137}\x03\x02\x02\x02\u{138}\
	\u{139}\x03\x02\x02\x02\u{139}\u{13a}\x03\x02\x02\x02\u{13a}\u{13c}\x05\
	\x12\x0a\x02\u{13b}\u{138}\x03\x02\x02\x02\u{13b}\u{13c}\x03\x02\x02\x02\
	\u{13c}\u{14a}\x03\x02\x02\x02\u{13d}\u{13f}\x05\x10\x09\x02\u{13e}\u{140}\
	\x05\x0c\x07\x02\u{13f}\u{13e}\x03\x02\x02\x02\u{13f}\u{140}\x03\x02\x02\
	\x02\u{140}\u{14a}\x03\x02\x02\x02\u{141}\u{146}\x05\x10\x09\x02\u{142}\
	\u{144}\x09\x05\x02\x02\u{143}\u{142}\x03\x02\x02\x02\u{143}\u{144}\x03\
	\x02\x02\x02\u{144}\u{145}\x03\x02\x02\x02\u{145}\u{147}\x05\x12\x0a\x02\
	\u{146}\u{143}\x03\x02\x02\x02\u{146}\u{147}\x03\x02\x02\x02\u{147}\u{14a}\
	\x03\x02\x02\x02\u{148}\u{14a}\x05\x06\x04\x02\u{149}\u{122}\x03\x02\x02\
	\x02\u{149}\u{123}\x03\x02\x02\x02\u{149}\u{128}\x03\x02\x02\x02\u{149}\
	\u{130}\x03\x02\x02\x02\u{149}\u{135}\x03\x02\x02\x02\u{149}\u{13d}\x03\
	\x02\x02\x02\u{149}\u{141}\x03\x02\x02\x02\u{149}\u{148}\x03\x02\x02\x02\
	\u{14a}\x0f\x03\x02\x02\x02\u{14b}\u{150}\x05\u{f0}\x79\x02\u{14c}\u{14d}\
	\x09\x05\x02\x02\u{14d}\u{14f}\x05\u{f0}\x79\x02\u{14e}\u{14c}\x03\x02\x02\
	\x02\u{14f}\u{152}\x03\x02\x02\x02\u{150}\u{14e}\x03\x02\x02\x02\u{150}\
	\u{151}\x03\x02\x02\x02\u{151}\u{153}\x03\x02\x02\x02\u{152}\u{150}\x03\
	\x02\x02\x02\u{153}\u{154}\x09\x05\x02\x02\u{154}\u{155}\x07\x1f\x02\x02\
	\u{155}\x11\x03\x02\x02\x02\u{156}\u{157}\x07\x0d\x02\x02\u{157}\u{161}\
	\x07\x0e\x02\x02\u{158}\u{15c}\x07\x0d\x02\x02\u{159}\u{15b}\x05\x0e\x08\
	\x02\u{15a}\u{159}\x03\x02\x02\x02\u{15b}\u{15e}\x03\x02\x02\x02\u{15c}\
	\u{15a}\x03\x02\x02\x02\u{15c}\u{15d}\x03\x02\x02\x02\u{15d}\u{15f}\x03\
	\x02\x02\x02\u{15e}\u{15c}\x03\x02\x02\x02\u{15f}\u{161}\x07\x0e\x02\x02\
	\u{160}\u{156}\x03\x02\x02\x02\u{160}\u{158}\x03\x02\x02\x02\u{161}\x13\
	\x03\x02\x02\x02\u{162}\u{163}\x07\x71\x02\x02\u{163}\x15\x03\x02\x02\x02\
	\u{164}\u{166}\x05\u{a8}\x55\x02\u{165}\u{164}\x03\x02\x02\x02\u{165}\u{166}\
	\x03\x02\x02\x02\u{166}\u{16a}\x03\x02\x02\x02\u{167}\u{169}\x05\u{b8}\x5d\
	\x02\u{168}\u{167}\x03\x02\x02\x02\u{169}\u{16c}\x03\x02\x02\x02\u{16a}\
	\u{168}\x03\x02\x02\x02\u{16a}\u{16b}\x03\x02\x02\x02\u{16b}\u{16d}\x03\
	\x02\x02\x02\u{16c}\u{16a}\x03\x02\x02\x02\u{16d}\u{16e}\x05\u{e2}\x72\x02\
	\u{16e}\u{16f}\x07\x72\x02\x02\u{16f}\u{171}\x05\u{f0}\x79\x02\u{170}\u{172}\
	\x05\u{9c}\x4f\x02\u{171}\u{170}\x03\x02\x02\x02\u{171}\u{172}\x03\x02\x02\
	\x02\u{172}\u{174}\x03\x02\x02\x02\u{173}\u{175}\x05\x1a\x0e\x02\u{174}\
	\u{173}\x03\x02\x02\x02\u{174}\u{175}\x03\x02\x02\x02\u{175}\u{177}\x03\
	\x02\x02\x02\u{176}\u{178}\x05\x64\x33\x02\u{177}\u{176}\x03\x02\x02\x02\
	\u{177}\u{178}\x03\x02\x02\x02\u{178}\u{179}\x03\x02\x02\x02\u{179}\u{17b}\
	\x05\x18\x0d\x02\u{17a}\u{17c}\x05\x04\x03\x02\u{17b}\u{17a}\x03\x02\x02\
	\x02\u{17b}\u{17c}\x03\x02\x02\x02\u{17c}\x17\x03\x02\x02\x02\u{17d}\u{184}\
	\x07\x0d\x02\x02\u{17e}\u{183}\x05\x22\x12\x02\u{17f}\u{183}\x05\x20\x11\
	\x02\u{180}\u{183}\x05\x1e\x10\x02\u{181}\u{183}\x05\x06\x04\x02\u{182}\
	\u{17e}\x03\x02\x02\x02\u{182}\u{17f}\x03\x02\x02\x02\u{182}\u{180}\x03\
	\x02\x02\x02\u{182}\u{181}\x03\x02\x02\x02\u{183}\u{186}\x03\x02\x02\x02\
	\u{184}\u{182}\x03\x02\x02\x02\u{184}\u{185}\x03\x02\x02\x02\u{185}\u{187}\
	\x03\x02\x02\x02\u{186}\u{184}\x03\x02\x02\x02\u{187}\u{188}\x07\x0e\x02\
	\x02\u{188}\x19\x03\x02\x02\x02\u{189}\u{18a}\x07\x09\x02\x02\u{18a}\u{19a}\
	\x07\x0a\x02\x02\u{18b}\u{18c}\x07\x09\x02\x02\u{18c}\u{191}\x05\x1c\x0f\
	\x02\u{18d}\u{18e}\x07\x04\x02\x02\u{18e}\u{190}\x05\x1c\x0f\x02\u{18f}\
	\u{18d}\x03\x02\x02\x02\u{190}\u{193}\x03\x02\x02\x02\u{191}\u{18f}\x03\
	\x02\x02\x02\u{191}\u{192}\x03\x02\x02\x02\u{192}\u{195}\x03\x02\x02\x02\
	\u{193}\u{191}\x03\x02\x02\x02\u{194}\u{196}\x07\x04\x02\x02\u{195}\u{194}\
	\x03\x02\x02\x02\u{195}\u{196}\x03\x02\x02\x02\u{196}\u{197}\x03\x02\x02\
	\x02\u{197}\u{198}\x07\x0a\x02\x02\u{198}\u{19a}\x03\x02\x02\x02\u{199}\
	\u{189}\x03\x02\x02\x02\u{199}\u{18b}\x03\x02\x02\x02\u{19a}\x1b\x03\x02\
	\x02\x02\u{19b}\u{19c}\x05\u{e6}\x74\x02\u{19c}\x1d\x03\x02\x02\x02\u{19d}\
	\u{19f}\x05\u{b8}\x5d\x02\u{19e}\u{19d}\x03\x02\x02\x02\u{19f}\u{1a2}\x03\
	\x02\x02\x02\u{1a0}\u{19e}\x03\x02\x02\x02\u{1a0}\u{1a1}\x03\x02\x02\x02\
	\u{1a1}\u{1a3}\x03\x02\x02\x02\u{1a2}\u{1a0}\x03\x02\x02\x02\u{1a3}\u{1a5}\
	\x05\u{e4}\x73\x02\u{1a4}\u{1a6}\x05\x64\x33\x02\u{1a5}\u{1a4}\x03\x02\x02\
	\x02\u{1a5}\u{1a6}\x03\x02\x02\x02\u{1a6}\u{1a8}\x03\x02\x02\x02\u{1a7}\
	\u{1a9}\x05\x4a\x26\x02\u{1a8}\u{1a7}\x03\x02\x02\x02\u{1a8}\u{1a9}\x03\
	\x02\x02\x02\u{1a9}\x1f\x03\x02\x02\x02\u{1aa}\u{1ac}\x05\u{b8}\x5d\x02\
	\u{1ab}\u{1aa}\x03\x02\x02\x02\u{1ac}\u{1af}\x03\x02\x02\x02\u{1ad}\u{1ab}\
	\x03\x02\x02\x02\u{1ad}\u{1ae}\x03\x02\x02\x02\u{1ae}\u{1b0}\x03\x02\x02\
	\x02\u{1af}\u{1ad}\x03\x02\x02\x02\u{1b0}\u{1b2}\x05\u{e6}\x74\x02\u{1b1}\
	\u{1b3}\x05\u{9c}\x4f\x02\u{1b2}\u{1b1}\x03\x02\x02\x02\u{1b2}\u{1b3}\x03\
	\x02\x02\x02\u{1b3}\u{1b4}\x03\x02\x02\x02\u{1b4}\u{1b6}\x05\x42\x22\x02\
	\u{1b5}\u{1b7}\x05\x48\x25\x02\u{1b6}\u{1b5}\x03\x02\x02\x02\u{1b6}\u{1b7}\
	\x03\x02\x02\x02\u{1b7}\u{1b9}\x03\x02\x02\x02\u{1b8}\u{1ba}\x05\x56\x2c\
	\x02\u{1b9}\u{1b8}\x03\x02\x02\x02\u{1b9}\u{1ba}\x03\x02\x02\x02\u{1ba}\
	\x21\x03\x02\x02\x02\u{1bb}\u{1bd}\x05\u{b8}\x5d\x02\u{1bc}\u{1bb}\x03\x02\
	\x02\x02\u{1bd}\u{1c0}\x03\x02\x02\x02\u{1be}\u{1bc}\x03\x02\x02\x02\u{1be}\
	\u{1bf}\x03\x02\x02\x02\u{1bf}\u{1c1}\x03\x02\x02\x02\u{1c0}\u{1be}\x03\
	\x02\x02\x02\u{1c1}\u{1c2}\x05\u{e4}\x73\x02\u{1c2}\u{1c3}\x05\x18\x0d\x02\
	\u{1c3}\x23\x03\x02\x02\x02\u{1c4}\u{1c6}\x05\u{a8}\x55\x02\u{1c5}\u{1c4}\
	\x03\x02\x02\x02\u{1c5}\u{1c6}\x03\x02\x02\x02\u{1c6}\u{1ca}\x03\x02\x02\
	\x02\u{1c7}\u{1c9}\x05\u{b8}\x5d\x02\u{1c8}\u{1c7}\x03\x02\x02\x02\u{1c9}\
	\u{1cc}\x03\x02\x02\x02\u{1ca}\u{1c8}\x03\x02\x02\x02\u{1ca}\u{1cb}\x03\
	\x02\x02\x02\u{1cb}\u{1cd}\x03\x02\x02\x02\u{1cc}\u{1ca}\x03\x02\x02\x02\
	\u{1cd}\u{1ce}\x05\u{e2}\x72\x02\u{1ce}\u{1cf}\x07\x73\x02\x02\u{1cf}\u{1d1}\
	\x05\u{f0}\x79\x02\u{1d0}\u{1d2}\x05\u{9c}\x4f\x02\u{1d1}\u{1d0}\x03\x02\
	\x02\x02\u{1d1}\u{1d2}\x03\x02\x02\x02\u{1d2}\u{1d4}\x03\x02\x02\x02\u{1d3}\
	\u{1d5}\x05\x2e\x18\x02\u{1d4}\u{1d3}\x03\x02\x02\x02\u{1d4}\u{1d5}\x03\
	\x02\x02\x02\u{1d5}\u{1d6}\x03\x02\x02\x02\u{1d6}\u{1d8}\x05\x26\x14\x02\
	\u{1d7}\u{1d9}\x05\x04\x03\x02\u{1d8}\u{1d7}\x03\x02\x02\x02\u{1d8}\u{1d9}\
	\x03\x02\x02\x02\u{1d9}\x25\x03\x02\x02\x02\u{1da}\u{1e2}\x07\x0d\x02\x02\
	\u{1db}\u{1e1}\x05\x28\x15\x02\u{1dc}\u{1e1}\x05\x20\x11\x02\u{1dd}\u{1e1}\
	\x05\x1e\x10\x02\u{1de}\u{1e1}\x05\x22\x12\x02\u{1df}\u{1e1}\x05\x06\x04\
	\x02\u{1e0}\u{1db}\x03\x02\x02\x02\u{1e0}\u{1dc}\x03\x02\x02\x02\u{1e0}\
	\u{1dd}\x03\x02\x02\x02\u{1e0}\u{1de}\x03\x02\x02\x02\u{1e0}\u{1df}\x03\
	\x02\x02\x02\u{1e1}\u{1e4}\x03\x02\x02\x02\u{1e2}\u{1e0}\x03\x02\x02\x02\
	\u{1e2}\u{1e3}\x03\x02\x02\x02\u{1e3}\u{1e5}\x03\x02\x02\x02\u{1e4}\u{1e2}\
	\x03\x02\x02\x02\u{1e5}\u{1e6}\x07\x0e\x02\x02\u{1e6}\x27\x03\x02\x02\x02\
	\u{1e7}\u{1e8}\x07\x76\x02\x02\u{1e8}\u{1eb}\x05\u{f0}\x79\x02\u{1e9}\u{1ea}\
	\x07\x35\x02\x02\u{1ea}\u{1ec}\x05\x76\x3c\x02\u{1eb}\u{1e9}\x03\x02\x02\
	\x02\u{1eb}\u{1ec}\x03\x02\x02\x02\u{1ec}\x29\x03\x02\x02\x02\u{1ed}\u{1ef}\
	\x05\u{a8}\x55\x02\u{1ee}\u{1ed}\x03\x02\x02\x02\u{1ee}\u{1ef}\x03\x02\x02\
	\x02\u{1ef}\u{1f3}\x03\x02\x02\x02\u{1f0}\u{1f2}\x05\u{b8}\x5d\x02\u{1f1}\
	\u{1f0}\x03\x02\x02\x02\u{1f2}\u{1f5}\x03\x02\x02\x02\u{1f3}\u{1f1}\x03\
	\x02\x02\x02\u{1f3}\u{1f4}\x03\x02\x02\x02\u{1f4}\u{1f6}\x03\x02\x02\x02\
	\u{1f5}\u{1f3}\x03\x02\x02\x02\u{1f6}\u{1f7}\x05\u{e2}\x72\x02\u{1f7}\u{1f8}\
	\x07\x78\x02\x02\u{1f8}\u{1fa}\x05\u{ee}\x78\x02\u{1f9}\u{1fb}\x05\u{9c}\
	\x4f\x02\u{1fa}\u{1f9}\x03\x02\x02\x02\u{1fa}\u{1fb}\x03\x02\x02\x02\u{1fb}\
	\u{1fd}\x03\x02\x02\x02\u{1fc}\u{1fe}\x05\x2e\x18\x02\u{1fd}\u{1fc}\x03\
	\x02\x02\x02\u{1fd}\u{1fe}\x03\x02\x02\x02\u{1fe}\u{1ff}\x03\x02\x02\x02\
	\u{1ff}\u{200}\x05\x2c\x17\x02\u{200}\x2b\x03\x02\x02\x02\u{201}\u{207}\
	\x07\x0d\x02\x02\u{202}\u{206}\x05\x28\x15\x02\u{203}\u{206}\x05\x20\x11\
	\x02\u{204}\u{206}\x05\x06\x04\x02\u{205}\u{202}\x03\x02\x02\x02\u{205}\
	\u{203}\x03\x02\x02\x02\u{205}\u{204}\x03\x02\x02\x02\u{206}\u{209}\x03\
	\x02\x02\x02\u{207}\u{205}\x03\x02\x02\x02\u{207}\u{208}\x03\x02\x02\x02\
	\u{208}\u{20a}\x03\x02\x02\x02\u{209}\u{207}\x03\x02\x02\x02\u{20a}\u{20b}\
	\x07\x0e\x02\x02\u{20b}\x2d\x03\x02\x02\x02\u{20c}\u{20d}\x09\x06\x02\x02\
	\u{20d}\u{20e}\x05\x76\x3c\x02\u{20e}\x2f\x03\x02\x02\x02\u{20f}\u{211}\
	\x05\u{a8}\x55\x02\u{210}\u{20f}\x03\x02\x02\x02\u{210}\u{211}\x03\x02\x02\
	\x02\u{211}\u{215}\x03\x02\x02\x02\u{212}\u{214}\x05\u{b8}\x5d\x02\u{213}\
	\u{212}\x03\x02\x02\x02\u{214}\u{217}\x03\x02\x02\x02\u{215}\u{213}\x03\
	\x02\x02\x02\u{215}\u{216}\x03\x02\x02\x02\u{216}\u{218}\x03\x02\x02\x02\
	\u{217}\u{215}\x03\x02\x02\x02\u{218}\u{219}\x05\u{e2}\x72\x02\u{219}\u{21a}\
	\x07\x74\x02\x02\u{21a}\u{21c}\x05\u{f0}\x79\x02\u{21b}\u{21d}\x05\u{9c}\
	\x4f\x02\u{21c}\u{21b}\x03\x02\x02\x02\u{21c}\u{21d}\x03\x02\x02\x02\u{21d}\
	\u{21f}\x03\x02\x02\x02\u{21e}\u{220}\x05\x32\x1a\x02\u{21f}\u{21e}\x03\
	\x02\x02\x02\u{21f}\u{220}\x03\x02\x02\x02\u{220}\u{222}\x03\x02\x02\x02\
	\u{221}\u{223}\x05\x64\x33\x02\u{222}\u{221}\x03\x02\x02\x02\u{222}\u{223}\
	\x03\x02\x02\x02\u{223}\u{224}\x03\x02\x02\x02\u{224}\u{225}\x05\x34\x1b\
	\x02\u{225}\x31\x03\x02\x02\x02\u{226}\u{228}\x07\x09\x02\x02\u{227}\u{229}\
	\x05\x76\x3c\x02\u{228}\u{227}\x03\x02\x02\x02\u{228}\u{229}\x03\x02\x02\
	\x02\u{229}\u{22a}\x03\x02\x02\x02\u{22a}\u{22b}\x07\x0a\x02\x02\u{22b}\
	\x33\x03\x02\x02\x02\u{22c}\u{232}\x07\x0d\x02\x02\u{22d}\u{231}\x05\x20\
	\x11\x02\u{22e}\u{231}\x05\x36\x1c\x02\u{22f}\u{231}\x05\x06\x04\x02\u{230}\
	\u{22d}\x03\x02\x02\x02\u{230}\u{22e}\x03\x02\x02\x02\u{230}\u{22f}\x03\
	\x02\x02\x02\u{231}\u{234}\x03\x02\x02\x02\u{232}\u{230}\x03\x02\x02\x02\
	\u{232}\u{233}\x03\x02\x02\x02\u{233}\u{235}\x03\x02\x02\x02\u{234}\u{232}\
	\x03\x02\x02\x02\u{235}\u{236}\x07\x0e\x02\x02\u{236}\x35\x03\x02\x02\x02\
	\u{237}\u{239}\x05\u{f0}\x79\x02\u{238}\u{23a}\x05\x38\x1d\x02\u{239}\u{238}\
	\x03\x02\x02\x02\u{239}\u{23a}\x03\x02\x02\x02\u{23a}\x37\x03\x02\x02\x02\
	\u{23b}\u{240}\x07\x0d\x02\x02\u{23c}\u{23f}\x05\x1e\x10\x02\u{23d}\u{23f}\
	\x05\x06\x04\x02\u{23e}\u{23c}\x03\x02\x02\x02\u{23e}\u{23d}\x03\x02\x02\
	\x02\u{23f}\u{242}\x03\x02\x02\x02\u{240}\u{23e}\x03\x02\x02\x02\u{240}\
	\u{241}\x03\x02\x02\x02\u{241}\u{243}\x03\x02\x02\x02\u{242}\u{240}\x03\
	\x02\x02\x02\u{243}\u{244}\x07\x0e\x02\x02\u{244}\x39\x03\x02\x02\x02\u{245}\
	\u{247}\x05\u{b8}\x5d\x02\u{246}\u{245}\x03\x02\x02\x02\u{247}\u{24a}\x03\
	\x02\x02\x02\u{248}\u{246}\x03\x02\x02\x02\u{248}\u{249}\x03\x02\x02\x02\
	\u{249}\u{24b}\x03\x02\x02\x02\u{24a}\u{248}\x03\x02\x02\x02\u{24b}\u{24c}\
	\x05\u{e2}\x72\x02\u{24c}\u{24d}\x07\x75\x02\x02\u{24d}\u{24f}\x05\u{f0}\
	\x79\x02\u{24e}\u{250}\x05\x32\x1a\x02\u{24f}\u{24e}\x03\x02\x02\x02\u{24f}\
	\u{250}\x03\x02\x02\x02\u{250}\u{252}\x03\x02\x02\x02\u{251}\u{253}\x05\
	\x64\x33\x02\u{252}\u{251}\x03\x02\x02\x02\u{252}\u{253}\x03\x02\x02\x02\
	\u{253}\u{254}\x03\x02\x02\x02\u{254}\u{255}\x05\x3c\x1f\x02\u{255}\x3b\
	\x03\x02\x02\x02\u{256}\u{25c}\x07\x0d\x02\x02\u{257}\u{25b}\x05\x20\x11\
	\x02\u{258}\u{25b}\x05\x3e\x20\x02\u{259}\u{25b}\x05\x06\x04\x02\u{25a}\
	\u{257}\x03\x02\x02\x02\u{25a}\u{258}\x03\x02\x02\x02\u{25a}\u{259}\x03\
	\x02\x02\x02\u{25b}\u{25e}\x03\x02\x02\x02\u{25c}\u{25a}\x03\x02\x02\x02\
	\u{25c}\u{25d}\x03\x02\x02\x02\u{25d}\u{25f}\x03\x02\x02\x02\u{25e}\u{25c}\
	\x03\x02\x02\x02\u{25f}\u{260}\x07\x0e\x02\x02\u{260}\x3d\x03\x02\x02\x02\
	\u{261}\u{263}\x05\u{b8}\x5d\x02\u{262}\u{261}\x03\x02\x02\x02\u{263}\u{266}\
	\x03\x02\x02\x02\u{264}\u{262}\x03\x02\x02\x02\u{264}\u{265}\x03\x02\x02\
	\x02\u{265}\u{267}\x03\x02\x02\x02\u{266}\u{264}\x03\x02\x02\x02\u{267}\
	\u{26a}\x05\u{f0}\x79\x02\u{268}\u{269}\x07\x35\x02\x02\u{269}\u{26b}\x05\
	\x72\x3a\x02\u{26a}\u{268}\x03\x02\x02\x02\u{26a}\u{26b}\x03\x02\x02\x02\
	\u{26b}\x3f\x03\x02\x02\x02\u{26c}\u{26e}\x05\u{a8}\x55\x02\u{26d}\u{26c}\
	\x03\x02\x02\x02\u{26d}\u{26e}\x03\x02\x02\x02\u{26e}\u{272}\x03\x02\x02\
	\x02\u{26f}\u{271}\x05\u{b8}\x5d\x02\u{270}\u{26f}\x03\x02\x02\x02\u{271}\
	\u{274}\x03\x02\x02\x02\u{272}\u{270}\x03\x02\x02\x02\u{272}\u{273}\x03\
	\x02\x02\x02\u{273}\u{275}\x03\x02\x02\x02\u{274}\u{272}\x03\x02\x02\x02\
	\u{275}\u{276}\x05\u{e2}\x72\x02\u{276}\u{277}\x07\u{80}\x02\x02\u{277}\
	\u{279}\x05\u{ee}\x78\x02\u{278}\u{27a}\x05\u{9c}\x4f\x02\u{279}\u{278}\
	\x03\x02\x02\x02\u{279}\u{27a}\x03\x02\x02\x02\u{27a}\u{27b}\x03\x02\x02\
	\x02\u{27b}\u{27d}\x05\x42\x22\x02\u{27c}\u{27e}\x05\x48\x25\x02\u{27d}\
	\u{27c}\x03\x02\x02\x02\u{27d}\u{27e}\x03\x02\x02\x02\u{27e}\u{27f}\x03\
	\x02\x02\x02\u{27f}\u{280}\x05\x56\x2c\x02\u{280}\x41\x03\x02\x02\x02\u{281}\
	\u{282}\x07\x09\x02\x02\u{282}\u{28f}\x07\x0a\x02\x02\u{283}\u{284}\x07\
	\x09\x02\x02\u{284}\u{289}\x05\x44\x23\x02\u{285}\u{286}\x07\x04\x02\x02\
	\u{286}\u{288}\x05\x44\x23\x02\u{287}\u{285}\x03\x02\x02\x02\u{288}\u{28b}\
	\x03\x02\x02\x02\u{289}\u{287}\x03\x02\x02\x02\u{289}\u{28a}\x03\x02\x02\
	\x02\u{28a}\u{28c}\x03\x02\x02\x02\u{28b}\u{289}\x03\x02\x02\x02\u{28c}\
	\u{28d}\x07\x0a\x02\x02\u{28d}\u{28f}\x03\x02\x02\x02\u{28e}\u{281}\x03\
	\x02\x02\x02\u{28e}\u{283}\x03\x02\x02\x02\u{28f}\x43\x03\x02\x02\x02\u{290}\
	\u{292}\x05\u{b8}\x5d\x02\u{291}\u{290}\x03\x02\x02\x02\u{292}\u{295}\x03\
	\x02\x02\x02\u{293}\u{291}\x03\x02\x02\x02\u{293}\u{294}\x03\x02\x02\x02\
	\u{294}\u{299}\x03\x02\x02\x02\u{295}\u{293}\x03\x02\x02\x02\u{296}\u{298}\
	\x05\u{f0}\x79\x02\u{297}\u{296}\x03\x02\x02\x02\u{298}\u{29b}\x03\x02\x02\
	\x02\u{299}\u{297}\x03\x02\x02\x02\u{299}\u{29a}\x03\x02\x02\x02\u{29a}\
	\u{29c}\x03\x02\x02\x02\u{29b}\u{299}\x03\x02\x02\x02\u{29c}\u{29e}\x05\
	\x46\x24\x02\u{29d}\u{29f}\x05\u{f0}\x79\x02\u{29e}\u{29d}\x03\x02\x02\x02\
	\u{29e}\u{29f}\x03\x02\x02\x02\u{29f}\u{2a1}\x03\x02\x02\x02\u{2a0}\u{2a2}\
	\x05\x64\x33\x02\u{2a1}\u{2a0}\x03\x02\x02\x02\u{2a1}\u{2a2}\x03\x02\x02\
	\x02\u{2a2}\u{2a4}\x03\x02\x02\x02\u{2a3}\u{2a5}\x05\x4a\x26\x02\u{2a4}\
	\u{2a3}\x03\x02\x02\x02\u{2a4}\u{2a5}\x03\x02\x02\x02\u{2a5}\u{2bc}\x03\
	\x02\x02\x02\u{2a6}\u{2a8}\x05\u{b8}\x5d\x02\u{2a7}\u{2a6}\x03\x02\x02\x02\
	\u{2a8}\u{2ab}\x03\x02\x02\x02\u{2a9}\u{2a7}\x03\x02\x02\x02\u{2a9}\u{2aa}\
	\x03\x02\x02\x02\u{2aa}\u{2af}\x03\x02\x02\x02\u{2ab}\u{2a9}\x03\x02\x02\
	\x02\u{2ac}\u{2ae}\x05\u{f0}\x79\x02\u{2ad}\u{2ac}\x03\x02\x02\x02\u{2ae}\
	\u{2b1}\x03\x02\x02\x02\u{2af}\u{2ad}\x03\x02\x02\x02\u{2af}\u{2b0}\x03\
	\x02\x02\x02\u{2b0}\u{2b2}\x03\x02\x02\x02\u{2b1}\u{2af}\x03\x02\x02\x02\
	\u{2b2}\u{2b4}\x05\u{f0}\x79\x02\u{2b3}\u{2b5}\x05\x64\x33\x02\u{2b4}\u{2b3}\
	\x03\x02\x02\x02\u{2b4}\u{2b5}\x03\x02\x02\x02\u{2b5}\u{2b7}\x03\x02\x02\
	\x02\u{2b6}\u{2b8}\x05\x4a\x26\x02\u{2b7}\u{2b6}\x03\x02\x02\x02\u{2b7}\
	\u{2b8}\x03\x02\x02\x02\u{2b8}\u{2bc}\x03\x02\x02\x02\u{2b9}\u{2bc}\x07\
	\x2b\x02\x02\u{2ba}\u{2bc}\x07\x30\x02\x02\u{2bb}\u{293}\x03\x02\x02\x02\
	\u{2bb}\u{2a9}\x03\x02\x02\x02\u{2bb}\u{2b9}\x03\x02\x02\x02\u{2bb}\u{2ba}\
	\x03\x02\x02\x02\u{2bc}\x45\x03\x02\x02\x02\u{2bd}\u{2c1}\x07\x5f\x02\x02\
	\u{2be}\u{2c1}\x07\x60\x02\x02\u{2bf}\u{2c1}\x07\x62\x02\x02\u{2c0}\u{2bd}\
	\x03\x02\x02\x02\u{2c0}\u{2be}\x03\x02\x02\x02\u{2c0}\u{2bf}\x03\x02\x02\
	\x02\u{2c1}\x47\x03\x02\x02\x02\u{2c2}\u{2c3}\x09\x07\x02\x02\u{2c3}\u{2df}\
	\x05\x76\x3c\x02\u{2c4}\u{2c5}\x09\x07\x02\x02\u{2c5}\u{2c7}\x05\x76\x3c\
	\x02\u{2c6}\u{2c4}\x03\x02\x02\x02\u{2c6}\u{2c7}\x03\x02\x02\x02\u{2c7}\
	\u{2c8}\x03\x02\x02\x02\u{2c8}\u{2c9}\x07\x20\x02\x02\u{2c9}\u{2df}\x05\
	\x76\x3c\x02\u{2ca}\u{2cb}\x09\x07\x02\x02\u{2cb}\u{2cd}\x05\x76\x3c\x02\
	\u{2cc}\u{2ca}\x03\x02\x02\x02\u{2cc}\u{2cd}\x03\x02\x02\x02\u{2cd}\u{2ce}\
	\x03\x02\x02\x02\u{2ce}\u{2cf}\x07\x20\x02\x02\u{2cf}\u{2db}\x07\x0b\x02\
	\x02\u{2d0}\u{2d5}\x05\x76\x3c\x02\u{2d1}\u{2d2}\x07\x04\x02\x02\u{2d2}\
	\u{2d4}\x05\x76\x3c\x02\u{2d3}\u{2d1}\x03\x02\x02\x02\u{2d4}\u{2d7}\x03\
	\x02\x02\x02\u{2d5}\u{2d3}\x03\x02\x02\x02\u{2d5}\u{2d6}\x03\x02\x02\x02\
	\u{2d6}\u{2d9}\x03\x02\x02\x02\u{2d7}\u{2d5}\x03\x02\x02\x02\u{2d8}\u{2da}\
	\x07\x04\x02\x02\u{2d9}\u{2d8}\x03\x02\x02\x02\u{2d9}\u{2da}\x03\x02\x02\
	\x02\u{2da}\u{2dc}\x03\x02\x02\x02\u{2db}\u{2d0}\x03\x02\x02\x02\u{2db}\
	\u{2dc}\x03\x02\x02\x02\u{2dc}\u{2dd}\x03\x02\x02\x02\u{2dd}\u{2df}\x07\
	\x0c\x02\x02\u{2de}\u{2c2}\x03\x02\x02\x02\u{2de}\u{2c6}\x03\x02\x02\x02\
	\u{2de}\u{2cc}\x03\x02\x02\x02\u{2df}\x49\x03\x02\x02\x02\u{2e0}\u{2e1}\
	\x07\x35\x02\x02\u{2e1}\u{2e2}\x05\x72\x3a\x02\u{2e2}\x4b\x03\x02\x02\x02\
	\u{2e3}\u{2e5}\x07\x55\x02\x02\u{2e4}\u{2e3}\x03\x02\x02\x02\u{2e4}\u{2e5}\
	\x03\x02\x02\x02\u{2e5}\u{2e6}\x03\x02\x02\x02\u{2e6}\u{2fb}\x05\x50\x29\
	\x02\u{2e7}\u{2e9}\x07\x55\x02\x02\u{2e8}\u{2e7}\x03\x02\x02\x02\u{2e8}\
	\u{2e9}\x03\x02\x02\x02\u{2e9}\u{2ea}\x03\x02\x02\x02\u{2ea}\u{2eb}\x07\
	\x03\x02\x02\u{2eb}\u{2ed}\x07\u{88}\x02\x02\u{2ec}\u{2ee}\x05\x50\x29\x02\
	\u{2ed}\u{2ec}\x03\x02\x02\x02\u{2ed}\u{2ee}\x03\x02\x02\x02\u{2ee}\u{2fb}\
	\x03\x02\x02\x02\u{2ef}\u{2f1}\x07\x55\x02\x02\u{2f0}\u{2ef}\x03\x02\x02\
	\x02\u{2f0}\u{2f1}\x03\x02\x02\x02\u{2f1}\u{2f2}\x03\x02\x02\x02\u{2f2}\
	\u{2f4}\x07\x03\x02\x02\u{2f3}\u{2f5}\x07\x4e\x02\x02\u{2f4}\u{2f3}\x03\
	\x02\x02\x02\u{2f4}\u{2f5}\x03\x02\x02\x02\u{2f5}\u{2f6}\x03\x02\x02\x02\
	\u{2f6}\u{2f8}\x05\u{f0}\x79\x02\u{2f7}\u{2f9}\x05\x50\x29\x02\u{2f8}\u{2f7}\
	\x03\x02\x02\x02\u{2f8}\u{2f9}\x03\x02\x02\x02\u{2f9}\u{2fb}\x03\x02\x02\
	\x02\u{2fa}\u{2e4}\x03\x02\x02\x02\u{2fa}\u{2e8}\x03\x02\x02\x02\u{2fa}\
	\u{2f0}\x03\x02\x02\x02\u{2fb}\x4d\x03\x02\x02\x02\u{2fc}\u{2fe}\x07\x55\
	\x02\x02\u{2fd}\u{2fc}\x03\x02\x02\x02\u{2fd}\u{2fe}\x03\x02\x02\x02\u{2fe}\
	\u{304}\x03\x02\x02\x02\u{2ff}\u{305}\x05\x56\x2c\x02\u{300}\u{302}\x05\
	\x50\x29\x02\u{301}\u{303}\x05\x56\x2c\x02\u{302}\u{301}\x03\x02\x02\x02\
	\u{302}\u{303}\x03\x02\x02\x02\u{303}\u{305}\x03\x02\x02\x02\u{304}\u{2ff}\
	\x03\x02\x02\x02\u{304}\u{300}\x03\x02\x02\x02\u{305}\u{325}\x03\x02\x02\
	\x02\u{306}\u{308}\x07\x55\x02\x02\u{307}\u{306}\x03\x02\x02\x02\u{307}\
	\u{308}\x03\x02\x02\x02\u{308}\u{309}\x03\x02\x02\x02\u{309}\u{30a}\x07\
	\x03\x02\x02\u{30a}\u{325}\x05\x56\x2c\x02\u{30b}\u{30d}\x07\x55\x02\x02\
	\u{30c}\u{30b}\x03\x02\x02\x02\u{30c}\u{30d}\x03\x02\x02\x02\u{30d}\u{30e}\
	\x03\x02\x02\x02\u{30e}\u{30f}\x07\x03\x02\x02\u{30f}\u{311}\x07\u{88}\x02\
	\x02\u{310}\u{312}\x05\x50\x29\x02\u{311}\u{310}\x03\x02\x02\x02\u{311}\
	\u{312}\x03\x02\x02\x02\u{312}\u{314}\x03\x02\x02\x02\u{313}\u{315}\x05\
	\x56\x2c\x02\u{314}\u{313}\x03\x02\x02\x02\u{314}\u{315}\x03\x02\x02\x02\
	\u{315}\u{325}\x03\x02\x02\x02\u{316}\u{318}\x07\x55\x02\x02\u{317}\u{316}\
	\x03\x02\x02\x02\u{317}\u{318}\x03\x02\x02\x02\u{318}\u{319}\x03\x02\x02\
	\x02\u{319}\u{31b}\x07\x03\x02\x02\u{31a}\u{31c}\x07\x4e\x02\x02\u{31b}\
	\u{31a}\x03\x02\x02\x02\u{31b}\u{31c}\x03\x02\x02\x02\u{31c}\u{31d}\x03\
	\x02\x02\x02\u{31d}\u{31f}\x05\u{f0}\x79\x02\u{31e}\u{320}\x05\x50\x29\x02\
	\u{31f}\u{31e}\x03\x02\x02\x02\u{31f}\u{320}\x03\x02\x02\x02\u{320}\u{322}\
	\x03\x02\x02\x02\u{321}\u{323}\x05\x56\x2c\x02\u{322}\u{321}\x03\x02\x02\
	\x02\u{322}\u{323}\x03\x02\x02\x02\u{323}\u{325}\x03\x02\x02\x02\u{324}\
	\u{2fd}\x03\x02\x02\x02\u{324}\u{307}\x03\x02\x02\x02\u{324}\u{30c}\x03\
	\x02\x02\x02\u{324}\u{317}\x03\x02\x02\x02\u{325}\x4f\x03\x02\x02\x02\u{326}\
	\u{327}\x07\x09\x02\x02\u{327}\u{337}\x07\x0a\x02\x02\u{328}\u{329}\x07\
	\x09\x02\x02\u{329}\u{32e}\x05\x52\x2a\x02\u{32a}\u{32b}\x07\x04\x02\x02\
	\u{32b}\u{32d}\x05\x52\x2a\x02\u{32c}\u{32a}\x03\x02\x02\x02\u{32d}\u{330}\
	\x03\x02\x02\x02\u{32e}\u{32c}\x03\x02\x02\x02\u{32e}\u{32f}\x03\x02\x02\
	\x02\u{32f}\u{332}\x03\x02\x02\x02\u{330}\u{32e}\x03\x02\x02\x02\u{331}\
	\u{333}\x07\x04\x02\x02\u{332}\u{331}\x03\x02\x02\x02\u{332}\u{333}\x03\
	\x02\x02\x02\u{333}\u{334}\x03\x02\x02\x02\u{334}\u{335}\x07\x0a\x02\x02\
	\u{335}\u{337}\x03\x02\x02\x02\u{336}\u{326}\x03\x02\x02\x02\u{336}\u{328}\
	\x03\x02\x02\x02\u{337}\x51\x03\x02\x02\x02\u{338}\u{33a}\x05\u{b8}\x5d\
	\x02\u{339}\u{338}\x03\x02\x02\x02\u{33a}\u{33d}\x03\x02\x02\x02\u{33b}\
	\u{339}\x03\x02\x02\x02\u{33b}\u{33c}\x03\x02\x02\x02\u{33c}\u{341}\x03\
	\x02\x02\x02\u{33d}\u{33b}\x03\x02\x02\x02\u{33e}\u{340}\x05\u{f0}\x79\x02\
	\u{33f}\u{33e}\x03\x02\x02\x02\u{340}\u{343}\x03\x02\x02\x02\u{341}\u{33f}\
	\x03\x02\x02\x02\u{341}\u{342}\x03\x02\x02\x02\u{342}\u{344}\x03\x02\x02\
	\x02\u{343}\u{341}\x03\x02\x02\x02\u{344}\u{345}\x05\u{f0}\x79\x02\u{345}\
	\u{346}\x07\x08\x02\x02\u{346}\u{347}\x05\x72\x3a\x02\u{347}\u{350}\x03\
	\x02\x02\x02\u{348}\u{34a}\x05\u{b8}\x5d\x02\u{349}\u{348}\x03\x02\x02\x02\
	\u{34a}\u{34d}\x03\x02\x02\x02\u{34b}\u{349}\x03\x02\x02\x02\u{34b}\u{34c}\
	\x03\x02\x02\x02\u{34c}\u{34e}\x03\x02\x02\x02\u{34d}\u{34b}\x03\x02\x02\
	\x02\u{34e}\u{350}\x05\x72\x3a\x02\u{34f}\u{33b}\x03\x02\x02\x02\u{34f}\
	\u{34b}\x03\x02\x02\x02\u{350}\x53\x03\x02\x02\x02\u{351}\u{353}\x05\u{b8}\
	\x5d\x02\u{352}\u{351}\x03\x02\x02\x02\u{353}\u{356}\x03\x02\x02\x02\u{354}\
	\u{352}\x03\x02\x02\x02\u{354}\u{355}\x03\x02\x02\x02\u{355}\u{357}\x03\
	\x02\x02\x02\u{356}\u{354}\x03\x02\x02\x02\u{357}\u{358}\x07\x7f\x02\x02\
	\u{358}\u{35a}\x05\x42\x22\x02\u{359}\u{35b}\x05\x48\x25\x02\u{35a}\u{359}\
	\x03\x02\x02\x02\u{35a}\u{35b}\x03\x02\x02\x02\u{35b}\u{35c}\x03\x02\x02\
	\x02\u{35c}\u{35d}\x05\x56\x2c\x02\u{35d}\x55\x03\x02\x02\x02\u{35e}\u{367}\
	\x07\x0d\x02\x02\u{35f}\u{366}\x05\x62\x32\x02\u{360}\u{366}\x05\x58\x2d\
	\x02\u{361}\u{366}\x05\x6c\x37\x02\u{362}\u{366}\x05\x68\x35\x02\u{363}\
	\u{366}\x05\x70\x39\x02\u{364}\u{366}\x05\x04\x03\x02\u{365}\u{35f}\x03\
	\x02\x02\x02\u{365}\u{360}\x03\x02\x02\x02\u{365}\u{361}\x03\x02\x02\x02\
	\u{365}\u{362}\x03\x02\x02\x02\u{365}\u{363}\x03\x02\x02\x02\u{365}\u{364}\
	\x03\x02\x02\x02\u{366}\u{369}\x03\x02\x02\x02\u{367}\u{365}\x03\x02\x02\
	\x02\u{367}\u{368}\x03\x02\x02\x02\u{368}\u{36a}\x03\x02\x02\x02\u{369}\
	\u{367}\x03\x02\x02\x02\u{36a}\u{36b}\x07\x0e\x02\x02\u{36b}\x57\x03\x02\
	\x02\x02\u{36c}\u{36e}\x05\u{b8}\x5d\x02\u{36d}\u{36c}\x03\x02\x02\x02\u{36e}\
	\u{371}\x03\x02\x02\x02\u{36f}\u{36d}\x03\x02\x02\x02\u{36f}\u{370}\x03\
	\x02\x02\x02\u{370}\u{372}\x03\x02\x02\x02\u{371}\u{36f}\x03\x02\x02\x02\
	\u{372}\u{373}\x07\x7c\x02\x02\u{373}\u{375}\x05\x5a\x2e\x02\u{374}\u{376}\
	\x05\x64\x33\x02\u{375}\u{374}\x03\x02\x02\x02\u{375}\u{376}\x03\x02\x02\
	\x02\u{376}\u{379}\x03\x02\x02\x02\u{377}\u{378}\x07\x35\x02\x02\u{378}\
	\u{37a}\x05\x70\x39\x02\u{379}\u{377}\x03\x02\x02\x02\u{379}\u{37a}\x03\
	\x02\x02\x02\u{37a}\x59\x03\x02\x02\x02\u{37b}\u{37e}\x05\x5e\x30\x02\u{37c}\
	\u{37e}\x05\x5c\x2f\x02\u{37d}\u{37b}\x03\x02\x02\x02\u{37d}\u{37c}\x03\
	\x02\x02\x02\u{37e}\x5b\x03\x02\x02\x02\u{37f}\u{384}\x05\u{e4}\x73\x02\
	\u{380}\u{381}\x07\x04\x02\x02\u{381}\u{383}\x05\u{e4}\x73\x02\u{382}\u{380}\
	\x03\x02\x02\x02\u{383}\u{386}\x03\x02\x02\x02\u{384}\u{382}\x03\x02\x02\
	\x02\u{384}\u{385}\x03\x02\x02\x02\u{385}\u{388}\x03\x02\x02\x02\u{386}\
	\u{384}\x03\x02\x02\x02\u{387}\u{389}\x07\x04\x02\x02\u{388}\u{387}\x03\
	\x02\x02\x02\u{388}\u{389}\x03\x02\x02\x02\u{389}\x5d\x03\x02\x02\x02\u{38a}\
	\u{398}\x07\x09\x02\x02\u{38b}\u{38c}\x05\x60\x31\x02\u{38c}\u{38d}\x07\
	\x04\x02\x02\u{38d}\u{399}\x03\x02\x02\x02\u{38e}\u{391}\x05\x60\x31\x02\
	\u{38f}\u{390}\x07\x04\x02\x02\u{390}\u{392}\x05\x60\x31\x02\u{391}\u{38f}\
	\x03\x02\x02\x02\u{392}\u{393}\x03\x02\x02\x02\u{393}\u{391}\x03\x02\x02\
	\x02\u{393}\u{394}\x03\x02\x02\x02\u{394}\u{396}\x03\x02\x02\x02\u{395}\
	\u{397}\x07\x04\x02\x02\u{396}\u{395}\x03\x02\x02\x02\u{396}\u{397}\x03\
	\x02\x02\x02\u{397}\u{399}\x03\x02\x02\x02\u{398}\u{38b}\x03\x02\x02\x02\
	\u{398}\u{38e}\x03\x02\x02\x02\u{398}\u{399}\x03\x02\x02\x02\u{399}\u{39a}\
	\x03\x02\x02\x02\u{39a}\u{3d1}\x07\x0a\x02\x02\u{39b}\u{39c}\x05\u{ee}\x78\
	\x02\u{39c}\u{3a8}\x07\x09\x02\x02\u{39d}\u{3a2}\x05\x60\x31\x02\u{39e}\
	\u{39f}\x07\x04\x02\x02\u{39f}\u{3a1}\x05\x60\x31\x02\u{3a0}\u{39e}\x03\
	\x02\x02\x02\u{3a1}\u{3a4}\x03\x02\x02\x02\u{3a2}\u{3a0}\x03\x02\x02\x02\
	\u{3a2}\u{3a3}\x03\x02\x02\x02\u{3a3}\u{3a6}\x03\x02\x02\x02\u{3a4}\u{3a2}\
	\x03\x02\x02\x02\u{3a5}\u{3a7}\x07\x04\x02\x02\u{3a6}\u{3a5}\x03\x02\x02\
	\x02\u{3a6}\u{3a7}\x03\x02\x02\x02\u{3a7}\u{3a9}\x03\x02\x02\x02\u{3a8}\
	\u{39d}\x03\x02\x02\x02\u{3a8}\u{3a9}\x03\x02\x02\x02\u{3a9}\u{3aa}\x03\
	\x02\x02\x02\u{3aa}\u{3ab}\x07\x0a\x02\x02\u{3ab}\u{3d1}\x03\x02\x02\x02\
	\u{3ac}\u{3ae}\x05\u{ee}\x78\x02\u{3ad}\u{3ac}\x03\x02\x02\x02\u{3ad}\u{3ae}\
	\x03\x02\x02\x02\u{3ae}\u{3af}\x03\x02\x02\x02\u{3af}\u{3bb}\x07\x0b\x02\
	\x02\u{3b0}\u{3b5}\x05\x60\x31\x02\u{3b1}\u{3b2}\x07\x04\x02\x02\u{3b2}\
	\u{3b4}\x05\x60\x31\x02\u{3b3}\u{3b1}\x03\x02\x02\x02\u{3b4}\u{3b7}\x03\
	\x02\x02\x02\u{3b5}\u{3b3}\x03\x02\x02\x02\u{3b5}\u{3b6}\x03\x02\x02\x02\
	\u{3b6}\u{3b9}\x03\x02\x02\x02\u{3b7}\u{3b5}\x03\x02\x02\x02\u{3b8}\u{3ba}\
	\x07\x04\x02\x02\u{3b9}\u{3b8}\x03\x02\x02\x02\u{3b9}\u{3ba}\x03\x02\x02\
	\x02\u{3ba}\u{3bc}\x03\x02\x02\x02\u{3bb}\u{3b0}\x03\x02\x02\x02\u{3bb}\
	\u{3bc}\x03\x02\x02\x02\u{3bc}\u{3bd}\x03\x02\x02\x02\u{3bd}\u{3d1}\x07\
	\x0c\x02\x02\u{3be}\u{3c0}\x05\u{ee}\x78\x02\u{3bf}\u{3be}\x03\x02\x02\x02\
	\u{3bf}\u{3c0}\x03\x02\x02\x02\u{3c0}\u{3c1}\x03\x02\x02\x02\u{3c1}\u{3cd}\
	\x07\x0d\x02\x02\u{3c2}\u{3c7}\x05\x60\x31\x02\u{3c3}\u{3c4}\x07\x04\x02\
	\x02\u{3c4}\u{3c6}\x05\x60\x31\x02\u{3c5}\u{3c3}\x03\x02\x02\x02\u{3c6}\
	\u{3c9}\x03\x02\x02\x02\u{3c7}\u{3c5}\x03\x02\x02\x02\u{3c7}\u{3c8}\x03\
	\x02\x02\x02\u{3c8}\u{3cb}\x03\x02\x02\x02\u{3c9}\u{3c7}\x03\x02\x02\x02\
	\u{3ca}\u{3cc}\x07\x04\x02\x02\u{3cb}\u{3ca}\x03\x02\x02\x02\u{3cb}\u{3cc}\
	\x03\x02\x02\x02\u{3cc}\u{3ce}\x03\x02\x02\x02\u{3cd}\u{3c2}\x03\x02\x02\
	\x02\u{3cd}\u{3ce}\x03\x02\x02\x02\u{3ce}\u{3cf}\x03\x02\x02\x02\u{3cf}\
	\u{3d1}\x07\x0e\x02\x02\u{3d0}\u{38a}\x03\x02\x02\x02\u{3d0}\u{39b}\x03\
	\x02\x02\x02\u{3d0}\u{3ad}\x03\x02\x02\x02\u{3d0}\u{3bf}\x03\x02\x02\x02\
	\u{3d1}\x5f\x03\x02\x02\x02\u{3d2}\u{3d3}\x05\u{e4}\x73\x02\u{3d3}\u{3d4}\
	\x07\x08\x02\x02\u{3d4}\u{3d6}\x03\x02\x02\x02\u{3d5}\u{3d2}\x03\x02\x02\
	\x02\u{3d5}\u{3d6}\x03\x02\x02\x02\u{3d6}\u{3da}\x03\x02\x02\x02\u{3d7}\
	\u{3d8}\x05\u{f0}\x79\x02\u{3d8}\u{3d9}\x07\x36\x02\x02\u{3d9}\u{3db}\x03\
	\x02\x02\x02\u{3da}\u{3d7}\x03\x02\x02\x02\u{3da}\u{3db}\x03\x02\x02\x02\
	\u{3db}\u{3dc}\x03\x02\x02\x02\u{3dc}\u{3f8}\x05\x5e\x30\x02\u{3dd}\u{3de}\
	\x05\u{e4}\x73\x02\u{3de}\u{3df}\x07\x08\x02\x02\u{3df}\u{3e1}\x03\x02\x02\
	\x02\u{3e0}\u{3dd}\x03\x02\x02\x02\u{3e0}\u{3e1}\x03\x02\x02\x02\u{3e1}\
	\u{3e5}\x03\x02\x02\x02\u{3e2}\u{3e3}\x05\u{f0}\x79\x02\u{3e3}\u{3e4}\x07\
	\x36\x02\x02\u{3e4}\u{3e6}\x03\x02\x02\x02\u{3e5}\u{3e2}\x03\x02\x02\x02\
	\u{3e5}\u{3e6}\x03\x02\x02\x02\u{3e6}\u{3e7}\x03\x02\x02\x02\u{3e7}\u{3f8}\
	\x05\u{f0}\x79\x02\u{3e8}\u{3ea}\x05\u{e4}\x73\x02\u{3e9}\u{3e8}\x03\x02\
	\x02\x02\u{3e9}\u{3ea}\x03\x02\x02\x02\u{3ea}\u{3eb}\x03\x02\x02\x02\u{3eb}\
	\u{3ed}\x07\x60\x02\x02\u{3ec}\u{3ee}\x05\u{f0}\x79\x02\u{3ed}\u{3ec}\x03\
	\x02\x02\x02\u{3ed}\u{3ee}\x03\x02\x02\x02\u{3ee}\u{3f8}\x03\x02\x02\x02\
	\u{3ef}\u{3f1}\x05\u{e4}\x73\x02\u{3f0}\u{3ef}\x03\x02\x02\x02\u{3f0}\u{3f1}\
	\x03\x02\x02\x02\u{3f1}\u{3f2}\x03\x02\x02\x02\u{3f2}\u{3f4}\x07\x5f\x02\
	\x02\u{3f3}\u{3f5}\x05\u{f0}\x79\x02\u{3f4}\u{3f3}\x03\x02\x02\x02\u{3f4}\
	\u{3f5}\x03\x02\x02\x02\u{3f5}\u{3f8}\x03\x02\x02\x02\u{3f6}\u{3f8}\x05\
	\u{e4}\x73\x02\u{3f7}\u{3d5}\x03\x02\x02\x02\u{3f7}\u{3e0}\x03\x02\x02\x02\
	\u{3f7}\u{3e9}\x03\x02\x02\x02\u{3f7}\u{3f0}\x03\x02\x02\x02\u{3f7}\u{3f6}\
	\x03\x02\x02\x02\u{3f8}\x61\x03\x02\x02\x02\u{3f9}\u{3fb}\x05\u{b8}\x5d\
	\x02\u{3fa}\u{3f9}\x03\x02\x02\x02\u{3fb}\u{3fe}\x03\x02\x02\x02\u{3fc}\
	\u{3fa}\x03\x02\x02\x02\u{3fc}\u{3fd}\x03\x02\x02\x02\u{3fd}\u{3ff}\x03\
	\x02\x02\x02\u{3fe}\u{3fc}\x03\x02\x02\x02\u{3ff}\u{400}\x05\u{e2}\x72\x02\
	\u{400}\u{401}\x07\x76\x02\x02\u{401}\u{403}\x05\u{f0}\x79\x02\u{402}\u{404}\
	\x05\u{9c}\x4f\x02\u{403}\u{402}\x03\x02\x02\x02\u{403}\u{404}\x03\x02\x02\
	\x02\u{404}\u{405}\x03\x02\x02\x02\u{405}\u{406}\x07\x35\x02\x02\u{406}\
	\u{407}\x05\x76\x3c\x02\u{407}\u{417}\x03\x02\x02\x02\u{408}\u{40a}\x05\
	\u{b8}\x5d\x02\u{409}\u{408}\x03\x02\x02\x02\u{40a}\u{40d}\x03\x02\x02\x02\
	\u{40b}\u{409}\x03\x02\x02\x02\u{40b}\u{40c}\x03\x02\x02\x02\u{40c}\u{40e}\
	\x03\x02\x02\x02\u{40d}\u{40b}\x03\x02\x02\x02\u{40e}\u{40f}\x05\u{e2}\x72\
	\x02\u{40f}\u{410}\x07\x76\x02\x02\u{410}\u{412}\x05\u{f0}\x79\x02\u{411}\
	\u{413}\x05\u{9c}\x4f\x02\u{412}\u{411}\x03\x02\x02\x02\u{412}\u{413}\x03\
	\x02\x02\x02\u{413}\u{414}\x03\x02\x02\x02\u{414}\u{415}\x05\u{aa}\x56\x02\
	\u{415}\u{417}\x03\x02\x02\x02\u{416}\u{3fc}\x03\x02\x02\x02\u{416}\u{40b}\
	\x03\x02\x02\x02\u{417}\x63\x03\x02\x02\x02\u{418}\u{419}\x07\x08\x02\x02\
	\u{419}\u{41a}\x05\x76\x3c\x02\u{41a}\x65\x03\x02\x02\x02\u{41b}\u{41d}\
	\x05\u{b8}\x5d\x02\u{41c}\u{41b}\x03\x02\x02\x02\u{41d}\u{420}\x03\x02\x02\
	\x02\u{41e}\u{41c}\x03\x02\x02\x02\u{41e}\u{41f}\x03\x02\x02\x02\u{41f}\
	\u{421}\x03\x02\x02\x02\u{420}\u{41e}\x03\x02\x02\x02\u{421}\u{422}\x07\
	\u{8b}\x02\x02\u{422}\u{423}\x05\x74\x3b\x02\u{423}\u{427}\x05\x56\x2c\x02\
	\u{424}\u{426}\x05\x6a\x36\x02\u{425}\u{424}\x03\x02\x02\x02\u{426}\u{429}\
	\x03\x02\x02\x02\u{427}\u{425}\x03\x02\x02\x02\u{427}\u{428}\x03\x02\x02\
	\x02\u{428}\u{42c}\x03\x02\x02\x02\u{429}\u{427}\x03\x02\x02\x02\u{42a}\
	\u{42b}\x07\u{8c}\x02\x02\u{42b}\u{42d}\x05\x56\x2c\x02\u{42c}\u{42a}\x03\
	\x02\x02\x02\u{42c}\u{42d}\x03\x02\x02\x02\u{42d}\x67\x03\x02\x02\x02\u{42e}\
	\u{430}\x05\u{b8}\x5d\x02\u{42f}\u{42e}\x03\x02\x02\x02\u{430}\u{433}\x03\
	\x02\x02\x02\u{431}\u{42f}\x03\x02\x02\x02\u{431}\u{432}\x03\x02\x02\x02\
	\u{432}\u{434}\x03\x02\x02\x02\u{433}\u{431}\x03\x02\x02\x02\u{434}\u{435}\
	\x07\u{8b}\x02\x02\u{435}\u{439}\x09\x08\x02\x02\u{436}\u{43a}\x05\x5e\x30\
	\x02\u{437}\u{43a}\x05\u{f0}\x79\x02\u{438}\u{43a}\x07\u{95}\x02\x02\u{439}\
	\u{436}\x03\x02\x02\x02\u{439}\u{437}\x03\x02\x02\x02\u{439}\u{438}\x03\
	\x02\x02\x02\u{43a}\u{43b}\x03\x02\x02\x02\u{43b}\u{43c}\x07\x35\x02\x02\
	\u{43c}\u{43d}\x05\x74\x3b\x02\u{43d}\u{43e}\x05\x56\x2c\x02\u{43e}\u{44b}\
	\x03\x02\x02\x02\u{43f}\u{441}\x05\u{b8}\x5d\x02\u{440}\u{43f}\x03\x02\x02\
	\x02\u{441}\u{444}\x03\x02\x02\x02\u{442}\u{440}\x03\x02\x02\x02\u{442}\
	\u{443}\x03\x02\x02\x02\u{443}\u{445}\x03\x02\x02\x02\u{444}\u{442}\x03\
	\x02\x02\x02\u{445}\u{446}\x07\u{8b}\x02\x02\u{446}\u{447}\x09\x08\x02\x02\
	\u{447}\u{448}\x05\x74\x3b\x02\u{448}\u{449}\x05\x56\x2c\x02\u{449}\u{44b}\
	\x03\x02\x02\x02\u{44a}\u{431}\x03\x02\x02\x02\u{44a}\u{442}\x03\x02\x02\
	\x02\u{44b}\x69\x03\x02\x02\x02\u{44c}\u{44d}\x07\u{8c}\x02\x02\u{44d}\u{44e}\
	\x07\u{8b}\x02\x02\u{44e}\u{44f}\x05\x74\x3b\x02\u{44f}\u{450}\x05\x56\x2c\
	\x02\u{450}\x6b\x03\x02\x02\x02\u{451}\u{453}\x05\u{b8}\x5d\x02\u{452}\u{451}\
	\x03\x02\x02\x02\u{453}\u{456}\x03\x02\x02\x02\u{454}\u{452}\x03\x02\x02\
	\x02\u{454}\u{455}\x03\x02\x02\x02\u{455}\u{457}\x03\x02\x02\x02\u{456}\
	\u{454}\x03\x02\x02\x02\u{457}\u{458}\x07\x7a\x02\x02\u{458}\u{459}\x05\
	\x74\x3b\x02\u{459}\u{45a}\x05\x56\x2c\x02\u{45a}\u{479}\x03\x02\x02\x02\
	\u{45b}\u{45d}\x05\u{b8}\x5d\x02\u{45c}\u{45b}\x03\x02\x02\x02\u{45d}\u{460}\
	\x03\x02\x02\x02\u{45e}\u{45c}\x03\x02\x02\x02\u{45e}\u{45f}\x03\x02\x02\
	\x02\u{45f}\u{461}\x03\x02\x02\x02\u{460}\u{45e}\x03\x02\x02\x02\u{461}\
	\u{462}\x07\x7a\x02\x02\u{462}\u{463}\x07\x7c\x02\x02\u{463}\u{464}\x05\
	\x5a\x2e\x02\u{464}\u{465}\x07\x35\x02\x02\u{465}\u{466}\x05\x74\x3b\x02\
	\u{466}\u{467}\x05\x56\x2c\x02\u{467}\u{479}\x03\x02\x02\x02\u{468}\u{46a}\
	\x05\u{b8}\x5d\x02\u{469}\u{468}\x03\x02\x02\x02\u{46a}\u{46d}\x03\x02\x02\
	\x02\u{46b}\u{469}\x03\x02\x02\x02\u{46b}\u{46c}\x03\x02\x02\x02\u{46c}\
	\u{46e}\x03\x02\x02\x02\u{46d}\u{46b}\x03\x02\x02\x02\u{46e}\u{46f}\x07\
	\x7b\x02\x02\u{46f}\u{470}\x05\x5a\x2e\x02\u{470}\u{471}\x05\u{9a}\x4e\x02\
	\u{471}\u{474}\x05\x74\x3b\x02\u{472}\u{473}\x07\u{8b}\x02\x02\u{473}\u{475}\
	\x05\x74\x3b\x02\u{474}\u{472}\x03\x02\x02\x02\u{474}\u{475}\x03\x02\x02\
	\x02\u{475}\u{476}\x03\x02\x02\x02\u{476}\u{477}\x05\x56\x2c\x02\u{477}\
	\u{479}\x03\x02\x02\x02\u{478}\u{454}\x03\x02\x02\x02\u{478}\u{45e}\x03\
	\x02\x02\x02\u{478}\u{46b}\x03\x02\x02\x02\u{479}\x6d\x03\x02\x02\x02\u{47a}\
	\u{47b}\x07\u{8b}\x02\x02\u{47b}\u{47c}\x05\x74\x3b\x02\u{47c}\x6f\x03\x02\
	\x02\x02\u{47d}\u{47f}\x05\u{b8}\x5d\x02\u{47e}\u{47d}\x03\x02\x02\x02\u{47f}\
	\u{482}\x03\x02\x02\x02\u{480}\u{47e}\x03\x02\x02\x02\u{480}\u{481}\x03\
	\x02\x02\x02\u{481}\u{483}\x03\x02\x02\x02\u{482}\u{480}\x03\x02\x02\x02\
	\u{483}\u{485}\x05\x72\x3a\x02\u{484}\u{486}\x07\x55\x02\x02\u{485}\u{484}\
	\x03\x02\x02\x02\u{485}\u{486}\x03\x02\x02\x02\u{486}\u{488}\x03\x02\x02\
	\x02\u{487}\u{489}\x05\x04\x03\x02\u{488}\u{487}\x03\x02\x02\x02\u{488}\
	\u{489}\x03\x02\x02\x02\u{489}\x71\x03\x02\x02\x02\u{48a}\u{48b}\x08\x3a\
	\x01\x02\u{48b}\u{48c}\x05\x7c\x3f\x02\u{48c}\u{48d}\x05\x72\x3a\x20\u{48d}\
	\u{4a8}\x03\x02\x02\x02\u{48e}\u{48f}\x07\x09\x02\x02\u{48f}\u{490}\x05\
	\x72\x3a\x02\u{490}\u{491}\x07\x0a\x02\x02\u{491}\u{4a8}\x03\x02\x02\x02\
	\u{492}\u{493}\x07\x17\x02\x02\u{493}\u{494}\x05\x72\x3a\x02\u{494}\u{495}\
	\x07\x18\x02\x02\u{495}\u{4a8}\x03\x02\x02\x02\u{496}\u{497}\x07\x15\x02\
	\x02\u{497}\u{498}\x05\x72\x3a\x02\u{498}\u{499}\x07\x16\x02\x02\u{499}\
	\u{4a8}\x03\x02\x02\x02\u{49a}\u{4a8}\x05\x7a\x3e\x02\u{49b}\u{4a8}\x05\
	\x66\x34\x02\u{49c}\u{4a8}\x05\u{ce}\x68\x02\u{49d}\u{4a8}\x05\u{bc}\x5f\
	\x02\u{49e}\u{4a8}\x05\u{be}\x60\x02\u{49f}\u{4a8}\x05\u{cc}\x67\x02\u{4a0}\
	\u{4a8}\x05\u{b6}\x5c\x02\u{4a1}\u{4a8}\x05\x54\x2b\x02\u{4a2}\u{4a8}\x05\
	\x56\x2c\x02\u{4a3}\u{4a8}\x05\u{a6}\x54\x02\u{4a4}\u{4a8}\x05\u{d6}\x6c\
	\x02\u{4a5}\u{4a8}\x05\u{de}\x70\x02\u{4a6}\u{4a8}\x05\x78\x3d\x02\u{4a7}\
	\u{48a}\x03\x02\x02\x02\u{4a7}\u{48e}\x03\x02\x02\x02\u{4a7}\u{492}\x03\
	\x02\x02\x02\u{4a7}\u{496}\x03\x02\x02\x02\u{4a7}\u{49a}\x03\x02\x02\x02\
	\u{4a7}\u{49b}\x03\x02\x02\x02\u{4a7}\u{49c}\x03\x02\x02\x02\u{4a7}\u{49d}\
	\x03\x02\x02\x02\u{4a7}\u{49e}\x03\x02\x02\x02\u{4a7}\u{49f}\x03\x02\x02\
	\x02\u{4a7}\u{4a0}\x03\x02\x02\x02\u{4a7}\u{4a1}\x03\x02\x02\x02\u{4a7}\
	\u{4a2}\x03\x02\x02\x02\u{4a7}\u{4a3}\x03\x02\x02\x02\u{4a7}\u{4a4}\x03\
	\x02\x02\x02\u{4a7}\u{4a5}\x03\x02\x02\x02\u{4a7}\u{4a6}\x03\x02\x02\x02\
	\u{4a8}\u{4f4}\x03\x02\x02\x02\u{4a9}\u{4aa}\x0c\x1f\x02\x02\u{4aa}\u{4ab}\
	\x05\u{86}\x44\x02\u{4ab}\u{4ac}\x05\x72\x3a\x1f\u{4ac}\u{4f3}\x03\x02\x02\
	\x02\u{4ad}\u{4ae}\x0c\x1e\x02\x02\u{4ae}\u{4af}\x05\u{8c}\x47\x02\u{4af}\
	\u{4b0}\x05\x72\x3a\x1f\u{4b0}\u{4f3}\x03\x02\x02\x02\u{4b1}\u{4b2}\x0c\
	\x1d\x02\x02\u{4b2}\u{4b3}\x05\u{8e}\x48\x02\u{4b3}\u{4b4}\x05\x72\x3a\x1e\
	\u{4b4}\u{4f3}\x03\x02\x02\x02\u{4b5}\u{4b6}\x0c\x1c\x02\x02\u{4b6}\u{4b7}\
	\x05\u{80}\x41\x02\u{4b7}\u{4b8}\x05\x72\x3a\x1d\u{4b8}\u{4f3}\x03\x02\x02\
	\x02\u{4b9}\u{4ba}\x0c\x1b\x02\x02\u{4ba}\u{4bb}\x05\u{90}\x49\x02\u{4bb}\
	\u{4bc}\x05\x72\x3a\x1c\u{4bc}\u{4f3}\x03\x02\x02\x02\u{4bd}\u{4be}\x0c\
	\x1a\x02\x02\u{4be}\u{4bf}\x05\u{88}\x45\x02\u{4bf}\u{4c0}\x05\x72\x3a\x1b\
	\u{4c0}\u{4f3}\x03\x02\x02\x02\u{4c1}\u{4c2}\x0c\x19\x02\x02\u{4c2}\u{4c3}\
	\x05\u{84}\x43\x02\u{4c3}\u{4c4}\x05\x72\x3a\x1a\u{4c4}\u{4f3}\x03\x02\x02\
	\x02\u{4c5}\u{4c6}\x0c\x16\x02\x02\u{4c6}\u{4c7}\x05\u{9a}\x4e\x02\u{4c7}\
	\u{4c8}\x05\x72\x3a\x17\u{4c8}\u{4f3}\x03\x02\x02\x02\u{4c9}\u{4ca}\x0c\
	\x15\x02\x02\u{4ca}\u{4cb}\x07\x54\x02\x02\u{4cb}\u{4f3}\x05\x72\x3a\x16\
	\u{4cc}\u{4cd}\x0c\x14\x02\x02\u{4cd}\u{4ce}\x05\u{92}\x4a\x02\u{4ce}\u{4cf}\
	\x05\x72\x3a\x15\u{4cf}\u{4f3}\x03\x02\x02\x02\u{4d0}\u{4d1}\x0c\x13\x02\
	\x02\u{4d1}\u{4d2}\x05\u{94}\x4b\x02\u{4d2}\u{4d3}\x05\x72\x3a\x13\u{4d3}\
	\u{4f3}\x03\x02\x02\x02\u{4d4}\u{4d5}\x0c\x25\x02\x02\u{4d5}\u{4f3}\x05\
	\x7e\x40\x02\u{4d6}\u{4d7}\x0c\x24\x02\x02\u{4d7}\u{4f3}\x05\u{dc}\x6f\x02\
	\u{4d8}\u{4d9}\x0c\x23\x02\x02\u{4d9}\u{4f3}\x05\u{a0}\x51\x02\u{4da}\u{4db}\
	\x0c\x22\x02\x02\u{4db}\u{4f3}\x05\x4e\x28\x02\u{4dc}\u{4de}\x0c\x21\x02\
	\x02\u{4dd}\u{4df}\x07\x55\x02\x02\u{4de}\u{4dd}\x03\x02\x02\x02\u{4de}\
	\u{4df}\x03\x02\x02\x02\u{4df}\u{4e0}\x03\x02\x02\x02\u{4e0}\u{4e1}\x07\
	\x03\x02\x02\u{4e1}\u{4e7}\x09\x09\x02\x02\u{4e2}\u{4e3}\x07\x5e\x02\x02\
	\u{4e3}\u{4e5}\x05\u{f0}\x79\x02\u{4e4}\u{4e6}\x05\x64\x33\x02\u{4e5}\u{4e4}\
	\x03\x02\x02\x02\u{4e5}\u{4e6}\x03\x02\x02\x02\u{4e6}\u{4e8}\x03\x02\x02\
	\x02\u{4e7}\u{4e2}\x03\x02\x02\x02\u{4e7}\u{4e8}\x03\x02\x02\x02\u{4e8}\
	\u{4e9}\x03\x02\x02\x02\u{4e9}\u{4f3}\x05\u{c0}\x61\x02\u{4ea}\u{4eb}\x0c\
	\x18\x02\x02\u{4eb}\u{4ec}\x05\u{96}\x4c\x02\u{4ec}\u{4ed}\x05\x76\x3c\x02\
	\u{4ed}\u{4f3}\x03\x02\x02\x02\u{4ee}\u{4ef}\x0c\x17\x02\x02\u{4ef}\u{4f0}\
	\x05\u{98}\x4d\x02\u{4f0}\u{4f1}\x05\x76\x3c\x02\u{4f1}\u{4f3}\x03\x02\x02\
	\x02\u{4f2}\u{4a9}\x03\x02\x02\x02\u{4f2}\u{4ad}\x03\x02\x02\x02\u{4f2}\
	\u{4b1}\x03\x02\x02\x02\u{4f2}\u{4b5}\x03\x02\x02\x02\u{4f2}\u{4b9}\x03\
	\x02\x02\x02\u{4f2}\u{4bd}\x03\x02\x02\x02\u{4f2}\u{4c1}\x03\x02\x02\x02\
	\u{4f2}\u{4c5}\x03\x02\x02\x02\u{4f2}\u{4c9}\x03\x02\x02\x02\u{4f2}\u{4cc}\
	\x03\x02\x02\x02\u{4f2}\u{4d0}\x03\x02\x02\x02\u{4f2}\u{4d4}\x03\x02\x02\
	\x02\u{4f2}\u{4d6}\x03\x02\x02\x02\u{4f2}\u{4d8}\x03\x02\x02\x02\u{4f2}\
	\u{4da}\x03\x02\x02\x02\u{4f2}\u{4dc}\x03\x02\x02\x02\u{4f2}\u{4ea}\x03\
	\x02\x02\x02\u{4f2}\u{4ee}\x03\x02\x02\x02\u{4f3}\u{4f6}\x03\x02\x02\x02\
	\u{4f4}\u{4f2}\x03\x02\x02\x02\u{4f4}\u{4f5}\x03\x02\x02\x02\u{4f5}\x73\
	\x03\x02\x02\x02\u{4f6}\u{4f4}\x03\x02\x02\x02\u{4f7}\u{4f8}\x08\x3b\x01\
	\x02\u{4f8}\u{4f9}\x05\x7c\x3f\x02\u{4f9}\u{4fa}\x05\x74\x3b\x14\u{4fa}\
	\u{50b}\x03\x02\x02\x02\u{4fb}\u{4fc}\x07\x09\x02\x02\u{4fc}\u{4fd}\x05\
	\x72\x3a\x02\u{4fd}\u{4fe}\x07\x0a\x02\x02\u{4fe}\u{50b}\x03\x02\x02\x02\
	\u{4ff}\u{500}\x07\x17\x02\x02\u{500}\u{501}\x05\x72\x3a\x02\u{501}\u{502}\
	\x07\x18\x02\x02\u{502}\u{50b}\x03\x02\x02\x02\u{503}\u{504}\x07\x15\x02\
	\x02\u{504}\u{505}\x05\x72\x3a\x02\u{505}\u{506}\x07\x16\x02\x02\u{506}\
	\u{50b}\x03\x02\x02\x02\u{507}\u{50b}\x05\u{d6}\x6c\x02\u{508}\u{50b}\x05\
	\u{de}\x70\x02\u{509}\u{50b}\x05\x78\x3d\x02\u{50a}\u{4f7}\x03\x02\x02\x02\
	\u{50a}\u{4fb}\x03\x02\x02\x02\u{50a}\u{4ff}\x03\x02\x02\x02\u{50a}\u{503}\
	\x03\x02\x02\x02\u{50a}\u{507}\x03\x02\x02\x02\u{50a}\u{508}\x03\x02\x02\
	\x02\u{50a}\u{509}\x03\x02\x02\x02\u{50b}\u{534}\x03\x02\x02\x02\u{50c}\
	\u{50d}\x0c\x10\x02\x02\u{50d}\u{50e}\x05\u{8c}\x47\x02\u{50e}\u{50f}\x05\
	\x74\x3b\x11\u{50f}\u{533}\x03\x02\x02\x02\u{510}\u{511}\x0c\x0f\x02\x02\
	\u{511}\u{512}\x05\u{8e}\x48\x02\u{512}\u{513}\x05\x74\x3b\x10\u{513}\u{533}\
	\x03\x02\x02\x02\u{514}\u{515}\x0c\x0e\x02\x02\u{515}\u{516}\x05\u{90}\x49\
	\x02\u{516}\u{517}\x05\x74\x3b\x0f\u{517}\u{533}\x03\x02\x02\x02\u{518}\
	\u{519}\x0c\x0d\x02\x02\u{519}\u{51a}\x05\u{84}\x43\x02\u{51a}\u{51b}\x05\
	\x74\x3b\x0e\u{51b}\u{533}\x03\x02\x02\x02\u{51c}\u{51d}\x0c\x0c\x02\x02\
	\u{51d}\u{51e}\x05\u{80}\x41\x02\u{51e}\u{51f}\x05\x74\x3b\x0d\u{51f}\u{533}\
	\x03\x02\x02\x02\u{520}\u{521}\x0c\x09\x02\x02\u{521}\u{522}\x05\u{88}\x45\
	\x02\u{522}\u{523}\x05\x74\x3b\x0a\u{523}\u{533}\x03\x02\x02\x02\u{524}\
	\u{525}\x0c\x13\x02\x02\u{525}\u{533}\x05\x4c\x27\x02\u{526}\u{527}\x0c\
	\x12\x02\x02\u{527}\u{533}\x05\u{a0}\x51\x02\u{528}\u{529}\x0c\x11\x02\x02\
	\u{529}\u{533}\x05\u{dc}\x6f\x02\u{52a}\u{52b}\x0c\x0b\x02\x02\u{52b}\u{52c}\
	\x05\u{96}\x4c\x02\u{52c}\u{52d}\x05\x76\x3c\x02\u{52d}\u{533}\x03\x02\x02\
	\x02\u{52e}\u{52f}\x0c\x0a\x02\x02\u{52f}\u{530}\x05\u{98}\x4d\x02\u{530}\
	\u{531}\x05\x76\x3c\x02\u{531}\u{533}\x03\x02\x02\x02\u{532}\u{50c}\x03\
	\x02\x02\x02\u{532}\u{510}\x03\x02\x02\x02\u{532}\u{514}\x03\x02\x02\x02\
	\u{532}\u{518}\x03\x02\x02\x02\u{532}\u{51c}\x03\x02\x02\x02\u{532}\u{520}\
	\x03\x02\x02\x02\u{532}\u{524}\x03\x02\x02\x02\u{532}\u{526}\x03\x02\x02\
	\x02\u{532}\u{528}\x03\x02\x02\x02\u{532}\u{52a}\x03\x02\x02\x02\u{532}\
	\u{52e}\x03\x02\x02\x02\u{533}\u{536}\x03\x02\x02\x02\u{534}\u{532}\x03\
	\x02\x02\x02\u{534}\u{535}\x03\x02\x02\x02\u{535}\x75\x03\x02\x02\x02\u{536}\
	\u{534}\x03\x02\x02\x02\u{537}\u{538}\x08\x3c\x01\x02\u{538}\u{539}\x05\
	\x7c\x3f\x02\u{539}\u{53a}\x05\x76\x3c\x0c\u{53a}\u{54e}\x03\x02\x02\x02\
	\u{53b}\u{549}\x07\x09\x02\x02\u{53c}\u{53d}\x05\x76\x3c\x02\u{53d}\u{53e}\
	\x07\x04\x02\x02\u{53e}\u{54a}\x03\x02\x02\x02\u{53f}\u{542}\x05\x76\x3c\
	\x02\u{540}\u{541}\x07\x04\x02\x02\u{541}\u{543}\x05\x76\x3c\x02\u{542}\
	\u{540}\x03\x02\x02\x02\u{543}\u{544}\x03\x02\x02\x02\u{544}\u{542}\x03\
	\x02\x02\x02\u{544}\u{545}\x03\x02\x02\x02\u{545}\u{547}\x03\x02\x02\x02\
	\u{546}\u{548}\x07\x04\x02\x02\u{547}\u{546}\x03\x02\x02\x02\u{547}\u{548}\
	\x03\x02\x02\x02\u{548}\u{54a}\x03\x02\x02\x02\u{549}\u{53c}\x03\x02\x02\
	\x02\u{549}\u{53f}\x03\x02\x02\x02\u{549}\u{54a}\x03\x02\x02\x02\u{54a}\
	\u{54b}\x03\x02\x02\x02\u{54b}\u{54e}\x07\x0a\x02\x02\u{54c}\u{54e}\x05\
	\x78\x3d\x02\u{54d}\u{537}\x03\x02\x02\x02\u{54d}\u{53b}\x03\x02\x02\x02\
	\u{54d}\u{54c}\x03\x02\x02\x02\u{54e}\u{564}\x03\x02\x02\x02\u{54f}\u{550}\
	\x0c\x08\x02\x02\u{550}\u{551}\x05\u{82}\x42\x02\u{551}\u{552}\x05\x76\x3c\
	\x09\u{552}\u{563}\x03\x02\x02\x02\u{553}\u{554}\x0c\x07\x02\x02\u{554}\
	\u{555}\x05\u{8a}\x46\x02\u{555}\u{556}\x05\x76\x3c\x08\u{556}\u{563}\x03\
	\x02\x02\x02\u{557}\u{558}\x0c\x06\x02\x02\u{558}\u{559}\x07\x1b\x02\x02\
	\u{559}\u{563}\x05\x76\x3c\x07\u{55a}\u{55b}\x0c\x0b\x02\x02\u{55b}\u{563}\
	\x07\x55\x02\x02\u{55c}\u{55d}\x0c\x0a\x02\x02\u{55d}\u{563}\x07\x3c\x02\
	\x02\u{55e}\u{55f}\x0c\x09\x02\x02\u{55f}\u{563}\x05\u{a2}\x52\x02\u{560}\
	\u{561}\x0c\x05\x02\x02\u{561}\u{563}\x05\u{a2}\x52\x02\u{562}\u{54f}\x03\
	\x02\x02\x02\u{562}\u{553}\x03\x02\x02\x02\u{562}\u{557}\x03\x02\x02\x02\
	\u{562}\u{55a}\x03\x02\x02\x02\u{562}\u{55c}\x03\x02\x02\x02\u{562}\u{55e}\
	\x03\x02\x02\x02\u{562}\u{560}\x03\x02\x02\x02\u{563}\u{566}\x03\x02\x02\
	\x02\u{564}\u{562}\x03\x02\x02\x02\u{564}\u{565}\x03\x02\x02\x02\u{565}\
	\x77\x03\x02\x02\x02\u{566}\u{564}\x03\x02\x02\x02\u{567}\u{56e}\x05\u{f8}\
	\x7d\x02\u{568}\u{56e}\x05\u{f4}\x7b\x02\u{569}\u{56e}\x05\u{e8}\x75\x02\
	\u{56a}\u{56e}\x05\u{ea}\x76\x02\u{56b}\u{56e}\x05\u{ee}\x78\x02\u{56c}\
	\u{56e}\x07\u{95}\x02\x02\u{56d}\u{567}\x03\x02\x02\x02\u{56d}\u{568}\x03\
	\x02\x02\x02\u{56d}\u{569}\x03\x02\x02\x02\u{56d}\u{56a}\x03\x02\x02\x02\
	\u{56d}\u{56b}\x03\x02\x02\x02\u{56d}\u{56c}\x03\x02\x02\x02\u{56e}\x79\
	\x03\x02\x02\x02\u{56f}\u{575}\x07\u{8e}\x02\x02\u{570}\u{572}\x07\u{8f}\
	\x02\x02\u{571}\u{573}\x05\x72\x3a\x02\u{572}\u{571}\x03\x02\x02\x02\u{572}\
	\u{573}\x03\x02\x02\x02\u{573}\u{575}\x03\x02\x02\x02\u{574}\u{56f}\x03\
	\x02\x02\x02\u{574}\u{570}\x03\x02\x02\x02\u{575}\u{597}\x03\x02\x02\x02\
	\u{576}\u{579}\x07\u{91}\x02\x02\u{577}\u{578}\x07\x6c\x02\x02\u{578}\u{57a}\
	\x05\u{f0}\x79\x02\u{579}\u{577}\x03\x02\x02\x02\u{579}\u{57a}\x03\x02\x02\
	\x02\u{57a}\u{597}\x03\x02\x02\x02\u{57b}\u{57e}\x07\u{92}\x02\x02\u{57c}\
	\u{57d}\x07\x6c\x02\x02\u{57d}\u{57f}\x05\u{f0}\x79\x02\u{57e}\u{57c}\x03\
	\x02\x02\x02\u{57e}\u{57f}\x03\x02\x02\x02\u{57f}\u{597}\x03\x02\x02\x02\
	\u{580}\u{582}\x07\u{94}\x02\x02\u{581}\u{583}\x05\x72\x3a\x02\u{582}\u{581}\
	\x03\x02\x02\x02\u{582}\u{583}\x03\x02\x02\x02\u{583}\u{597}\x03\x02\x02\
	\x02\u{584}\u{587}\x07\u{90}\x02\x02\u{585}\u{586}\x07\x6c\x02\x02\u{586}\
	\u{588}\x05\u{f0}\x79\x02\u{587}\u{585}\x03\x02\x02\x02\u{587}\u{588}\x03\
	\x02\x02\x02\u{588}\u{58a}\x03\x02\x02\x02\u{589}\u{58b}\x05\x72\x3a\x02\
	\u{58a}\u{589}\x03\x02\x02\x02\u{58a}\u{58b}\x03\x02\x02\x02\u{58b}\u{597}\
	\x03\x02\x02\x02\u{58c}\u{58d}\x07\u{90}\x02\x02\u{58d}\u{597}\x07\u{91}\
	\x02\x02\u{58e}\u{58f}\x07\u{90}\x02\x02\u{58f}\u{590}\x07\u{84}\x02\x02\
	\u{590}\u{597}\x05\x72\x3a\x02\u{591}\u{594}\x07\u{93}\x02\x02\u{592}\u{593}\
	\x07\x6c\x02\x02\u{593}\u{595}\x05\u{f0}\x79\x02\u{594}\u{592}\x03\x02\x02\
	\x02\u{594}\u{595}\x03\x02\x02\x02\u{595}\u{597}\x03\x02\x02\x02\u{596}\
	\u{574}\x03\x02\x02\x02\u{596}\u{576}\x03\x02\x02\x02\u{596}\u{57b}\x03\
	\x02\x02\x02\u{596}\u{580}\x03\x02\x02\x02\u{596}\u{584}\x03\x02\x02\x02\
	\u{596}\u{58c}\x03\x02\x02\x02\u{596}\u{58e}\x03\x02\x02\x02\u{596}\u{591}\
	\x03\x02\x02\x02\u{597}\x7b\x03\x02\x02\x02\u{598}\u{599}\x09\x0a\x02\x02\
	\u{599}\x7d\x03\x02\x02\x02\u{59a}\u{59b}\x09\x0b\x02\x02\u{59b}\x7f\x03\
	\x02\x02\x02\u{59c}\u{59d}\x09\x0c\x02\x02\u{59d}\u{81}\x03\x02\x02\x02\
	\u{59e}\u{59f}\x09\x0d\x02\x02\u{59f}\u{83}\x03\x02\x02\x02\u{5a0}\u{5a1}\
	\x09\x0e\x02\x02\u{5a1}\u{85}\x03\x02\x02\x02\u{5a2}\u{5a3}\x09\x0f\x02\
	\x02\u{5a3}\u{87}\x03\x02\x02\x02\u{5a4}\u{5a5}\x07\x61\x02\x02\u{5a5}\u{89}\
	\x03\x02\x02\x02\u{5a6}\u{5a7}\x09\x10\x02\x02\u{5a7}\u{8b}\x03\x02\x02\
	\x02\u{5a8}\u{5a9}\x09\x11\x02\x02\u{5a9}\u{8d}\x03\x02\x02\x02\u{5aa}\u{5ab}\
	\x09\x12\x02\x02\u{5ab}\u{8f}\x03\x02\x02\x02\u{5ac}\u{5ad}\x09\x13\x02\
	\x02\u{5ad}\u{91}\x03\x02\x02\x02\u{5ae}\u{5af}\x09\x14\x02\x02\u{5af}\u{93}\
	\x03\x02\x02\x02\u{5b0}\u{5b1}\x09\x15\x02\x02\u{5b1}\u{95}\x03\x02\x02\
	\x02\u{5b2}\u{5b9}\x07\x5b\x02\x02\u{5b3}\u{5b4}\x07\x5b\x02\x02\u{5b4}\
	\u{5b9}\x07\x3e\x02\x02\u{5b5}\u{5b9}\x07\x5c\x02\x02\u{5b6}\u{5b9}\x07\
	\x5d\x02\x02\u{5b7}\u{5b9}\x07\x59\x02\x02\u{5b8}\u{5b2}\x03\x02\x02\x02\
	\u{5b8}\u{5b3}\x03\x02\x02\x02\u{5b8}\u{5b5}\x03\x02\x02\x02\u{5b8}\u{5b6}\
	\x03\x02\x02\x02\u{5b8}\u{5b7}\x03\x02\x02\x02\u{5b9}\u{97}\x03\x02\x02\
	\x02\u{5ba}\u{5bb}\x07\x5e\x02\x02\u{5bb}\u{99}\x03\x02\x02\x02\u{5bc}\u{5c2}\
	\x07\x57\x02\x02\u{5bd}\u{5be}\x07\x3e\x02\x02\u{5be}\u{5c2}\x07\x57\x02\
	\x02\u{5bf}\u{5c2}\x07\x56\x02\x02\u{5c0}\u{5c2}\x07\x58\x02\x02\u{5c1}\
	\u{5bc}\x03\x02\x02\x02\u{5c1}\u{5bd}\x03\x02\x02\x02\u{5c1}\u{5bf}\x03\
	\x02\x02\x02\u{5c1}\u{5c0}\x03\x02\x02\x02\u{5c2}\u{9b}\x03\x02\x02\x02\
	\u{5c3}\u{5c4}\x07\x0f\x02\x02\u{5c4}\u{5ea}\x07\x10\x02\x02\u{5c5}\u{5c6}\
	\x07\x0f\x02\x02\u{5c6}\u{5cb}\x05\u{9e}\x50\x02\u{5c7}\u{5c8}\x07\x04\x02\
	\x02\u{5c8}\u{5ca}\x05\u{9e}\x50\x02\u{5c9}\u{5c7}\x03\x02\x02\x02\u{5ca}\
	\u{5cd}\x03\x02\x02\x02\u{5cb}\u{5c9}\x03\x02\x02\x02\u{5cb}\u{5cc}\x03\
	\x02\x02\x02\u{5cc}\u{5cf}\x03\x02\x02\x02\u{5cd}\u{5cb}\x03\x02\x02\x02\
	\u{5ce}\u{5d0}\x07\x04\x02\x02\u{5cf}\u{5ce}\x03\x02\x02\x02\u{5cf}\u{5d0}\
	\x03\x02\x02\x02\u{5d0}\u{5d1}\x03\x02\x02\x02\u{5d1}\u{5d2}\x07\x10\x02\
	\x02\u{5d2}\u{5ea}\x03\x02\x02\x02\u{5d3}\u{5d5}\x07\x07\x02\x02\u{5d4}\
	\u{5d3}\x03\x02\x02\x02\u{5d4}\u{5d5}\x03\x02\x02\x02\u{5d5}\u{5d6}\x03\
	\x02\x02\x02\u{5d6}\u{5d7}\x07\x2b\x02\x02\u{5d7}\u{5ea}\x07\x30\x02\x02\
	\u{5d8}\u{5da}\x07\x07\x02\x02\u{5d9}\u{5d8}\x03\x02\x02\x02\u{5d9}\u{5da}\
	\x03\x02\x02\x02\u{5da}\u{5db}\x03\x02\x02\x02\u{5db}\u{5dc}\x07\x2b\x02\
	\x02\u{5dc}\u{5e1}\x05\u{9e}\x50\x02\u{5dd}\u{5de}\x07\x04\x02\x02\u{5de}\
	\u{5e0}\x05\u{9e}\x50\x02\u{5df}\u{5dd}\x03\x02\x02\x02\u{5e0}\u{5e3}\x03\
	\x02\x02\x02\u{5e1}\u{5df}\x03\x02\x02\x02\u{5e1}\u{5e2}\x03\x02\x02\x02\
	\u{5e2}\u{5e5}\x03\x02\x02\x02\u{5e3}\u{5e1}\x03\x02\x02\x02\u{5e4}\u{5e6}\
	\x07\x04\x02\x02\u{5e5}\u{5e4}\x03\x02\x02\x02\u{5e5}\u{5e6}\x03\x02\x02\
	\x02\u{5e6}\u{5e7}\x03\x02\x02\x02\u{5e7}\u{5e8}\x07\x30\x02\x02\u{5e8}\
	\u{5ea}\x03\x02\x02\x02\u{5e9}\u{5c3}\x03\x02\x02\x02\u{5e9}\u{5c5}\x03\
	\x02\x02\x02\u{5e9}\u{5d4}\x03\x02\x02\x02\u{5e9}\u{5d9}\x03\x02\x02\x02\
	\u{5ea}\u{9d}\x03\x02\x02\x02\u{5eb}\u{5ec}\x05\u{f0}\x79\x02\u{5ec}\u{5ed}\
	\x07\x08\x02\x02\u{5ed}\u{5ef}\x03\x02\x02\x02\u{5ee}\u{5eb}\x03\x02\x02\
	\x02\u{5ee}\u{5ef}\x03\x02\x02\x02\u{5ef}\u{5f0}\x03\x02\x02\x02\u{5f0}\
	\u{5f1}\x05\x76\x3c\x02\u{5f1}\u{9f}\x03\x02\x02\x02\u{5f2}\u{5f3}\x07\x07\
	\x02\x02\u{5f3}\u{5f4}\x07\x2b\x02\x02\u{5f4}\u{615}\x07\x30\x02\x02\u{5f5}\
	\u{5f6}\x07\x07\x02\x02\u{5f6}\u{5f7}\x07\x2b\x02\x02\u{5f7}\u{5fc}\x05\
	\u{a4}\x53\x02\u{5f8}\u{5f9}\x07\x04\x02\x02\u{5f9}\u{5fb}\x05\u{a4}\x53\
	\x02\u{5fa}\u{5f8}\x03\x02\x02\x02\u{5fb}\u{5fe}\x03\x02\x02\x02\u{5fc}\
	\u{5fa}\x03\x02\x02\x02\u{5fc}\u{5fd}\x03\x02\x02\x02\u{5fd}\u{600}\x03\
	\x02\x02\x02\u{5fe}\u{5fc}\x03\x02\x02\x02\u{5ff}\u{601}\x07\x04\x02\x02\
	\u{600}\u{5ff}\x03\x02\x02\x02\u{600}\u{601}\x03\x02\x02\x02\u{601}\u{602}\
	\x03\x02\x02\x02\u{602}\u{603}\x07\x30\x02\x02\u{603}\u{615}\x03\x02\x02\
	\x02\u{604}\u{605}\x07\x0f\x02\x02\u{605}\u{615}\x07\x10\x02\x02\u{606}\
	\u{607}\x07\x0f\x02\x02\u{607}\u{60c}\x05\u{a4}\x53\x02\u{608}\u{609}\x07\
	\x04\x02\x02\u{609}\u{60b}\x05\u{a4}\x53\x02\u{60a}\u{608}\x03\x02\x02\x02\
	\u{60b}\u{60e}\x03\x02\x02\x02\u{60c}\u{60a}\x03\x02\x02\x02\u{60c}\u{60d}\
	\x03\x02\x02\x02\u{60d}\u{610}\x03\x02\x02\x02\u{60e}\u{60c}\x03\x02\x02\
	\x02\u{60f}\u{611}\x07\x04\x02\x02\u{610}\u{60f}\x03\x02\x02\x02\u{610}\
	\u{611}\x03\x02\x02\x02\u{611}\u{612}\x03\x02\x02\x02\u{612}\u{613}\x07\
	\x10\x02\x02\u{613}\u{615}\x03\x02\x02\x02\u{614}\u{5f2}\x03\x02\x02\x02\
	\u{614}\u{5f5}\x03\x02\x02\x02\u{614}\u{604}\x03\x02\x02\x02\u{614}\u{606}\
	\x03\x02\x02\x02\u{615}\u{a1}\x03\x02\x02\x02\u{616}\u{618}\x07\x07\x02\
	\x02\u{617}\u{616}\x03\x02\x02\x02\u{617}\u{618}\x03\x02\x02\x02\u{618}\
	\u{619}\x03\x02\x02\x02\u{619}\u{61a}\x07\x2b\x02\x02\u{61a}\u{61f}\x05\
	\u{a4}\x53\x02\u{61b}\u{61c}\x07\x04\x02\x02\u{61c}\u{61e}\x05\u{a4}\x53\
	\x02\u{61d}\u{61b}\x03\x02\x02\x02\u{61e}\u{621}\x03\x02\x02\x02\u{61f}\
	\u{61d}\x03\x02\x02\x02\u{61f}\u{620}\x03\x02\x02\x02\u{620}\u{622}\x03\
	\x02\x02\x02\u{621}\u{61f}\x03\x02\x02\x02\u{622}\u{623}\x07\x30\x02\x02\
	\u{623}\u{630}\x03\x02\x02\x02\u{624}\u{625}\x07\x0f\x02\x02\u{625}\u{62a}\
	\x05\u{a4}\x53\x02\u{626}\u{627}\x07\x04\x02\x02\u{627}\u{629}\x05\u{a4}\
	\x53\x02\u{628}\u{626}\x03\x02\x02\x02\u{629}\u{62c}\x03\x02\x02\x02\u{62a}\
	\u{628}\x03\x02\x02\x02\u{62a}\u{62b}\x03\x02\x02\x02\u{62b}\u{62d}\x03\
	\x02\x02\x02\u{62c}\u{62a}\x03\x02\x02\x02\u{62d}\u{62e}\x07\x10\x02\x02\
	\u{62e}\u{630}\x03\x02\x02\x02\u{62f}\u{617}\x03\x02\x02\x02\u{62f}\u{624}\
	\x03\x02\x02\x02\u{630}\u{a3}\x03\x02\x02\x02\u{631}\u{632}\x05\u{f0}\x79\
	\x02\u{632}\u{633}\x07\x08\x02\x02\u{633}\u{635}\x03\x02\x02\x02\u{634}\
	\u{631}\x03\x02\x02\x02\u{634}\u{635}\x03\x02\x02\x02\u{635}\u{636}\x03\
	\x02\x02\x02\u{636}\u{637}\x05\x76\x3c\x02\u{637}\u{a5}\x03\x02\x02\x02\
	\u{638}\u{639}\x07\x6c\x02\x02\u{639}\u{63a}\x05\u{f0}\x79\x02\u{63a}\u{a7}\
	\x03\x02\x02\x02\u{63b}\u{63d}\x05\u{b8}\x5d\x02\u{63c}\u{63b}\x03\x02\x02\
	\x02\u{63d}\u{640}\x03\x02\x02\x02\u{63e}\u{63c}\x03\x02\x02\x02\u{63e}\
	\u{63f}\x03\x02\x02\x02\u{63f}\u{641}\x03\x02\x02\x02\u{640}\u{63e}\x03\
	\x02\x02\x02\u{641}\u{642}\x05\u{e2}\x72\x02\u{642}\u{66a}\x07\x77\x02\x02\
	\u{643}\u{648}\x05\u{f0}\x79\x02\u{644}\u{645}\x07\x04\x02\x02\u{645}\u{647}\
	\x05\u{f0}\x79\x02\u{646}\u{644}\x03\x02\x02\x02\u{647}\u{64a}\x03\x02\x02\
	\x02\u{648}\u{646}\x03\x02\x02\x02\u{648}\u{649}\x03\x02\x02\x02\u{649}\
	\u{64c}\x03\x02\x02\x02\u{64a}\u{648}\x03\x02\x02\x02\u{64b}\u{64d}\x07\
	\x04\x02\x02\u{64c}\u{64b}\x03\x02\x02\x02\u{64c}\u{64d}\x03\x02\x02\x02\
	\u{64d}\u{66b}\x03\x02\x02\x02\u{64e}\u{64f}\x07\x2b\x02\x02\u{64f}\u{654}\
	\x05\u{f0}\x79\x02\u{650}\u{651}\x07\x04\x02\x02\u{651}\u{653}\x05\u{f0}\
	\x79\x02\u{652}\u{650}\x03\x02\x02\x02\u{653}\u{656}\x03\x02\x02\x02\u{654}\
	\u{652}\x03\x02\x02\x02\u{654}\u{655}\x03\x02\x02\x02\u{655}\u{658}\x03\
	\x02\x02\x02\u{656}\u{654}\x03\x02\x02\x02\u{657}\u{659}\x07\x04\x02\x02\
	\u{658}\u{657}\x03\x02\x02\x02\u{658}\u{659}\x03\x02\x02\x02\u{659}\u{65a}\
	\x03\x02\x02\x02\u{65a}\u{65b}\x07\x30\x02\x02\u{65b}\u{66b}\x03\x02\x02\
	\x02\u{65c}\u{65d}\x07\x0f\x02\x02\u{65d}\u{662}\x05\u{f0}\x79\x02\u{65e}\
	\u{65f}\x07\x04\x02\x02\u{65f}\u{661}\x05\u{f0}\x79\x02\u{660}\u{65e}\x03\
	\x02\x02\x02\u{661}\u{664}\x03\x02\x02\x02\u{662}\u{660}\x03\x02\x02\x02\
	\u{662}\u{663}\x03\x02\x02\x02\u{663}\u{666}\x03\x02\x02\x02\u{664}\u{662}\
	\x03\x02\x02\x02\u{665}\u{667}\x07\x04\x02\x02\u{666}\u{665}\x03\x02\x02\
	\x02\u{666}\u{667}\x03\x02\x02\x02\u{667}\u{668}\x03\x02\x02\x02\u{668}\
	\u{669}\x07\x10\x02\x02\u{669}\u{66b}\x03\x02\x02\x02\u{66a}\u{643}\x03\
	\x02\x02\x02\u{66a}\u{64e}\x03\x02\x02\x02\u{66a}\u{65c}\x03\x02\x02\x02\
	\u{66a}\u{66b}\x03\x02\x02\x02\u{66b}\u{66c}\x03\x02\x02\x02\u{66c}\u{66d}\
	\x05\u{aa}\x56\x02\u{66d}\u{a9}\x03\x02\x02\x02\u{66e}\u{674}\x07\x0d\x02\
	\x02\u{66f}\u{673}\x05\u{ac}\x57\x02\u{670}\u{673}\x05\u{ae}\x58\x02\u{671}\
	\u{673}\x05\x06\x04\x02\u{672}\u{66f}\x03\x02\x02\x02\u{672}\u{670}\x03\
	\x02\x02\x02\u{672}\u{671}\x03\x02\x02\x02\u{673}\u{676}\x03\x02\x02\x02\
	\u{674}\u{672}\x03\x02\x02\x02\u{674}\u{675}\x03\x02\x02\x02\u{675}\u{677}\
	\x03\x02\x02\x02\u{676}\u{674}\x03\x02\x02\x02\u{677}\u{678}\x07\x0e\x02\
	\x02\u{678}\u{ab}\x03\x02\x02\x02\u{679}\u{67a}\x07\u{87}\x02\x02\u{67a}\
	\u{681}\x05\u{b0}\x59\x02\u{67b}\u{67c}\x07\u{8e}\x02\x02\u{67c}\u{681}\
	\x05\x76\x3c\x02\u{67d}\u{67e}\x05\u{f0}\x79\x02\u{67e}\u{67f}\x05\u{b4}\
	\x5b\x02\u{67f}\u{681}\x03\x02\x02\x02\u{680}\u{679}\x03\x02\x02\x02\u{680}\
	\u{67b}\x03\x02\x02\x02\u{680}\u{67d}\x03\x02\x02\x02\u{681}\u{ad}\x03\x02\
	\x02\x02\u{682}\u{683}\x07\x79\x02\x02\u{683}\u{684}\x05\x76\x3c\x02\u{684}\
	\u{af}\x03\x02\x02\x02\u{685}\u{689}\x07\x0d\x02\x02\u{686}\u{688}\x05\u{b2}\
	\x5a\x02\u{687}\u{686}\x03\x02\x02\x02\u{688}\u{68b}\x03\x02\x02\x02\u{689}\
	\u{687}\x03\x02\x02\x02\u{689}\u{68a}\x03\x02\x02\x02\u{68a}\u{68c}\x03\
	\x02\x02\x02\u{68b}\u{689}\x03\x02\x02\x02\u{68c}\u{68d}\x07\x0e\x02\x02\
	\u{68d}\u{b1}\x03\x02\x02\x02\u{68e}\u{68f}\x05\u{f0}\x79\x02\u{68f}\u{690}\
	\x07\x08\x02\x02\u{690}\u{691}\x05\x76\x3c\x02\u{691}\u{694}\x03\x02\x02\
	\x02\u{692}\u{694}\x05\x06\x04\x02\u{693}\u{68e}\x03\x02\x02\x02\u{693}\
	\u{692}\x03\x02\x02\x02\u{694}\u{b3}\x03\x02\x02\x02\u{695}\u{69a}\x07\x0d\
	\x02\x02\u{696}\u{699}\x05\x70\x39\x02\u{697}\u{699}\x05\x06\x04\x02\u{698}\
	\u{696}\x03\x02\x02\x02\u{698}\u{697}\x03\x02\x02\x02\u{699}\u{69c}\x03\
	\x02\x02\x02\u{69a}\u{698}\x03\x02\x02\x02\u{69a}\u{69b}\x03\x02\x02\x02\
	\u{69b}\u{69d}\x03\x02\x02\x02\u{69c}\u{69a}\x03\x02\x02\x02\u{69d}\u{69e}\
	\x07\x0e\x02\x02\u{69e}\u{b5}\x03\x02\x02\x02\u{69f}\u{6a0}\x07\x4e\x02\
	\x02\u{6a0}\u{6a2}\x05\u{ba}\x5e\x02\u{6a1}\u{6a3}\x05\x18\x0d\x02\u{6a2}\
	\u{6a1}\x03\x02\x02\x02\u{6a2}\u{6a3}\x03\x02\x02\x02\u{6a3}\u{6b3}\x03\
	\x02\x02\x02\u{6a4}\u{6a5}\x07\x4e\x02\x02\u{6a5}\u{6a6}\x07\x0b\x02\x02\
	\u{6a6}\u{6ab}\x05\u{ba}\x5e\x02\u{6a7}\u{6a8}\x07\x04\x02\x02\u{6a8}\u{6aa}\
	\x05\u{ba}\x5e\x02\u{6a9}\u{6a7}\x03\x02\x02\x02\u{6aa}\u{6ad}\x03\x02\x02\
	\x02\u{6ab}\u{6a9}\x03\x02\x02\x02\u{6ab}\u{6ac}\x03\x02\x02\x02\u{6ac}\
	\u{6ae}\x03\x02\x02\x02\u{6ad}\u{6ab}\x03\x02\x02\x02\u{6ae}\u{6b0}\x07\
	\x0c\x02\x02\u{6af}\u{6b1}\x05\x18\x0d\x02\u{6b0}\u{6af}\x03\x02\x02\x02\
	\u{6b0}\u{6b1}\x03\x02\x02\x02\u{6b1}\u{6b3}\x03\x02\x02\x02\u{6b2}\u{69f}\
	\x03\x02\x02\x02\u{6b2}\u{6a4}\x03\x02\x02\x02\u{6b3}\u{b7}\x03\x02\x02\
	\x02\u{6b4}\u{6b5}\x07\x4f\x02\x02\u{6b5}\u{6b7}\x05\u{ba}\x5e\x02\u{6b6}\
	\u{6b8}\x05\x18\x0d\x02\u{6b7}\u{6b6}\x03\x02\x02\x02\u{6b7}\u{6b8}\x03\
	\x02\x02\x02\u{6b8}\u{6c6}\x03\x02\x02\x02\u{6b9}\u{6ba}\x07\x4f\x02\x02\
	\u{6ba}\u{6bb}\x07\x0b\x02\x02\u{6bb}\u{6c0}\x05\u{ba}\x5e\x02\u{6bc}\u{6bd}\
	\x07\x04\x02\x02\u{6bd}\u{6bf}\x05\u{ba}\x5e\x02\u{6be}\u{6bc}\x03\x02\x02\
	\x02\u{6bf}\u{6c2}\x03\x02\x02\x02\u{6c0}\u{6be}\x03\x02\x02\x02\u{6c0}\
	\u{6c1}\x03\x02\x02\x02\u{6c1}\u{6c3}\x03\x02\x02\x02\u{6c2}\u{6c0}\x03\
	\x02\x02\x02\u{6c3}\u{6c4}\x07\x0c\x02\x02\u{6c4}\u{6c6}\x03\x02\x02\x02\
	\u{6c5}\u{6b4}\x03\x02\x02\x02\u{6c5}\u{6b9}\x03\x02\x02\x02\u{6c6}\u{b9}\
	\x03\x02\x02\x02\u{6c7}\u{6c9}\x05\u{ee}\x78\x02\u{6c8}\u{6ca}\x05\x50\x29\
	\x02\u{6c9}\u{6c8}\x03\x02\x02\x02\u{6c9}\u{6ca}\x03\x02\x02\x02\u{6ca}\
	\u{6cc}\x03\x02\x02\x02\u{6cb}\u{6cd}\x05\x18\x0d\x02\u{6cc}\u{6cb}\x03\
	\x02\x02\x02\u{6cc}\u{6cd}\x03\x02\x02\x02\u{6cd}\u{bb}\x03\x02\x02\x02\
	\u{6ce}\u{6d0}\x05\u{b8}\x5d\x02\u{6cf}\u{6ce}\x03\x02\x02\x02\u{6d0}\u{6d3}\
	\x03\x02\x02\x02\u{6d1}\u{6cf}\x03\x02\x02\x02\u{6d1}\u{6d2}\x03\x02\x02\
	\x02\u{6d2}\u{6d4}\x03\x02\x02\x02\u{6d3}\u{6d1}\x03\x02\x02\x02\u{6d4}\
	\u{6d6}\x07\u{81}\x02\x02\u{6d5}\u{6d7}\x05\x76\x3c\x02\u{6d6}\u{6d5}\x03\
	\x02\x02\x02\u{6d6}\u{6d7}\x03\x02\x02\x02\u{6d7}\u{6d8}\x03\x02\x02\x02\
	\u{6d8}\u{6d9}\x05\x56\x2c\x02\u{6d9}\u{bd}\x03\x02\x02\x02\u{6da}\u{6dc}\
	\x05\u{b8}\x5d\x02\u{6db}\u{6da}\x03\x02\x02\x02\u{6dc}\u{6df}\x03\x02\x02\
	\x02\u{6dd}\u{6db}\x03\x02\x02\x02\u{6dd}\u{6de}\x03\x02\x02\x02\u{6de}\
	\u{6e0}\x03\x02\x02\x02\u{6df}\u{6dd}\x03\x02\x02\x02\u{6e0}\u{6e4}\x09\
	\x09\x02\x02\u{6e1}\u{6e2}\x05\u{f0}\x79\x02\u{6e2}\u{6e3}\x07\x36\x02\x02\
	\u{6e3}\u{6e5}\x03\x02\x02\x02\u{6e4}\u{6e1}\x03\x02\x02\x02\u{6e4}\u{6e5}\
	\x03\x02\x02\x02\u{6e5}\u{6e6}\x03\x02\x02\x02\u{6e6}\u{6e8}\x05\x74\x3b\
	\x02\u{6e7}\u{6e9}\x07\x55\x02\x02\u{6e8}\u{6e7}\x03\x02\x02\x02\u{6e8}\
	\u{6e9}\x03\x02\x02\x02\u{6e9}\u{6ea}\x03\x02\x02\x02\u{6ea}\u{6eb}\x05\
	\u{c0}\x61\x02\u{6eb}\u{bf}\x03\x02\x02\x02\u{6ec}\u{6f1}\x07\x0d\x02\x02\
	\u{6ed}\u{6f0}\x05\u{c2}\x62\x02\u{6ee}\u{6f0}\x05\x06\x04\x02\u{6ef}\u{6ed}\
	\x03\x02\x02\x02\u{6ef}\u{6ee}\x03\x02\x02\x02\u{6f0}\u{6f3}\x03\x02\x02\
	\x02\u{6f1}\u{6ef}\x03\x02\x02\x02\u{6f1}\u{6f2}\x03\x02\x02\x02\u{6f2}\
	\u{6f4}\x03\x02\x02\x02\u{6f3}\u{6f1}\x03\x02\x02\x02\u{6f4}\u{6f5}\x07\
	\x0e\x02\x02\u{6f5}\u{c1}\x03\x02\x02\x02\u{6f6}\u{6f8}\x05\u{b8}\x5d\x02\
	\u{6f7}\u{6f6}\x03\x02\x02\x02\u{6f8}\u{6fb}\x03\x02\x02\x02\u{6f9}\u{6f7}\
	\x03\x02\x02\x02\u{6f9}\u{6fa}\x03\x02\x02\x02\u{6fa}\u{6fc}\x03\x02\x02\
	\x02\u{6fb}\u{6f9}\x03\x02\x02\x02\u{6fc}\u{6fd}\x07\u{84}\x02\x02\u{6fd}\
	\u{743}\x05\u{f0}\x79\x02\u{6fe}\u{700}\x05\u{b8}\x5d\x02\u{6ff}\u{6fe}\
	\x03\x02\x02\x02\u{700}\u{703}\x03\x02\x02\x02\u{701}\u{6ff}\x03\x02\x02\
	\x02\u{701}\u{702}\x03\x02\x02\x02\u{702}\u{704}\x03\x02\x02\x02\u{703}\
	\u{701}\x03\x02\x02\x02\u{704}\u{705}\x07\u{84}\x02\x02\u{705}\u{711}\x07\
	\x0b\x02\x02\u{706}\u{70b}\x05\u{f0}\x79\x02\u{707}\u{708}\x07\x04\x02\x02\
	\u{708}\u{70a}\x05\u{f0}\x79\x02\u{709}\u{707}\x03\x02\x02\x02\u{70a}\u{70d}\
	\x03\x02\x02\x02\u{70b}\u{709}\x03\x02\x02\x02\u{70b}\u{70c}\x03\x02\x02\
	\x02\u{70c}\u{70f}\x03\x02\x02\x02\u{70d}\u{70b}\x03\x02\x02\x02\u{70e}\
	\u{710}\x07\x04\x02\x02\u{70f}\u{70e}\x03\x02\x02\x02\u{70f}\u{710}\x03\
	\x02\x02\x02\u{710}\u{712}\x03\x02\x02\x02\u{711}\u{706}\x03\x02\x02\x02\
	\u{711}\u{712}\x03\x02\x02\x02\u{712}\u{713}\x03\x02\x02\x02\u{713}\u{743}\
	\x07\x0c\x02\x02\u{714}\u{716}\x05\u{b8}\x5d\x02\u{715}\u{714}\x03\x02\x02\
	\x02\u{716}\u{719}\x03\x02\x02\x02\u{717}\u{715}\x03\x02\x02\x02\u{717}\
	\u{718}\x03\x02\x02\x02\u{718}\u{71a}\x03\x02\x02\x02\u{719}\u{717}\x03\
	\x02\x02\x02\u{71a}\u{71b}\x07\x76\x02\x02\u{71b}\u{71e}\x05\x76\x3c\x02\
	\u{71c}\u{71d}\x07\u{8b}\x02\x02\u{71d}\u{71f}\x05\x74\x3b\x02\u{71e}\u{71c}\
	\x03\x02\x02\x02\u{71e}\u{71f}\x03\x02\x02\x02\u{71f}\u{720}\x03\x02\x02\
	\x02\u{720}\u{721}\x05\u{c4}\x63\x02\u{721}\u{743}\x03\x02\x02\x02\u{722}\
	\u{724}\x05\u{b8}\x5d\x02\u{723}\u{722}\x03\x02\x02\x02\u{724}\u{727}\x03\
	\x02\x02\x02\u{725}\u{723}\x03\x02\x02\x02\u{725}\u{726}\x03\x02\x02\x02\
	\u{726}\u{728}\x03\x02\x02\x02\u{727}\u{725}\x03\x02\x02\x02\u{728}\u{729}\
	\x07\u{86}\x02\x02\u{729}\u{72a}\x05\x74\x3b\x02\u{72a}\u{72b}\x05\u{c4}\
	\x63\x02\u{72b}\u{743}\x03\x02\x02\x02\u{72c}\u{72e}\x05\u{b8}\x5d\x02\u{72d}\
	\u{72c}\x03\x02\x02\x02\u{72e}\u{731}\x03\x02\x02\x02\u{72f}\u{72d}\x03\
	\x02\x02\x02\u{72f}\u{730}\x03\x02\x02\x02\u{730}\u{732}\x03\x02\x02\x02\
	\u{731}\u{72f}\x03\x02\x02\x02\u{732}\u{733}\x07\u{8c}\x02\x02\u{733}\u{743}\
	\x05\u{c4}\x63\x02\u{734}\u{736}\x05\u{b8}\x5d\x02\u{735}\u{734}\x03\x02\
	\x02\x02\u{736}\u{739}\x03\x02\x02\x02\u{737}\u{735}\x03\x02\x02\x02\u{737}\
	\u{738}\x03\x02\x02\x02\u{738}\u{73a}\x03\x02\x02\x02\u{739}\u{737}\x03\
	\x02\x02\x02\u{73a}\u{73b}\x07\u{85}\x02\x02\u{73b}\u{73e}\x05\u{c6}\x64\
	\x02\u{73c}\u{73d}\x07\u{8b}\x02\x02\u{73d}\u{73f}\x05\x74\x3b\x02\u{73e}\
	\u{73c}\x03\x02\x02\x02\u{73e}\u{73f}\x03\x02\x02\x02\u{73f}\u{740}\x03\
	\x02\x02\x02\u{740}\u{741}\x05\u{c4}\x63\x02\u{741}\u{743}\x03\x02\x02\x02\
	\u{742}\u{6f9}\x03\x02\x02\x02\u{742}\u{701}\x03\x02\x02\x02\u{742}\u{717}\
	\x03\x02\x02\x02\u{742}\u{725}\x03\x02\x02\x02\u{742}\u{72f}\x03\x02\x02\
	\x02\u{742}\u{737}\x03\x02\x02\x02\u{743}\u{c3}\x03\x02\x02\x02\u{744}\u{748}\
	\x07\x08\x02\x02\u{745}\u{747}\x05\x72\x3a\x02\u{746}\u{745}\x03\x02\x02\
	\x02\u{747}\u{74a}\x03\x02\x02\x02\u{748}\u{746}\x03\x02\x02\x02\u{748}\
	\u{749}\x03\x02\x02\x02\u{749}\u{c5}\x03\x02\x02\x02\u{74a}\u{748}\x03\x02\
	\x02\x02\u{74b}\u{74c}\x08\x64\x01\x02\u{74c}\u{74d}\x05\u{c8}\x65\x02\u{74d}\
	\u{756}\x03\x02\x02\x02\u{74e}\u{74f}\x0c\x05\x02\x02\u{74f}\u{750}\x09\
	\x16\x02\x02\u{750}\u{755}\x05\u{c6}\x64\x06\u{751}\u{752}\x0c\x04\x02\x02\
	\u{752}\u{753}\x07\x61\x02\x02\u{753}\u{755}\x05\u{c6}\x64\x05\u{754}\u{74e}\
	\x03\x02\x02\x02\u{754}\u{751}\x03\x02\x02\x02\u{755}\u{758}\x03\x02\x02\
	\x02\u{756}\u{754}\x03\x02\x02\x02\u{756}\u{757}\x03\x02\x02\x02\u{757}\
	\u{c7}\x03\x02\x02\x02\u{758}\u{756}\x03\x02\x02\x02\u{759}\u{770}\x05\u{ca}\
	\x66\x02\u{75a}\u{75b}\x05\u{f0}\x79\x02\u{75b}\u{75c}\x07\x36\x02\x02\u{75c}\
	\u{75d}\x05\u{c8}\x65\x02\u{75d}\u{770}\x03\x02\x02\x02\u{75e}\u{75f}\x05\
	\u{e4}\x73\x02\u{75f}\u{763}\x07\x08\x02\x02\u{760}\u{761}\x05\u{f0}\x79\
	\x02\u{761}\u{762}\x07\x36\x02\x02\u{762}\u{764}\x03\x02\x02\x02\u{763}\
	\u{760}\x03\x02\x02\x02\u{763}\u{764}\x03\x02\x02\x02\u{764}\u{765}\x03\
	\x02\x02\x02\u{765}\u{766}\x05\u{c8}\x65\x02\u{766}\u{770}\x03\x02\x02\x02\
	\u{767}\u{769}\x09\x17\x02\x02\u{768}\u{76a}\x05\u{f0}\x79\x02\u{769}\u{768}\
	\x03\x02\x02\x02\u{769}\u{76a}\x03\x02\x02\x02\u{76a}\u{770}\x03\x02\x02\
	\x02\u{76b}\u{770}\x05\u{ee}\x78\x02\u{76c}\u{770}\x05\u{f4}\x7b\x02\u{76d}\
	\u{770}\x05\u{f8}\x7d\x02\u{76e}\u{770}\x07\u{95}\x02\x02\u{76f}\u{759}\
	\x03\x02\x02\x02\u{76f}\u{75a}\x03\x02\x02\x02\u{76f}\u{75e}\x03\x02\x02\
	\x02\u{76f}\u{767}\x03\x02\x02\x02\u{76f}\u{76b}\x03\x02\x02\x02\u{76f}\
	\u{76c}\x03\x02\x02\x02\u{76f}\u{76d}\x03\x02\x02\x02\u{76f}\u{76e}\x03\
	\x02\x02\x02\u{770}\u{c9}\x03\x02\x02\x02\u{771}\u{773}\x05\u{ee}\x78\x02\
	\u{772}\u{771}\x03\x02\x02\x02\u{772}\u{773}\x03\x02\x02\x02\u{773}\u{774}\
	\x03\x02\x02\x02\u{774}\u{775}\x07\x09\x02\x02\u{775}\u{7c4}\x07\x0a\x02\
	\x02\u{776}\u{778}\x05\u{ee}\x78\x02\u{777}\u{776}\x03\x02\x02\x02\u{777}\
	\u{778}\x03\x02\x02\x02\u{778}\u{779}\x03\x02\x02\x02\u{779}\u{77a}\x07\
	\x0b\x02\x02\u{77a}\u{7c4}\x07\x0c\x02\x02\u{77b}\u{77d}\x05\u{ee}\x78\x02\
	\u{77c}\u{77b}\x03\x02\x02\x02\u{77c}\u{77d}\x03\x02\x02\x02\u{77d}\u{77e}\
	\x03\x02\x02\x02\u{77e}\u{77f}\x07\x0d\x02\x02\u{77f}\u{7c4}\x07\x0e\x02\
	\x02\u{780}\u{781}\x07\x09\x02\x02\u{781}\u{782}\x05\u{c8}\x65\x02\u{782}\
	\u{783}\x07\x04\x02\x02\u{783}\u{784}\x07\x0a\x02\x02\u{784}\u{7c4}\x03\
	\x02\x02\x02\u{785}\u{786}\x07\x09\x02\x02\u{786}\u{789}\x05\u{c8}\x65\x02\
	\u{787}\u{788}\x07\x04\x02\x02\u{788}\u{78a}\x05\u{c8}\x65\x02\u{789}\u{787}\
	\x03\x02\x02\x02\u{78a}\u{78b}\x03\x02\x02\x02\u{78b}\u{789}\x03\x02\x02\
	\x02\u{78b}\u{78c}\x03\x02\x02\x02\u{78c}\u{78e}\x03\x02\x02\x02\u{78d}\
	\u{78f}\x07\x04\x02\x02\u{78e}\u{78d}\x03\x02\x02\x02\u{78e}\u{78f}\x03\
	\x02\x02\x02\u{78f}\u{790}\x03\x02\x02\x02\u{790}\u{791}\x07\x0a\x02\x02\
	\u{791}\u{7c4}\x03\x02\x02\x02\u{792}\u{793}\x05\u{ee}\x78\x02\u{793}\u{794}\
	\x07\x09\x02\x02\u{794}\u{799}\x05\u{c8}\x65\x02\u{795}\u{796}\x07\x04\x02\
	\x02\u{796}\u{798}\x05\u{c8}\x65\x02\u{797}\u{795}\x03\x02\x02\x02\u{798}\
	\u{79b}\x03\x02\x02\x02\u{799}\u{797}\x03\x02\x02\x02\u{799}\u{79a}\x03\
	\x02\x02\x02\u{79a}\u{79d}\x03\x02\x02\x02\u{79b}\u{799}\x03\x02\x02\x02\
	\u{79c}\u{79e}\x07\x04\x02\x02\u{79d}\u{79c}\x03\x02\x02\x02\u{79d}\u{79e}\
	\x03\x02\x02\x02\u{79e}\u{79f}\x03\x02\x02\x02\u{79f}\u{7a0}\x07\x0a\x02\
	\x02\u{7a0}\u{7c4}\x03\x02\x02\x02\u{7a1}\u{7a3}\x05\u{ee}\x78\x02\u{7a2}\
	\u{7a1}\x03\x02\x02\x02\u{7a2}\u{7a3}\x03\x02\x02\x02\u{7a3}\u{7a4}\x03\
	\x02\x02\x02\u{7a4}\u{7a5}\x07\x0b\x02\x02\u{7a5}\u{7aa}\x05\u{c8}\x65\x02\
	\u{7a6}\u{7a7}\x07\x04\x02\x02\u{7a7}\u{7a9}\x05\u{c8}\x65\x02\u{7a8}\u{7a6}\
	\x03\x02\x02\x02\u{7a9}\u{7ac}\x03\x02\x02\x02\u{7aa}\u{7a8}\x03\x02\x02\
	\x02\u{7aa}\u{7ab}\x03\x02\x02\x02\u{7ab}\u{7ae}\x03\x02\x02\x02\u{7ac}\
	\u{7aa}\x03\x02\x02\x02\u{7ad}\u{7af}\x07\x04\x02\x02\u{7ae}\u{7ad}\x03\
	\x02\x02\x02\u{7ae}\u{7af}\x03\x02\x02\x02\u{7af}\u{7b0}\x03\x02\x02\x02\
	\u{7b0}\u{7b1}\x07\x0c\x02\x02\u{7b1}\u{7c4}\x03\x02\x02\x02\u{7b2}\u{7b4}\
	\x05\u{ee}\x78\x02\u{7b3}\u{7b2}\x03\x02\x02\x02\u{7b3}\u{7b4}\x03\x02\x02\
	\x02\u{7b4}\u{7b5}\x03\x02\x02\x02\u{7b5}\u{7b6}\x07\x0d\x02\x02\u{7b6}\
	\u{7bb}\x05\u{c8}\x65\x02\u{7b7}\u{7b8}\x07\x04\x02\x02\u{7b8}\u{7ba}\x05\
	\u{c8}\x65\x02\u{7b9}\u{7b7}\x03\x02\x02\x02\u{7ba}\u{7bd}\x03\x02\x02\x02\
	\u{7bb}\u{7b9}\x03\x02\x02\x02\u{7bb}\u{7bc}\x03\x02\x02\x02\u{7bc}\u{7bf}\
	\x03\x02\x02\x02\u{7bd}\u{7bb}\x03\x02\x02\x02\u{7be}\u{7c0}\x07\x04\x02\
	\x02\u{7bf}\u{7be}\x03\x02\x02\x02\u{7bf}\u{7c0}\x03\x02\x02\x02\u{7c0}\
	\u{7c1}\x03\x02\x02\x02\u{7c1}\u{7c2}\x07\x0e\x02\x02\u{7c2}\u{7c4}\x03\
	\x02\x02\x02\u{7c3}\u{772}\x03\x02\x02\x02\u{7c3}\u{777}\x03\x02\x02\x02\
	\u{7c3}\u{77c}\x03\x02\x02\x02\u{7c3}\u{780}\x03\x02\x02\x02\u{7c3}\u{785}\
	\x03\x02\x02\x02\u{7c3}\u{792}\x03\x02\x02\x02\u{7c3}\u{7a2}\x03\x02\x02\
	\x02\u{7c3}\u{7b3}\x03\x02\x02\x02\u{7c4}\u{cb}\x03\x02\x02\x02\u{7c5}\u{7c7}\
	\x07\x7e\x02\x02\u{7c6}\u{7c8}\x05\u{9c}\x4f\x02\u{7c7}\u{7c6}\x03\x02\x02\
	\x02\u{7c7}\u{7c8}\x03\x02\x02\x02\u{7c8}\u{7ca}\x03\x02\x02\x02\u{7c9}\
	\u{7cb}\x05\x1a\x0e\x02\u{7ca}\u{7c9}\x03\x02\x02\x02\u{7ca}\u{7cb}\x03\
	\x02\x02\x02\u{7cb}\u{7cd}\x03\x02\x02\x02\u{7cc}\u{7ce}\x05\x64\x33\x02\
	\u{7cd}\u{7cc}\x03\x02\x02\x02\u{7cd}\u{7ce}\x03\x02\x02\x02\u{7ce}\u{7cf}\
	\x03\x02\x02\x02\u{7cf}\u{7d0}\x05\x18\x0d\x02\u{7d0}\u{cd}\x03\x02\x02\
	\x02\u{7d1}\u{7d2}\x07\x7d\x02\x02\u{7d2}\u{7d4}\x05\u{e6}\x74\x02\u{7d3}\
	\u{7d5}\x05\u{a2}\x52\x02\u{7d4}\u{7d3}\x03\x02\x02\x02\u{7d4}\u{7d5}\x03\
	\x02\x02\x02\u{7d5}\u{7d7}\x03\x02\x02\x02\u{7d6}\u{7d8}\x05\x50\x29\x02\
	\u{7d7}\u{7d6}\x03\x02\x02\x02\u{7d7}\u{7d8}\x03\x02\x02\x02\u{7d8}\u{7d9}\
	\x03\x02\x02\x02\u{7d9}\u{7da}\x05\u{d0}\x69\x02\u{7da}\u{7e3}\x03\x02\x02\
	\x02\u{7db}\u{7dc}\x07\x7d\x02\x02\u{7dc}\u{7de}\x05\u{e6}\x74\x02\u{7dd}\
	\u{7df}\x05\u{a2}\x52\x02\u{7de}\u{7dd}\x03\x02\x02\x02\u{7de}\u{7df}\x03\
	\x02\x02\x02\u{7df}\u{7e0}\x03\x02\x02\x02\u{7e0}\u{7e1}\x05\x50\x29\x02\
	\u{7e1}\u{7e3}\x03\x02\x02\x02\u{7e2}\u{7d1}\x03\x02\x02\x02\u{7e2}\u{7db}\
	\x03\x02\x02\x02\u{7e3}\u{cf}\x03\x02\x02\x02\u{7e4}\u{7e9}\x07\x0d\x02\
	\x02\u{7e5}\u{7e8}\x05\u{d2}\x6a\x02\u{7e6}\u{7e8}\x05\x06\x04\x02\u{7e7}\
	\u{7e5}\x03\x02\x02\x02\u{7e7}\u{7e6}\x03\x02\x02\x02\u{7e8}\u{7eb}\x03\
	\x02\x02\x02\u{7e9}\u{7e7}\x03\x02\x02\x02\u{7e9}\u{7ea}\x03\x02\x02\x02\
	\u{7ea}\u{7ec}\x03\x02\x02\x02\u{7eb}\u{7e9}\x03\x02\x02\x02\u{7ec}\u{7ed}\
	\x07\x0e\x02\x02\u{7ed}\u{d1}\x03\x02\x02\x02\u{7ee}\u{7f0}\x05\u{d4}\x6b\
	\x02\u{7ef}\u{7ee}\x03\x02\x02\x02\u{7ef}\u{7f0}\x03\x02\x02\x02\u{7f0}\
	\u{7f1}\x03\x02\x02\x02\u{7f1}\u{7f2}\x05\x72\x3a\x02\u{7f2}\u{d3}\x03\x02\
	\x02\x02\u{7f3}\u{7f4}\x05\u{f0}\x79\x02\u{7f4}\u{7f5}\x07\x08\x02\x02\u{7f5}\
	\u{7ff}\x03\x02\x02\x02\u{7f6}\u{7f7}\x07\u{88}\x02\x02\u{7f7}\u{7ff}\x07\
	\x08\x02\x02\u{7f8}\u{7f9}\x05\u{f6}\x7c\x02\u{7f9}\u{7fa}\x07\x08\x02\x02\
	\u{7fa}\u{7ff}\x03\x02\x02\x02\u{7fb}\u{7fc}\x05\u{de}\x70\x02\u{7fc}\u{7fd}\
	\x07\x08\x02\x02\u{7fd}\u{7ff}\x03\x02\x02\x02\u{7fe}\u{7f3}\x03\x02\x02\
	\x02\u{7fe}\u{7f6}\x03\x02\x02\x02\u{7fe}\u{7f8}\x03\x02\x02\x02\u{7fe}\
	\u{7fb}\x03\x02\x02\x02\u{7ff}\u{d5}\x03\x02\x02\x02\u{800}\u{801}\x07\x09\
	\x02\x02\u{801}\u{815}\x07\x0a\x02\x02\u{802}\u{803}\x07\x09\x02\x02\u{803}\
	\u{806}\x05\u{d8}\x6d\x02\u{804}\u{805}\x07\x04\x02\x02\u{805}\u{807}\x05\
	\u{d8}\x6d\x02\u{806}\u{804}\x03\x02\x02\x02\u{807}\u{808}\x03\x02\x02\x02\
	\u{808}\u{806}\x03\x02\x02\x02\u{808}\u{809}\x03\x02\x02\x02\u{809}\u{80b}\
	\x03\x02\x02\x02\u{80a}\u{80c}\x07\x04\x02\x02\u{80b}\u{80a}\x03\x02\x02\
	\x02\u{80b}\u{80c}\x03\x02\x02\x02\u{80c}\u{80d}\x03\x02\x02\x02\u{80d}\
	\u{80e}\x07\x0a\x02\x02\u{80e}\u{815}\x03\x02\x02\x02\u{80f}\u{810}\x07\
	\x09\x02\x02\u{810}\u{811}\x05\u{d8}\x6d\x02\u{811}\u{812}\x07\x04\x02\x02\
	\u{812}\u{813}\x07\x0a\x02\x02\u{813}\u{815}\x03\x02\x02\x02\u{814}\u{800}\
	\x03\x02\x02\x02\u{814}\u{802}\x03\x02\x02\x02\u{814}\u{80f}\x03\x02\x02\
	\x02\u{815}\u{d7}\x03\x02\x02\x02\u{816}\u{818}\x05\u{da}\x6e\x02\u{817}\
	\u{816}\x03\x02\x02\x02\u{817}\u{818}\x03\x02\x02\x02\u{818}\u{819}\x03\
	\x02\x02\x02\u{819}\u{81a}\x05\x72\x3a\x02\u{81a}\u{d9}\x03\x02\x02\x02\
	\u{81b}\u{81c}\x05\u{f0}\x79\x02\u{81c}\u{81d}\x07\x08\x02\x02\u{81d}\u{824}\
	\x03\x02\x02\x02\u{81e}\u{81f}\x07\u{88}\x02\x02\u{81f}\u{824}\x07\x08\x02\
	\x02\u{820}\u{821}\x05\u{f6}\x7c\x02\u{821}\u{822}\x07\x08\x02\x02\u{822}\
	\u{824}\x03\x02\x02\x02\u{823}\u{81b}\x03\x02\x02\x02\u{823}\u{81e}\x03\
	\x02\x02\x02\u{823}\u{820}\x03\x02\x02\x02\u{824}\u{db}\x03\x02\x02\x02\
	\u{825}\u{827}\x07\x55\x02\x02\u{826}\u{825}\x03\x02\x02\x02\u{826}\u{827}\
	\x03\x02\x02\x02\u{827}\u{828}\x03\x02\x02\x02\u{828}\u{829}\x05\u{de}\x70\
	\x02\u{829}\u{dd}\x03\x02\x02\x02\u{82a}\u{836}\x07\x0b\x02\x02\u{82b}\u{830}\
	\x05\u{e0}\x71\x02\u{82c}\u{82d}\x07\x04\x02\x02\u{82d}\u{82f}\x05\u{e0}\
	\x71\x02\u{82e}\u{82c}\x03\x02\x02\x02\u{82f}\u{832}\x03\x02\x02\x02\u{830}\
	\u{82e}\x03\x02\x02\x02\u{830}\u{831}\x03\x02\x02\x02\u{831}\u{834}\x03\
	\x02\x02\x02\u{832}\u{830}\x03\x02\x02\x02\u{833}\u{835}\x07\x04\x02\x02\
	\u{834}\u{833}\x03\x02\x02\x02\u{834}\u{835}\x03\x02\x02\x02\u{835}\u{837}\
	\x03\x02\x02\x02\u{836}\u{82b}\x03\x02\x02\x02\u{836}\u{837}\x03\x02\x02\
	\x02\u{837}\u{838}\x03\x02\x02\x02\u{838}\u{849}\x07\x0c\x02\x02\u{839}\
	\u{845}\x07\x11\x02\x02\u{83a}\u{83f}\x05\u{e0}\x71\x02\u{83b}\u{83c}\x07\
	\x04\x02\x02\u{83c}\u{83e}\x05\u{e0}\x71\x02\u{83d}\u{83b}\x03\x02\x02\x02\
	\u{83e}\u{841}\x03\x02\x02\x02\u{83f}\u{83d}\x03\x02\x02\x02\u{83f}\u{840}\
	\x03\x02\x02\x02\u{840}\u{843}\x03\x02\x02\x02\u{841}\u{83f}\x03\x02\x02\
	\x02\u{842}\u{844}\x07\x04\x02\x02\u{843}\u{842}\x03\x02\x02\x02\u{843}\
	\u{844}\x03\x02\x02\x02\u{844}\u{846}\x03\x02\x02\x02\u{845}\u{83a}\x03\
	\x02\x02\x02\u{845}\u{846}\x03\x02\x02\x02\u{846}\u{847}\x03\x02\x02\x02\
	\u{847}\u{849}\x07\x12\x02\x02\u{848}\u{82a}\x03\x02\x02\x02\u{848}\u{839}\
	\x03\x02\x02\x02\u{849}\u{df}\x03\x02\x02\x02\u{84a}\u{883}\x07\x08\x02\
	\x02\u{84b}\u{883}\x05\x72\x3a\x02\u{84c}\u{84d}\x05\x72\x3a\x02\u{84d}\
	\u{84e}\x07\x08\x02\x02\u{84e}\u{883}\x03\x02\x02\x02\u{84f}\u{850}\x07\
	\x08\x02\x02\u{850}\u{883}\x05\x72\x3a\x02\u{851}\u{852}\x05\x72\x3a\x02\
	\u{852}\u{853}\x07\x08\x02\x02\u{853}\u{854}\x05\x72\x3a\x02\u{854}\u{883}\
	\x03\x02\x02\x02\u{855}\u{859}\x07\x07\x02\x02\u{856}\u{857}\x07\x08\x02\
	\x02\u{857}\u{859}\x07\x08\x02\x02\u{858}\u{855}\x03\x02\x02\x02\u{858}\
	\u{856}\x03\x02\x02\x02\u{859}\u{883}\x03\x02\x02\x02\u{85a}\u{85e}\x05\
	\x72\x3a\x02\u{85b}\u{85f}\x07\x07\x02\x02\u{85c}\u{85d}\x07\x08\x02\x02\
	\u{85d}\u{85f}\x07\x08\x02\x02\u{85e}\u{85b}\x03\x02\x02\x02\u{85e}\u{85c}\
	\x03\x02\x02\x02\u{85f}\u{883}\x03\x02\x02\x02\u{860}\u{861}\x07\x08\x02\
	\x02\u{861}\u{862}\x05\x72\x3a\x02\u{862}\u{863}\x07\x08\x02\x02\u{863}\
	\u{883}\x03\x02\x02\x02\u{864}\u{868}\x07\x07\x02\x02\u{865}\u{866}\x07\
	\x08\x02\x02\u{866}\u{868}\x07\x08\x02\x02\u{867}\u{864}\x03\x02\x02\x02\
	\u{867}\u{865}\x03\x02\x02\x02\u{868}\u{869}\x03\x02\x02\x02\u{869}\u{883}\
	\x05\x72\x3a\x02\u{86a}\u{86b}\x05\x72\x3a\x02\u{86b}\u{86c}\x07\x08\x02\
	\x02\u{86c}\u{86d}\x05\x72\x3a\x02\u{86d}\u{86e}\x07\x08\x02\x02\u{86e}\
	\u{883}\x03\x02\x02\x02\u{86f}\u{870}\x07\x08\x02\x02\u{870}\u{871}\x05\
	\x72\x3a\x02\u{871}\u{872}\x07\x08\x02\x02\u{872}\u{873}\x05\x72\x3a\x02\
	\u{873}\u{883}\x03\x02\x02\x02\u{874}\u{878}\x05\x72\x3a\x02\u{875}\u{879}\
	\x07\x07\x02\x02\u{876}\u{877}\x07\x08\x02\x02\u{877}\u{879}\x07\x08\x02\
	\x02\u{878}\u{875}\x03\x02\x02\x02\u{878}\u{876}\x03\x02\x02\x02\u{879}\
	\u{87a}\x03\x02\x02\x02\u{87a}\u{87b}\x05\x72\x3a\x02\u{87b}\u{883}\x03\
	\x02\x02\x02\u{87c}\u{87d}\x05\x72\x3a\x02\u{87d}\u{87e}\x07\x08\x02\x02\
	\u{87e}\u{87f}\x05\x72\x3a\x02\u{87f}\u{880}\x07\x08\x02\x02\u{880}\u{881}\
	\x05\x72\x3a\x02\u{881}\u{883}\x03\x02\x02\x02\u{882}\u{84a}\x03\x02\x02\
	\x02\u{882}\u{84b}\x03\x02\x02\x02\u{882}\u{84c}\x03\x02\x02\x02\u{882}\
	\u{84f}\x03\x02\x02\x02\u{882}\u{851}\x03\x02\x02\x02\u{882}\u{858}\x03\
	\x02\x02\x02\u{882}\u{85a}\x03\x02\x02\x02\u{882}\u{860}\x03\x02\x02\x02\
	\u{882}\u{867}\x03\x02\x02\x02\u{882}\u{86a}\x03\x02\x02\x02\u{882}\u{86f}\
	\x03\x02\x02\x02\u{882}\u{874}\x03\x02\x02\x02\u{882}\u{87c}\x03\x02\x02\
	\x02\u{883}\u{e1}\x03\x02\x02\x02\u{884}\u{886}\x05\u{f0}\x79\x02\u{885}\
	\u{884}\x03\x02\x02\x02\u{886}\u{889}\x03\x02\x02\x02\u{887}\u{885}\x03\
	\x02\x02\x02\u{887}\u{888}\x03\x02\x02\x02\u{888}\u{e3}\x03\x02\x02\x02\
	\u{889}\u{887}\x03\x02\x02\x02\u{88a}\u{88c}\x05\u{f0}\x79\x02\u{88b}\u{88a}\
	\x03\x02\x02\x02\u{88c}\u{88f}\x03\x02\x02\x02\u{88d}\u{88b}\x03\x02\x02\
	\x02\u{88d}\u{88e}\x03\x02\x02\x02\u{88e}\u{890}\x03\x02\x02\x02\u{88f}\
	\u{88d}\x03\x02\x02\x02\u{890}\u{891}\x05\u{f0}\x79\x02\u{891}\u{e5}\x03\
	\x02\x02\x02\u{892}\u{894}\x05\u{f0}\x79\x02\u{893}\u{892}\x03\x02\x02\x02\
	\u{894}\u{897}\x03\x02\x02\x02\u{895}\u{893}\x03\x02\x02\x02\u{895}\u{896}\
	\x03\x02\x02\x02\u{896}\u{898}\x03\x02\x02\x02\u{897}\u{895}\x03\x02\x02\
	\x02\u{898}\u{89d}\x05\u{f0}\x79\x02\u{899}\u{89a}\x07\x07\x02\x02\u{89a}\
	\u{89c}\x05\u{f0}\x79\x02\u{89b}\u{899}\x03\x02\x02\x02\u{89c}\u{89f}\x03\
	\x02\x02\x02\u{89d}\u{89b}\x03\x02\x02\x02\u{89d}\u{89e}\x03\x02\x02\x02\
	\u{89e}\u{e7}\x03\x02\x02\x02\u{89f}\u{89d}\x03\x02\x02\x02\u{8a0}\u{8a3}\
	\x07\x50\x02\x02\u{8a1}\u{8a4}\x05\u{f0}\x79\x02\u{8a2}\u{8a4}\x05\u{f2}\
	\x7a\x02\u{8a3}\u{8a1}\x03\x02\x02\x02\u{8a3}\u{8a2}\x03\x02\x02\x02\u{8a3}\
	\u{8a4}\x03\x02\x02\x02\u{8a4}\u{e9}\x03\x02\x02\x02\u{8a5}\u{8a6}\x09\x18\
	\x02\x02\u{8a6}\u{8ac}\x07\u{88}\x02\x02\u{8a7}\u{8a9}\x07\x6e\x02\x02\u{8a8}\
	\u{8aa}\x07\u{88}\x02\x02\u{8a9}\u{8a8}\x03\x02\x02\x02\u{8a9}\u{8aa}\x03\
	\x02\x02\x02\u{8aa}\u{8ac}\x03\x02\x02\x02\u{8ab}\u{8a5}\x03\x02\x02\x02\
	\u{8ab}\u{8a7}\x03\x02\x02\x02\u{8ac}\u{eb}\x03\x02\x02\x02\u{8ad}\u{8b2}\
	\x05\u{f0}\x79\x02\u{8ae}\u{8af}\x09\x05\x02\x02\u{8af}\u{8b1}\x05\u{f0}\
	\x79\x02\u{8b0}\u{8ae}\x03\x02\x02\x02\u{8b1}\u{8b4}\x03\x02\x02\x02\u{8b2}\
	\u{8b0}\x03\x02\x02\x02\u{8b2}\u{8b3}\x03\x02\x02\x02\u{8b3}\u{ed}\x03\x02\
	\x02\x02\u{8b4}\u{8b2}\x03\x02\x02\x02\u{8b5}\u{8ba}\x05\u{f0}\x79\x02\u{8b6}\
	\u{8b7}\x07\x07\x02\x02\u{8b7}\u{8b9}\x05\u{f0}\x79\x02\u{8b8}\u{8b6}\x03\
	\x02\x02\x02\u{8b9}\u{8bc}\x03\x02\x02\x02\u{8ba}\u{8b8}\x03\x02\x02\x02\
	\u{8ba}\u{8bb}\x03\x02\x02\x02\u{8bb}\u{ef}\x03\x02\x02\x02\u{8bc}\u{8ba}\
	\x03\x02\x02\x02\u{8bd}\u{8be}\x09\x19\x02\x02\u{8be}\u{f1}\x03\x02\x02\
	\x02\u{8bf}\u{8c0}\x09\x1a\x02\x02\u{8c0}\u{f3}\x03\x02\x02\x02\u{8c1}\u{8c3}\
	\x05\u{f2}\x7a\x02\u{8c2}\u{8c4}\x05\u{f0}\x79\x02\u{8c3}\u{8c2}\x03\x02\
	\x02\x02\u{8c3}\u{8c4}\x03\x02\x02\x02\u{8c4}\u{f5}\x03\x02\x02\x02\u{8c5}\
	\u{8c9}\x07\u{8a}\x02\x02\u{8c6}\u{8c8}\x07\u{9c}\x02\x02\u{8c7}\u{8c6}\
	\x03\x02\x02\x02\u{8c8}\u{8cb}\x03\x02\x02\x02\u{8c9}\u{8c7}\x03\x02\x02\
	\x02\u{8c9}\u{8ca}\x03\x02\x02\x02\u{8ca}\u{8cc}\x03\x02\x02\x02\u{8cb}\
	\u{8c9}\x03\x02\x02\x02\u{8cc}\u{8cd}\x07\u{9d}\x02\x02\u{8cd}\u{f7}\x03\
	\x02\x02\x02\u{8ce}\u{8d0}\x05\u{f0}\x79\x02\u{8cf}\u{8ce}\x03\x02\x02\x02\
	\u{8cf}\u{8d0}\x03\x02\x02\x02\u{8d0}\u{8d1}\x03\x02\x02\x02\u{8d1}\u{8d2}\
	\x05\u{f6}\x7c\x02\u{8d2}\u{f9}\x03\x02\x02\x02\u{142}\u{109}\u{10b}\u{117}\
	\u{11e}\u{126}\u{12b}\u{12e}\u{133}\u{138}\u{13b}\u{13f}\u{143}\u{146}\u{149}\
	\u{150}\u{15c}\u{160}\u{165}\u{16a}\u{171}\u{174}\u{177}\u{17b}\u{182}\u{184}\
	\u{191}\u{195}\u{199}\u{1a0}\u{1a5}\u{1a8}\u{1ad}\u{1b2}\u{1b6}\u{1b9}\u{1be}\
	\u{1c5}\u{1ca}\u{1d1}\u{1d4}\u{1d8}\u{1e0}\u{1e2}\u{1eb}\u{1ee}\u{1f3}\u{1fa}\
	\u{1fd}\u{205}\u{207}\u{210}\u{215}\u{21c}\u{21f}\u{222}\u{228}\u{230}\u{232}\
	\u{239}\u{23e}\u{240}\u{248}\u{24f}\u{252}\u{25a}\u{25c}\u{264}\u{26a}\u{26d}\
	\u{272}\u{279}\u{27d}\u{289}\u{28e}\u{293}\u{299}\u{29e}\u{2a1}\u{2a4}\u{2a9}\
	\u{2af}\u{2b4}\u{2b7}\u{2bb}\u{2c0}\u{2c6}\u{2cc}\u{2d5}\u{2d9}\u{2db}\u{2de}\
	\u{2e4}\u{2e8}\u{2ed}\u{2f0}\u{2f4}\u{2f8}\u{2fa}\u{2fd}\u{302}\u{304}\u{307}\
	\u{30c}\u{311}\u{314}\u{317}\u{31b}\u{31f}\u{322}\u{324}\u{32e}\u{332}\u{336}\
	\u{33b}\u{341}\u{34b}\u{34f}\u{354}\u{35a}\u{365}\u{367}\u{36f}\u{375}\u{379}\
	\u{37d}\u{384}\u{388}\u{393}\u{396}\u{398}\u{3a2}\u{3a6}\u{3a8}\u{3ad}\u{3b5}\
	\u{3b9}\u{3bb}\u{3bf}\u{3c7}\u{3cb}\u{3cd}\u{3d0}\u{3d5}\u{3da}\u{3e0}\u{3e5}\
	\u{3e9}\u{3ed}\u{3f0}\u{3f4}\u{3f7}\u{3fc}\u{403}\u{40b}\u{412}\u{416}\u{41e}\
	\u{427}\u{42c}\u{431}\u{439}\u{442}\u{44a}\u{454}\u{45e}\u{46b}\u{474}\u{478}\
	\u{480}\u{485}\u{488}\u{4a7}\u{4de}\u{4e5}\u{4e7}\u{4f2}\u{4f4}\u{50a}\u{532}\
	\u{534}\u{544}\u{547}\u{549}\u{54d}\u{562}\u{564}\u{56d}\u{572}\u{574}\u{579}\
	\u{57e}\u{582}\u{587}\u{58a}\u{594}\u{596}\u{5b8}\u{5c1}\u{5cb}\u{5cf}\u{5d4}\
	\u{5d9}\u{5e1}\u{5e5}\u{5e9}\u{5ee}\u{5fc}\u{600}\u{60c}\u{610}\u{614}\u{617}\
	\u{61f}\u{62a}\u{62f}\u{634}\u{63e}\u{648}\u{64c}\u{654}\u{658}\u{662}\u{666}\
	\u{66a}\u{672}\u{674}\u{680}\u{689}\u{693}\u{698}\u{69a}\u{6a2}\u{6ab}\u{6b0}\
	\u{6b2}\u{6b7}\u{6c0}\u{6c5}\u{6c9}\u{6cc}\u{6d1}\u{6d6}\u{6dd}\u{6e4}\u{6e8}\
	\u{6ef}\u{6f1}\u{6f9}\u{701}\u{70b}\u{70f}\u{711}\u{717}\u{71e}\u{725}\u{72f}\
	\u{737}\u{73e}\u{742}\u{748}\u{754}\u{756}\u{763}\u{769}\u{76f}\u{772}\u{777}\
	\u{77c}\u{78b}\u{78e}\u{799}\u{79d}\u{7a2}\u{7aa}\u{7ae}\u{7b3}\u{7bb}\u{7bf}\
	\u{7c3}\u{7c7}\u{7ca}\u{7cd}\u{7d4}\u{7d7}\u{7de}\u{7e2}\u{7e7}\u{7e9}\u{7ef}\
	\u{7fe}\u{808}\u{80b}\u{814}\u{817}\u{823}\u{826}\u{830}\u{834}\u{836}\u{83f}\
	\u{843}\u{845}\u{848}\u{858}\u{85e}\u{867}\u{878}\u{882}\u{887}\u{88d}\u{895}\
	\u{89d}\u{8a3}\u{8a9}\u{8ab}\u{8b2}\u{8ba}\u{8c3}\u{8c9}\u{8cf}";
