// Generated from ValkyrieAntlr.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use super::{valkyrieantlrlistener::*, valkyrieantlrvisitor::*};
use antlr_rust::{
    atn::{ATN, INVALID_ALT},
    atn_deserializer::ATNDeserializer,
    dfa::DFA,
    error_strategy::{DefaultErrorStrategy, ErrorStrategy},
    errors::*,
    int_stream::EOF,
    parser::{BaseParser, Parser, ParserNodeType, ParserRecog},
    parser_atn_simulator::ParserATNSimulator,
    parser_rule_context::{cast, cast_mut, BaseParserRuleContext, ParserRuleContext},
    recognizer::{Actions, Recognizer},
    rule_context::{BaseRuleContext, CustomRuleContext, RuleContext},
    token::{OwningToken, Token, TOKEN_EOF},
    token_factory::{CommonTokenFactory, TokenAware, TokenFactory},
    token_stream::TokenStream,
    tree::*,
    vocabulary::{Vocabulary, VocabularyImpl},
    PredictionContextCache, TokenSource,
};

use antlr_rust::{lazy_static, TidAble, TidExt};

use std::{
    any::{Any, TypeId},
    borrow::{Borrow, BorrowMut},
    cell::RefCell,
    convert::TryFrom,
    marker::PhantomData,
    ops::{Deref, DerefMut},
    rc::Rc,
    sync::Arc,
};

pub const T__0: isize = 1;
pub const DOT: isize = 2;
pub const COMMA: isize = 3;
pub const SEMICOLON: isize = 4;
pub const FAKE_COLON: isize = 5;
pub const OP_PROPORTION: isize = 6;
pub const COLON: isize = 7;
pub const PARENTHESES_L: isize = 8;
pub const PARENTHESES_R: isize = 9;
pub const BRACKET_L: isize = 10;
pub const BRACKET_R: isize = 11;
pub const BRACE_L: isize = 12;
pub const BRACE_R: isize = 13;
pub const GENERIC_L: isize = 14;
pub const GENERIC_R: isize = 15;
pub const OFFSET_L: isize = 16;
pub const OFFSET_R: isize = 17;
pub const RANGE_L: isize = 18;
pub const RANGE_R: isize = 19;
pub const CEILING_L: isize = 20;
pub const CEILING_R: isize = 21;
pub const FLOOR_L: isize = 22;
pub const FLOOR_R: isize = 23;
pub const COLLECTION_L: isize = 24;
pub const COLLECTION_R: isize = 25;
pub const OP_ADD: isize = 26;
pub const OP_SUB: isize = 27;
pub const OP_INC: isize = 28;
pub const OP_DEC: isize = 29;
pub const OP_MUL: isize = 30;
pub const OP_DIV: isize = 31;
pub const OP_REM: isize = 32;
pub const OP_DIV_REM: isize = 33;
pub const OP_LAST: isize = 34;
pub const OP_EQ: isize = 35;
pub const OP_NE: isize = 36;
pub const OP_NEE: isize = 37;
pub const OP_EEE: isize = 38;
pub const OP_LEQ: isize = 39;
pub const OP_LLE: isize = 40;
pub const OP_LLL: isize = 41;
pub const OP_LL: isize = 42;
pub const OP_LT: isize = 43;
pub const OP_GEQ: isize = 44;
pub const OP_GGE: isize = 45;
pub const OP_GGG: isize = 46;
pub const OP_GG: isize = 47;
pub const OP_GT: isize = 48;
pub const OP_LEFT: isize = 49;
pub const OP_ARROW: isize = 50;
pub const OP_ARROW2: isize = 51;
pub const OP_ARROW3: isize = 52;
pub const OP_ASSIGN: isize = 53;
pub const OP_BIND: isize = 54;
pub const OP_MAY_ASSIGN: isize = 55;
pub const OP_ADD_ASSIGN: isize = 56;
pub const OP_SUB_ASSIGN: isize = 57;
pub const OP_MUL_ASSIGN: isize = 58;
pub const OP_DIV_ASSIGN: isize = 59;
pub const LOGIC_NOT: isize = 60;
pub const LOGIC_AND: isize = 61;
pub const LOGIC_XAND: isize = 62;
pub const LOGIC_NAND: isize = 63;
pub const LOGIC_OR: isize = 64;
pub const LOGIC_XOR: isize = 65;
pub const LOGIC_NOR: isize = 66;
pub const SET_INTERSECTION: isize = 67;
pub const SET_UNION: isize = 68;
pub const OP_AND: isize = 69;
pub const OP_OR: isize = 70;
pub const OP_IMPL: isize = 71;
pub const OP_IFF: isize = 72;
pub const OP_MAP: isize = 73;
pub const OP_APPLY2: isize = 74;
pub const OP_APPLY3: isize = 75;
pub const OP_AT: isize = 76;
pub const OP_HASH: isize = 77;
pub const LAMBDA_SLOT: isize = 78;
pub const MACRO_SLOT: isize = 79;
pub const OP_UNIMPLEMENTED: isize = 80;
pub const OP_OR_DEFAULT: isize = 81;
pub const OP_OR_ELSE: isize = 82;
pub const OP_AND_THEN: isize = 83;
pub const OP_NOT: isize = 84;
pub const KW_NOT: isize = 85;
pub const OP_IN: isize = 86;
pub const KW_IN: isize = 87;
pub const OP_NOT_IN: isize = 88;
pub const OP_CONTINUES: isize = 89;
pub const KW_IS: isize = 90;
pub const OP_IS: isize = 91;
pub const OP_IS_NOT: isize = 92;
pub const KW_AS: isize = 93;
pub const OP_DOT3: isize = 94;
pub const OP_DOT2: isize = 95;
pub const OP_UNTIL: isize = 96;
pub const OP_POW: isize = 97;
pub const OP_INVERSE: isize = 98;
pub const OP_ROOT2: isize = 99;
pub const OP_ROOT3: isize = 100;
pub const OP_ROOT4: isize = 101;
pub const OP_TEMPERATURE: isize = 102;
pub const OP_TRANSPOSE: isize = 103;
pub const OP_PERCENT: isize = 104;
pub const OP_REFERENCE: isize = 105;
pub const OP_LABEL: isize = 106;
pub const KW_NAMESPACE: isize = 107;
pub const KW_IMPORT: isize = 108;
pub const KW_EXTENSION: isize = 109;
pub const KW_CLASS: isize = 110;
pub const KW_TRAIT: isize = 111;
pub const KW_UNION: isize = 112;
pub const KW_BITFLAGS: isize = 113;
pub const KW_TYPE: isize = 114;
pub const KW_TEMPLATE: isize = 115;
pub const KW_EXTENDS: isize = 116;
pub const KW_IMPLEMENTS: isize = 117;
pub const KW_WHILE: isize = 118;
pub const KW_FOR: isize = 119;
pub const KW_LET: isize = 120;
pub const KW_WITCH: isize = 121;
pub const KW_NEW: isize = 122;
pub const KW_OBJECT: isize = 123;
pub const KW_LAMBDA: isize = 124;
pub const KW_FUNCTION: isize = 125;
pub const KW_TRY: isize = 126;
pub const KW_MATCH: isize = 127;
pub const KW_CATCH: isize = 128;
pub const KW_WITH: isize = 129;
pub const KW_CASE: isize = 130;
pub const KW_WHEN: isize = 131;
pub const INTEGER: isize = 132;
pub const DECIMAL: isize = 133;
pub const STRING_SINGLE: isize = 134;
pub const STRING_DOUBLE: isize = 135;
pub const STRING_BLOCK: isize = 136;
pub const KW_IF: isize = 137;
pub const KW_ELSE: isize = 138;
pub const KW_OTHERWISE: isize = 139;
pub const RETURN: isize = 140;
pub const RESUME: isize = 141;
pub const YIELD: isize = 142;
pub const BREAK: isize = 143;
pub const CONTINUE: isize = 144;
pub const RAISE: isize = 145;
pub const SPECIAL: isize = 146;
pub const RAW_ID: isize = 147;
pub const UNICODE_ID: isize = 148;
pub const LINE_COMMENT: isize = 149;
pub const BLOCK_COMMENT: isize = 150;
pub const WHITE_SPACE: isize = 151;
pub const ERROR_CHARACTAR: isize = 152;
pub const RULE_program: usize = 0;
pub const RULE_eos: usize = 1;
pub const RULE_eos_free: usize = 2;
pub const RULE_define_namespace: usize = 3;
pub const RULE_import_statement: usize = 4;
pub const RULE_import_as: usize = 5;
pub const RULE_import_term: usize = 6;
pub const RULE_import_name: usize = 7;
pub const RULE_import_block: usize = 8;
pub const RULE_define_extension: usize = 9;
pub const RULE_define_class: usize = 10;
pub const RULE_class_block: usize = 11;
pub const RULE_class_inherit: usize = 12;
pub const RULE_class_inherit_item: usize = 13;
pub const RULE_class_field: usize = 14;
pub const RULE_class_method: usize = 15;
pub const RULE_class_dsl: usize = 16;
pub const RULE_define_trait: usize = 17;
pub const RULE_trait_block: usize = 18;
pub const RULE_define_trait_type: usize = 19;
pub const RULE_define_extends: usize = 20;
pub const RULE_extends_block: usize = 21;
pub const RULE_with_implements: usize = 22;
pub const RULE_define_union: usize = 23;
pub const RULE_base_layout: usize = 24;
pub const RULE_union_block: usize = 25;
pub const RULE_define_variant: usize = 26;
pub const RULE_variant_block: usize = 27;
pub const RULE_define_bitflags: usize = 28;
pub const RULE_bitflags_block: usize = 29;
pub const RULE_bitflags_item: usize = 30;
pub const RULE_define_function: usize = 31;
pub const RULE_function_parameters: usize = 32;
pub const RULE_parameter_item: usize = 33;
pub const RULE_parameter_default: usize = 34;
pub const RULE_function_call: usize = 35;
pub const RULE_tuple_call_body: usize = 36;
pub const RULE_tuple_call_item: usize = 37;
pub const RULE_define_lambda: usize = 38;
pub const RULE_function_block: usize = 39;
pub const RULE_let_binding: usize = 40;
pub const RULE_let_pattern: usize = 41;
pub const RULE_let_pattern_plain: usize = 42;
pub const RULE_let_pattern_tuple: usize = 43;
pub const RULE_let_pattern_item: usize = 44;
pub const RULE_define_type: usize = 45;
pub const RULE_type_hint: usize = 46;
pub const RULE_effect_hint: usize = 47;
pub const RULE_if_statement: usize = 48;
pub const RULE_guard_statement: usize = 49;
pub const RULE_else_if_statement: usize = 50;
pub const RULE_loop_statement: usize = 51;
pub const RULE_if_guard: usize = 52;
pub const RULE_expression_root: usize = 53;
pub const RULE_expression: usize = 54;
pub const RULE_inline_expression: usize = 55;
pub const RULE_type_expression: usize = 56;
pub const RULE_atomic: usize = 57;
pub const RULE_control_expression: usize = 58;
pub const RULE_op_prefix: usize = 59;
pub const RULE_op_suffix: usize = 60;
pub const RULE_op_compare: usize = 61;
pub const RULE_op_pattern: usize = 62;
pub const RULE_infix_map: usize = 63;
pub const RULE_infix_pow: usize = 64;
pub const RULE_infix_range: usize = 65;
pub const RULE_infix_arrows: usize = 66;
pub const RULE_op_multiple: usize = 67;
pub const RULE_op_plus: usize = 68;
pub const RULE_op_logic: usize = 69;
pub const RULE_op_pipeline: usize = 70;
pub const RULE_op_assign: usize = 71;
pub const RULE_infix_is: usize = 72;
pub const RULE_infix_as: usize = 73;
pub const RULE_infix_in: usize = 74;
pub const RULE_define_generic: usize = 75;
pub const RULE_generic_item: usize = 76;
pub const RULE_generic_call: usize = 77;
pub const RULE_generic_call_in_type: usize = 78;
pub const RULE_generic_pair: usize = 79;
pub const RULE_define_label: usize = 80;
pub const RULE_template_call: usize = 81;
pub const RULE_template_block: usize = 82;
pub const RULE_template_statements: usize = 83;
pub const RULE_where_block: usize = 84;
pub const RULE_where_bound: usize = 85;
pub const RULE_require_block: usize = 86;
pub const RULE_macro_call: usize = 87;
pub const RULE_annotation: usize = 88;
pub const RULE_annotation_call_item: usize = 89;
pub const RULE_try_statement: usize = 90;
pub const RULE_match_statement: usize = 91;
pub const RULE_match_block: usize = 92;
pub const RULE_match_terms: usize = 93;
pub const RULE_match_case_block: usize = 94;
pub const RULE_case_pattern: usize = 95;
pub const RULE_case_pattern_item: usize = 96;
pub const RULE_case_pattern_tuple: usize = 97;
pub const RULE_object_statement: usize = 98;
pub const RULE_new_statement: usize = 99;
pub const RULE_new_body: usize = 100;
pub const RULE_new_block: usize = 101;
pub const RULE_tuple_literal: usize = 102;
pub const RULE_collection_pair: usize = 103;
pub const RULE_slice_call: usize = 104;
pub const RULE_range_literal: usize = 105;
pub const RULE_range_axis: usize = 106;
pub const RULE_modifiers: usize = 107;
pub const RULE_modified_identifier: usize = 108;
pub const RULE_modified_namepath: usize = 109;
pub const RULE_lambda_name: usize = 110;
pub const RULE_output_name: usize = 111;
pub const RULE_namepath_free: usize = 112;
pub const RULE_namepath: usize = 113;
pub const RULE_identifier: usize = 114;
pub const RULE_number: usize = 115;
pub const RULE_number_literal: usize = 116;
pub const RULE_string: usize = 117;
pub const RULE_string_literal: usize = 118;
pub const ruleNames: [&'static str; 119] = [
    "program",
    "eos",
    "eos_free",
    "define_namespace",
    "import_statement",
    "import_as",
    "import_term",
    "import_name",
    "import_block",
    "define_extension",
    "define_class",
    "class_block",
    "class_inherit",
    "class_inherit_item",
    "class_field",
    "class_method",
    "class_dsl",
    "define_trait",
    "trait_block",
    "define_trait_type",
    "define_extends",
    "extends_block",
    "with_implements",
    "define_union",
    "base_layout",
    "union_block",
    "define_variant",
    "variant_block",
    "define_bitflags",
    "bitflags_block",
    "bitflags_item",
    "define_function",
    "function_parameters",
    "parameter_item",
    "parameter_default",
    "function_call",
    "tuple_call_body",
    "tuple_call_item",
    "define_lambda",
    "function_block",
    "let_binding",
    "let_pattern",
    "let_pattern_plain",
    "let_pattern_tuple",
    "let_pattern_item",
    "define_type",
    "type_hint",
    "effect_hint",
    "if_statement",
    "guard_statement",
    "else_if_statement",
    "loop_statement",
    "if_guard",
    "expression_root",
    "expression",
    "inline_expression",
    "type_expression",
    "atomic",
    "control_expression",
    "op_prefix",
    "op_suffix",
    "op_compare",
    "op_pattern",
    "infix_map",
    "infix_pow",
    "infix_range",
    "infix_arrows",
    "op_multiple",
    "op_plus",
    "op_logic",
    "op_pipeline",
    "op_assign",
    "infix_is",
    "infix_as",
    "infix_in",
    "define_generic",
    "generic_item",
    "generic_call",
    "generic_call_in_type",
    "generic_pair",
    "define_label",
    "template_call",
    "template_block",
    "template_statements",
    "where_block",
    "where_bound",
    "require_block",
    "macro_call",
    "annotation",
    "annotation_call_item",
    "try_statement",
    "match_statement",
    "match_block",
    "match_terms",
    "match_case_block",
    "case_pattern",
    "case_pattern_item",
    "case_pattern_tuple",
    "object_statement",
    "new_statement",
    "new_body",
    "new_block",
    "tuple_literal",
    "collection_pair",
    "slice_call",
    "range_literal",
    "range_axis",
    "modifiers",
    "modified_identifier",
    "modified_namepath",
    "lambda_name",
    "output_name",
    "namepath_free",
    "namepath",
    "identifier",
    "number",
    "number_literal",
    "string",
    "string_literal",
];

pub const _LITERAL_NAMES: [Option<&'static str>; 146] = [
    None,
    Some("'where'"),
    Some("'.'"),
    None,
    Some("';'"),
    None,
    None,
    None,
    Some("'('"),
    Some("')'"),
    Some("'['"),
    Some("']'"),
    Some("'{'"),
    Some("'}'"),
    Some("'\u{27E8}'"),
    Some("'\u{27E9}'"),
    Some("'\u{2045}'"),
    Some("'\u{2046}'"),
    Some("'\u{27E6}'"),
    Some("'\u{27E7}'"),
    Some("'\u{2308}'"),
    Some("'\u{2309}'"),
    Some("'\u{230A}'"),
    Some("'\u{230B}'"),
    Some("'\u{2983}'"),
    Some("'\u{2984}'"),
    Some("'+'"),
    Some("'-'"),
    Some("'++'"),
    Some("'--'"),
    Some("'*'"),
    None,
    None,
    None,
    Some("'%%'"),
    Some("'=='"),
    None,
    None,
    None,
    None,
    Some("'<<='"),
    None,
    None,
    Some("'<'"),
    None,
    Some("'>>='"),
    None,
    None,
    Some("'>'"),
    None,
    None,
    None,
    Some("'==>'"),
    Some("'='"),
    None,
    Some("'?='"),
    Some("'+='"),
    Some("'-='"),
    Some("'*='"),
    Some("'/='"),
    Some("'\u{00AC}'"),
    None,
    Some("'\u{2A5F}'"),
    Some("'\u{22BC}'"),
    None,
    Some("'\u{22BB}'"),
    Some("'\u{22BD}'"),
    Some("'\u{2229}'"),
    Some("'\u{222A}'"),
    Some("'&'"),
    Some("'|'"),
    Some("'\u{203D}'"),
    Some("'\u{21D4}'"),
    None,
    None,
    None,
    Some("'@'"),
    None,
    None,
    None,
    None,
    Some("'??'"),
    Some("'?:'"),
    Some("'?'"),
    Some("'!'"),
    Some("'not'"),
    None,
    Some("'in'"),
    Some("'\u{2209}'"),
    None,
    Some("'is'"),
    None,
    None,
    None,
    None,
    None,
    None,
    Some("'^'"),
    Some("'\u{215F}'"),
    Some("'\u{221A}'"),
    Some("'\u{221B}'"),
    Some("'\u{221C}'"),
    None,
    None,
    None,
    Some("'\u{203B}'"),
    Some("'\u{00B6}'"),
    None,
    None,
    Some("'extension'"),
    None,
    None,
    Some("'union'"),
    Some("'flags'"),
    Some("'type'"),
    Some("'template'"),
    Some("'extends'"),
    Some("'implements'"),
    None,
    Some("'for'"),
    Some("'let'"),
    Some("'which'"),
    Some("'new'"),
    Some("'object'"),
    Some("'lambda'"),
    None,
    Some("'try'"),
    Some("'match'"),
    Some("'catch'"),
    Some("'with'"),
    Some("'case'"),
    Some("'when'"),
    None,
    None,
    None,
    None,
    None,
    Some("'if'"),
    Some("'else'"),
    Some("'otherwise'"),
    Some("'return'"),
    Some("'resume'"),
    Some("'yield'"),
    Some("'break'"),
    Some("'continue'"),
    Some("'raise'"),
];
pub const _SYMBOLIC_NAMES: [Option<&'static str>; 153] = [
    None,
    None,
    Some("DOT"),
    Some("COMMA"),
    Some("SEMICOLON"),
    Some("FAKE_COLON"),
    Some("OP_PROPORTION"),
    Some("COLON"),
    Some("PARENTHESES_L"),
    Some("PARENTHESES_R"),
    Some("BRACKET_L"),
    Some("BRACKET_R"),
    Some("BRACE_L"),
    Some("BRACE_R"),
    Some("GENERIC_L"),
    Some("GENERIC_R"),
    Some("OFFSET_L"),
    Some("OFFSET_R"),
    Some("RANGE_L"),
    Some("RANGE_R"),
    Some("CEILING_L"),
    Some("CEILING_R"),
    Some("FLOOR_L"),
    Some("FLOOR_R"),
    Some("COLLECTION_L"),
    Some("COLLECTION_R"),
    Some("OP_ADD"),
    Some("OP_SUB"),
    Some("OP_INC"),
    Some("OP_DEC"),
    Some("OP_MUL"),
    Some("OP_DIV"),
    Some("OP_REM"),
    Some("OP_DIV_REM"),
    Some("OP_LAST"),
    Some("OP_EQ"),
    Some("OP_NE"),
    Some("OP_NEE"),
    Some("OP_EEE"),
    Some("OP_LEQ"),
    Some("OP_LLE"),
    Some("OP_LLL"),
    Some("OP_LL"),
    Some("OP_LT"),
    Some("OP_GEQ"),
    Some("OP_GGE"),
    Some("OP_GGG"),
    Some("OP_GG"),
    Some("OP_GT"),
    Some("OP_LEFT"),
    Some("OP_ARROW"),
    Some("OP_ARROW2"),
    Some("OP_ARROW3"),
    Some("OP_ASSIGN"),
    Some("OP_BIND"),
    Some("OP_MAY_ASSIGN"),
    Some("OP_ADD_ASSIGN"),
    Some("OP_SUB_ASSIGN"),
    Some("OP_MUL_ASSIGN"),
    Some("OP_DIV_ASSIGN"),
    Some("LOGIC_NOT"),
    Some("LOGIC_AND"),
    Some("LOGIC_XAND"),
    Some("LOGIC_NAND"),
    Some("LOGIC_OR"),
    Some("LOGIC_XOR"),
    Some("LOGIC_NOR"),
    Some("SET_INTERSECTION"),
    Some("SET_UNION"),
    Some("OP_AND"),
    Some("OP_OR"),
    Some("OP_IMPL"),
    Some("OP_IFF"),
    Some("OP_MAP"),
    Some("OP_APPLY2"),
    Some("OP_APPLY3"),
    Some("OP_AT"),
    Some("OP_HASH"),
    Some("LAMBDA_SLOT"),
    Some("MACRO_SLOT"),
    Some("OP_UNIMPLEMENTED"),
    Some("OP_OR_DEFAULT"),
    Some("OP_OR_ELSE"),
    Some("OP_AND_THEN"),
    Some("OP_NOT"),
    Some("KW_NOT"),
    Some("OP_IN"),
    Some("KW_IN"),
    Some("OP_NOT_IN"),
    Some("OP_CONTINUES"),
    Some("KW_IS"),
    Some("OP_IS"),
    Some("OP_IS_NOT"),
    Some("KW_AS"),
    Some("OP_DOT3"),
    Some("OP_DOT2"),
    Some("OP_UNTIL"),
    Some("OP_POW"),
    Some("OP_INVERSE"),
    Some("OP_ROOT2"),
    Some("OP_ROOT3"),
    Some("OP_ROOT4"),
    Some("OP_TEMPERATURE"),
    Some("OP_TRANSPOSE"),
    Some("OP_PERCENT"),
    Some("OP_REFERENCE"),
    Some("OP_LABEL"),
    Some("KW_NAMESPACE"),
    Some("KW_IMPORT"),
    Some("KW_EXTENSION"),
    Some("KW_CLASS"),
    Some("KW_TRAIT"),
    Some("KW_UNION"),
    Some("KW_BITFLAGS"),
    Some("KW_TYPE"),
    Some("KW_TEMPLATE"),
    Some("KW_EXTENDS"),
    Some("KW_IMPLEMENTS"),
    Some("KW_WHILE"),
    Some("KW_FOR"),
    Some("KW_LET"),
    Some("KW_WITCH"),
    Some("KW_NEW"),
    Some("KW_OBJECT"),
    Some("KW_LAMBDA"),
    Some("KW_FUNCTION"),
    Some("KW_TRY"),
    Some("KW_MATCH"),
    Some("KW_CATCH"),
    Some("KW_WITH"),
    Some("KW_CASE"),
    Some("KW_WHEN"),
    Some("INTEGER"),
    Some("DECIMAL"),
    Some("STRING_SINGLE"),
    Some("STRING_DOUBLE"),
    Some("STRING_BLOCK"),
    Some("KW_IF"),
    Some("KW_ELSE"),
    Some("KW_OTHERWISE"),
    Some("RETURN"),
    Some("RESUME"),
    Some("YIELD"),
    Some("BREAK"),
    Some("CONTINUE"),
    Some("RAISE"),
    Some("SPECIAL"),
    Some("RAW_ID"),
    Some("UNICODE_ID"),
    Some("LINE_COMMENT"),
    Some("BLOCK_COMMENT"),
    Some("WHITE_SPACE"),
    Some("ERROR_CHARACTAR"),
];
lazy_static! {
    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
    static ref VOCABULARY: Box<dyn Vocabulary> =
        Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
}

type BaseParserType<'input, I> = BaseParser<
    'input,
    ValkyrieAntlrParserExt<'input>,
    I,
    ValkyrieAntlrParserContextType,
    dyn ValkyrieAntlrListener<'input> + 'input,
>;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type ValkyrieAntlrTreeWalker<'input, 'a> =
    ParseTreeWalker<'input, 'a, ValkyrieAntlrParserContextType, dyn ValkyrieAntlrListener<'input> + 'a>;

/// Parser for ValkyrieAntlr grammar
pub struct ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    base: BaseParserType<'input, I>,
    interpreter: Arc<ParserATNSimulator>,
    _shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn get_serialized_atn() -> &'static str {
        _serializedATN
    }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
        antlr_rust::recognizer::check_version("0", "3");
        let interpreter =
            Arc::new(ParserATNSimulator::new(_ATN.clone(), _decision_to_DFA.clone(), _shared_context_cache.clone()));
        Self {
            base: BaseParser::new_base_parser(
                input,
                Arc::clone(&interpreter),
                ValkyrieAntlrParserExt { _pd: Default::default() },
            ),
            interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }
}

type DynStrategy<'input, I> = Box<dyn ErrorStrategy<'input, BaseParserType<'input, I>> + 'input>;

impl<'input, I> ValkyrieAntlrParser<'input, I, DynStrategy<'input, I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self {
        Self::with_strategy(input, Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    pub fn new(input: I) -> Self {
        Self::with_strategy(input, DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for ValkyrieAntlrParser
pub trait ValkyrieAntlrParserContext<'input>:
    for<'x> Listenable<dyn ValkyrieAntlrListener<'input> + 'x>
    + for<'x> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'x>
    + ParserRuleContext<'input, TF = LocalTokenFactory<'input>, Ctx = ValkyrieAntlrParserContextType>
{
}

antlr_rust::coerce_from! { 'input : ValkyrieAntlrParserContext<'input> }

impl<'input, 'x, T> VisitableDyn<T> for dyn ValkyrieAntlrParserContext<'input> + 'input
where
    T: ValkyrieAntlrVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn ValkyrieAntlrVisitor<'input> + 'x))
    }
}

impl<'input> ValkyrieAntlrParserContext<'input> for TerminalNode<'input, ValkyrieAntlrParserContextType> {}
impl<'input> ValkyrieAntlrParserContext<'input> for ErrorNode<'input, ValkyrieAntlrParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn ValkyrieAntlrListener<'input> + 'input }

pub struct ValkyrieAntlrParserContextType;
antlr_rust::tid! {ValkyrieAntlrParserContextType}

impl<'input> ParserNodeType<'input> for ValkyrieAntlrParserContextType {
    type TF = LocalTokenFactory<'input>;
    type Type = dyn ValkyrieAntlrParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    type Target = BaseParserType<'input, I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct ValkyrieAntlrParserExt<'input> {
    _pd: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserExt<'input> {}
antlr_rust::tid! { ValkyrieAntlrParserExt<'a> }

impl<'input> TokenAware<'input> for ValkyrieAntlrParserExt<'input> {
    type TF = LocalTokenFactory<'input>;
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    ParserRecog<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
}

impl<'input, I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>>
    Actions<'input, BaseParserType<'input, I>> for ValkyrieAntlrParserExt<'input>
{
    fn get_grammar_file_name(&self) -> &str {
        "ValkyrieAntlr.g4"
    }

    fn get_rule_names(&self) -> &[&str] {
        &ruleNames
    }

    fn get_vocabulary(&self) -> &dyn Vocabulary {
        &**VOCABULARY
    }
    fn sempred(
        _localctx: Option<&(dyn ValkyrieAntlrParserContext<'input> + 'input)>,
        rule_index: isize,
        pred_index: isize,
        recog: &mut BaseParserType<'input, I>,
    ) -> bool {
        match rule_index {
            54 => ValkyrieAntlrParser::<'input, I, _>::expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            55 => ValkyrieAntlrParser::<'input, I, _>::inline_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            56 => ValkyrieAntlrParser::<'input, I, _>::type_expression_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            95 => ValkyrieAntlrParser::<'input, I, _>::case_pattern_sempred(
                _localctx.and_then(|x| x.downcast_ref()),
                pred_index,
                recog,
            ),
            _ => true,
        }
    }
}

impl<'input, I> ValkyrieAntlrParser<'input, I, DefaultErrorStrategy<'input, ValkyrieAntlrParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
{
    fn expression_sempred(
        _localctx: Option<&ExpressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            0 => recog.precpred(None, 29),
            1 => recog.precpred(None, 28),
            2 => recog.precpred(None, 27),
            3 => recog.precpred(None, 26),
            4 => recog.precpred(None, 25),
            5 => recog.precpred(None, 24),
            6 => recog.precpred(None, 23),
            7 => recog.precpred(None, 20),
            8 => recog.precpred(None, 18),
            9 => recog.precpred(None, 17),
            10 => recog.precpred(None, 36),
            11 => recog.precpred(None, 35),
            12 => recog.precpred(None, 34),
            13 => recog.precpred(None, 33),
            14 => recog.precpred(None, 32),
            15 => recog.precpred(None, 31),
            16 => recog.precpred(None, 22),
            17 => recog.precpred(None, 21),
            18 => recog.precpred(None, 19),
            _ => true,
        }
    }
    fn inline_expression_sempred(
        _localctx: Option<&Inline_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            19 => recog.precpred(None, 14),
            20 => recog.precpred(None, 13),
            21 => recog.precpred(None, 12),
            22 => recog.precpred(None, 11),
            23 => recog.precpred(None, 10),
            24 => recog.precpred(None, 7),
            25 => recog.precpred(None, 17),
            26 => recog.precpred(None, 16),
            27 => recog.precpred(None, 15),
            28 => recog.precpred(None, 9),
            29 => recog.precpred(None, 8),
            _ => true,
        }
    }
    fn type_expression_sempred(
        _localctx: Option<&Type_expressionContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            30 => recog.precpred(None, 6),
            31 => recog.precpred(None, 5),
            32 => recog.precpred(None, 4),
            33 => recog.precpred(None, 7),
            34 => recog.precpred(None, 3),
            _ => true,
        }
    }
    fn case_pattern_sempred(
        _localctx: Option<&Case_patternContext<'input>>,
        pred_index: isize,
        recog: &mut <Self as Deref>::Target,
    ) -> bool {
        match pred_index {
            35 => recog.precpred(None, 3),
            36 => recog.precpred(None, 2),
            _ => true,
        }
    }
}
//------------------- program ----------------
pub type ProgramContextAll<'input> = ProgramContext<'input>;

pub type ProgramContext<'input> = BaseParserRuleContext<'input, ProgramContextExt<'input>>;

#[derive(Clone)]
pub struct ProgramContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ProgramContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ProgramContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_program(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_program(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ProgramContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_program(self);
    }
}

impl<'input> CustomRuleContext<'input> for ProgramContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_program
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_program }
}
antlr_rust::tid! {ProgramContextExt<'a>}

impl<'input> ProgramContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ProgramContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, ProgramContextExt { ph: PhantomData }))
    }
}

pub trait ProgramContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ProgramContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token EOF
    /// Returns `None` if there is no child corresponding to token EOF
    fn EOF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(EOF, 0)
    }
    fn define_namespace_all(&self) -> Vec<Rc<Define_namespaceContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_namespace(&self, i: usize) -> Option<Rc<Define_namespaceContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn import_statement_all(&self) -> Vec<Rc<Import_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn import_statement(&self, i: usize) -> Option<Rc<Import_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_extension_all(&self) -> Vec<Rc<Define_extensionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_extension(&self, i: usize) -> Option<Rc<Define_extensionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_class_all(&self) -> Vec<Rc<Define_classContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_class(&self, i: usize) -> Option<Rc<Define_classContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_union_all(&self) -> Vec<Rc<Define_unionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_union(&self, i: usize) -> Option<Rc<Define_unionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_bitflags_all(&self) -> Vec<Rc<Define_bitflagsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_bitflags(&self, i: usize) -> Option<Rc<Define_bitflagsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_trait_all(&self) -> Vec<Rc<Define_traitContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait(&self, i: usize) -> Option<Rc<Define_traitContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_extends_all(&self) -> Vec<Rc<Define_extendsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_extends(&self, i: usize) -> Option<Rc<Define_extendsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_function_all(&self) -> Vec<Rc<Define_functionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_function(&self, i: usize) -> Option<Rc<Define_functionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_type_all(&self) -> Vec<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_type(&self, i: usize) -> Option<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn let_binding_all(&self) -> Vec<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_binding(&self, i: usize) -> Option<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn loop_statement_all(&self) -> Vec<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn loop_statement(&self, i: usize) -> Option<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn guard_statement_all(&self) -> Vec<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn guard_statement(&self, i: usize) -> Option<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn expression_root_all(&self) -> Vec<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression_root(&self, i: usize) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_all(&self) -> Vec<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos(&self, i: usize) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ProgramContextAttrs<'input> for ProgramContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn program(&mut self) -> Result<Rc<ProgramContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ProgramContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_program);
        let mut _localctx: Rc<ProgramContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(255);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la - 4) & !0x3f) == 0
                    && ((1usize << (_la - 4))
                        & ((1usize << (SEMICOLON - 4))
                            | (1usize << (FAKE_COLON - 4))
                            | (1usize << (PARENTHESES_L - 4))
                            | (1usize << (BRACKET_L - 4))
                            | (1usize << (BRACE_L - 4))
                            | (1usize << (OFFSET_L - 4))
                            | (1usize << (CEILING_L - 4))
                            | (1usize << (FLOOR_L - 4))
                            | (1usize << (OP_ADD - 4))
                            | (1usize << (OP_SUB - 4))
                            | (1usize << (OP_MUL - 4))
                            | (1usize << (OP_REM - 4))
                            | (1usize << (OP_LAST - 4))))
                        != 0)
                    || (((_la - 69) & !0x3f) == 0
                        && ((1usize << (_la - 69))
                            & ((1usize << (OP_AND - 69))
                                | (1usize << (OP_AT - 69))
                                | (1usize << (OP_HASH - 69))
                                | (1usize << (LAMBDA_SLOT - 69))
                                | (1usize << (OP_NOT - 69))
                                | (1usize << (OP_DOT3 - 69))
                                | (1usize << (OP_DOT2 - 69))
                                | (1usize << (OP_INVERSE - 69))
                                | (1usize << (OP_ROOT2 - 69))
                                | (1usize << (OP_ROOT3 - 69))))
                            != 0)
                    || (((_la - 101) & !0x3f) == 0
                        && ((1usize << (_la - 101))
                            & ((1usize << (OP_ROOT4 - 101))
                                | (1usize << (OP_REFERENCE - 101))
                                | (1usize << (OP_LABEL - 101))
                                | (1usize << (KW_NAMESPACE - 101))
                                | (1usize << (KW_IMPORT - 101))
                                | (1usize << (KW_EXTENSION - 101))
                                | (1usize << (KW_CLASS - 101))
                                | (1usize << (KW_TRAIT - 101))
                                | (1usize << (KW_UNION - 101))
                                | (1usize << (KW_BITFLAGS - 101))
                                | (1usize << (KW_TYPE - 101))
                                | (1usize << (KW_TEMPLATE - 101))
                                | (1usize << (KW_EXTENDS - 101))
                                | (1usize << (KW_WHILE - 101))
                                | (1usize << (KW_FOR - 101))
                                | (1usize << (KW_LET - 101))
                                | (1usize << (KW_NEW - 101))
                                | (1usize << (KW_OBJECT - 101))
                                | (1usize << (KW_LAMBDA - 101))
                                | (1usize << (KW_FUNCTION - 101))
                                | (1usize << (KW_TRY - 101))
                                | (1usize << (KW_MATCH - 101))
                                | (1usize << (KW_CATCH - 101))
                                | (1usize << (INTEGER - 101))))
                            != 0)
                    || (((_la - 133) & !0x3f) == 0
                        && ((1usize << (_la - 133))
                            & ((1usize << (DECIMAL - 133))
                                | (1usize << (STRING_SINGLE - 133))
                                | (1usize << (STRING_DOUBLE - 133))
                                | (1usize << (STRING_BLOCK - 133))
                                | (1usize << (KW_IF - 133))
                                | (1usize << (RETURN - 133))
                                | (1usize << (RESUME - 133))
                                | (1usize << (YIELD - 133))
                                | (1usize << (BREAK - 133))
                                | (1usize << (CONTINUE - 133))
                                | (1usize << (RAISE - 133))
                                | (1usize << (SPECIAL - 133))
                                | (1usize << (RAW_ID - 133))
                                | (1usize << (UNICODE_ID - 133))))
                            != 0)
                {
                    {
                        recog.base.set_state(253);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(0, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_namespace */
                                    recog.base.set_state(238);
                                    recog.define_namespace()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule import_statement */
                                    recog.base.set_state(239);
                                    recog.import_statement()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule define_extension */
                                    recog.base.set_state(240);
                                    recog.define_extension()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule define_class */
                                    recog.base.set_state(241);
                                    recog.define_class()?;
                                }
                            }
                            5 => {
                                {
                                    /* InvokeRule define_union */
                                    recog.base.set_state(242);
                                    recog.define_union()?;
                                }
                            }
                            6 => {
                                {
                                    /* InvokeRule define_bitflags */
                                    recog.base.set_state(243);
                                    recog.define_bitflags()?;
                                }
                            }
                            7 => {
                                {
                                    /* InvokeRule define_trait */
                                    recog.base.set_state(244);
                                    recog.define_trait()?;
                                }
                            }
                            8 => {
                                {
                                    /* InvokeRule define_extends */
                                    recog.base.set_state(245);
                                    recog.define_extends()?;
                                }
                            }
                            9 => {
                                {
                                    /* InvokeRule define_function */
                                    recog.base.set_state(246);
                                    recog.define_function()?;
                                }
                            }
                            10 => {
                                {
                                    /* InvokeRule define_type */
                                    recog.base.set_state(247);
                                    recog.define_type()?;
                                }
                            }
                            11 => {
                                {
                                    /* InvokeRule let_binding */
                                    recog.base.set_state(248);
                                    recog.let_binding()?;
                                }
                            }
                            12 => {
                                {
                                    /* InvokeRule loop_statement */
                                    recog.base.set_state(249);
                                    recog.loop_statement()?;
                                }
                            }
                            13 => {
                                {
                                    /* InvokeRule guard_statement */
                                    recog.base.set_state(250);
                                    recog.guard_statement()?;
                                }
                            }
                            14 => {
                                {
                                    /* InvokeRule expression_root */
                                    recog.base.set_state(251);
                                    recog.expression_root()?;
                                }
                            }
                            15 => {
                                {
                                    /* InvokeRule eos */
                                    recog.base.set_state(252);
                                    recog.eos()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(257);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(258);
                recog.base.match_token(EOF, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos ----------------
pub type EosContextAll<'input> = EosContext<'input>;

pub type EosContext<'input> = BaseParserRuleContext<'input, EosContextExt<'input>>;

#[derive(Clone)]
pub struct EosContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for EosContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EosContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EosContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos(self);
    }
}

impl<'input> CustomRuleContext<'input> for EosContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos }
}
antlr_rust::tid! {EosContextExt<'a>}

impl<'input> EosContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<EosContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, EosContextExt { ph: PhantomData }))
    }
}

pub trait EosContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<EosContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FAKE_COLON
    /// Returns `None` if there is no child corresponding to token FAKE_COLON
    fn FAKE_COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FAKE_COLON, 0)
    }
}

impl<'input> EosContextAttrs<'input> for EosContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos(&mut self) -> Result<Rc<EosContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = EosContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_eos);
        let mut _localctx: Rc<EosContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(260);
                _la = recog.base.input.la(1);
                if { !(_la == SEMICOLON || _la == FAKE_COLON) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- eos_free ----------------
pub type Eos_freeContextAll<'input> = Eos_freeContext<'input>;

pub type Eos_freeContext<'input> = BaseParserRuleContext<'input, Eos_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Eos_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Eos_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Eos_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_eos_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_eos_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Eos_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_eos_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Eos_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_eos_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_eos_free }
}
antlr_rust::tid! {Eos_freeContextExt<'a>}

impl<'input> Eos_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Eos_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Eos_freeContextExt { ph: PhantomData }))
    }
}

pub trait Eos_freeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Eos_freeContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token COMMA
    /// Returns `None` if there is no child corresponding to token COMMA
    fn COMMA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, 0)
    }
    /// Retrieves first TerminalNode corresponding to token SEMICOLON
    /// Returns `None` if there is no child corresponding to token SEMICOLON
    fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SEMICOLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token FAKE_COLON
    /// Returns `None` if there is no child corresponding to token FAKE_COLON
    fn FAKE_COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FAKE_COLON, 0)
    }
}

impl<'input> Eos_freeContextAttrs<'input> for Eos_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn eos_free(&mut self) -> Result<Rc<Eos_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Eos_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_eos_free);
        let mut _localctx: Rc<Eos_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(262);
                _la = recog.base.input.la(1);
                if {
                    !(((_la) & !0x3f) == 0
                        && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_namespace ----------------
pub type Define_namespaceContextAll<'input> = Define_namespaceContext<'input>;

pub type Define_namespaceContext<'input> = BaseParserRuleContext<'input, Define_namespaceContextExt<'input>>;

#[derive(Clone)]
pub struct Define_namespaceContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_namespaceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_namespaceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_namespace(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_namespace(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_namespaceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_namespace(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_namespaceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_namespace
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_namespace }
}
antlr_rust::tid! {Define_namespaceContextExt<'a>}

impl<'input> Define_namespaceContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_namespaceContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_namespaceContextExt { ph: PhantomData }))
    }
}

pub trait Define_namespaceContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_namespaceContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NAMESPACE
    /// Returns `None` if there is no child corresponding to token KW_NAMESPACE
    fn KW_NAMESPACE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NAMESPACE, 0)
    }
    fn namepath_free(&self) -> Option<Rc<Namepath_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_namespaceContextAttrs<'input> for Define_namespaceContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_namespace(&mut self) -> Result<Rc<Define_namespaceContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_namespaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_define_namespace);
        let mut _localctx: Rc<Define_namespaceContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(264);
                recog.base.match_token(KW_NAMESPACE, &mut recog.err_handler)?;

                /* InvokeRule namepath_free */
                recog.base.set_state(265);
                recog.namepath_free()?;

                recog.base.set_state(267);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(2, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(266);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_statement ----------------
pub type Import_statementContextAll<'input> = Import_statementContext<'input>;

pub type Import_statementContext<'input> = BaseParserRuleContext<'input, Import_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Import_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_statement }
}
antlr_rust::tid! {Import_statementContextExt<'a>}

impl<'input> Import_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_statementContextExt { ph: PhantomData }))
    }
}

pub trait Import_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IMPORT
    /// Returns `None` if there is no child corresponding to token KW_IMPORT
    fn KW_IMPORT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPORT, 0)
    }
    fn import_term(&self) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_statementContextAttrs<'input> for Import_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_statement(&mut self) -> Result<Rc<Import_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_import_statement);
        let mut _localctx: Rc<Import_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(269);
                recog.base.match_token(KW_IMPORT, &mut recog.err_handler)?;

                /* InvokeRule import_term */
                recog.base.set_state(270);
                recog.import_term()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_as ----------------
pub type Import_asContextAll<'input> = Import_asContext<'input>;

pub type Import_asContext<'input> = BaseParserRuleContext<'input, Import_asContextExt<'input>>;

#[derive(Clone)]
pub struct Import_asContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_asContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_asContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_as(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_as(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_asContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_as(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_asContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_as
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_as }
}
antlr_rust::tid! {Import_asContextExt<'a>}

impl<'input> Import_asContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_asContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_asContextExt { ph: PhantomData }))
    }
}

pub trait Import_asContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Import_asContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
}

impl<'input> Import_asContextAttrs<'input> for Import_asContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_as(&mut self) -> Result<Rc<Import_asContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_asContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_import_as);
        let mut _localctx: Rc<Import_asContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(272);
                recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                recog.base.set_state(274);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AT || _la == OP_HASH {
                    {
                        recog.base.set_state(273);
                        _la = recog.base.input.la(1);
                        if { !(_la == OP_AT || _la == OP_HASH) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                    }
                }

                /* InvokeRule identifier */
                recog.base.set_state(276);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_term ----------------
pub type Import_termContextAll<'input> = Import_termContext<'input>;

pub type Import_termContext<'input> = BaseParserRuleContext<'input, Import_termContextExt<'input>>;

#[derive(Clone)]
pub struct Import_termContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_termContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_termContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_term(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_term(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_termContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_term(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_termContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_term
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_term }
}
antlr_rust::tid! {Import_termContextExt<'a>}

impl<'input> Import_termContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_termContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_termContextExt { ph: PhantomData }))
    }
}

pub trait Import_termContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_termContextExt<'input>>
{
    fn import_block(&self) -> Option<Rc<Import_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn import_name(&self) -> Option<Rc<Import_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn import_as(&self) -> Option<Rc<Import_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Import_termContextAttrs<'input> for Import_termContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_term(&mut self) -> Result<Rc<Import_termContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_termContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_import_term);
        let mut _localctx: Rc<Import_termContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(317);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(13, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule import_block */
                        recog.base.set_state(278);
                        recog.import_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(279);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(280);
                        recog.import_name()?;

                        recog.base.set_state(282);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(281);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(284);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(285);
                        recog.import_name()?;

                        recog.base.set_state(290);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(6, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(287);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(286);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(289);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(292);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(293);
                        recog.import_name()?;

                        recog.base.set_state(295);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(294);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(297);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule import_name */
                        recog.base.set_state(298);
                        recog.import_name()?;

                        recog.base.set_state(303);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(9, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(300);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(299);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(302);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(305);
                        recog.import_name()?;

                        recog.base.set_state(307);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_AS {
                            {
                                /* InvokeRule import_as */
                                recog.base.set_state(306);
                                recog.import_as()?;
                            }
                        }
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule import_name */
                        recog.base.set_state(309);
                        recog.import_name()?;

                        recog.base.set_state(314);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(12, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(311);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == DOT || _la == OP_PROPORTION {
                                        {
                                            recog.base.set_state(310);
                                            _la = recog.base.input.la(1);
                                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                                recog.err_handler.recover_inline(&mut recog.base)?;
                                            }
                                            else {
                                                if recog.base.input.la(1) == TOKEN_EOF {
                                                    recog.base.matched_eof = true
                                                };
                                                recog.err_handler.report_match(&mut recog.base);
                                                recog.base.consume(&mut recog.err_handler);
                                            }
                                        }
                                    }

                                    /* InvokeRule import_block */
                                    recog.base.set_state(313);
                                    recog.import_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(316);
                        recog.eos_free()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_name ----------------
pub type Import_nameContextAll<'input> = Import_nameContext<'input>;

pub type Import_nameContext<'input> = BaseParserRuleContext<'input, Import_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Import_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_name }
}
antlr_rust::tid! {Import_nameContextExt<'a>}

impl<'input> Import_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_nameContextExt { ph: PhantomData }))
    }
}

pub trait Import_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_nameContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Import_nameContextAttrs<'input> for Import_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_name(&mut self) -> Result<Rc<Import_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_import_name);
        let mut _localctx: Rc<Import_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(319);
                recog.identifier()?;

                recog.base.set_state(324);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(14, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(320);
                                _la = recog.base.input.la(1);
                                if { !(_la == DOT || _la == OP_PROPORTION) } {
                                    recog.err_handler.recover_inline(&mut recog.base)?;
                                }
                                else {
                                    if recog.base.input.la(1) == TOKEN_EOF {
                                        recog.base.matched_eof = true
                                    };
                                    recog.err_handler.report_match(&mut recog.base);
                                    recog.base.consume(&mut recog.err_handler);
                                }
                                /* InvokeRule identifier */
                                recog.base.set_state(321);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(326);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(14, &mut recog.base)?;
                }
                {
                    recog.base.set_state(327);
                    _la = recog.base.input.la(1);
                    if { !(_la == DOT || _la == OP_PROPORTION) } {
                        recog.err_handler.recover_inline(&mut recog.base)?;
                    }
                    else {
                        if recog.base.input.la(1) == TOKEN_EOF {
                            recog.base.matched_eof = true
                        };
                        recog.err_handler.report_match(&mut recog.base);
                        recog.base.consume(&mut recog.err_handler);
                    }
                    {
                        recog.base.set_state(328);
                        recog.base.match_token(OP_MUL, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- import_block ----------------
pub type Import_blockContextAll<'input> = Import_blockContext<'input>;

pub type Import_blockContext<'input> = BaseParserRuleContext<'input, Import_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Import_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Import_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Import_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_import_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_import_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Import_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_import_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Import_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_import_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_import_block }
}
antlr_rust::tid! {Import_blockContextExt<'a>}

impl<'input> Import_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Import_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Import_blockContextExt { ph: PhantomData }))
    }
}

pub trait Import_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Import_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn import_term_all(&self) -> Vec<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn import_term(&self, i: usize) -> Option<Rc<Import_termContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Import_blockContextAttrs<'input> for Import_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn import_block(&mut self) -> Result<Rc<Import_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Import_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_import_block);
        let mut _localctx: Rc<Import_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(340);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(16, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(330);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(331);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(332);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(336);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while (((_la) & !0x3f) == 0
                            && ((1usize << _la)
                                & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_AT
                            || _la == OP_HASH
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                {
                                    /* InvokeRule import_term */
                                    recog.base.set_state(333);
                                    recog.import_term()?;
                                }
                            }
                            recog.base.set_state(338);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(339);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extension ----------------
pub type Define_extensionContextAll<'input> = Define_extensionContext<'input>;

pub type Define_extensionContext<'input> = BaseParserRuleContext<'input, Define_extensionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extensionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extensionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extensionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extension(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extension(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extensionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extension(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extensionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extension
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extension }
}
antlr_rust::tid! {Define_extensionContextExt<'a>}

impl<'input> Define_extensionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extensionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extensionContextExt { ph: PhantomData }))
    }
}

pub trait Define_extensionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extensionContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_EXTENSION
    /// Returns `None` if there is no child corresponding to token KW_EXTENSION
    fn KW_EXTENSION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENSION, 0)
    }
}

impl<'input> Define_extensionContextAttrs<'input> for Define_extensionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extension(&mut self) -> Result<Rc<Define_extensionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extensionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_define_extension);
        let mut _localctx: Rc<Define_extensionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(342);
                recog.base.match_token(KW_EXTENSION, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_class ----------------
pub type Define_classContextAll<'input> = Define_classContext<'input>;

pub type Define_classContext<'input> = BaseParserRuleContext<'input, Define_classContextExt<'input>>;

#[derive(Clone)]
pub struct Define_classContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_classContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_classContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_class(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_class(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_classContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_class(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_classContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_class
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_class }
}
antlr_rust::tid! {Define_classContextExt<'a>}

impl<'input> Define_classContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_classContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_classContextExt { ph: PhantomData }))
    }
}

pub trait Define_classContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_classContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CLASS
    /// Returns `None` if there is no child corresponding to token KW_CLASS
    fn KW_CLASS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CLASS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_classContextAttrs<'input> for Define_classContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_class(&mut self) -> Result<Rc<Define_classContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_classContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_define_class);
        let mut _localctx: Rc<Define_classContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(345);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(17, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(344);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(350);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(347);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(352);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(353);
                recog.modifiers()?;

                recog.base.set_state(354);
                recog.base.match_token(KW_CLASS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(355);
                recog.identifier()?;

                recog.base.set_state(357);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(356);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(360);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(359);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(363);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(362);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(365);
                recog.class_block()?;

                recog.base.set_state(367);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(22, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(366);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_block ----------------
pub type Class_blockContextAll<'input> = Class_blockContext<'input>;

pub type Class_blockContext<'input> = BaseParserRuleContext<'input, Class_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Class_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_block }
}
antlr_rust::tid! {Class_blockContextExt<'a>}

impl<'input> Class_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_blockContextExt { ph: PhantomData }))
    }
}

pub trait Class_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_dsl_all(&self) -> Vec<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_dsl(&self, i: usize) -> Option<Rc<Class_dslContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_blockContextAttrs<'input> for Class_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_block(&mut self) -> Result<Rc<Class_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_class_block);
        let mut _localctx: Rc<Class_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(369);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(376);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(374);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(23, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_dsl */
                                    recog.base.set_state(370);
                                    recog.class_dsl()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(371);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(372);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(373);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(378);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(379);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit ----------------
pub type Class_inheritContextAll<'input> = Class_inheritContext<'input>;

pub type Class_inheritContext<'input> = BaseParserRuleContext<'input, Class_inheritContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inheritContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inheritContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inheritContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inheritContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inheritContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit }
}
antlr_rust::tid! {Class_inheritContextExt<'a>}

impl<'input> Class_inheritContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inheritContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inheritContextExt { ph: PhantomData }))
    }
}

pub trait Class_inheritContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inheritContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn class_inherit_item_all(&self) -> Vec<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_inherit_item(&self, i: usize) -> Option<Rc<Class_inherit_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Class_inheritContextAttrs<'input> for Class_inheritContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit(&mut self) -> Result<Rc<Class_inheritContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inheritContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_class_inherit);
        let mut _localctx: Rc<Class_inheritContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(397);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(27, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(381);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(382);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(383);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule class_inherit_item */
                        recog.base.set_state(384);
                        recog.class_inherit_item()?;

                        recog.base.set_state(389);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(25, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(385);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule class_inherit_item */
                                        recog.base.set_state(386);
                                        recog.class_inherit_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(391);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(25, &mut recog.base)?;
                        }
                        recog.base.set_state(393);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(392);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(395);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_inherit_item ----------------
pub type Class_inherit_itemContextAll<'input> = Class_inherit_itemContext<'input>;

pub type Class_inherit_itemContext<'input> = BaseParserRuleContext<'input, Class_inherit_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Class_inherit_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_inherit_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_inherit_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_inherit_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_inherit_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_inherit_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_inherit_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_inherit_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_inherit_item }
}
antlr_rust::tid! {Class_inherit_itemContextExt<'a>}

impl<'input> Class_inherit_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_inherit_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_inherit_itemContextExt { ph: PhantomData }))
    }
}

pub trait Class_inherit_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_inherit_itemContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_inherit_itemContextAttrs<'input> for Class_inherit_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_inherit_item(&mut self) -> Result<Rc<Class_inherit_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_inherit_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_class_inherit_item);
        let mut _localctx: Rc<Class_inherit_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_namepath */
                recog.base.set_state(399);
                recog.modified_namepath()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_field ----------------
pub type Class_fieldContextAll<'input> = Class_fieldContext<'input>;

pub type Class_fieldContext<'input> = BaseParserRuleContext<'input, Class_fieldContextExt<'input>>;

#[derive(Clone)]
pub struct Class_fieldContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_fieldContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_fieldContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_field(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_field(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_fieldContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_field(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_fieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_field
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_field }
}
antlr_rust::tid! {Class_fieldContextExt<'a>}

impl<'input> Class_fieldContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_fieldContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_fieldContextExt { ph: PhantomData }))
    }
}

pub trait Class_fieldContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_fieldContextExt<'input>>
{
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_fieldContextAttrs<'input> for Class_fieldContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_field(&mut self) -> Result<Rc<Class_fieldContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_fieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_class_field);
        let mut _localctx: Rc<Class_fieldContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(404);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(401);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(406);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(407);
                recog.modified_identifier()?;

                recog.base.set_state(409);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(408);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(412);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        /* InvokeRule parameter_default */
                        recog.base.set_state(411);
                        recog.parameter_default()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_method ----------------
pub type Class_methodContextAll<'input> = Class_methodContext<'input>;

pub type Class_methodContext<'input> = BaseParserRuleContext<'input, Class_methodContextExt<'input>>;

#[derive(Clone)]
pub struct Class_methodContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_methodContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_methodContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_method(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_method(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_methodContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_method(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_methodContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_method
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_method }
}
antlr_rust::tid! {Class_methodContextExt<'a>}

impl<'input> Class_methodContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_methodContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_methodContextExt { ph: PhantomData }))
    }
}

pub trait Class_methodContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Class_methodContextExt<'input>>
{
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn effect_hint(&self) -> Option<Rc<Effect_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Class_methodContextAttrs<'input> for Class_methodContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_method(&mut self) -> Result<Rc<Class_methodContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_methodContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_class_method);
        let mut _localctx: Rc<Class_methodContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(417);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(414);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(419);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_namepath */
                recog.base.set_state(420);
                recog.modified_namepath()?;

                recog.base.set_state(422);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(421);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(424);
                recog.function_parameters()?;

                recog.base.set_state(426);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(425);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(429);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_DIV {
                    {
                        /* InvokeRule effect_hint */
                        recog.base.set_state(428);
                        recog.effect_hint()?;
                    }
                }

                recog.base.set_state(432);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule function_block */
                        recog.base.set_state(431);
                        recog.function_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- class_dsl ----------------
pub type Class_dslContextAll<'input> = Class_dslContext<'input>;

pub type Class_dslContext<'input> = BaseParserRuleContext<'input, Class_dslContextExt<'input>>;

#[derive(Clone)]
pub struct Class_dslContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Class_dslContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Class_dslContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_class_dsl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_class_dsl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Class_dslContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_class_dsl(self);
    }
}

impl<'input> CustomRuleContext<'input> for Class_dslContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_class_dsl
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_class_dsl }
}
antlr_rust::tid! {Class_dslContextExt<'a>}

impl<'input> Class_dslContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Class_dslContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Class_dslContextExt { ph: PhantomData }))
    }
}

pub trait Class_dslContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Class_dslContextExt<'input>> {
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Class_dslContextAttrs<'input> for Class_dslContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn class_dsl(&mut self) -> Result<Rc<Class_dslContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Class_dslContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_class_dsl);
        let mut _localctx: Rc<Class_dslContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(437);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(434);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(439);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modified_identifier */
                recog.base.set_state(440);
                recog.modified_identifier()?;

                /* InvokeRule class_block */
                recog.base.set_state(441);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait ----------------
pub type Define_traitContextAll<'input> = Define_traitContext<'input>;

pub type Define_traitContext<'input> = BaseParserRuleContext<'input, Define_traitContextExt<'input>>;

#[derive(Clone)]
pub struct Define_traitContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_traitContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_traitContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_traitContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_traitContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait }
}
antlr_rust::tid! {Define_traitContextExt<'a>}

impl<'input> Define_traitContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_traitContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_traitContextExt { ph: PhantomData }))
    }
}

pub trait Define_traitContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_traitContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TRAIT
    /// Returns `None` if there is no child corresponding to token KW_TRAIT
    fn KW_TRAIT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRAIT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn trait_block(&self) -> Option<Rc<Trait_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn with_implements(&self) -> Option<Rc<With_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_traitContextAttrs<'input> for Define_traitContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait(&mut self) -> Result<Rc<Define_traitContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_traitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_define_trait);
        let mut _localctx: Rc<Define_traitContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(444);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(37, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(443);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(449);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(446);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(451);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(452);
                recog.modifiers()?;

                recog.base.set_state(453);
                recog.base.match_token(KW_TRAIT, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(454);
                recog.identifier()?;

                recog.base.set_state(456);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(455);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(459);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule with_implements */
                        recog.base.set_state(458);
                        recog.with_implements()?;
                    }
                }

                /* InvokeRule trait_block */
                recog.base.set_state(461);
                recog.trait_block()?;

                recog.base.set_state(463);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(41, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(462);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- trait_block ----------------
pub type Trait_blockContextAll<'input> = Trait_blockContext<'input>;

pub type Trait_blockContext<'input> = BaseParserRuleContext<'input, Trait_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Trait_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Trait_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Trait_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_trait_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_trait_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Trait_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_trait_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Trait_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_trait_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_trait_block }
}
antlr_rust::tid! {Trait_blockContextExt<'a>}

impl<'input> Trait_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Trait_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Trait_blockContextExt { ph: PhantomData }))
    }
}

pub trait Trait_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Trait_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_trait_type_all(&self) -> Vec<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait_type(&self, i: usize) -> Option<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Trait_blockContextAttrs<'input> for Trait_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn trait_block(&mut self) -> Result<Rc<Trait_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Trait_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_trait_block);
        let mut _localctx: Rc<Trait_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(465);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(472);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == KW_TYPE
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(470);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(42, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_trait_type */
                                    recog.base.set_state(466);
                                    recog.define_trait_type()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(467);
                                    recog.class_method()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(468);
                                    recog.class_field()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(469);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(474);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(475);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_trait_type ----------------
pub type Define_trait_typeContextAll<'input> = Define_trait_typeContext<'input>;

pub type Define_trait_typeContext<'input> = BaseParserRuleContext<'input, Define_trait_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_trait_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_trait_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_trait_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_trait_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_trait_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_trait_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_trait_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_trait_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_trait_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_trait_type }
}
antlr_rust::tid! {Define_trait_typeContextExt<'a>}

impl<'input> Define_trait_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_trait_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_trait_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_trait_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_trait_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_trait_typeContextAttrs<'input> for Define_trait_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_trait_type(&mut self) -> Result<Rc<Define_trait_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_trait_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_define_trait_type);
        let mut _localctx: Rc<Define_trait_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(477);
                recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(478);
                recog.identifier()?;

                recog.base.set_state(481);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(479);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(480);
                        recog.type_expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_extends ----------------
pub type Define_extendsContextAll<'input> = Define_extendsContext<'input>;

pub type Define_extendsContext<'input> = BaseParserRuleContext<'input, Define_extendsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_extendsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_extendsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_extendsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_extends(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_extends(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_extendsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_extends(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_extendsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_extends
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_extends }
}
antlr_rust::tid! {Define_extendsContextExt<'a>}

impl<'input> Define_extendsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_extendsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_extendsContextExt { ph: PhantomData }))
    }
}

pub trait Define_extendsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_extendsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_EXTENDS
    /// Returns `None` if there is no child corresponding to token KW_EXTENDS
    fn KW_EXTENDS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_EXTENDS, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn extends_block(&self) -> Option<Rc<Extends_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn with_implements(&self) -> Option<Rc<With_implementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_extendsContextAttrs<'input> for Define_extendsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_extends(&mut self) -> Result<Rc<Define_extendsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_extendsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_define_extends);
        let mut _localctx: Rc<Define_extendsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(484);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(45, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(483);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(489);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(486);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(491);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(492);
                recog.modifiers()?;

                recog.base.set_state(493);
                recog.base.match_token(KW_EXTENDS, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(494);
                recog.namepath()?;

                recog.base.set_state(496);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(495);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(499);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == KW_IMPLEMENTS {
                    {
                        /* InvokeRule with_implements */
                        recog.base.set_state(498);
                        recog.with_implements()?;
                    }
                }

                /* InvokeRule extends_block */
                recog.base.set_state(501);
                recog.extends_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- extends_block ----------------
pub type Extends_blockContextAll<'input> = Extends_blockContext<'input>;

pub type Extends_blockContext<'input> = BaseParserRuleContext<'input, Extends_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Extends_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Extends_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Extends_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_extends_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_extends_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Extends_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_extends_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Extends_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_extends_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_extends_block }
}
antlr_rust::tid! {Extends_blockContextExt<'a>}

impl<'input> Extends_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Extends_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Extends_blockContextExt { ph: PhantomData }))
    }
}

pub trait Extends_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Extends_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_trait_type_all(&self) -> Vec<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_trait_type(&self, i: usize) -> Option<Rc<Define_trait_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Extends_blockContextAttrs<'input> for Extends_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn extends_block(&mut self) -> Result<Rc<Extends_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Extends_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_extends_block);
        let mut _localctx: Rc<Extends_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(503);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(509);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == KW_TYPE
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(507);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            KW_TYPE => {
                                {
                                    /* InvokeRule define_trait_type */
                                    recog.base.set_state(504);
                                    recog.define_trait_type()?;
                                }
                            }

                            OP_HASH | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(505);
                                    recog.class_method()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(506);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(511);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(512);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- with_implements ----------------
pub type With_implementsContextAll<'input> = With_implementsContext<'input>;

pub type With_implementsContext<'input> = BaseParserRuleContext<'input, With_implementsContextExt<'input>>;

#[derive(Clone)]
pub struct With_implementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for With_implementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for With_implementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_with_implements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_with_implements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for With_implementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_with_implements(self);
    }
}

impl<'input> CustomRuleContext<'input> for With_implementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_with_implements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_with_implements }
}
antlr_rust::tid! {With_implementsContextExt<'a>}

impl<'input> With_implementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<With_implementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, With_implementsContextExt { ph: PhantomData }))
    }
}

pub trait With_implementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<With_implementsContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IMPLEMENTS
    /// Returns `None` if there is no child corresponding to token KW_IMPLEMENTS
    fn KW_IMPLEMENTS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IMPLEMENTS, 0)
    }
}

impl<'input> With_implementsContextAttrs<'input> for With_implementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn with_implements(&mut self) -> Result<Rc<With_implementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = With_implementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_with_implements);
        let mut _localctx: Rc<With_implementsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(514);
                _la = recog.base.input.la(1);
                if { !(_la == COLON || _la == KW_IMPLEMENTS) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                /* InvokeRule type_expression */
                recog.base.set_state(515);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_union ----------------
pub type Define_unionContextAll<'input> = Define_unionContext<'input>;

pub type Define_unionContext<'input> = BaseParserRuleContext<'input, Define_unionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_unionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_unionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_unionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_union(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_union(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_unionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_union(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_unionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_union
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_union }
}
antlr_rust::tid! {Define_unionContextExt<'a>}

impl<'input> Define_unionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_unionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_unionContextExt { ph: PhantomData }))
    }
}

pub trait Define_unionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_unionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_UNION
    /// Returns `None` if there is no child corresponding to token KW_UNION
    fn KW_UNION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_UNION, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn union_block(&self) -> Option<Rc<Union_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_unionContextAttrs<'input> for Define_unionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_union(&mut self) -> Result<Rc<Define_unionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_unionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_define_union);
        let mut _localctx: Rc<Define_unionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(520);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(517);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(522);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(523);
                recog.modifiers()?;

                recog.base.set_state(524);
                recog.base.match_token(KW_UNION, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(525);
                recog.identifier()?;

                recog.base.set_state(527);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(526);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(530);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(529);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule union_block */
                recog.base.set_state(532);
                recog.union_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- base_layout ----------------
pub type Base_layoutContextAll<'input> = Base_layoutContext<'input>;

pub type Base_layoutContext<'input> = BaseParserRuleContext<'input, Base_layoutContextExt<'input>>;

#[derive(Clone)]
pub struct Base_layoutContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Base_layoutContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Base_layoutContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_base_layout(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_base_layout(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Base_layoutContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_base_layout(self);
    }
}

impl<'input> CustomRuleContext<'input> for Base_layoutContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_base_layout
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_base_layout }
}
antlr_rust::tid! {Base_layoutContextExt<'a>}

impl<'input> Base_layoutContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Base_layoutContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Base_layoutContextExt { ph: PhantomData }))
    }
}

pub trait Base_layoutContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Base_layoutContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Base_layoutContextAttrs<'input> for Base_layoutContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn base_layout(&mut self) -> Result<Rc<Base_layoutContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Base_layoutContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_base_layout);
        let mut _localctx: Rc<Base_layoutContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(534);
                recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                recog.base.set_state(536);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 8) & !0x3f) == 0
                    && ((1usize << (_la - 8))
                        & ((1usize << (PARENTHESES_L - 8))
                            | (1usize << (OP_ADD - 8))
                            | (1usize << (OP_SUB - 8))
                            | (1usize << (OP_MUL - 8))
                            | (1usize << (OP_REM - 8))
                            | (1usize << (OP_LAST - 8))))
                        != 0)
                    || (((_la - 69) & !0x3f) == 0
                        && ((1usize << (_la - 69))
                            & ((1usize << (OP_AND - 69))
                                | (1usize << (LAMBDA_SLOT - 69))
                                | (1usize << (OP_NOT - 69))
                                | (1usize << (OP_DOT3 - 69))
                                | (1usize << (OP_DOT2 - 69))
                                | (1usize << (OP_INVERSE - 69))
                                | (1usize << (OP_ROOT2 - 69))
                                | (1usize << (OP_ROOT3 - 69))))
                            != 0)
                    || (((_la - 101) & !0x3f) == 0
                        && ((1usize << (_la - 101))
                            & ((1usize << (OP_ROOT4 - 101)) | (1usize << (OP_REFERENCE - 101)) | (1usize << (INTEGER - 101))))
                            != 0)
                    || (((_la - 133) & !0x3f) == 0
                        && ((1usize << (_la - 133))
                            & ((1usize << (DECIMAL - 133))
                                | (1usize << (STRING_SINGLE - 133))
                                | (1usize << (STRING_DOUBLE - 133))
                                | (1usize << (STRING_BLOCK - 133))
                                | (1usize << (SPECIAL - 133))
                                | (1usize << (RAW_ID - 133))
                                | (1usize << (UNICODE_ID - 133))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(535);
                        recog.type_expression_rec(0)?;
                    }
                }

                recog.base.set_state(538);
                recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- union_block ----------------
pub type Union_blockContextAll<'input> = Union_blockContext<'input>;

pub type Union_blockContext<'input> = BaseParserRuleContext<'input, Union_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Union_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Union_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Union_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_union_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_union_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Union_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_union_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Union_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_union_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_union_block }
}
antlr_rust::tid! {Union_blockContextExt<'a>}

impl<'input> Union_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Union_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Union_blockContextExt { ph: PhantomData }))
    }
}

pub trait Union_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Union_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_variant_all(&self) -> Vec<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_variant(&self, i: usize) -> Option<Rc<Define_variantContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Union_blockContextAttrs<'input> for Union_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn union_block(&mut self) -> Result<Rc<Union_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Union_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_union_block);
        let mut _localctx: Rc<Union_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(540);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(546);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(544);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(55, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(541);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule define_variant */
                                    recog.base.set_state(542);
                                    recog.define_variant()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(543);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(548);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(549);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_variant ----------------
pub type Define_variantContextAll<'input> = Define_variantContext<'input>;

pub type Define_variantContext<'input> = BaseParserRuleContext<'input, Define_variantContextExt<'input>>;

#[derive(Clone)]
pub struct Define_variantContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_variantContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_variantContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_variant(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_variant(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_variantContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_variant(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_variantContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_variant
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_variant }
}
antlr_rust::tid! {Define_variantContextExt<'a>}

impl<'input> Define_variantContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_variantContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_variantContextExt { ph: PhantomData }))
    }
}

pub trait Define_variantContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_variantContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn variant_block(&self) -> Option<Rc<Variant_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_variantContextAttrs<'input> for Define_variantContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_variant(&mut self) -> Result<Rc<Define_variantContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_variantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_define_variant);
        let mut _localctx: Rc<Define_variantContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(551);
                recog.identifier()?;

                recog.base.set_state(553);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == BRACE_L {
                    {
                        /* InvokeRule variant_block */
                        recog.base.set_state(552);
                        recog.variant_block()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- variant_block ----------------
pub type Variant_blockContextAll<'input> = Variant_blockContext<'input>;

pub type Variant_blockContext<'input> = BaseParserRuleContext<'input, Variant_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Variant_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Variant_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Variant_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_variant_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_variant_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Variant_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_variant_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Variant_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_variant_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_variant_block }
}
antlr_rust::tid! {Variant_blockContextExt<'a>}

impl<'input> Variant_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Variant_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Variant_blockContextExt { ph: PhantomData }))
    }
}

pub trait Variant_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Variant_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_field_all(&self) -> Vec<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_field(&self, i: usize) -> Option<Rc<Class_fieldContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Variant_blockContextAttrs<'input> for Variant_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn variant_block(&mut self) -> Result<Rc<Variant_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Variant_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_variant_block);
        let mut _localctx: Rc<Variant_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(555);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(560);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(558);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_HASH | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule class_field */
                                    recog.base.set_state(556);
                                    recog.class_field()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(557);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(562);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(563);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_bitflags ----------------
pub type Define_bitflagsContextAll<'input> = Define_bitflagsContext<'input>;

pub type Define_bitflagsContext<'input> = BaseParserRuleContext<'input, Define_bitflagsContextExt<'input>>;

#[derive(Clone)]
pub struct Define_bitflagsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_bitflagsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_bitflagsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_bitflags(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_bitflags(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_bitflagsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_bitflags(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_bitflagsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_bitflags
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_bitflags }
}
antlr_rust::tid! {Define_bitflagsContextExt<'a>}

impl<'input> Define_bitflagsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_bitflagsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_bitflagsContextExt { ph: PhantomData }))
    }
}

pub trait Define_bitflagsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_bitflagsContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_BITFLAGS
    /// Returns `None` if there is no child corresponding to token KW_BITFLAGS
    fn KW_BITFLAGS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_BITFLAGS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn bitflags_block(&self) -> Option<Rc<Bitflags_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn base_layout(&self) -> Option<Rc<Base_layoutContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_bitflagsContextAttrs<'input> for Define_bitflagsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_bitflags(&mut self) -> Result<Rc<Define_bitflagsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_bitflagsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_define_bitflags);
        let mut _localctx: Rc<Define_bitflagsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(568);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(565);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(570);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(571);
                recog.modifiers()?;

                recog.base.set_state(572);
                recog.base.match_token(KW_BITFLAGS, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(573);
                recog.identifier()?;

                recog.base.set_state(575);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule base_layout */
                        recog.base.set_state(574);
                        recog.base_layout()?;
                    }
                }

                recog.base.set_state(578);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(577);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule bitflags_block */
                recog.base.set_state(580);
                recog.bitflags_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_block ----------------
pub type Bitflags_blockContextAll<'input> = Bitflags_blockContext<'input>;

pub type Bitflags_blockContext<'input> = BaseParserRuleContext<'input, Bitflags_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_block }
}
antlr_rust::tid! {Bitflags_blockContextExt<'a>}

impl<'input> Bitflags_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_blockContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn class_method_all(&self) -> Vec<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn class_method(&self, i: usize) -> Option<Rc<Class_methodContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn bitflags_item_all(&self) -> Vec<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn bitflags_item(&self, i: usize) -> Option<Rc<Bitflags_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Bitflags_blockContextAttrs<'input> for Bitflags_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_block(&mut self) -> Result<Rc<Bitflags_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_bitflags_block);
        let mut _localctx: Rc<Bitflags_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(582);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(588);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        recog.base.set_state(586);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(63, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule class_method */
                                    recog.base.set_state(583);
                                    recog.class_method()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule bitflags_item */
                                    recog.base.set_state(584);
                                    recog.bitflags_item()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(585);
                                    recog.eos_free()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(590);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(591);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- bitflags_item ----------------
pub type Bitflags_itemContextAll<'input> = Bitflags_itemContext<'input>;

pub type Bitflags_itemContext<'input> = BaseParserRuleContext<'input, Bitflags_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Bitflags_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Bitflags_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Bitflags_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_bitflags_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_bitflags_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Bitflags_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_bitflags_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Bitflags_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_bitflags_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_bitflags_item }
}
antlr_rust::tid! {Bitflags_itemContextExt<'a>}

impl<'input> Bitflags_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Bitflags_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Bitflags_itemContextExt { ph: PhantomData }))
    }
}

pub trait Bitflags_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Bitflags_itemContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Bitflags_itemContextAttrs<'input> for Bitflags_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn bitflags_item(&mut self) -> Result<Rc<Bitflags_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Bitflags_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_bitflags_item);
        let mut _localctx: Rc<Bitflags_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(596);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(593);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(598);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule identifier */
                recog.base.set_state(599);
                recog.identifier()?;

                recog.base.set_state(602);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(600);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(601);
                        recog.expression_rec(0)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_function ----------------
pub type Define_functionContextAll<'input> = Define_functionContext<'input>;

pub type Define_functionContext<'input> = BaseParserRuleContext<'input, Define_functionContextExt<'input>>;

#[derive(Clone)]
pub struct Define_functionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_functionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_functionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_function(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_function(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_functionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_function(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_functionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_function
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_function }
}
antlr_rust::tid! {Define_functionContextExt<'a>}

impl<'input> Define_functionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_functionContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_functionContextExt { ph: PhantomData }))
    }
}

pub trait Define_functionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_functionContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_FUNCTION
    /// Returns `None` if there is no child corresponding to token KW_FUNCTION
    fn KW_FUNCTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FUNCTION, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_call(&self) -> Option<Rc<Template_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn effect_hint(&self) -> Option<Rc<Effect_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_functionContextAttrs<'input> for Define_functionContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_function(&mut self) -> Result<Rc<Define_functionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_functionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_define_function);
        let mut _localctx: Rc<Define_functionContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(605);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(67, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule template_call */
                            recog.base.set_state(604);
                            recog.template_call()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(610);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(607);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(612);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                /* InvokeRule modifiers */
                recog.base.set_state(613);
                recog.modifiers()?;

                recog.base.set_state(614);
                recog.base.match_token(KW_FUNCTION, &mut recog.err_handler)?;

                /* InvokeRule namepath */
                recog.base.set_state(615);
                recog.namepath()?;

                recog.base.set_state(617);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(616);
                        recog.define_generic()?;
                    }
                }

                /* InvokeRule function_parameters */
                recog.base.set_state(619);
                recog.function_parameters()?;

                recog.base.set_state(621);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(620);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(624);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_DIV {
                    {
                        /* InvokeRule effect_hint */
                        recog.base.set_state(623);
                        recog.effect_hint()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(626);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_parameters ----------------
pub type Function_parametersContextAll<'input> = Function_parametersContext<'input>;

pub type Function_parametersContext<'input> = BaseParserRuleContext<'input, Function_parametersContextExt<'input>>;

#[derive(Clone)]
pub struct Function_parametersContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_parametersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_parametersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_parameters(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_parameters(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_parametersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_parameters(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_parametersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_parameters
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_parameters }
}
antlr_rust::tid! {Function_parametersContextExt<'a>}

impl<'input> Function_parametersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_parametersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Function_parametersContextExt { ph: PhantomData },
        ))
    }
}

pub trait Function_parametersContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_parametersContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn parameter_item_all(&self) -> Vec<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn parameter_item(&self, i: usize) -> Option<Rc<Parameter_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Function_parametersContextAttrs<'input> for Function_parametersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_parameters(&mut self) -> Result<Rc<Function_parametersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_parametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_function_parameters);
        let mut _localctx: Rc<Function_parametersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(641);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(73, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(628);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(629);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(630);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule parameter_item */
                        recog.base.set_state(631);
                        recog.parameter_item()?;

                        recog.base.set_state(636);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(632);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule parameter_item */
                                    recog.base.set_state(633);
                                    recog.parameter_item()?;
                                }
                            }
                            recog.base.set_state(638);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(639);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_item ----------------
pub type Parameter_itemContextAll<'input> = Parameter_itemContext<'input>;

pub type Parameter_itemContext<'input> = BaseParserRuleContext<'input, Parameter_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_itemContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub id: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_item }
}
antlr_rust::tid! {Parameter_itemContextExt<'a>}

impl<'input> Parameter_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Parameter_itemContextExt { identifier: None, id: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Parameter_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_itemContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_DOT3
    /// Returns `None` if there is no child corresponding to token OP_DOT3
    fn OP_DOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT3, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn parameter_default(&self) -> Option<Rc<Parameter_defaultContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT2
    /// Returns `None` if there is no child corresponding to token OP_DOT2
    fn OP_DOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
}

impl<'input> Parameter_itemContextAttrs<'input> for Parameter_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_item(&mut self) -> Result<Rc<Parameter_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_parameter_item);
        let mut _localctx: Rc<Parameter_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(708);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(88, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(646);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(643);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(648);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(652);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == RAW_ID || _la == UNICODE_ID {
                            {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(649);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier = Some(tmp.clone());

                                    let temp = cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier.clone().unwrap();
                                    cast_mut::<_, Parameter_itemContext>(&mut _localctx).mods.push(temp);
                                }
                            }
                            recog.base.set_state(654);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(655);
                        recog.base.match_token(OP_DOT3, &mut recog.err_handler)?;

                        recog.base.set_state(657);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(656);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Parameter_itemContext>(&mut _localctx).id = Some(tmp.clone());
                            }
                        }

                        recog.base.set_state(660);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON || _la == OP_ARROW {
                            {
                                /* InvokeRule type_hint */
                                recog.base.set_state(659);
                                recog.type_hint()?;
                            }
                        }

                        recog.base.set_state(663);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_ASSIGN {
                            {
                                /* InvokeRule parameter_default */
                                recog.base.set_state(662);
                                recog.parameter_default()?;
                            }
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(668);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(665);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(670);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(674);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == RAW_ID || _la == UNICODE_ID {
                            {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(671);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier = Some(tmp.clone());

                                    let temp = cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier.clone().unwrap();
                                    cast_mut::<_, Parameter_itemContext>(&mut _localctx).mods.push(temp);
                                }
                            }
                            recog.base.set_state(676);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(677);
                        recog.base.match_token(OP_DOT2, &mut recog.err_handler)?;

                        recog.base.set_state(679);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(678);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Parameter_itemContext>(&mut _localctx).id = Some(tmp.clone());
                            }
                        }

                        recog.base.set_state(682);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON || _la == OP_ARROW {
                            {
                                /* InvokeRule type_hint */
                                recog.base.set_state(681);
                                recog.type_hint()?;
                            }
                        }

                        recog.base.set_state(685);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_ASSIGN {
                            {
                                /* InvokeRule parameter_default */
                                recog.base.set_state(684);
                                recog.parameter_default()?;
                            }
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(690);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(687);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(692);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(696);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(85, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        /* InvokeRule identifier */
                                        recog.base.set_state(693);
                                        let tmp = recog.identifier()?;
                                        cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier = Some(tmp.clone());

                                        let temp =
                                            cast_mut::<_, Parameter_itemContext>(&mut _localctx).identifier.clone().unwrap();
                                        cast_mut::<_, Parameter_itemContext>(&mut _localctx).mods.push(temp);
                                    }
                                }
                            }
                            recog.base.set_state(698);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(85, &mut recog.base)?;
                        }
                        /* InvokeRule identifier */
                        recog.base.set_state(699);
                        let tmp = recog.identifier()?;
                        cast_mut::<_, Parameter_itemContext>(&mut _localctx).id = Some(tmp.clone());

                        recog.base.set_state(701);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COLON || _la == OP_ARROW {
                            {
                                /* InvokeRule type_hint */
                                recog.base.set_state(700);
                                recog.type_hint()?;
                            }
                        }

                        recog.base.set_state(704);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_ASSIGN {
                            {
                                /* InvokeRule parameter_default */
                                recog.base.set_state(703);
                                recog.parameter_default()?;
                            }
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(706);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(707);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- parameter_default ----------------
pub type Parameter_defaultContextAll<'input> = Parameter_defaultContext<'input>;

pub type Parameter_defaultContext<'input> = BaseParserRuleContext<'input, Parameter_defaultContextExt<'input>>;

#[derive(Clone)]
pub struct Parameter_defaultContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Parameter_defaultContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Parameter_defaultContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_parameter_default(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_parameter_default(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Parameter_defaultContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_parameter_default(self);
    }
}

impl<'input> CustomRuleContext<'input> for Parameter_defaultContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_parameter_default
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_parameter_default }
}
antlr_rust::tid! {Parameter_defaultContextExt<'a>}

impl<'input> Parameter_defaultContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Parameter_defaultContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Parameter_defaultContextExt { ph: PhantomData }))
    }
}

pub trait Parameter_defaultContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Parameter_defaultContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Parameter_defaultContextAttrs<'input> for Parameter_defaultContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn parameter_default(&mut self) -> Result<Rc<Parameter_defaultContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Parameter_defaultContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_parameter_default);
        let mut _localctx: Rc<Parameter_defaultContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(710);
                recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                /* InvokeRule expression */
                recog.base.set_state(711);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_call ----------------
pub type Function_callContextAll<'input> = Function_callContext<'input>;

pub type Function_callContext<'input> = BaseParserRuleContext<'input, Function_callContextExt<'input>>;

#[derive(Clone)]
pub struct Function_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_call }
}
antlr_rust::tid! {Function_callContextExt<'a>}

impl<'input> Function_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_callContextExt { ph: PhantomData }))
    }
}

pub trait Function_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_callContextExt<'input>>
{
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
}

impl<'input> Function_callContextAttrs<'input> for Function_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_call(&mut self) -> Result<Rc<Function_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_function_call);
        let mut _localctx: Rc<Function_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(736);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(95, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(714);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(713);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(716);
                        recog.tuple_call_body()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(718);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(717);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(720);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(721);
                        recog.base.match_token(INTEGER, &mut recog.err_handler)?;

                        recog.base.set_state(723);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(91, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(722);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(726);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AND_THEN {
                            {
                                recog.base.set_state(725);
                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(728);
                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                        recog.base.set_state(730);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_AT {
                            {
                                recog.base.set_state(729);
                                recog.base.match_token(OP_AT, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule namepath */
                        recog.base.set_state(732);
                        recog.namepath()?;

                        recog.base.set_state(734);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(94, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule tuple_call_body */
                                    recog.base.set_state(733);
                                    recog.tuple_call_body()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_body ----------------
pub type Tuple_call_bodyContextAll<'input> = Tuple_call_bodyContext<'input>;

pub type Tuple_call_bodyContext<'input> = BaseParserRuleContext<'input, Tuple_call_bodyContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_bodyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_body(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_body(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_bodyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_body(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_bodyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_body
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_body }
}
antlr_rust::tid! {Tuple_call_bodyContextExt<'a>}

impl<'input> Tuple_call_bodyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_bodyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_call_bodyContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_call_bodyContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_bodyContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn tuple_call_item_all(&self) -> Vec<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tuple_call_item(&self, i: usize) -> Option<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Tuple_call_bodyContextAttrs<'input> for Tuple_call_bodyContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_body(&mut self) -> Result<Rc<Tuple_call_bodyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_bodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_tuple_call_body);
        let mut _localctx: Rc<Tuple_call_bodyContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(754);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(98, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(738);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(739);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(740);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule tuple_call_item */
                        recog.base.set_state(741);
                        recog.tuple_call_item()?;

                        recog.base.set_state(746);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(96, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(742);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule tuple_call_item */
                                        recog.base.set_state(743);
                                        recog.tuple_call_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(748);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(96, &mut recog.base)?;
                        }
                        recog.base.set_state(750);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(749);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(752);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_call_item ----------------
pub type Tuple_call_itemContextAll<'input> = Tuple_call_itemContext<'input>;

pub type Tuple_call_itemContext<'input> = BaseParserRuleContext<'input, Tuple_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_call_item }
}
antlr_rust::tid! {Tuple_call_itemContextExt<'a>}

impl<'input> Tuple_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_call_itemContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_call_itemContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Tuple_call_itemContextAttrs<'input> for Tuple_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_call_item(&mut self) -> Result<Rc<Tuple_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_tuple_call_item);
        let mut _localctx: Rc<Tuple_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(761);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(99, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(756);
                        recog.identifier()?;

                        recog.base.set_state(757);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(758);
                        recog.expression_rec(0)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(760);
                        recog.expression_rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_lambda ----------------
pub type Define_lambdaContextAll<'input> = Define_lambdaContext<'input>;

pub type Define_lambdaContext<'input> = BaseParserRuleContext<'input, Define_lambdaContextExt<'input>>;

#[derive(Clone)]
pub struct Define_lambdaContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_lambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_lambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_lambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_lambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_lambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_lambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_lambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_lambda
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_lambda }
}
antlr_rust::tid! {Define_lambdaContextExt<'a>}

impl<'input> Define_lambdaContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_lambdaContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_lambdaContextExt { ph: PhantomData }))
    }
}

pub trait Define_lambdaContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_lambdaContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LAMBDA
    /// Returns `None` if there is no child corresponding to token KW_LAMBDA
    fn KW_LAMBDA(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LAMBDA, 0)
    }
    fn function_parameters(&self) -> Option<Rc<Function_parametersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_lambdaContextAttrs<'input> for Define_lambdaContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_lambda(&mut self) -> Result<Rc<Define_lambdaContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_lambdaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_define_lambda);
        let mut _localctx: Rc<Define_lambdaContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(766);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(763);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(768);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(769);
                recog.base.match_token(KW_LAMBDA, &mut recog.err_handler)?;

                /* InvokeRule function_parameters */
                recog.base.set_state(770);
                recog.function_parameters()?;

                recog.base.set_state(772);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(771);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(774);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- function_block ----------------
pub type Function_blockContextAll<'input> = Function_blockContext<'input>;

pub type Function_blockContext<'input> = BaseParserRuleContext<'input, Function_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Function_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Function_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Function_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_function_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_function_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Function_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_function_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Function_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_function_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_function_block }
}
antlr_rust::tid! {Function_blockContextExt<'a>}

impl<'input> Function_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Function_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Function_blockContextExt { ph: PhantomData }))
    }
}

pub trait Function_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Function_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn define_type_all(&self) -> Vec<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn define_type(&self, i: usize) -> Option<Rc<Define_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn let_binding_all(&self) -> Vec<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_binding(&self, i: usize) -> Option<Rc<Let_bindingContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn loop_statement_all(&self) -> Vec<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn loop_statement(&self, i: usize) -> Option<Rc<Loop_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn guard_statement_all(&self) -> Vec<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn guard_statement(&self, i: usize) -> Option<Rc<Guard_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn expression_root_all(&self) -> Vec<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression_root(&self, i: usize) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_all(&self) -> Vec<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos(&self, i: usize) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Function_blockContextAttrs<'input> for Function_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn function_block(&mut self) -> Result<Rc<Function_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Function_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_function_block);
        let mut _localctx: Rc<Function_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(776);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(785);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la - 4) & !0x3f) == 0
                    && ((1usize << (_la - 4))
                        & ((1usize << (SEMICOLON - 4))
                            | (1usize << (FAKE_COLON - 4))
                            | (1usize << (PARENTHESES_L - 4))
                            | (1usize << (BRACKET_L - 4))
                            | (1usize << (BRACE_L - 4))
                            | (1usize << (OFFSET_L - 4))
                            | (1usize << (CEILING_L - 4))
                            | (1usize << (FLOOR_L - 4))
                            | (1usize << (OP_ADD - 4))
                            | (1usize << (OP_SUB - 4))
                            | (1usize << (OP_MUL - 4))
                            | (1usize << (OP_REM - 4))
                            | (1usize << (OP_LAST - 4))))
                        != 0)
                    || (((_la - 69) & !0x3f) == 0
                        && ((1usize << (_la - 69))
                            & ((1usize << (OP_AND - 69))
                                | (1usize << (OP_AT - 69))
                                | (1usize << (OP_HASH - 69))
                                | (1usize << (LAMBDA_SLOT - 69))
                                | (1usize << (OP_NOT - 69))
                                | (1usize << (OP_DOT3 - 69))
                                | (1usize << (OP_DOT2 - 69))
                                | (1usize << (OP_INVERSE - 69))
                                | (1usize << (OP_ROOT2 - 69))
                                | (1usize << (OP_ROOT3 - 69))))
                            != 0)
                    || (((_la - 101) & !0x3f) == 0
                        && ((1usize << (_la - 101))
                            & ((1usize << (OP_ROOT4 - 101))
                                | (1usize << (OP_REFERENCE - 101))
                                | (1usize << (OP_LABEL - 101))
                                | (1usize << (KW_TYPE - 101))
                                | (1usize << (KW_WHILE - 101))
                                | (1usize << (KW_FOR - 101))
                                | (1usize << (KW_LET - 101))
                                | (1usize << (KW_NEW - 101))
                                | (1usize << (KW_OBJECT - 101))
                                | (1usize << (KW_LAMBDA - 101))
                                | (1usize << (KW_TRY - 101))
                                | (1usize << (KW_MATCH - 101))
                                | (1usize << (KW_CATCH - 101))
                                | (1usize << (INTEGER - 101))))
                            != 0)
                    || (((_la - 133) & !0x3f) == 0
                        && ((1usize << (_la - 133))
                            & ((1usize << (DECIMAL - 133))
                                | (1usize << (STRING_SINGLE - 133))
                                | (1usize << (STRING_DOUBLE - 133))
                                | (1usize << (STRING_BLOCK - 133))
                                | (1usize << (KW_IF - 133))
                                | (1usize << (RETURN - 133))
                                | (1usize << (RESUME - 133))
                                | (1usize << (YIELD - 133))
                                | (1usize << (BREAK - 133))
                                | (1usize << (CONTINUE - 133))
                                | (1usize << (RAISE - 133))
                                | (1usize << (SPECIAL - 133))
                                | (1usize << (RAW_ID - 133))
                                | (1usize << (UNICODE_ID - 133))))
                            != 0)
                {
                    {
                        recog.base.set_state(783);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(102, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule define_type */
                                    recog.base.set_state(777);
                                    recog.define_type()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule let_binding */
                                    recog.base.set_state(778);
                                    recog.let_binding()?;
                                }
                            }
                            3 => {
                                {
                                    /* InvokeRule loop_statement */
                                    recog.base.set_state(779);
                                    recog.loop_statement()?;
                                }
                            }
                            4 => {
                                {
                                    /* InvokeRule guard_statement */
                                    recog.base.set_state(780);
                                    recog.guard_statement()?;
                                }
                            }
                            5 => {
                                {
                                    /* InvokeRule expression_root */
                                    recog.base.set_state(781);
                                    recog.expression_root()?;
                                }
                            }
                            6 => {
                                {
                                    /* InvokeRule eos */
                                    recog.base.set_state(782);
                                    recog.eos()?;
                                }
                            }

                            _ => {}
                        }
                    }
                    recog.base.set_state(787);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(788);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_binding ----------------
pub type Let_bindingContextAll<'input> = Let_bindingContext<'input>;

pub type Let_bindingContext<'input> = BaseParserRuleContext<'input, Let_bindingContextExt<'input>>;

#[derive(Clone)]
pub struct Let_bindingContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_bindingContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_bindingContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_binding(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_binding(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_bindingContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_binding(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_bindingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_binding
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_binding }
}
antlr_rust::tid! {Let_bindingContextExt<'a>}

impl<'input> Let_bindingContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_bindingContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_bindingContextExt { ph: PhantomData }))
    }
}

pub trait Let_bindingContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_bindingContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn expression_root(&self) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Let_bindingContextAttrs<'input> for Let_bindingContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_binding(&mut self) -> Result<Rc<Let_bindingContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_bindingContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_let_binding);
        let mut _localctx: Rc<Let_bindingContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(793);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(790);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(795);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(796);
                recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                /* InvokeRule let_pattern */
                recog.base.set_state(797);
                recog.let_pattern()?;

                recog.base.set_state(799);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(798);
                        recog.type_hint()?;
                    }
                }

                recog.base.set_state(803);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_ASSIGN {
                    {
                        recog.base.set_state(801);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule expression_root */
                        recog.base.set_state(802);
                        recog.expression_root()?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern ----------------
pub type Let_patternContextAll<'input> = Let_patternContext<'input>;

pub type Let_patternContext<'input> = BaseParserRuleContext<'input, Let_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Let_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern }
}
antlr_rust::tid! {Let_patternContextExt<'a>}

impl<'input> Let_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_patternContextExt { ph: PhantomData }))
    }
}

pub trait Let_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_patternContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_plain(&self) -> Option<Rc<Let_pattern_plainContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Let_patternContextAttrs<'input> for Let_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern(&mut self) -> Result<Rc<Let_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_let_pattern);
        let mut _localctx: Rc<Let_patternContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(807);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(107, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(805);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule let_pattern_plain */
                        recog.base.set_state(806);
                        recog.let_pattern_plain()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_plain ----------------
pub type Let_pattern_plainContextAll<'input> = Let_pattern_plainContext<'input>;

pub type Let_pattern_plainContext<'input> = BaseParserRuleContext<'input, Let_pattern_plainContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_plainContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_plainContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_plain(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_plain(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_plainContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_plain(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_plainContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_plain
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_plain }
}
antlr_rust::tid! {Let_pattern_plainContextExt<'a>}

impl<'input> Let_pattern_plainContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_plainContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_plainContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_plainContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_plainContextExt<'input>>
{
    fn modified_identifier_all(&self) -> Vec<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn modified_identifier(&self, i: usize) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Let_pattern_plainContextAttrs<'input> for Let_pattern_plainContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_plain(&mut self) -> Result<Rc<Let_pattern_plainContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_plainContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_let_pattern_plain);
        let mut _localctx: Rc<Let_pattern_plainContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule modified_identifier */
                recog.base.set_state(809);
                recog.modified_identifier()?;

                recog.base.set_state(814);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(108, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(810);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                /* InvokeRule modified_identifier */
                                recog.base.set_state(811);
                                recog.modified_identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(816);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(108, &mut recog.base)?;
                }
                recog.base.set_state(818);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COMMA {
                    {
                        recog.base.set_state(817);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                    }
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_tuple ----------------
pub type Let_pattern_tupleContextAll<'input> = Let_pattern_tupleContext<'input>;

pub type Let_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Let_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_tuple }
}
antlr_rust::tid! {Let_pattern_tupleContextExt<'a>}

impl<'input> Let_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Let_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Let_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn let_pattern_item_all(&self) -> Vec<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn let_pattern_item(&self, i: usize) -> Option<Rc<Let_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
}

impl<'input> Let_pattern_tupleContextAttrs<'input> for Let_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_tuple(&mut self) -> Result<Rc<Let_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_let_pattern_tuple);
        let mut _localctx: Rc<Let_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(890);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(124, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(820);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(834);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(112, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(821);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(822);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                }
                            }

                            x if x == 2 => {
                                {
                                    /* InvokeRule let_pattern_item */
                                    recog.base.set_state(824);
                                    recog.let_pattern_item()?;

                                    recog.base.set_state(827);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = 1;
                                    loop {
                                        match _alt {
                                            x if x == 1 => {
                                                {
                                                    recog.base.set_state(825);
                                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                    /* InvokeRule let_pattern_item */
                                                    recog.base.set_state(826);
                                                    recog.let_pattern_item()?;
                                                }
                                            }

                                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                        }
                                        recog.base.set_state(829);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = recog.interpreter.adaptive_predict(110, &mut recog.base)?;
                                        if _alt == 2 || _alt == INVALID_ALT {
                                            break;
                                        }
                                    }
                                    recog.base.set_state(832);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _la = recog.base.input.la(1);
                                    if _la == COMMA {
                                        {
                                            recog.base.set_state(831);
                                            recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                        }
                                    }
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(836);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(837);
                        recog.namepath()?;

                        recog.base.set_state(838);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(850);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DOT2
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(839);
                                recog.let_pattern_item()?;

                                recog.base.set_state(844);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(113, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(840);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(841);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(846);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(113, &mut recog.base)?;
                                }
                                recog.base.set_state(848);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(847);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(852);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(855);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(854);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(857);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(869);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DOT2
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(858);
                                recog.let_pattern_item()?;

                                recog.base.set_state(863);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(117, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(859);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(860);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(865);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(117, &mut recog.base)?;
                                }
                                recog.base.set_state(867);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(866);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(871);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(873);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(872);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(875);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(887);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la) & !0x3f) == 0
                            && ((1usize << _la) & ((1usize << PARENTHESES_L) | (1usize << BRACKET_L) | (1usize << BRACE_L)))
                                != 0)
                            || _la == OP_DOT2
                            || _la == RAW_ID
                            || _la == UNICODE_ID
                        {
                            {
                                /* InvokeRule let_pattern_item */
                                recog.base.set_state(876);
                                recog.let_pattern_item()?;

                                recog.base.set_state(881);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(121, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(877);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule let_pattern_item */
                                                recog.base.set_state(878);
                                                recog.let_pattern_item()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(883);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(121, &mut recog.base)?;
                                }
                                recog.base.set_state(885);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(884);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(889);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- let_pattern_item ----------------
pub type Let_pattern_itemContextAll<'input> = Let_pattern_itemContext<'input>;

pub type Let_pattern_itemContext<'input> = BaseParserRuleContext<'input, Let_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Let_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Let_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_let_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_let_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Let_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_let_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Let_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_let_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_let_pattern_item }
}
antlr_rust::tid! {Let_pattern_itemContextExt<'a>}

impl<'input> Let_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Let_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Let_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Let_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Let_pattern_itemContextExt<'input>>
{
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT2
    /// Returns `None` if there is no child corresponding to token OP_DOT2
    fn OP_DOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT2, 0)
    }
}

impl<'input> Let_pattern_itemContextAttrs<'input> for Let_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn let_pattern_item(&mut self) -> Result<Rc<Let_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Let_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_let_pattern_item);
        let mut _localctx: Rc<Let_pattern_itemContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(922);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(131, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(895);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(125, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(892);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(893);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(900);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(126, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(897);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(898);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule let_pattern_tuple */
                        recog.base.set_state(902);
                        recog.let_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(906);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(127, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule modified_identifier */
                                    recog.base.set_state(903);
                                    recog.modified_identifier()?;

                                    recog.base.set_state(904);
                                    recog.base.match_token(COLON, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(911);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(128, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(908);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(909);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule identifier */
                        recog.base.set_state(913);
                        recog.identifier()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(915);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule modified_identifier */
                                recog.base.set_state(914);
                                recog.modified_identifier()?;
                            }
                        }

                        recog.base.set_state(917);
                        recog.base.match_token(OP_DOT2, &mut recog.err_handler)?;

                        recog.base.set_state(919);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(918);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Let_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());
                            }
                        }
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(921);
                        recog.modified_identifier()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_type ----------------
pub type Define_typeContextAll<'input> = Define_typeContext<'input>;

pub type Define_typeContext<'input> = BaseParserRuleContext<'input, Define_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Define_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_type }
}
antlr_rust::tid! {Define_typeContextExt<'a>}

impl<'input> Define_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_typeContextExt { ph: PhantomData }))
    }
}

pub trait Define_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_typeContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn template_block(&self) -> Option<Rc<Template_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_typeContextAttrs<'input> for Define_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_type(&mut self) -> Result<Rc<Define_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_define_type);
        let mut _localctx: Rc<Define_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(953);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(136, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(927);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(924);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(929);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(930);
                        recog.modifiers()?;

                        recog.base.set_state(931);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(932);
                        recog.identifier()?;

                        recog.base.set_state(934);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule define_generic */
                                recog.base.set_state(933);
                                recog.define_generic()?;
                            }
                        }

                        recog.base.set_state(936);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(937);
                        recog.type_expression_rec(0)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(942);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(939);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(944);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(945);
                        recog.modifiers()?;

                        recog.base.set_state(946);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(947);
                        recog.identifier()?;

                        recog.base.set_state(949);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule define_generic */
                                recog.base.set_state(948);
                                recog.define_generic()?;
                            }
                        }

                        /* InvokeRule template_block */
                        recog.base.set_state(951);
                        recog.template_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- type_hint ----------------
pub type Type_hintContextAll<'input> = Type_hintContext<'input>;

pub type Type_hintContext<'input> = BaseParserRuleContext<'input, Type_hintContextExt<'input>>;

#[derive(Clone)]
pub struct Type_hintContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_hintContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_hintContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_type_hint(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_type_hint(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_hintContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_type_hint(self);
    }
}

impl<'input> CustomRuleContext<'input> for Type_hintContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_hint
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_hint }
}
antlr_rust::tid! {Type_hintContextExt<'a>}

impl<'input> Type_hintContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_hintContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Type_hintContextExt { ph: PhantomData }))
    }
}

pub trait Type_hintContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Type_hintContextExt<'input>> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
}

impl<'input> Type_hintContextAttrs<'input> for Type_hintContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_hint(&mut self) -> Result<Rc<Type_hintContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Type_hintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_type_hint);
        let mut _localctx: Rc<Type_hintContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(955);
                _la = recog.base.input.la(1);
                if { !(_la == COLON || _la == OP_ARROW) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                /* InvokeRule type_expression */
                recog.base.set_state(956);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- effect_hint ----------------
pub type Effect_hintContextAll<'input> = Effect_hintContext<'input>;

pub type Effect_hintContext<'input> = BaseParserRuleContext<'input, Effect_hintContextExt<'input>>;

#[derive(Clone)]
pub struct Effect_hintContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Effect_hintContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Effect_hintContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_effect_hint(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_effect_hint(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Effect_hintContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_effect_hint(self);
    }
}

impl<'input> CustomRuleContext<'input> for Effect_hintContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_effect_hint
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_effect_hint }
}
antlr_rust::tid! {Effect_hintContextExt<'a>}

impl<'input> Effect_hintContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Effect_hintContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Effect_hintContextExt { ph: PhantomData }))
    }
}

pub trait Effect_hintContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Effect_hintContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Effect_hintContextAttrs<'input> for Effect_hintContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn effect_hint(&mut self) -> Result<Rc<Effect_hintContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Effect_hintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_effect_hint);
        let mut _localctx: Rc<Effect_hintContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(958);
                recog.base.match_token(OP_DIV, &mut recog.err_handler)?;

                /* InvokeRule type_expression */
                recog.base.set_state(959);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_statement ----------------
pub type If_statementContextAll<'input> = If_statementContext<'input>;

pub type If_statementContext<'input> = BaseParserRuleContext<'input, If_statementContextExt<'input>>;

#[derive(Clone)]
pub struct If_statementContextExt<'input> {
    pub then_block: Option<Rc<Function_blockContextAll<'input>>>,
    pub else_block: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_statement }
}
antlr_rust::tid! {If_statementContextExt<'a>}

impl<'input> If_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            If_statementContextExt { then_block: None, else_block: None, ph: PhantomData },
        ))
    }
}

pub trait If_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<If_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block_all(&self) -> Vec<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn function_block(&self, i: usize) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn else_if_statement_all(&self) -> Vec<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn else_if_statement(&self, i: usize) -> Option<Rc<Else_if_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
}

impl<'input> If_statementContextAttrs<'input> for If_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_statement(&mut self) -> Result<Rc<If_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_if_statement);
        let mut _localctx: Rc<If_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(964);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(961);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(966);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(967);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(968);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(969);
                let tmp = recog.function_block()?;
                cast_mut::<_, If_statementContext>(&mut _localctx).then_block = Some(tmp.clone());

                recog.base.set_state(973);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(138, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule else_if_statement */
                                recog.base.set_state(970);
                                recog.else_if_statement()?;
                            }
                        }
                    }
                    recog.base.set_state(975);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(138, &mut recog.base)?;
                }
                recog.base.set_state(978);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(139, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            recog.base.set_state(976);
                            recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                            /* InvokeRule function_block */
                            recog.base.set_state(977);
                            let tmp = recog.function_block()?;
                            cast_mut::<_, If_statementContext>(&mut _localctx).else_block = Some(tmp.clone());
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- guard_statement ----------------
pub type Guard_statementContextAll<'input> = Guard_statementContext<'input>;

pub type Guard_statementContext<'input> = BaseParserRuleContext<'input, Guard_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Guard_statementContextExt<'input> {
    pub then: Option<Rc<Function_blockContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Guard_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Guard_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_guard_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_guard_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Guard_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_guard_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Guard_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_guard_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_guard_statement }
}
antlr_rust::tid! {Guard_statementContextExt<'a>}

impl<'input> Guard_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Guard_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Guard_statementContextExt { then: None, ph: PhantomData },
        ))
    }
}

pub trait Guard_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Guard_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn let_pattern_tuple(&self) -> Option<Rc<Let_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Guard_statementContextAttrs<'input> for Guard_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn guard_statement(&mut self) -> Result<Rc<Guard_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Guard_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_guard_statement);
        let mut _localctx: Rc<Guard_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1008);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(143, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(983);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(980);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(985);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(986);
                        recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                        recog.base.set_state(987);
                        _la = recog.base.input.la(1);
                        if { !(_la == KW_NOT || _la == KW_LET) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        recog.base.set_state(991);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(141, &mut recog.base)? {
                            1 => {
                                {
                                    /* InvokeRule let_pattern_tuple */
                                    recog.base.set_state(988);
                                    recog.let_pattern_tuple()?;
                                }
                            }
                            2 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(989);
                                    recog.identifier()?;
                                }
                            }
                            3 => {
                                recog.base.set_state(990);
                                recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                            }

                            _ => {}
                        }
                        recog.base.set_state(993);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(994);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(995);
                        let tmp = recog.function_block()?;
                        cast_mut::<_, Guard_statementContext>(&mut _localctx).then = Some(tmp.clone());
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1000);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(997);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1002);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1003);
                        recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                        recog.base.set_state(1004);
                        _la = recog.base.input.la(1);
                        if { !(_la == KW_NOT || _la == KW_LET) } {
                            recog.err_handler.recover_inline(&mut recog.base)?;
                        }
                        else {
                            if recog.base.input.la(1) == TOKEN_EOF {
                                recog.base.matched_eof = true
                            };
                            recog.err_handler.report_match(&mut recog.base);
                            recog.base.consume(&mut recog.err_handler);
                        }
                        /* InvokeRule inline_expression */
                        recog.base.set_state(1005);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(1006);
                        let tmp = recog.function_block()?;
                        cast_mut::<_, Guard_statementContext>(&mut _localctx).then = Some(tmp.clone());
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- else_if_statement ----------------
pub type Else_if_statementContextAll<'input> = Else_if_statementContext<'input>;

pub type Else_if_statementContext<'input> = BaseParserRuleContext<'input, Else_if_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Else_if_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Else_if_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Else_if_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_else_if_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_else_if_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Else_if_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_else_if_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Else_if_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_else_if_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_else_if_statement }
}
antlr_rust::tid! {Else_if_statementContextExt<'a>}

impl<'input> Else_if_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Else_if_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Else_if_statementContextExt { ph: PhantomData }))
    }
}

pub trait Else_if_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Else_if_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Else_if_statementContextAttrs<'input> for Else_if_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn else_if_statement(&mut self) -> Result<Rc<Else_if_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Else_if_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_else_if_statement);
        let mut _localctx: Rc<Else_if_statementContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1010);
                recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                recog.base.set_state(1011);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(1012);
                recog.inline_expression_rec(0)?;

                /* InvokeRule function_block */
                recog.base.set_state(1013);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- loop_statement ----------------
#[derive(Debug)]
pub enum Loop_statementContextAll<'input> {
    ForLoopContext(ForLoopContext<'input>),
    WhileLetContext(WhileLetContext<'input>),
    WhileLoopContext(WhileLoopContext<'input>),
    Error(Loop_statementContext<'input>),
}
antlr_rust::tid! {Loop_statementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Loop_statementContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Loop_statementContextAll<'input> {}

impl<'input> Deref for Loop_statementContextAll<'input> {
    type Target = dyn Loop_statementContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Loop_statementContextAll::*;
        match self {
            ForLoopContext(inner) => inner,
            WhileLetContext(inner) => inner,
            WhileLoopContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Loop_statementContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Loop_statementContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Loop_statementContext<'input> = BaseParserRuleContext<'input, Loop_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Loop_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Loop_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Loop_statementContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Loop_statementContext<'input> {}

impl<'input> CustomRuleContext<'input> for Loop_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}
antlr_rust::tid! {Loop_statementContextExt<'a>}

impl<'input> Loop_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Loop_statementContextExt { ph: PhantomData },
        )))
    }
}

pub trait Loop_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Loop_statementContextExt<'input>>
{
}

impl<'input> Loop_statementContextAttrs<'input> for Loop_statementContext<'input> {}

pub type ForLoopContext<'input> = BaseParserRuleContext<'input, ForLoopContextExt<'input>>;

pub trait ForLoopContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_FOR
    /// Returns `None` if there is no child corresponding to token KW_FOR
    fn KW_FOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_FOR, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn infix_in(&self) -> Option<Rc<Infix_inContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
}

impl<'input> ForLoopContextAttrs<'input> for ForLoopContext<'input> {}

pub struct ForLoopContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    pub cond: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub guard: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ForLoopContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ForLoopContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ForLoopContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ForLoop(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ForLoop(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ForLoopContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ForLoop(self);
    }
}

impl<'input> CustomRuleContext<'input> for ForLoopContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for ForLoopContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for ForLoopContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for ForLoopContext<'input> {}

impl<'input> ForLoopContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::ForLoopContext(BaseParserRuleContext::copy_from(
            ctx,
            ForLoopContextExt { cond: None, guard: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type WhileLetContext<'input> = BaseParserRuleContext<'input, WhileLetContextExt<'input>>;

pub trait WhileLetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_LET
    /// Returns `None` if there is no child corresponding to token KW_LET
    fn KW_LET(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_LET, 0)
    }
    fn let_pattern(&self) -> Option<Rc<Let_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileLetContextAttrs<'input> for WhileLetContext<'input> {}

pub struct WhileLetContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileLetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileLetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileLetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileLet(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileLet(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileLetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileLet(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileLetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for WhileLetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for WhileLetContext<'input> {}

impl<'input> WhileLetContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::WhileLetContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileLetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type WhileLoopContext<'input> = BaseParserRuleContext<'input, WhileLoopContextExt<'input>>;

pub trait WhileLoopContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHILE
    /// Returns `None` if there is no child corresponding to token KW_WHILE
    fn KW_WHILE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHILE, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> WhileLoopContextAttrs<'input> for WhileLoopContext<'input> {}

pub struct WhileLoopContextExt<'input> {
    base: Loop_statementContextExt<'input>,
    pub cond: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {WhileLoopContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for WhileLoopContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for WhileLoopContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_WhileLoop(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_WhileLoop(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for WhileLoopContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_WhileLoop(self);
    }
}

impl<'input> CustomRuleContext<'input> for WhileLoopContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_loop_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_loop_statement }
}

impl<'input> Borrow<Loop_statementContextExt<'input>> for WhileLoopContext<'input> {
    fn borrow(&self) -> &Loop_statementContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Loop_statementContextExt<'input>> for WhileLoopContext<'input> {
    fn borrow_mut(&mut self) -> &mut Loop_statementContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Loop_statementContextAttrs<'input> for WhileLoopContext<'input> {}

impl<'input> WhileLoopContextExt<'input> {
    fn new(ctx: &dyn Loop_statementContextAttrs<'input>) -> Rc<Loop_statementContextAll<'input>> {
        Rc::new(Loop_statementContextAll::WhileLoopContext(BaseParserRuleContext::copy_from(
            ctx,
            WhileLoopContextExt { cond: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn loop_statement(&mut self) -> Result<Rc<Loop_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Loop_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_loop_statement);
        let mut _localctx: Rc<Loop_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1054);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(148, &mut recog.base)? {
                1 => {
                    let tmp = WhileLoopContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1018);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1015);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1020);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1021);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1022);
                        let tmp = recog.inline_expression_rec(0)?;
                        if let Loop_statementContextAll::WhileLoopContext(ctx) =
                            cast_mut::<_, Loop_statementContextAll>(&mut _localctx)
                        {
                            ctx.cond = Some(tmp.clone());
                        }
                        else {
                            unreachable!("cant cast");
                        }

                        /* InvokeRule function_block */
                        recog.base.set_state(1023);
                        recog.function_block()?;
                    }
                }
                2 => {
                    let tmp = WhileLetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1028);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1025);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1030);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1031);
                        recog.base.match_token(KW_WHILE, &mut recog.err_handler)?;

                        recog.base.set_state(1032);
                        recog.base.match_token(KW_LET, &mut recog.err_handler)?;

                        /* InvokeRule let_pattern */
                        recog.base.set_state(1033);
                        recog.let_pattern()?;

                        recog.base.set_state(1034);
                        recog.base.match_token(OP_ASSIGN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1035);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule function_block */
                        recog.base.set_state(1036);
                        recog.function_block()?;
                    }
                }
                3 => {
                    let tmp = ForLoopContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1041);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1038);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1043);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1044);
                        recog.base.match_token(KW_FOR, &mut recog.err_handler)?;

                        /* InvokeRule let_pattern */
                        recog.base.set_state(1045);
                        recog.let_pattern()?;

                        /* InvokeRule infix_in */
                        recog.base.set_state(1046);
                        recog.infix_in()?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1047);
                        let tmp = recog.inline_expression_rec(0)?;
                        if let Loop_statementContextAll::ForLoopContext(ctx) =
                            cast_mut::<_, Loop_statementContextAll>(&mut _localctx)
                        {
                            ctx.cond = Some(tmp.clone());
                        }
                        else {
                            unreachable!("cant cast");
                        }

                        recog.base.set_state(1050);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1048);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1049);
                                let tmp = recog.inline_expression_rec(0)?;
                                if let Loop_statementContextAll::ForLoopContext(ctx) =
                                    cast_mut::<_, Loop_statementContextAll>(&mut _localctx)
                                {
                                    ctx.guard = Some(tmp.clone());
                                }
                                else {
                                    unreachable!("cant cast");
                                }
                            }
                        }

                        /* InvokeRule function_block */
                        recog.base.set_state(1052);
                        recog.function_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- if_guard ----------------
pub type If_guardContextAll<'input> = If_guardContext<'input>;

pub type If_guardContext<'input> = BaseParserRuleContext<'input, If_guardContextExt<'input>>;

#[derive(Clone)]
pub struct If_guardContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for If_guardContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for If_guardContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_if_guard(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_if_guard(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for If_guardContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_if_guard(self);
    }
}

impl<'input> CustomRuleContext<'input> for If_guardContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_if_guard
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_if_guard }
}
antlr_rust::tid! {If_guardContextExt<'a>}

impl<'input> If_guardContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<If_guardContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, If_guardContextExt { ph: PhantomData }))
    }
}

pub trait If_guardContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<If_guardContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> If_guardContextAttrs<'input> for If_guardContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn if_guard(&mut self) -> Result<Rc<If_guardContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = If_guardContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_if_guard);
        let mut _localctx: Rc<If_guardContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1056);
                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                /* InvokeRule inline_expression */
                recog.base.set_state(1057);
                recog.inline_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression_root ----------------
pub type Expression_rootContextAll<'input> = Expression_rootContext<'input>;

pub type Expression_rootContext<'input> = BaseParserRuleContext<'input, Expression_rootContextExt<'input>>;

#[derive(Clone)]
pub struct Expression_rootContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Expression_rootContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Expression_rootContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_expression_root(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_expression_root(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Expression_rootContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_expression_root(self);
    }
}

impl<'input> CustomRuleContext<'input> for Expression_rootContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression_root
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression_root }
}
antlr_rust::tid! {Expression_rootContextExt<'a>}

impl<'input> Expression_rootContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Expression_rootContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Expression_rootContextExt { ph: PhantomData }))
    }
}

pub trait Expression_rootContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Expression_rootContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    fn eos(&self) -> Option<Rc<EosContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Expression_rootContextAttrs<'input> for Expression_rootContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression_root(&mut self) -> Result<Rc<Expression_rootContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Expression_rootContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_expression_root);
        let mut _localctx: Rc<Expression_rootContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1062);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(149, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule annotation */
                                recog.base.set_state(1059);
                                recog.annotation()?;
                            }
                        }
                    }
                    recog.base.set_state(1064);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(149, &mut recog.base)?;
                }
                /* InvokeRule expression */
                recog.base.set_state(1065);
                recog.expression_rec(0)?;

                recog.base.set_state(1067);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AND_THEN {
                    {
                        recog.base.set_state(1066);
                        recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                    }
                }

                recog.base.set_state(1070);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(151, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule eos */
                            recog.base.set_state(1069);
                            recog.eos()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- expression ----------------
#[derive(Debug)]
pub enum ExpressionContextAll<'input> {
    EIfContext(EIfContext<'input>),
    EUntilContext(EUntilContext<'input>),
    EInContext(EInContext<'input>),
    EFloorContext(EFloorContext<'input>),
    EPlusContext(EPlusContext<'input>),
    ESliceContext(ESliceContext<'input>),
    EDotMatchContext(EDotMatchContext<'input>),
    ETryContext(ETryContext<'input>),
    EAsContext(EAsContext<'input>),
    EObjectContext(EObjectContext<'input>),
    ETupleContext(ETupleContext<'input>),
    ERangeContext(ERangeContext<'input>),
    EAssignContext(EAssignContext<'input>),
    EAtomContext(EAtomContext<'input>),
    EMulContext(EMulContext<'input>),
    EPipeContext(EPipeContext<'input>),
    ELambdaContext(ELambdaContext<'input>),
    EOrElseContext(EOrElseContext<'input>),
    EGroupContext(EGroupContext<'input>),
    EFunctionContext(EFunctionContext<'input>),
    ESuffixContext(ESuffixContext<'input>),
    EClosureContext(EClosureContext<'input>),
    EMatchContext(EMatchContext<'input>),
    EMacroContext(EMacroContext<'input>),
    EPrefixContext(EPrefixContext<'input>),
    ECompareContext(ECompareContext<'input>),
    EGenericContext(EGenericContext<'input>),
    EIsAContext(EIsAContext<'input>),
    EPowContext(EPowContext<'input>),
    EDefineContext(EDefineContext<'input>),
    EMapContext(EMapContext<'input>),
    ELogicContext(ELogicContext<'input>),
    EControlContext(EControlContext<'input>),
    ENewContext(ENewContext<'input>),
    ECeilingContext(ECeilingContext<'input>),
    Error(ExpressionContext<'input>),
}
antlr_rust::tid! {ExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ExpressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContextAll<'input> {}

impl<'input> Deref for ExpressionContextAll<'input> {
    type Target = dyn ExpressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use ExpressionContextAll::*;
        match self {
            EIfContext(inner) => inner,
            EUntilContext(inner) => inner,
            EInContext(inner) => inner,
            EFloorContext(inner) => inner,
            EPlusContext(inner) => inner,
            ESliceContext(inner) => inner,
            EDotMatchContext(inner) => inner,
            ETryContext(inner) => inner,
            EAsContext(inner) => inner,
            EObjectContext(inner) => inner,
            ETupleContext(inner) => inner,
            ERangeContext(inner) => inner,
            EAssignContext(inner) => inner,
            EAtomContext(inner) => inner,
            EMulContext(inner) => inner,
            EPipeContext(inner) => inner,
            ELambdaContext(inner) => inner,
            EOrElseContext(inner) => inner,
            EGroupContext(inner) => inner,
            EFunctionContext(inner) => inner,
            ESuffixContext(inner) => inner,
            EClosureContext(inner) => inner,
            EMatchContext(inner) => inner,
            EMacroContext(inner) => inner,
            EPrefixContext(inner) => inner,
            ECompareContext(inner) => inner,
            EGenericContext(inner) => inner,
            EIsAContext(inner) => inner,
            EPowContext(inner) => inner,
            EDefineContext(inner) => inner,
            EMapContext(inner) => inner,
            ELogicContext(inner) => inner,
            EControlContext(inner) => inner,
            ENewContext(inner) => inner,
            ECeilingContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type ExpressionContext<'input> = BaseParserRuleContext<'input, ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ExpressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ExpressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ExpressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid! {ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ExpressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait ExpressionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ExpressionContextExt<'input>> {}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input> {}

pub type EIfContext<'input> = BaseParserRuleContext<'input, EIfContextExt<'input>>;

pub trait EIfContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn if_statement(&self) -> Option<Rc<If_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EIfContextAttrs<'input> for EIfContext<'input> {}

pub struct EIfContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EIfContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EIfContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EIfContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIf(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIf(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EIfContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIf(self);
    }
}

impl<'input> CustomRuleContext<'input> for EIfContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EIfContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EIfContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EIfContext<'input> {}

impl<'input> EIfContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EIfContext(BaseParserRuleContext::copy_from(
            ctx,
            EIfContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EUntilContext<'input> = BaseParserRuleContext<'input, EUntilContextExt<'input>>;

pub trait EUntilContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_range(&self) -> Option<Rc<Infix_rangeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EUntilContextAttrs<'input> for EUntilContext<'input> {}

pub struct EUntilContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EUntilContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EUntilContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EUntilContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EUntil(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EUntil(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EUntilContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EUntil(self);
    }
}

impl<'input> CustomRuleContext<'input> for EUntilContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EUntilContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EUntilContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EUntilContext<'input> {}

impl<'input> EUntilContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EUntilContext(BaseParserRuleContext::copy_from(
            ctx,
            EUntilContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EInContext<'input> = BaseParserRuleContext<'input, EInContextExt<'input>>;

pub trait EInContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_in(&self) -> Option<Rc<Infix_inContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EInContextAttrs<'input> for EInContext<'input> {}

pub struct EInContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EInContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EInContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EInContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIn(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIn(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EInContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIn(self);
    }
}

impl<'input> CustomRuleContext<'input> for EInContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EInContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EInContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EInContext<'input> {}

impl<'input> EInContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EInContext(BaseParserRuleContext::copy_from(
            ctx,
            EInContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EFloorContext<'input> = BaseParserRuleContext<'input, EFloorContextExt<'input>>;

pub trait EFloorContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token FLOOR_L
    /// Returns `None` if there is no child corresponding to token FLOOR_L
    fn FLOOR_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FLOOR_R
    /// Returns `None` if there is no child corresponding to token FLOOR_R
    fn FLOOR_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_R, 0)
    }
}

impl<'input> EFloorContextAttrs<'input> for EFloorContext<'input> {}

pub struct EFloorContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EFloorContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EFloorContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EFloorContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EFloor(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EFloor(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EFloorContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EFloor(self);
    }
}

impl<'input> CustomRuleContext<'input> for EFloorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EFloorContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EFloorContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EFloorContext<'input> {}

impl<'input> EFloorContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EFloorContext(BaseParserRuleContext::copy_from(
            ctx,
            EFloorContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPlusContext<'input> = BaseParserRuleContext<'input, EPlusContextExt<'input>>;

pub trait EPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPlusContextAttrs<'input> for EPlusContext<'input> {}

pub struct EPlusContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPlusContext<'input> {}

impl<'input> EPlusContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            EPlusContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESliceContext<'input> = BaseParserRuleContext<'input, ESliceContextExt<'input>>;

pub trait ESliceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ESliceContextAttrs<'input> for ESliceContext<'input> {}

pub struct ESliceContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESliceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESliceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESliceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESlice(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESlice(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESliceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESlice(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESliceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESliceContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESliceContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESliceContext<'input> {}

impl<'input> ESliceContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESliceContext(BaseParserRuleContext::copy_from(
            ctx,
            ESliceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDotMatchContext<'input> = BaseParserRuleContext<'input, EDotMatchContextExt<'input>>;

pub trait EDotMatchContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDotMatchContextAttrs<'input> for EDotMatchContext<'input> {}

pub struct EDotMatchContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDotMatchContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDotMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDotMatchContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDotMatch(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDotMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDotMatchContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDotMatch(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDotMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDotMatchContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDotMatchContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDotMatchContext<'input> {}

impl<'input> EDotMatchContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDotMatchContext(BaseParserRuleContext::copy_from(
            ctx,
            EDotMatchContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ETryContext<'input> = BaseParserRuleContext<'input, ETryContextExt<'input>>;

pub trait ETryContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn try_statement(&self) -> Option<Rc<Try_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ETryContextAttrs<'input> for ETryContext<'input> {}

pub struct ETryContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ETryContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ETryContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ETryContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ETry(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ETry(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ETryContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ETry(self);
    }
}

impl<'input> CustomRuleContext<'input> for ETryContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ETryContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ETryContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ETryContext<'input> {}

impl<'input> ETryContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ETryContext(BaseParserRuleContext::copy_from(
            ctx,
            ETryContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAsContext<'input> = BaseParserRuleContext<'input, EAsContextExt<'input>>;

pub trait EAsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_as(&self) -> Option<Rc<Infix_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EAsContextAttrs<'input> for EAsContext<'input> {}

pub struct EAsContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAs(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAsContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAsContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAsContext<'input> {}

impl<'input> EAsContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAsContext(BaseParserRuleContext::copy_from(
            ctx,
            EAsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EObjectContext<'input> = BaseParserRuleContext<'input, EObjectContextExt<'input>>;

pub trait EObjectContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn object_statement(&self) -> Option<Rc<Object_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EObjectContextAttrs<'input> for EObjectContext<'input> {}

pub struct EObjectContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EObjectContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EObjectContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EObjectContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EObject(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EObject(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EObjectContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EObject(self);
    }
}

impl<'input> CustomRuleContext<'input> for EObjectContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EObjectContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EObjectContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EObjectContext<'input> {}

impl<'input> EObjectContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EObjectContext(BaseParserRuleContext::copy_from(
            ctx,
            EObjectContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ETupleContext<'input> = BaseParserRuleContext<'input, ETupleContextExt<'input>>;

pub trait ETupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn tuple_literal(&self) -> Option<Rc<Tuple_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ETupleContextAttrs<'input> for ETupleContext<'input> {}

pub struct ETupleContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ETupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ETupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ETupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ETuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ETuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ETupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ETuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for ETupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ETupleContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ETupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ETupleContext<'input> {}

impl<'input> ETupleContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ETupleContext(BaseParserRuleContext::copy_from(
            ctx,
            ETupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ERangeContext<'input> = BaseParserRuleContext<'input, ERangeContextExt<'input>>;

pub trait ERangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ERangeContextAttrs<'input> for ERangeContext<'input> {}

pub struct ERangeContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ERangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ERangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ERangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ERange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ERange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ERangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ERange(self);
    }
}

impl<'input> CustomRuleContext<'input> for ERangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ERangeContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ERangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ERangeContext<'input> {}

impl<'input> ERangeContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ERangeContext(BaseParserRuleContext::copy_from(
            ctx,
            ERangeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAssignContext<'input> = BaseParserRuleContext<'input, EAssignContextExt<'input>>;

pub trait EAssignContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_assign(&self) -> Option<Rc<Op_assignContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EAssignContextAttrs<'input> for EAssignContext<'input> {}

pub struct EAssignContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAssignContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAssignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAssignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAssign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAssign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAssignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAssign(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAssignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAssignContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAssignContext<'input> {}

impl<'input> EAssignContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAssignContext(BaseParserRuleContext::copy_from(
            ctx,
            EAssignContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EAtomContext<'input> = BaseParserRuleContext<'input, EAtomContextExt<'input>>;

pub trait EAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EAtomContextAttrs<'input> for EAtomContext<'input> {}

pub struct EAtomContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for EAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EAtomContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EAtomContext<'input> {}

impl<'input> EAtomContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            EAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMulContext<'input> = BaseParserRuleContext<'input, EMulContextExt<'input>>;

pub trait EMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EMulContextAttrs<'input> for EMulContext<'input> {}

pub struct EMulContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMulContext<'input> {}

impl<'input> EMulContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMulContext(BaseParserRuleContext::copy_from(
            ctx,
            EMulContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPipeContext<'input> = BaseParserRuleContext<'input, EPipeContextExt<'input>>;

pub trait EPipeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_pipeline(&self) -> Option<Rc<Op_pipelineContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPipeContextAttrs<'input> for EPipeContext<'input> {}

pub struct EPipeContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPipeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPipeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPipeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPipe(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPipe(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPipeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPipe(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPipeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPipeContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPipeContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPipeContext<'input> {}

impl<'input> EPipeContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPipeContext(BaseParserRuleContext::copy_from(
            ctx,
            EPipeContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELambdaContext<'input> = BaseParserRuleContext<'input, ELambdaContextExt<'input>>;

pub trait ELambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_lambda(&self) -> Option<Rc<Define_lambdaContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ELambdaContextAttrs<'input> for ELambdaContext<'input> {}

pub struct ELambdaContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELambdaContext<'input> {}

impl<'input> ELambdaContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            ELambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EOrElseContext<'input> = BaseParserRuleContext<'input, EOrElseContextExt<'input>>;

pub trait EOrElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OP_OR_ELSE
    /// Returns `None` if there is no child corresponding to token OP_OR_ELSE
    fn OP_OR_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR_ELSE, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn op_assign(&self) -> Option<Rc<Op_assignContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EOrElseContextAttrs<'input> for EOrElseContext<'input> {}

pub struct EOrElseContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Op_assignContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EOrElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EOrElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EOrElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EOrElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EOrElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EOrElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EOrElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for EOrElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EOrElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EOrElseContext<'input> {}

impl<'input> EOrElseContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EOrElseContext(BaseParserRuleContext::copy_from(
            ctx,
            EOrElseContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EGroupContext<'input> = BaseParserRuleContext<'input, EGroupContextExt<'input>>;

pub trait EGroupContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
}

impl<'input> EGroupContextAttrs<'input> for EGroupContext<'input> {}

pub struct EGroupContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EGroupContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EGroupContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EGroupContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EGroup(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EGroup(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EGroupContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EGroup(self);
    }
}

impl<'input> CustomRuleContext<'input> for EGroupContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EGroupContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EGroupContext<'input> {}

impl<'input> EGroupContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EGroupContext(BaseParserRuleContext::copy_from(
            ctx,
            EGroupContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EFunctionContext<'input> = BaseParserRuleContext<'input, EFunctionContextExt<'input>>;

pub trait EFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EFunctionContextAttrs<'input> for EFunctionContext<'input> {}

pub struct EFunctionContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for EFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EFunctionContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EFunctionContext<'input> {}

impl<'input> EFunctionContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            EFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ESuffixContext<'input> = BaseParserRuleContext<'input, ESuffixContextExt<'input>>;

pub trait ESuffixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn op_suffix(&self) -> Option<Rc<Op_suffixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ESuffixContextAttrs<'input> for ESuffixContext<'input> {}

pub struct ESuffixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ESuffixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ESuffixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ESuffixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ESuffix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ESuffix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ESuffixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ESuffix(self);
    }
}

impl<'input> CustomRuleContext<'input> for ESuffixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ESuffixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ESuffixContext<'input> {}

impl<'input> ESuffixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ESuffixContext(BaseParserRuleContext::copy_from(
            ctx,
            ESuffixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EClosureContext<'input> = BaseParserRuleContext<'input, EClosureContextExt<'input>>;

pub trait EClosureContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token DOT
    /// Returns `None` if there is no child corresponding to token DOT
    fn DOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, 0)
    }
}

impl<'input> EClosureContextAttrs<'input> for EClosureContext<'input> {}

pub struct EClosureContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EClosureContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EClosureContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EClosureContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EClosure(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EClosure(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EClosureContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EClosure(self);
    }
}

impl<'input> CustomRuleContext<'input> for EClosureContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EClosureContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EClosureContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EClosureContext<'input> {}

impl<'input> EClosureContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EClosureContext(BaseParserRuleContext::copy_from(
            ctx,
            EClosureContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMatchContext<'input> = BaseParserRuleContext<'input, EMatchContextExt<'input>>;

pub trait EMatchContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn match_statement(&self) -> Option<Rc<Match_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMatchContextAttrs<'input> for EMatchContext<'input> {}

pub struct EMatchContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMatchContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMatchContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMatchContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMatch(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMatch(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMatchContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMatch(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMatchContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMatchContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMatchContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMatchContext<'input> {}

impl<'input> EMatchContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMatchContext(BaseParserRuleContext::copy_from(
            ctx,
            EMatchContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMacroContext<'input> = BaseParserRuleContext<'input, EMacroContextExt<'input>>;

pub trait EMacroContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn macro_call(&self) -> Option<Rc<Macro_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EMacroContextAttrs<'input> for EMacroContext<'input> {}

pub struct EMacroContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMacroContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMacroContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMacroContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMacro(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMacro(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMacroContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMacro(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMacroContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMacroContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMacroContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMacroContext<'input> {}

impl<'input> EMacroContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMacroContext(BaseParserRuleContext::copy_from(
            ctx,
            EMacroContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPrefixContext<'input> = BaseParserRuleContext<'input, EPrefixContextExt<'input>>;

pub trait EPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EPrefixContextAttrs<'input> for EPrefixContext<'input> {}

pub struct EPrefixContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPrefixContext<'input> {}

impl<'input> EPrefixContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            EPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ECompareContext<'input> = BaseParserRuleContext<'input, ECompareContextExt<'input>>;

pub trait ECompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ECompareContextAttrs<'input> for ECompareContext<'input> {}

pub struct ECompareContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ECompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ECompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ECompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ECompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ECompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ECompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ECompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ECompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ECompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ECompareContext<'input> {}

impl<'input> ECompareContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ECompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ECompareContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EGenericContext<'input> = BaseParserRuleContext<'input, EGenericContextExt<'input>>;

pub trait EGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call(&self) -> Option<Rc<Generic_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EGenericContextAttrs<'input> for EGenericContext<'input> {}

pub struct EGenericContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for EGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EGenericContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EGenericContext<'input> {}

impl<'input> EGenericContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            EGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EIsAContext<'input> = BaseParserRuleContext<'input, EIsAContextExt<'input>>;

pub trait EIsAContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_is(&self) -> Option<Rc<Infix_isContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EIsAContextAttrs<'input> for EIsAContext<'input> {}

pub struct EIsAContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EIsAContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EIsAContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EIsAContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EIsA(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EIsA(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EIsAContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EIsA(self);
    }
}

impl<'input> CustomRuleContext<'input> for EIsAContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EIsAContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EIsAContext<'input> {}

impl<'input> EIsAContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EIsAContext(BaseParserRuleContext::copy_from(
            ctx,
            EIsAContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EPowContext<'input> = BaseParserRuleContext<'input, EPowContextExt<'input>>;

pub trait EPowContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_pow(&self) -> Option<Rc<Infix_powContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EPowContextAttrs<'input> for EPowContext<'input> {}

pub struct EPowContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EPowContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EPowContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EPowContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EPow(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EPow(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EPowContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EPow(self);
    }
}

impl<'input> CustomRuleContext<'input> for EPowContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EPowContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EPowContext<'input> {}

impl<'input> EPowContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EPowContext(BaseParserRuleContext::copy_from(
            ctx,
            EPowContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EDefineContext<'input> = BaseParserRuleContext<'input, EDefineContextExt<'input>>;

pub trait EDefineContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn define_label(&self) -> Option<Rc<Define_labelContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EDefineContextAttrs<'input> for EDefineContext<'input> {}

pub struct EDefineContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EDefineContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EDefineContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EDefineContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EDefine(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EDefine(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EDefineContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EDefine(self);
    }
}

impl<'input> CustomRuleContext<'input> for EDefineContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EDefineContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EDefineContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EDefineContext<'input> {}

impl<'input> EDefineContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EDefineContext(BaseParserRuleContext::copy_from(
            ctx,
            EDefineContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EMapContext<'input> = BaseParserRuleContext<'input, EMapContextExt<'input>>;

pub trait EMapContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_map(&self) -> Option<Rc<Infix_mapContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> EMapContextAttrs<'input> for EMapContext<'input> {}

pub struct EMapContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EMapContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EMapContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EMapContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EMap(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EMap(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EMapContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EMap(self);
    }
}

impl<'input> CustomRuleContext<'input> for EMapContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EMapContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EMapContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EMapContext<'input> {}

impl<'input> EMapContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EMapContext(BaseParserRuleContext::copy_from(
            ctx,
            EMapContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ELogicContext<'input> = BaseParserRuleContext<'input, ELogicContextExt<'input>>;

pub trait ELogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ELogicContextAttrs<'input> for ELogicContext<'input> {}

pub struct ELogicContextExt<'input> {
    base: ExpressionContextExt<'input>,
    pub lhs: Option<Rc<ExpressionContextAll<'input>>>,
    pub rhs: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ELogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ELogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ELogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ELogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ELogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ELogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ELogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ELogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ELogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ELogicContext<'input> {}

impl<'input> ELogicContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ELogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ELogicContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type EControlContext<'input> = BaseParserRuleContext<'input, EControlContextExt<'input>>;

pub trait EControlContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn control_expression(&self) -> Option<Rc<Control_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> EControlContextAttrs<'input> for EControlContext<'input> {}

pub struct EControlContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {EControlContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for EControlContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for EControlContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_EControl(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_EControl(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for EControlContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_EControl(self);
    }
}

impl<'input> CustomRuleContext<'input> for EControlContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for EControlContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for EControlContext<'input> {}

impl<'input> EControlContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::EControlContext(BaseParserRuleContext::copy_from(
            ctx,
            EControlContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ENewContext<'input> = BaseParserRuleContext<'input, ENewContextExt<'input>>;

pub trait ENewContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn new_statement(&self) -> Option<Rc<New_statementContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ENewContextAttrs<'input> for ENewContext<'input> {}

pub struct ENewContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ENewContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ENewContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ENewContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ENew(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ENew(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ENewContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ENew(self);
    }
}

impl<'input> CustomRuleContext<'input> for ENewContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ENewContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ENewContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ENewContext<'input> {}

impl<'input> ENewContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ENewContext(BaseParserRuleContext::copy_from(
            ctx,
            ENewContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ECeilingContext<'input> = BaseParserRuleContext<'input, ECeilingContextExt<'input>>;

pub trait ECeilingContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CEILING_L
    /// Returns `None` if there is no child corresponding to token CEILING_L
    fn CEILING_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token CEILING_R
    /// Returns `None` if there is no child corresponding to token CEILING_R
    fn CEILING_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_R, 0)
    }
}

impl<'input> ECeilingContextAttrs<'input> for ECeilingContext<'input> {}

pub struct ECeilingContextExt<'input> {
    base: ExpressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ECeilingContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ECeilingContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ECeilingContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ECeiling(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ECeiling(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ECeilingContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ECeiling(self);
    }
}

impl<'input> CustomRuleContext<'input> for ECeilingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}

impl<'input> Borrow<ExpressionContextExt<'input>> for ECeilingContext<'input> {
    fn borrow(&self) -> &ExpressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<ExpressionContextExt<'input>> for ECeilingContext<'input> {
    fn borrow_mut(&mut self) -> &mut ExpressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> ExpressionContextAttrs<'input> for ECeilingContext<'input> {}

impl<'input> ECeilingContextExt<'input> {
    fn new(ctx: &dyn ExpressionContextAttrs<'input>) -> Rc<ExpressionContextAll<'input>> {
        Rc::new(ExpressionContextAll::ECeilingContext(BaseParserRuleContext::copy_from(
            ctx,
            ECeilingContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn expression(&mut self) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        self.expression_rec(0)
    }

    fn expression_rec(&mut self, _p: isize) -> Result<Rc<ExpressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 108, RULE_expression, _p);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 108;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1101);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(152, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = EPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(1073);
                            recog.op_prefix()?;

                            /* InvokeRule expression */
                            recog.base.set_state(1074);
                            recog.expression_rec(30)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = EGroupContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1076);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1077);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1078);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = EFloorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1080);
                            recog.base.match_token(FLOOR_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1081);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1082);
                            recog.base.match_token(FLOOR_R, &mut recog.err_handler)?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = ECeilingContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1084);
                            recog.base.match_token(CEILING_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1085);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1086);
                            recog.base.match_token(CEILING_R, &mut recog.err_handler)?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = EControlContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule control_expression */
                            recog.base.set_state(1088);
                            recog.control_expression()?;
                        }
                    }
                    6 => {
                        {
                            let mut tmp = EIfContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule if_statement */
                            recog.base.set_state(1089);
                            recog.if_statement()?;
                        }
                    }
                    7 => {
                        {
                            let mut tmp = ENewContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule new_statement */
                            recog.base.set_state(1090);
                            recog.new_statement()?;
                        }
                    }
                    8 => {
                        {
                            let mut tmp = ETryContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule try_statement */
                            recog.base.set_state(1091);
                            recog.try_statement()?;
                        }
                    }
                    9 => {
                        {
                            let mut tmp = EMatchContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule match_statement */
                            recog.base.set_state(1092);
                            recog.match_statement()?;
                        }
                    }
                    10 => {
                        {
                            let mut tmp = EObjectContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule object_statement */
                            recog.base.set_state(1093);
                            recog.object_statement()?;
                        }
                    }
                    11 => {
                        {
                            let mut tmp = EMacroContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule macro_call */
                            recog.base.set_state(1094);
                            recog.macro_call()?;
                        }
                    }
                    12 => {
                        {
                            let mut tmp = ELambdaContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule define_lambda */
                            recog.base.set_state(1095);
                            recog.define_lambda()?;
                        }
                    }
                    13 => {
                        {
                            let mut tmp = EFunctionContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule function_block */
                            recog.base.set_state(1096);
                            recog.function_block()?;
                        }
                    }
                    14 => {
                        {
                            let mut tmp = EDefineContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule define_label */
                            recog.base.set_state(1097);
                            recog.define_label()?;
                        }
                    }
                    15 => {
                        {
                            let mut tmp = ETupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule tuple_literal */
                            recog.base.set_state(1098);
                            recog.tuple_literal()?;
                        }
                    }
                    16 => {
                        {
                            let mut tmp = ERangeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule range_literal */
                            recog.base.set_state(1099);
                            recog.range_literal()?;
                        }
                    }
                    17 => {
                        {
                            let mut tmp = EAtomContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1100);
                            recog.atomic()?;
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1186);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(159, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1184);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(158, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EPowContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EPowContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1103);
                                        if !({ recog.precpred(None, 29) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 29)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_pow */
                                        recog.base.set_state(1104);
                                        recog.infix_pow()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1105);
                                        let tmp = recog.expression_rec(29)?;
                                        if let ExpressionContextAll::EPowContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EMulContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EMulContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1107);
                                        if !({ recog.precpred(None, 28) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 28)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(1108);
                                        recog.op_multiple()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1109);
                                        let tmp = recog.expression_rec(29)?;
                                        if let ExpressionContextAll::EMulContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EPlusContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EPlusContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1111);
                                        if !({ recog.precpred(None, 27) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 27)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(1112);
                                        recog.op_plus()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1113);
                                        let tmp = recog.expression_rec(28)?;
                                        if let ExpressionContextAll::EPlusContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ELogicContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::ELogicContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1115);
                                        if !({ recog.precpred(None, 26) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 26)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(1116);
                                        recog.op_logic()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1117);
                                        let tmp = recog.expression_rec(27)?;
                                        if let ExpressionContextAll::ELogicContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ECompareContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::ECompareContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1119);
                                        if !({ recog.precpred(None, 25) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 25)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1120);
                                        recog.op_compare()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1121);
                                        let tmp = recog.expression_rec(26)?;
                                        if let ExpressionContextAll::ECompareContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EUntilContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EUntilContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1123);
                                        if !({ recog.precpred(None, 24) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 24)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_range */
                                        recog.base.set_state(1124);
                                        recog.infix_range()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1125);
                                        let tmp = recog.expression_rec(25)?;
                                        if let ExpressionContextAll::EUntilContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EMapContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EMapContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1127);
                                        if !({ recog.precpred(None, 23) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 23)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_map */
                                        recog.base.set_state(1128);
                                        recog.infix_map()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1129);
                                        let tmp = recog.expression_rec(24)?;
                                        if let ExpressionContextAll::EMapContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EInContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EInContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1131);
                                        if !({ recog.precpred(None, 20) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 20)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_in */
                                        recog.base.set_state(1132);
                                        recog.infix_in()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1133);
                                        let tmp = recog.expression_rec(21)?;
                                        if let ExpressionContextAll::EInContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EPipeContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EPipeContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1135);
                                        if !({ recog.precpred(None, 18) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 18)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_pipeline */
                                        recog.base.set_state(1136);
                                        recog.op_pipeline()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1137);
                                        let tmp = recog.expression_rec(19)?;
                                        if let ExpressionContextAll::EPipeContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                10 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EAssignContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EAssignContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1139);
                                        if !({ recog.precpred(None, 17) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 17)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_assign */
                                        recog.base.set_state(1140);
                                        recog.op_assign()?;

                                        /* InvokeRule expression */
                                        recog.base.set_state(1141);
                                        let tmp = recog.expression_rec(18)?;
                                        if let ExpressionContextAll::EAssignContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                11 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ESuffixContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1143);
                                        if !({ recog.precpred(None, 36) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 36)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_suffix */
                                        recog.base.set_state(1144);
                                        recog.op_suffix()?;
                                    }
                                }
                                12 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ESliceContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1145);
                                        if !({ recog.precpred(None, 35) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 35)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule slice_call */
                                        recog.base.set_state(1146);
                                        recog.slice_call()?;
                                    }
                                }
                                13 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EGenericContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1147);
                                        if !({ recog.precpred(None, 34) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 34)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call */
                                        recog.base.set_state(1148);
                                        recog.generic_call()?;
                                    }
                                }
                                14 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EFunctionContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1149);
                                        if !({ recog.precpred(None, 33) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 33)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule function_call */
                                        recog.base.set_state(1150);
                                        recog.function_call()?;
                                    }
                                }
                                15 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EClosureContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1151);
                                        if !({ recog.precpred(None, 32) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 32)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1153);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == OP_AND_THEN {
                                            {
                                                recog.base.set_state(1152);
                                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                                            }
                                        }

                                        recog.base.set_state(1156);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == DOT {
                                            {
                                                recog.base.set_state(1155);
                                                recog.base.match_token(DOT, &mut recog.err_handler)?;
                                            }
                                        }

                                        /* InvokeRule function_block */
                                        recog.base.set_state(1158);
                                        recog.function_block()?;
                                    }
                                }
                                16 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EDotMatchContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1159);
                                        if !({ recog.precpred(None, 31) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 31)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1161);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == OP_AND_THEN {
                                            {
                                                recog.base.set_state(1160);
                                                recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                                            }
                                        }

                                        recog.base.set_state(1163);
                                        recog.base.match_token(DOT, &mut recog.err_handler)?;

                                        recog.base.set_state(1164);
                                        _la = recog.base.input.la(1);
                                        if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                                            recog.err_handler.recover_inline(&mut recog.base)?;
                                        }
                                        else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog.err_handler.report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        recog.base.set_state(1170);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == KW_AS {
                                            {
                                                recog.base.set_state(1165);
                                                recog.base.match_token(KW_AS, &mut recog.err_handler)?;

                                                /* InvokeRule identifier */
                                                recog.base.set_state(1166);
                                                recog.identifier()?;

                                                recog.base.set_state(1168);
                                                recog.err_handler.sync(&mut recog.base)?;
                                                _la = recog.base.input.la(1);
                                                if _la == COLON || _la == OP_ARROW {
                                                    {
                                                        /* InvokeRule type_hint */
                                                        recog.base.set_state(1167);
                                                        recog.type_hint()?;
                                                    }
                                                }
                                            }
                                        }

                                        /* InvokeRule match_block */
                                        recog.base.set_state(1172);
                                        recog.match_block()?;
                                    }
                                }
                                17 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EIsAContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EIsAContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1173);
                                        if !({ recog.precpred(None, 22) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 22)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_is */
                                        recog.base.set_state(1174);
                                        recog.infix_is()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1175);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EIsAContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                18 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp =
                                            EAsContextExt::new(&**ExpressionContextExt::new(_parentctx.clone(), _parentState));
                                        if let ExpressionContextAll::EAsContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1177);
                                        if !({ recog.precpred(None, 21) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 21)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_as */
                                        recog.base.set_state(1178);
                                        recog.infix_as()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1179);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let ExpressionContextAll::EAsContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                19 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = EOrElseContextExt::new(&**ExpressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let ExpressionContextAll::EOrElseContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1181);
                                        if !({ recog.precpred(None, 19) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 19)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1182);
                                        recog.base.match_token(OP_OR_ELSE, &mut recog.err_handler)?;

                                        /* InvokeRule op_assign */
                                        recog.base.set_state(1183);
                                        let tmp = recog.op_assign()?;
                                        if let ExpressionContextAll::EOrElseContext(ctx) =
                                            cast_mut::<_, ExpressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1188);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(159, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- inline_expression ----------------
#[derive(Debug)]
pub enum Inline_expressionContextAll<'input> {
    ILogicContext(ILogicContext<'input>),
    IPlusContext(IPlusContext<'input>),
    ICompareContext(ICompareContext<'input>),
    IGenericContext(IGenericContext<'input>),
    IFunctionContext(IFunctionContext<'input>),
    IMapContext(IMapContext<'input>),
    IIsContext(IIsContext<'input>),
    ITupleContext(ITupleContext<'input>),
    IRangeContext(IRangeContext<'input>),
    IGroupContext(IGroupContext<'input>),
    IMulContext(IMulContext<'input>),
    IAsContext(IAsContext<'input>),
    IPrefixContext(IPrefixContext<'input>),
    IFloorContext(IFloorContext<'input>),
    IAtomContext(IAtomContext<'input>),
    ICeilingContext(ICeilingContext<'input>),
    ISliceContext(ISliceContext<'input>),
    Error(Inline_expressionContext<'input>),
}
antlr_rust::tid! {Inline_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Inline_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContextAll<'input> {}

impl<'input> Deref for Inline_expressionContextAll<'input> {
    type Target = dyn Inline_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Inline_expressionContextAll::*;
        match self {
            ILogicContext(inner) => inner,
            IPlusContext(inner) => inner,
            ICompareContext(inner) => inner,
            IGenericContext(inner) => inner,
            IFunctionContext(inner) => inner,
            IMapContext(inner) => inner,
            IIsContext(inner) => inner,
            ITupleContext(inner) => inner,
            IRangeContext(inner) => inner,
            IGroupContext(inner) => inner,
            IMulContext(inner) => inner,
            IAsContext(inner) => inner,
            IPrefixContext(inner) => inner,
            IFloorContext(inner) => inner,
            IAtomContext(inner) => inner,
            ICeilingContext(inner) => inner,
            ISliceContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Inline_expressionContext<'input> = BaseParserRuleContext<'input, Inline_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Inline_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Inline_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Inline_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Inline_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}
antlr_rust::tid! {Inline_expressionContextExt<'a>}

impl<'input> Inline_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Inline_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Inline_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Inline_expressionContextExt<'input>>
{
}

impl<'input> Inline_expressionContextAttrs<'input> for Inline_expressionContext<'input> {}

pub type ILogicContext<'input> = BaseParserRuleContext<'input, ILogicContextExt<'input>>;

pub trait ILogicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_logic(&self) -> Option<Rc<Op_logicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ILogicContextAttrs<'input> for ILogicContext<'input> {}

pub struct ILogicContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ILogicContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ILogicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ILogicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ILogic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ILogic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ILogicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ILogic(self);
    }
}

impl<'input> CustomRuleContext<'input> for ILogicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ILogicContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ILogicContext<'input> {}

impl<'input> ILogicContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ILogicContext(BaseParserRuleContext::copy_from(
            ctx,
            ILogicContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPlusContext<'input> = BaseParserRuleContext<'input, IPlusContextExt<'input>>;

pub trait IPlusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_plus(&self) -> Option<Rc<Op_plusContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IPlusContextAttrs<'input> for IPlusContext<'input> {}

pub struct IPlusContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPlusContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPlusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPlusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPlus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPlus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPlusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPlus(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPlusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPlusContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPlusContext<'input> {}

impl<'input> IPlusContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPlusContext(BaseParserRuleContext::copy_from(
            ctx,
            IPlusContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ICompareContext<'input> = BaseParserRuleContext<'input, ICompareContextExt<'input>>;

pub trait ICompareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_compare(&self) -> Option<Rc<Op_compareContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ICompareContextAttrs<'input> for ICompareContext<'input> {}

pub struct ICompareContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ICompareContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ICompareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ICompareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ICompare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ICompare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ICompareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ICompare(self);
    }
}

impl<'input> CustomRuleContext<'input> for ICompareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ICompareContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ICompareContext<'input> {}

impl<'input> ICompareContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ICompareContext(BaseParserRuleContext::copy_from(
            ctx,
            ICompareContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IGenericContext<'input> = BaseParserRuleContext<'input, IGenericContextExt<'input>>;

pub trait IGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call(&self) -> Option<Rc<Generic_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IGenericContextAttrs<'input> for IGenericContext<'input> {}

pub struct IGenericContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for IGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IGenericContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IGenericContext<'input> {}

impl<'input> IGenericContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            IGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IFunctionContext<'input> = BaseParserRuleContext<'input, IFunctionContextExt<'input>>;

pub trait IFunctionContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn function_call(&self) -> Option<Rc<Function_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IFunctionContextAttrs<'input> for IFunctionContext<'input> {}

pub struct IFunctionContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IFunctionContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IFunctionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IFunctionContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IFunction(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IFunction(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IFunctionContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IFunction(self);
    }
}

impl<'input> CustomRuleContext<'input> for IFunctionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IFunctionContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IFunctionContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IFunctionContext<'input> {}

impl<'input> IFunctionContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IFunctionContext(BaseParserRuleContext::copy_from(
            ctx,
            IFunctionContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IMapContext<'input> = BaseParserRuleContext<'input, IMapContextExt<'input>>;

pub trait IMapContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_map(&self) -> Option<Rc<Infix_mapContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IMapContextAttrs<'input> for IMapContext<'input> {}

pub struct IMapContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IMapContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IMapContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IMapContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IMap(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IMap(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IMapContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IMap(self);
    }
}

impl<'input> CustomRuleContext<'input> for IMapContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IMapContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IMapContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IMapContext<'input> {}

impl<'input> IMapContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IMapContext(BaseParserRuleContext::copy_from(
            ctx,
            IMapContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IIsContext<'input> = BaseParserRuleContext<'input, IIsContextExt<'input>>;

pub trait IIsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_is(&self) -> Option<Rc<Infix_isContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IIsContextAttrs<'input> for IIsContext<'input> {}

pub struct IIsContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IIsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IIsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IIsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IIs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IIs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IIsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IIs(self);
    }
}

impl<'input> CustomRuleContext<'input> for IIsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IIsContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IIsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IIsContext<'input> {}

impl<'input> IIsContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IIsContext(BaseParserRuleContext::copy_from(
            ctx,
            IIsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ITupleContext<'input> = BaseParserRuleContext<'input, ITupleContextExt<'input>>;

pub trait ITupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn tuple_literal(&self) -> Option<Rc<Tuple_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ITupleContextAttrs<'input> for ITupleContext<'input> {}

pub struct ITupleContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ITupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ITupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ITupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ITuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ITuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ITupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ITuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for ITupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ITupleContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ITupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ITupleContext<'input> {}

impl<'input> ITupleContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ITupleContext(BaseParserRuleContext::copy_from(
            ctx,
            ITupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IRangeContext<'input> = BaseParserRuleContext<'input, IRangeContextExt<'input>>;

pub trait IRangeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn infix_range(&self) -> Option<Rc<Infix_rangeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IRangeContextAttrs<'input> for IRangeContext<'input> {}

pub struct IRangeContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IRangeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IRangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IRangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IRange(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IRange(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IRangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IRange(self);
    }
}

impl<'input> CustomRuleContext<'input> for IRangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IRangeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IRangeContext<'input> {}

impl<'input> IRangeContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IRangeContext(BaseParserRuleContext::copy_from(
            ctx,
            IRangeContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IGroupContext<'input> = BaseParserRuleContext<'input, IGroupContextExt<'input>>;

pub trait IGroupContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
}

impl<'input> IGroupContextAttrs<'input> for IGroupContext<'input> {}

pub struct IGroupContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IGroupContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IGroupContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IGroupContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IGroup(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IGroup(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IGroupContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IGroup(self);
    }
}

impl<'input> CustomRuleContext<'input> for IGroupContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IGroupContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IGroupContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IGroupContext<'input> {}

impl<'input> IGroupContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IGroupContext(BaseParserRuleContext::copy_from(
            ctx,
            IGroupContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IMulContext<'input> = BaseParserRuleContext<'input, IMulContextExt<'input>>;

pub trait IMulContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_multiple(&self) -> Option<Rc<Op_multipleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression_all(&self) -> Vec<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn inline_expression(&self, i: usize) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> IMulContextAttrs<'input> for IMulContext<'input> {}

pub struct IMulContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IMulContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IMulContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IMulContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IMul(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IMul(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IMulContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IMul(self);
    }
}

impl<'input> CustomRuleContext<'input> for IMulContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IMulContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IMulContext<'input> {}

impl<'input> IMulContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IMulContext(BaseParserRuleContext::copy_from(
            ctx,
            IMulContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IAsContext<'input> = BaseParserRuleContext<'input, IAsContextExt<'input>>;

pub trait IAsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn infix_as(&self) -> Option<Rc<Infix_asContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IAsContextAttrs<'input> for IAsContext<'input> {}

pub struct IAsContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    pub lhs: Option<Rc<Inline_expressionContextAll<'input>>>,
    pub rhs: Option<Rc<Type_expressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IAsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IAsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IAsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IAs(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IAs(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IAsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IAs(self);
    }
}

impl<'input> CustomRuleContext<'input> for IAsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IAsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IAsContext<'input> {}

impl<'input> IAsContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IAsContext(BaseParserRuleContext::copy_from(
            ctx,
            IAsContextExt { lhs: None, rhs: None, base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IPrefixContext<'input> = BaseParserRuleContext<'input, IPrefixContextExt<'input>>;

pub trait IPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IPrefixContextAttrs<'input> for IPrefixContext<'input> {}

pub struct IPrefixContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for IPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IPrefixContext<'input> {}

impl<'input> IPrefixContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            IPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IFloorContext<'input> = BaseParserRuleContext<'input, IFloorContextExt<'input>>;

pub trait IFloorContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token FLOOR_L
    /// Returns `None` if there is no child corresponding to token FLOOR_L
    fn FLOOR_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token FLOOR_R
    /// Returns `None` if there is no child corresponding to token FLOOR_R
    fn FLOOR_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(FLOOR_R, 0)
    }
}

impl<'input> IFloorContextAttrs<'input> for IFloorContext<'input> {}

pub struct IFloorContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IFloorContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IFloorContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IFloorContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IFloor(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IFloor(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IFloorContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IFloor(self);
    }
}

impl<'input> CustomRuleContext<'input> for IFloorContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IFloorContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IFloorContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IFloorContext<'input> {}

impl<'input> IFloorContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IFloorContext(BaseParserRuleContext::copy_from(
            ctx,
            IFloorContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type IAtomContext<'input> = BaseParserRuleContext<'input, IAtomContextExt<'input>>;

pub trait IAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> IAtomContextAttrs<'input> for IAtomContext<'input> {}

pub struct IAtomContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {IAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for IAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_IAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_IAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_IAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for IAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for IAtomContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for IAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for IAtomContext<'input> {}

impl<'input> IAtomContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::IAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            IAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ICeilingContext<'input> = BaseParserRuleContext<'input, ICeilingContextExt<'input>>;

pub trait ICeilingContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CEILING_L
    /// Returns `None` if there is no child corresponding to token CEILING_L
    fn CEILING_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_L, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token CEILING_R
    /// Returns `None` if there is no child corresponding to token CEILING_R
    fn CEILING_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CEILING_R, 0)
    }
}

impl<'input> ICeilingContextAttrs<'input> for ICeilingContext<'input> {}

pub struct ICeilingContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ICeilingContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ICeilingContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ICeilingContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ICeiling(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ICeiling(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ICeilingContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ICeiling(self);
    }
}

impl<'input> CustomRuleContext<'input> for ICeilingContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ICeilingContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ICeilingContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ICeilingContext<'input> {}

impl<'input> ICeilingContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ICeilingContext(BaseParserRuleContext::copy_from(
            ctx,
            ICeilingContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ISliceContext<'input> = BaseParserRuleContext<'input, ISliceContextExt<'input>>;

pub trait ISliceContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn slice_call(&self) -> Option<Rc<Slice_callContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ISliceContextAttrs<'input> for ISliceContext<'input> {}

pub struct ISliceContextExt<'input> {
    base: Inline_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ISliceContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ISliceContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ISliceContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ISlice(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ISlice(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ISliceContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ISlice(self);
    }
}

impl<'input> CustomRuleContext<'input> for ISliceContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_inline_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_inline_expression }
}

impl<'input> Borrow<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow(&self) -> &Inline_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Inline_expressionContextExt<'input>> for ISliceContext<'input> {
    fn borrow_mut(&mut self) -> &mut Inline_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Inline_expressionContextAttrs<'input> for ISliceContext<'input> {}

impl<'input> ISliceContextExt<'input> {
    fn new(ctx: &dyn Inline_expressionContextAttrs<'input>) -> Rc<Inline_expressionContextAll<'input>> {
        Rc::new(Inline_expressionContextAll::ISliceContext(BaseParserRuleContext::copy_from(
            ctx,
            ISliceContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn inline_expression(&mut self) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        self.inline_expression_rec(0)
    }

    fn inline_expression_rec(&mut self, _p: isize) -> Result<Rc<Inline_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Inline_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 110, RULE_inline_expression, _p);
        let mut _localctx: Rc<Inline_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 110;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1208);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(160, &mut recog.base)? {
                    1 => {
                        {
                            let mut tmp = IPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(1190);
                            recog.op_prefix()?;

                            /* InvokeRule inline_expression */
                            recog.base.set_state(1191);
                            recog.inline_expression_rec(18)?;
                        }
                    }
                    2 => {
                        {
                            let mut tmp = IGroupContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1193);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1194);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1195);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }
                    3 => {
                        {
                            let mut tmp = IFloorContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1197);
                            recog.base.match_token(FLOOR_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1198);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1199);
                            recog.base.match_token(FLOOR_R, &mut recog.err_handler)?;
                        }
                    }
                    4 => {
                        {
                            let mut tmp = ICeilingContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1201);
                            recog.base.match_token(CEILING_L, &mut recog.err_handler)?;

                            /* InvokeRule expression */
                            recog.base.set_state(1202);
                            recog.expression_rec(0)?;

                            recog.base.set_state(1203);
                            recog.base.match_token(CEILING_R, &mut recog.err_handler)?;
                        }
                    }
                    5 => {
                        {
                            let mut tmp = ITupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule tuple_literal */
                            recog.base.set_state(1205);
                            recog.tuple_literal()?;
                        }
                    }
                    6 => {
                        {
                            let mut tmp = IRangeContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule range_literal */
                            recog.base.set_state(1206);
                            recog.range_literal()?;
                        }
                    }
                    7 => {
                        {
                            let mut tmp = IAtomContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1207);
                            recog.atomic()?;
                        }
                    }

                    _ => {}
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1250);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(162, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1248);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(161, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IMulContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IMulContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1210);
                                        if !({ recog.precpred(None, 14) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 14)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_multiple */
                                        recog.base.set_state(1211);
                                        recog.op_multiple()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1212);
                                        let tmp = recog.inline_expression_rec(15)?;
                                        if let Inline_expressionContextAll::IMulContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IPlusContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IPlusContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1214);
                                        if !({ recog.precpred(None, 13) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 13)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_plus */
                                        recog.base.set_state(1215);
                                        recog.op_plus()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1216);
                                        let tmp = recog.inline_expression_rec(14)?;
                                        if let Inline_expressionContextAll::IPlusContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ILogicContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::ILogicContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1218);
                                        if !({ recog.precpred(None, 12) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 12)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_logic */
                                        recog.base.set_state(1219);
                                        recog.op_logic()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1220);
                                        let tmp = recog.inline_expression_rec(13)?;
                                        if let Inline_expressionContextAll::ILogicContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IMapContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IMapContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1222);
                                        if !({ recog.precpred(None, 11) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 11)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_map */
                                        recog.base.set_state(1223);
                                        recog.infix_map()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1224);
                                        let tmp = recog.inline_expression_rec(12)?;
                                        if let Inline_expressionContextAll::IMapContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ICompareContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::ICompareContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1226);
                                        if !({ recog.precpred(None, 10) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 10)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_compare */
                                        recog.base.set_state(1227);
                                        recog.op_compare()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1228);
                                        let tmp = recog.inline_expression_rec(11)?;
                                        if let Inline_expressionContextAll::ICompareContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                6 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IRangeContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IRangeContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1230);
                                        if !({ recog.precpred(None, 7) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 7)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_range */
                                        recog.base.set_state(1231);
                                        recog.infix_range()?;

                                        /* InvokeRule inline_expression */
                                        recog.base.set_state(1232);
                                        let tmp = recog.inline_expression_rec(8)?;
                                        if let Inline_expressionContextAll::IRangeContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                7 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IFunctionContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1234);
                                        if !({ recog.precpred(None, 17) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 17)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule function_call */
                                        recog.base.set_state(1235);
                                        recog.function_call()?;
                                    }
                                }
                                8 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IGenericContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1236);
                                        if !({ recog.precpred(None, 16) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 16)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call */
                                        recog.base.set_state(1237);
                                        recog.generic_call()?;
                                    }
                                }
                                9 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = ISliceContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1238);
                                        if !({ recog.precpred(None, 15) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 15)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule slice_call */
                                        recog.base.set_state(1239);
                                        recog.slice_call()?;
                                    }
                                }
                                10 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IIsContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IIsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1240);
                                        if !({ recog.precpred(None, 9) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 9)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_is */
                                        recog.base.set_state(1241);
                                        recog.infix_is()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1242);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let Inline_expressionContextAll::IIsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }
                                11 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = IAsContextExt::new(&**Inline_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        if let Inline_expressionContextAll::IAsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut tmp)
                                        {
                                            ctx.lhs = Some(_prevctx.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inline_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1244);
                                        if !({ recog.precpred(None, 8) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 8)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_as */
                                        recog.base.set_state(1245);
                                        recog.infix_as()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1246);
                                        let tmp = recog.type_expression_rec(0)?;
                                        if let Inline_expressionContextAll::IAsContext(ctx) =
                                            cast_mut::<_, Inline_expressionContextAll>(&mut _localctx)
                                        {
                                            ctx.rhs = Some(tmp.clone());
                                        }
                                        else {
                                            unreachable!("cant cast");
                                        }
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1252);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(162, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- type_expression ----------------
#[derive(Debug)]
pub enum Type_expressionContextAll<'input> {
    TPrefixContext(TPrefixContext<'input>),
    TGenericContext(TGenericContext<'input>),
    TPatternContext(TPatternContext<'input>),
    TTupleContext(TTupleContext<'input>),
    TAtomContext(TAtomContext<'input>),
    TAddContext(TAddContext<'input>),
    TArrowsContext(TArrowsContext<'input>),
    Error(Type_expressionContext<'input>),
}
antlr_rust::tid! {Type_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Type_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContextAll<'input> {}

impl<'input> Deref for Type_expressionContextAll<'input> {
    type Target = dyn Type_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Type_expressionContextAll::*;
        match self {
            TPrefixContext(inner) => inner,
            TGenericContext(inner) => inner,
            TPatternContext(inner) => inner,
            TTupleContext(inner) => inner,
            TAtomContext(inner) => inner,
            TAddContext(inner) => inner,
            TArrowsContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Type_expressionContext<'input> = BaseParserRuleContext<'input, Type_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Type_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Type_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Type_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Type_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}
antlr_rust::tid! {Type_expressionContextExt<'a>}

impl<'input> Type_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Type_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Type_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Type_expressionContextExt<'input>>
{
}

impl<'input> Type_expressionContextAttrs<'input> for Type_expressionContext<'input> {}

pub type TPrefixContext<'input> = BaseParserRuleContext<'input, TPrefixContextExt<'input>>;

pub trait TPrefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn op_prefix(&self) -> Option<Rc<Op_prefixContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TPrefixContextAttrs<'input> for TPrefixContext<'input> {}

pub struct TPrefixContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TPrefixContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TPrefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TPrefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TPrefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TPrefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TPrefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TPrefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for TPrefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TPrefixContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TPrefixContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TPrefixContext<'input> {}

impl<'input> TPrefixContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TPrefixContext(BaseParserRuleContext::copy_from(
            ctx,
            TPrefixContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TGenericContext<'input> = BaseParserRuleContext<'input, TGenericContextExt<'input>>;

pub trait TGenericContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TGenericContextAttrs<'input> for TGenericContext<'input> {}

pub struct TGenericContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TGenericContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TGenericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TGenericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TGeneric(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TGeneric(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TGenericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TGeneric(self);
    }
}

impl<'input> CustomRuleContext<'input> for TGenericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TGenericContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TGenericContext<'input> {}

impl<'input> TGenericContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TGenericContext(BaseParserRuleContext::copy_from(
            ctx,
            TGenericContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TPatternContext<'input> = BaseParserRuleContext<'input, TPatternContextExt<'input>>;

pub trait TPatternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn op_pattern(&self) -> Option<Rc<Op_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TPatternContextAttrs<'input> for TPatternContext<'input> {}

pub struct TPatternContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TPatternContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TPatternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TPatternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TPattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TPattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TPatternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TPattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for TPatternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TPatternContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TPatternContext<'input> {}

impl<'input> TPatternContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TPatternContext(BaseParserRuleContext::copy_from(
            ctx,
            TPatternContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TTupleContext<'input> = BaseParserRuleContext<'input, TTupleContextExt<'input>>;

pub trait TTupleContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> TTupleContextAttrs<'input> for TTupleContext<'input> {}

pub struct TTupleContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TTupleContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TTupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TTupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TTuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TTuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TTupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TTuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for TTupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TTupleContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TTupleContext<'input> {}

impl<'input> TTupleContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TTupleContext(BaseParserRuleContext::copy_from(
            ctx,
            TTupleContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TAtomContext<'input> = BaseParserRuleContext<'input, TAtomContextExt<'input>>;

pub trait TAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn atomic(&self) -> Option<Rc<AtomicContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TAtomContextAttrs<'input> for TAtomContext<'input> {}

pub struct TAtomContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for TAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TAtomContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TAtomContext<'input> {}

impl<'input> TAtomContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            TAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TAddContext<'input> = BaseParserRuleContext<'input, TAddContextExt<'input>>;

pub trait TAddContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> TAddContextAttrs<'input> for TAddContext<'input> {}

pub struct TAddContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TAddContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TAddContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TAddContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TAdd(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TAdd(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TAddContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TAdd(self);
    }
}

impl<'input> CustomRuleContext<'input> for TAddContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TAddContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TAddContext<'input> {}

impl<'input> TAddContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TAddContext(BaseParserRuleContext::copy_from(
            ctx,
            TAddContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type TArrowsContext<'input> = BaseParserRuleContext<'input, TArrowsContextExt<'input>>;

pub trait TArrowsContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn type_expression_all(&self) -> Vec<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn type_expression(&self, i: usize) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn infix_arrows(&self) -> Option<Rc<Infix_arrowsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> TArrowsContextAttrs<'input> for TArrowsContext<'input> {}

pub struct TArrowsContextExt<'input> {
    base: Type_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {TArrowsContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for TArrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for TArrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_TArrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_TArrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for TArrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_TArrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for TArrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_type_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_type_expression }
}

impl<'input> Borrow<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow(&self) -> &Type_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Type_expressionContextExt<'input>> for TArrowsContext<'input> {
    fn borrow_mut(&mut self) -> &mut Type_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Type_expressionContextAttrs<'input> for TArrowsContext<'input> {}

impl<'input> TArrowsContextExt<'input> {
    fn new(ctx: &dyn Type_expressionContextAttrs<'input>) -> Rc<Type_expressionContextAll<'input>> {
        Rc::new(Type_expressionContextAll::TArrowsContext(BaseParserRuleContext::copy_from(
            ctx,
            TArrowsContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn type_expression(&mut self) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        self.type_expression_rec(0)
    }

    fn type_expression_rec(&mut self, _p: isize) -> Result<Rc<Type_expressionContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Type_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 112, RULE_type_expression, _p);
        let mut _localctx: Rc<Type_expressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 112;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1275);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.base.input.la(1) {
                    OP_ADD | OP_SUB | OP_MUL | OP_AND | OP_NOT | OP_DOT3 | OP_DOT2 | OP_INVERSE | OP_ROOT2 | OP_ROOT3
                    | OP_ROOT4 | OP_REFERENCE => {
                        {
                            let mut tmp = TPrefixContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();

                            /* InvokeRule op_prefix */
                            recog.base.set_state(1254);
                            recog.op_prefix()?;

                            /* InvokeRule type_expression */
                            recog.base.set_state(1255);
                            recog.type_expression_rec(8)?;
                        }
                    }

                    PARENTHESES_L => {
                        {
                            let mut tmp = TTupleContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            recog.base.set_state(1257);
                            recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                            recog.base.set_state(1271);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(165, &mut recog.base)? {
                                x if x == 1 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1258);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1259);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }

                                x if x == 2 => {
                                    {
                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1261);
                                        recog.type_expression_rec(0)?;

                                        recog.base.set_state(1264);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _alt = 1;
                                        loop {
                                            match _alt {
                                                x if x == 1 => {
                                                    {
                                                        recog.base.set_state(1262);
                                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                        /* InvokeRule type_expression */
                                                        recog.base.set_state(1263);
                                                        recog.type_expression_rec(0)?;
                                                    }
                                                }

                                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                                            }
                                            recog.base.set_state(1266);
                                            recog.err_handler.sync(&mut recog.base)?;
                                            _alt = recog.interpreter.adaptive_predict(163, &mut recog.base)?;
                                            if _alt == 2 || _alt == INVALID_ALT {
                                                break;
                                            }
                                        }
                                        recog.base.set_state(1269);
                                        recog.err_handler.sync(&mut recog.base)?;
                                        _la = recog.base.input.la(1);
                                        if _la == COMMA {
                                            {
                                                recog.base.set_state(1268);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                            }
                                        }
                                    }
                                }

                                _ => {}
                            }
                            recog.base.set_state(1273);
                            recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                        }
                    }

                    OP_REM | OP_LAST | LAMBDA_SLOT | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE | STRING_BLOCK
                    | SPECIAL | RAW_ID | UNICODE_ID => {
                        {
                            let mut tmp = TAtomContextExt::new(&**_localctx);
                            recog.ctx = Some(tmp.clone());
                            _localctx = tmp;
                            _prevctx = _localctx.clone();
                            /* InvokeRule atomic */
                            recog.base.set_state(1274);
                            recog.atomic()?;
                        }
                    }

                    _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1294);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(168, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1292);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(167, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TPatternContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1277);
                                        if !({ recog.precpred(None, 6) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 6)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule op_pattern */
                                        recog.base.set_state(1278);
                                        recog.op_pattern()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1279);
                                        recog.type_expression_rec(7)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TArrowsContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1281);
                                        if !({ recog.precpred(None, 5) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 5)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule infix_arrows */
                                        recog.base.set_state(1282);
                                        recog.infix_arrows()?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1283);
                                        recog.type_expression_rec(6)?;
                                    }
                                }
                                3 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TAddContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1285);
                                        if !({ recog.precpred(None, 4) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 4)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1286);
                                        recog.base.match_token(OP_ADD, &mut recog.err_handler)?;

                                        /* InvokeRule type_expression */
                                        recog.base.set_state(1287);
                                        recog.type_expression_rec(5)?;
                                    }
                                }
                                4 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TGenericContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1288);
                                        if !({ recog.precpred(None, 7) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 7)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call_in_type */
                                        recog.base.set_state(1289);
                                        recog.generic_call_in_type()?;
                                    }
                                }
                                5 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = TGenericContextExt::new(&**Type_expressionContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_type_expression);
                                        _localctx = tmp;
                                        recog.base.set_state(1290);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        /* InvokeRule generic_call_in_type */
                                        recog.base.set_state(1291);
                                        recog.generic_call_in_type()?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1296);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(168, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- atomic ----------------
#[derive(Debug)]
pub enum AtomicContextAll<'input> {
    ASpecialContext(ASpecialContext<'input>),
    ALambdaContext(ALambdaContext<'input>),
    ANumberContext(ANumberContext<'input>),
    AOutputContext(AOutputContext<'input>),
    AStringContext(AStringContext<'input>),
    ANamepathContext(ANamepathContext<'input>),
    Error(AtomicContext<'input>),
}
antlr_rust::tid! {AtomicContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for AtomicContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for AtomicContextAll<'input> {}

impl<'input> Deref for AtomicContextAll<'input> {
    type Target = dyn AtomicContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use AtomicContextAll::*;
        match self {
            ASpecialContext(inner) => inner,
            ALambdaContext(inner) => inner,
            ANumberContext(inner) => inner,
            AOutputContext(inner) => inner,
            AStringContext(inner) => inner,
            ANamepathContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AtomicContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AtomicContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type AtomicContext<'input> = BaseParserRuleContext<'input, AtomicContextExt<'input>>;

#[derive(Clone)]
pub struct AtomicContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for AtomicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AtomicContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AtomicContext<'input> {}

impl<'input> CustomRuleContext<'input> for AtomicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}
antlr_rust::tid! {AtomicContextExt<'a>}

impl<'input> AtomicContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            AtomicContextExt { ph: PhantomData },
        )))
    }
}

pub trait AtomicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<AtomicContextExt<'input>> {}

impl<'input> AtomicContextAttrs<'input> for AtomicContext<'input> {}

pub type ASpecialContext<'input> = BaseParserRuleContext<'input, ASpecialContextExt<'input>>;

pub trait ASpecialContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> ASpecialContextAttrs<'input> for ASpecialContext<'input> {}

pub struct ASpecialContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ASpecialContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ASpecialContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ASpecialContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ASpecial(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ASpecial(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ASpecialContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ASpecial(self);
    }
}

impl<'input> CustomRuleContext<'input> for ASpecialContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ASpecialContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ASpecialContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ASpecialContext<'input> {}

impl<'input> ASpecialContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ASpecialContext(BaseParserRuleContext::copy_from(
            ctx,
            ASpecialContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ALambdaContext<'input> = BaseParserRuleContext<'input, ALambdaContextExt<'input>>;

pub trait ALambdaContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn lambda_name(&self) -> Option<Rc<Lambda_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ALambdaContextAttrs<'input> for ALambdaContext<'input> {}

pub struct ALambdaContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ALambdaContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ALambdaContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ALambdaContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ALambda(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ALambda(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ALambdaContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ALambda(self);
    }
}

impl<'input> CustomRuleContext<'input> for ALambdaContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ALambdaContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ALambdaContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ALambdaContext<'input> {}

impl<'input> ALambdaContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ALambdaContext(BaseParserRuleContext::copy_from(
            ctx,
            ALambdaContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ANumberContext<'input> = BaseParserRuleContext<'input, ANumberContextExt<'input>>;

pub trait ANumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ANumberContextAttrs<'input> for ANumberContext<'input> {}

pub struct ANumberContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ANumberContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ANumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ANumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ANumber(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ANumber(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ANumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ANumber(self);
    }
}

impl<'input> CustomRuleContext<'input> for ANumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ANumberContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ANumberContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ANumberContext<'input> {}

impl<'input> ANumberContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ANumberContext(BaseParserRuleContext::copy_from(
            ctx,
            ANumberContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type AOutputContext<'input> = BaseParserRuleContext<'input, AOutputContextExt<'input>>;

pub trait AOutputContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn output_name(&self) -> Option<Rc<Output_nameContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AOutputContextAttrs<'input> for AOutputContext<'input> {}

pub struct AOutputContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AOutputContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for AOutputContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AOutputContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_AOutput(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_AOutput(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AOutputContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_AOutput(self);
    }
}

impl<'input> CustomRuleContext<'input> for AOutputContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for AOutputContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for AOutputContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for AOutputContext<'input> {}

impl<'input> AOutputContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::AOutputContext(BaseParserRuleContext::copy_from(
            ctx,
            AOutputContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type AStringContext<'input> = BaseParserRuleContext<'input, AStringContextExt<'input>>;

pub trait AStringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> AStringContextAttrs<'input> for AStringContext<'input> {}

pub struct AStringContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {AStringContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for AStringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AStringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_AString(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_AString(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AStringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_AString(self);
    }
}

impl<'input> CustomRuleContext<'input> for AStringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for AStringContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for AStringContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for AStringContext<'input> {}

impl<'input> AStringContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::AStringContext(BaseParserRuleContext::copy_from(
            ctx,
            AStringContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type ANamepathContext<'input> = BaseParserRuleContext<'input, ANamepathContextExt<'input>>;

pub trait ANamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> ANamepathContextAttrs<'input> for ANamepathContext<'input> {}

pub struct ANamepathContextExt<'input> {
    base: AtomicContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {ANamepathContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for ANamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ANamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_ANamepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_ANamepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ANamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_ANamepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for ANamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_atomic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_atomic }
}

impl<'input> Borrow<AtomicContextExt<'input>> for ANamepathContext<'input> {
    fn borrow(&self) -> &AtomicContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<AtomicContextExt<'input>> for ANamepathContext<'input> {
    fn borrow_mut(&mut self) -> &mut AtomicContextExt<'input> {
        &mut self.base
    }
}

impl<'input> AtomicContextAttrs<'input> for ANamepathContext<'input> {}

impl<'input> ANamepathContextExt<'input> {
    fn new(ctx: &dyn AtomicContextAttrs<'input>) -> Rc<AtomicContextAll<'input>> {
        Rc::new(AtomicContextAll::ANamepathContext(BaseParserRuleContext::copy_from(
            ctx,
            ANamepathContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn atomic(&mut self) -> Result<Rc<AtomicContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = AtomicContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_atomic);
        let mut _localctx: Rc<AtomicContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1303);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(169, &mut recog.base)? {
                1 => {
                    let tmp = AStringContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        /* InvokeRule string_literal */
                        recog.base.set_state(1297);
                        recog.string_literal()?;
                    }
                }
                2 => {
                    let tmp = ANumberContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        /* InvokeRule number_literal */
                        recog.base.set_state(1298);
                        recog.number_literal()?;
                    }
                }
                3 => {
                    let tmp = ALambdaContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        /* InvokeRule lambda_name */
                        recog.base.set_state(1299);
                        recog.lambda_name()?;
                    }
                }
                4 => {
                    let tmp = AOutputContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        /* InvokeRule output_name */
                        recog.base.set_state(1300);
                        recog.output_name()?;
                    }
                }
                5 => {
                    let tmp = ANamepathContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1301);
                        recog.namepath()?;
                    }
                }
                6 => {
                    let tmp = ASpecialContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1302);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- control_expression ----------------
#[derive(Debug)]
pub enum Control_expressionContextAll<'input> {
    CBreakContext(CBreakContext<'input>),
    CWithContext(CWithContext<'input>),
    CYieldContext(CYieldContext<'input>),
    CReturnContext(CReturnContext<'input>),
    CRaiseContext(CRaiseContext<'input>),
    CContinueContext(CContinueContext<'input>),
    Error(Control_expressionContext<'input>),
}
antlr_rust::tid! {Control_expressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Control_expressionContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Control_expressionContextAll<'input> {}

impl<'input> Deref for Control_expressionContextAll<'input> {
    type Target = dyn Control_expressionContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Control_expressionContextAll::*;
        match self {
            CBreakContext(inner) => inner,
            CWithContext(inner) => inner,
            CYieldContext(inner) => inner,
            CReturnContext(inner) => inner,
            CRaiseContext(inner) => inner,
            CContinueContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Control_expressionContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Control_expressionContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Control_expressionContext<'input> = BaseParserRuleContext<'input, Control_expressionContextExt<'input>>;

#[derive(Clone)]
pub struct Control_expressionContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Control_expressionContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Control_expressionContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Control_expressionContext<'input> {}

impl<'input> CustomRuleContext<'input> for Control_expressionContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}
antlr_rust::tid! {Control_expressionContextExt<'a>}

impl<'input> Control_expressionContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Control_expressionContextExt { ph: PhantomData },
        )))
    }
}

pub trait Control_expressionContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Control_expressionContextExt<'input>>
{
}

impl<'input> Control_expressionContextAttrs<'input> for Control_expressionContext<'input> {}

pub type CBreakContext<'input> = BaseParserRuleContext<'input, CBreakContextExt<'input>>;

pub trait CBreakContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BREAK
    /// Returns `None` if there is no child corresponding to token BREAK
    fn BREAK(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BREAK, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
}

impl<'input> CBreakContextAttrs<'input> for CBreakContext<'input> {}

pub struct CBreakContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CBreakContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CBreakContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CBreakContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CBreak(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CBreak(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CBreakContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CBreak(self);
    }
}

impl<'input> CustomRuleContext<'input> for CBreakContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CBreakContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CBreakContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CBreakContext<'input> {}

impl<'input> CBreakContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CBreakContext(BaseParserRuleContext::copy_from(
            ctx,
            CBreakContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CWithContext<'input> = BaseParserRuleContext<'input, CWithContextExt<'input>>;

pub trait CWithContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CWithContextAttrs<'input> for CWithContext<'input> {}

pub struct CWithContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CWithContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CWithContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CWithContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CWith(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CWithContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CWith(self);
    }
}

impl<'input> CustomRuleContext<'input> for CWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CWithContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CWithContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CWithContext<'input> {}

impl<'input> CWithContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CWithContext(BaseParserRuleContext::copy_from(
            ctx,
            CWithContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CYieldContext<'input> = BaseParserRuleContext<'input, CYieldContextExt<'input>>;

pub trait CYieldContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token YIELD
    /// Returns `None` if there is no child corresponding to token YIELD
    fn YIELD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(YIELD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CYieldContextAttrs<'input> for CYieldContext<'input> {}

pub struct CYieldContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CYieldContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CYieldContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CYieldContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CYield(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CYield(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CYieldContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CYield(self);
    }
}

impl<'input> CustomRuleContext<'input> for CYieldContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CYieldContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CYieldContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CYieldContext<'input> {}

impl<'input> CYieldContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CYieldContext(BaseParserRuleContext::copy_from(
            ctx,
            CYieldContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CReturnContext<'input> = BaseParserRuleContext<'input, CReturnContextExt<'input>>;

pub trait CReturnContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token RETURN
    /// Returns `None` if there is no child corresponding to token RETURN
    fn RETURN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RESUME
    /// Returns `None` if there is no child corresponding to token RESUME
    fn RESUME(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RESUME, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CReturnContextAttrs<'input> for CReturnContext<'input> {}

pub struct CReturnContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CReturnContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CReturnContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CReturnContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CReturn(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CReturn(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CReturnContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CReturn(self);
    }
}

impl<'input> CustomRuleContext<'input> for CReturnContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CReturnContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CReturnContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CReturnContext<'input> {}

impl<'input> CReturnContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CReturnContext(BaseParserRuleContext::copy_from(
            ctx,
            CReturnContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CRaiseContext<'input> = BaseParserRuleContext<'input, CRaiseContextExt<'input>>;

pub trait CRaiseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token RAISE
    /// Returns `None` if there is no child corresponding to token RAISE
    fn RAISE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAISE, 0)
    }
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CRaiseContextAttrs<'input> for CRaiseContext<'input> {}

pub struct CRaiseContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CRaiseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CRaiseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CRaiseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CRaise(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CRaise(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CRaiseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CRaise(self);
    }
}

impl<'input> CustomRuleContext<'input> for CRaiseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CRaiseContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CRaiseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CRaiseContext<'input> {}

impl<'input> CRaiseContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CRaiseContext(BaseParserRuleContext::copy_from(
            ctx,
            CRaiseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CContinueContext<'input> = BaseParserRuleContext<'input, CContinueContextExt<'input>>;

pub trait CContinueContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token CONTINUE
    /// Returns `None` if there is no child corresponding to token CONTINUE
    fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(CONTINUE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CContinueContextAttrs<'input> for CContinueContext<'input> {}

pub struct CContinueContextExt<'input> {
    base: Control_expressionContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CContinueContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CContinueContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CContinueContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CContinue(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CContinue(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CContinueContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CContinue(self);
    }
}

impl<'input> CustomRuleContext<'input> for CContinueContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_control_expression
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_control_expression }
}

impl<'input> Borrow<Control_expressionContextExt<'input>> for CContinueContext<'input> {
    fn borrow(&self) -> &Control_expressionContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Control_expressionContextExt<'input>> for CContinueContext<'input> {
    fn borrow_mut(&mut self) -> &mut Control_expressionContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Control_expressionContextAttrs<'input> for CContinueContext<'input> {}

impl<'input> CContinueContextExt<'input> {
    fn new(ctx: &dyn Control_expressionContextAttrs<'input>) -> Rc<Control_expressionContextAll<'input>> {
        Rc::new(Control_expressionContextAll::CContinueContext(BaseParserRuleContext::copy_from(
            ctx,
            CContinueContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn control_expression(&mut self) -> Result<Rc<Control_expressionContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Control_expressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_control_expression);
        let mut _localctx: Rc<Control_expressionContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1337);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(176, &mut recog.base)? {
                1 => {
                    let tmp = CReturnContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1310);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            RETURN => {
                                recog.base.set_state(1305);
                                recog.base.match_token(RETURN, &mut recog.err_handler)?;
                            }

                            RESUME => {
                                {
                                    recog.base.set_state(1306);
                                    recog.base.match_token(RESUME, &mut recog.err_handler)?;

                                    recog.base.set_state(1308);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    match recog.interpreter.adaptive_predict(170, &mut recog.base)? {
                                        x if x == 1 => {
                                            {
                                                /* InvokeRule expression */
                                                recog.base.set_state(1307);
                                                recog.expression_rec(0)?;
                                            }
                                        }

                                        _ => {}
                                    }
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                2 => {
                    let tmp = CBreakContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1312);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;

                        recog.base.set_state(1315);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(172, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1313);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1314);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                3 => {
                    let tmp = CContinueContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1317);
                        recog.base.match_token(CONTINUE, &mut recog.err_handler)?;

                        recog.base.set_state(1320);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(173, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1318);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1319);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                4 => {
                    let tmp = CRaiseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1322);
                        recog.base.match_token(RAISE, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1323);
                        recog.expression_rec(0)?;
                    }
                }
                5 => {
                    let tmp = CYieldContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1324);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1327);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(174, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    recog.base.set_state(1325);
                                    recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                                    /* InvokeRule identifier */
                                    recog.base.set_state(1326);
                                    recog.identifier()?;
                                }
                            }

                            _ => {}
                        }
                        recog.base.set_state(1330);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(175, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule expression */
                                    recog.base.set_state(1329);
                                    recog.expression_rec(0)?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                6 => {
                    let tmp = CBreakContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1332);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1333);
                        recog.base.match_token(BREAK, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    let tmp = CWithContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 7);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1334);
                        recog.base.match_token(YIELD, &mut recog.err_handler)?;

                        recog.base.set_state(1335);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1336);
                        recog.expression_rec(0)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_prefix ----------------
pub type Op_prefixContextAll<'input> = Op_prefixContext<'input>;

pub type Op_prefixContext<'input> = BaseParserRuleContext<'input, Op_prefixContextExt<'input>>;

#[derive(Clone)]
pub struct Op_prefixContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_prefixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_prefixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_prefix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_prefix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_prefixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_prefix(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_prefixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_prefix
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_prefix }
}
antlr_rust::tid! {Op_prefixContextExt<'a>}

impl<'input> Op_prefixContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_prefixContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_prefixContextExt { ph: PhantomData }))
    }
}

pub trait Op_prefixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_prefixContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_NOT
    /// Returns `None` if there is no child corresponding to token OP_NOT
    fn OP_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REFERENCE
    /// Returns `None` if there is no child corresponding to token OP_REFERENCE
    fn OP_REFERENCE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REFERENCE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT2
    /// Returns `None` if there is no child corresponding to token OP_DOT2
    fn OP_DOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DOT3
    /// Returns `None` if there is no child corresponding to token OP_DOT3
    fn OP_DOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DOT3, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_INVERSE
    /// Returns `None` if there is no child corresponding to token OP_INVERSE
    fn OP_INVERSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_INVERSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT2
    /// Returns `None` if there is no child corresponding to token OP_ROOT2
    fn OP_ROOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT3
    /// Returns `None` if there is no child corresponding to token OP_ROOT3
    fn OP_ROOT3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT3, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT4
    /// Returns `None` if there is no child corresponding to token OP_ROOT4
    fn OP_ROOT4(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT4, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
}

impl<'input> Op_prefixContextAttrs<'input> for Op_prefixContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_prefix(&mut self) -> Result<Rc<Op_prefixContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_prefixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_op_prefix);
        let mut _localctx: Rc<Op_prefixContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1339);
                _la = recog.base.input.la(1);
                if {
                    !((((_la) & !0x3f) == 0
                        && ((1usize << _la) & ((1usize << OP_ADD) | (1usize << OP_SUB) | (1usize << OP_MUL))) != 0)
                        || (((_la - 69) & !0x3f) == 0
                            && ((1usize << (_la - 69))
                                & ((1usize << (OP_AND - 69))
                                    | (1usize << (OP_NOT - 69))
                                    | (1usize << (OP_DOT3 - 69))
                                    | (1usize << (OP_DOT2 - 69))
                                    | (1usize << (OP_INVERSE - 69))
                                    | (1usize << (OP_ROOT2 - 69))
                                    | (1usize << (OP_ROOT3 - 69))))
                                != 0)
                        || _la == OP_ROOT4
                        || _la == OP_REFERENCE)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_suffix ----------------
pub type Op_suffixContextAll<'input> = Op_suffixContext<'input>;

pub type Op_suffixContext<'input> = BaseParserRuleContext<'input, Op_suffixContextExt<'input>>;

#[derive(Clone)]
pub struct Op_suffixContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_suffixContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_suffixContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_suffix(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_suffix(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_suffixContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_suffix(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_suffixContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_suffix
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_suffix }
}
antlr_rust::tid! {Op_suffixContextExt<'a>}

impl<'input> Op_suffixContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_suffixContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_suffixContextExt { ph: PhantomData }))
    }
}

pub trait Op_suffixContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_suffixContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_NOT
    /// Returns `None` if there is no child corresponding to token OP_NOT
    fn OP_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TEMPERATURE
    /// Returns `None` if there is no child corresponding to token OP_TEMPERATURE
    fn OP_TEMPERATURE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TEMPERATURE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_TRANSPOSE
    /// Returns `None` if there is no child corresponding to token OP_TRANSPOSE
    fn OP_TRANSPOSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_TRANSPOSE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PERCENT
    /// Returns `None` if there is no child corresponding to token OP_PERCENT
    fn OP_PERCENT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PERCENT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REM
    /// Returns `None` if there is no child corresponding to token OP_REM
    fn OP_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR_DEFAULT
    /// Returns `None` if there is no child corresponding to token OP_OR_DEFAULT
    fn OP_OR_DEFAULT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR_DEFAULT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_INC
    /// Returns `None` if there is no child corresponding to token OP_INC
    fn OP_INC(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_INC, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DEC
    /// Returns `None` if there is no child corresponding to token OP_DEC
    fn OP_DEC(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DEC, 0)
    }
}

impl<'input> Op_suffixContextAttrs<'input> for Op_suffixContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_suffix(&mut self) -> Result<Rc<Op_suffixContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_suffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_op_suffix);
        let mut _localctx: Rc<Op_suffixContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1341);
                _la = recog.base.input.la(1);
                if {
                    !((((_la - 28) & !0x3f) == 0
                        && ((1usize << (_la - 28))
                            & ((1usize << (OP_INC - 28)) | (1usize << (OP_DEC - 28)) | (1usize << (OP_REM - 28))))
                            != 0)
                        || (((_la - 81) & !0x3f) == 0
                            && ((1usize << (_la - 81))
                                & ((1usize << (OP_OR_DEFAULT - 81))
                                    | (1usize << (OP_NOT - 81))
                                    | (1usize << (OP_TEMPERATURE - 81))
                                    | (1usize << (OP_TRANSPOSE - 81))
                                    | (1usize << (OP_PERCENT - 81))))
                                != 0))
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_compare ----------------
pub type Op_compareContextAll<'input> = Op_compareContext<'input>;

pub type Op_compareContext<'input> = BaseParserRuleContext<'input, Op_compareContextExt<'input>>;

#[derive(Clone)]
pub struct Op_compareContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_compareContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_compareContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_compare(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_compare(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_compareContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_compare(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_compareContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_compare
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_compare }
}
antlr_rust::tid! {Op_compareContextExt<'a>}

impl<'input> Op_compareContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_compareContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_compareContextExt { ph: PhantomData }))
    }
}

pub trait Op_compareContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_compareContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LEQ
    /// Returns `None` if there is no child corresponding to token OP_LEQ
    fn OP_LEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GEQ
    /// Returns `None` if there is no child corresponding to token OP_GEQ
    fn OP_GEQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GEQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_EQ
    /// Returns `None` if there is no child corresponding to token OP_EQ
    fn OP_EQ(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_EQ, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NE
    /// Returns `None` if there is no child corresponding to token OP_NE
    fn OP_NE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_EEE
    /// Returns `None` if there is no child corresponding to token OP_EEE
    fn OP_EEE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_EEE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NEE
    /// Returns `None` if there is no child corresponding to token OP_NEE
    fn OP_NEE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NEE, 0)
    }
}

impl<'input> Op_compareContextAttrs<'input> for Op_compareContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_compare(&mut self) -> Result<Rc<Op_compareContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_compareContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_op_compare);
        let mut _localctx: Rc<Op_compareContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1343);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 35) & !0x3f) == 0
                        && ((1usize << (_la - 35))
                            & ((1usize << (OP_EQ - 35))
                                | (1usize << (OP_NE - 35))
                                | (1usize << (OP_NEE - 35))
                                | (1usize << (OP_EEE - 35))
                                | (1usize << (OP_LEQ - 35))
                                | (1usize << (OP_LT - 35))
                                | (1usize << (OP_GEQ - 35))
                                | (1usize << (OP_GT - 35))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_pattern ----------------
pub type Op_patternContextAll<'input> = Op_patternContext<'input>;

pub type Op_patternContext<'input> = BaseParserRuleContext<'input, Op_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Op_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_patternContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_pattern(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_pattern(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_patternContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_pattern(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_pattern }
}
antlr_rust::tid! {Op_patternContextExt<'a>}

impl<'input> Op_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_patternContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_patternContextExt { ph: PhantomData }))
    }
}

pub trait Op_patternContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_patternContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AND
    /// Returns `None` if there is no child corresponding to token OP_AND
    fn OP_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
}

impl<'input> Op_patternContextAttrs<'input> for Op_patternContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_pattern(&mut self) -> Result<Rc<Op_patternContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_op_pattern);
        let mut _localctx: Rc<Op_patternContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1345);
                _la = recog.base.input.la(1);
                if { !(_la == OP_AND || _la == OP_OR) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_map ----------------
pub type Infix_mapContextAll<'input> = Infix_mapContext<'input>;

pub type Infix_mapContext<'input> = BaseParserRuleContext<'input, Infix_mapContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_mapContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_mapContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_mapContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_map(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_map(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_mapContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_map(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_mapContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_map
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_map }
}
antlr_rust::tid! {Infix_mapContextExt<'a>}

impl<'input> Infix_mapContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_mapContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_mapContextExt { ph: PhantomData }))
    }
}

pub trait Infix_mapContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_mapContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_MAP
    /// Returns `None` if there is no child corresponding to token OP_MAP
    fn OP_MAP(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MAP, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_APPLY2
    /// Returns `None` if there is no child corresponding to token OP_APPLY2
    fn OP_APPLY2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_APPLY2, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_APPLY3
    /// Returns `None` if there is no child corresponding to token OP_APPLY3
    fn OP_APPLY3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_APPLY3, 0)
    }
}

impl<'input> Infix_mapContextAttrs<'input> for Infix_mapContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_map(&mut self) -> Result<Rc<Infix_mapContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_mapContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_infix_map);
        let mut _localctx: Rc<Infix_mapContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1347);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 73) & !0x3f) == 0
                        && ((1usize << (_la - 73))
                            & ((1usize << (OP_MAP - 73)) | (1usize << (OP_APPLY2 - 73)) | (1usize << (OP_APPLY3 - 73))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_pow ----------------
pub type Infix_powContextAll<'input> = Infix_powContext<'input>;

pub type Infix_powContext<'input> = BaseParserRuleContext<'input, Infix_powContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_powContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_powContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_powContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_pow(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_pow(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_powContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_pow(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_powContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_pow
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_pow }
}
antlr_rust::tid! {Infix_powContextExt<'a>}

impl<'input> Infix_powContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_powContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_powContextExt { ph: PhantomData }))
    }
}

pub trait Infix_powContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_powContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_POW
    /// Returns `None` if there is no child corresponding to token OP_POW
    fn OP_POW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_POW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ROOT2
    /// Returns `None` if there is no child corresponding to token OP_ROOT2
    fn OP_ROOT2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ROOT2, 0)
    }
}

impl<'input> Infix_powContextAttrs<'input> for Infix_powContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_pow(&mut self) -> Result<Rc<Infix_powContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_powContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_infix_pow);
        let mut _localctx: Rc<Infix_powContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1349);
                _la = recog.base.input.la(1);
                if { !(_la == OP_POW || _la == OP_ROOT2) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_range ----------------
pub type Infix_rangeContextAll<'input> = Infix_rangeContext<'input>;

pub type Infix_rangeContext<'input> = BaseParserRuleContext<'input, Infix_rangeContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_rangeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_rangeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_rangeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_range(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_range(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_rangeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_range(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_rangeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_range
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_range }
}
antlr_rust::tid! {Infix_rangeContextExt<'a>}

impl<'input> Infix_rangeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_rangeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_rangeContextExt { ph: PhantomData }))
    }
}

pub trait Infix_rangeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_rangeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> Infix_rangeContextAttrs<'input> for Infix_rangeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_range(&mut self) -> Result<Rc<Infix_rangeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_rangeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_infix_range);
        let mut _localctx: Rc<Infix_rangeContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1351);
                recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_arrows ----------------
pub type Infix_arrowsContextAll<'input> = Infix_arrowsContext<'input>;

pub type Infix_arrowsContext<'input> = BaseParserRuleContext<'input, Infix_arrowsContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_arrowsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_arrowsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_arrowsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_arrows(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_arrows(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_arrowsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_arrows(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_arrowsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_arrows
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_arrows }
}
antlr_rust::tid! {Infix_arrowsContextExt<'a>}

impl<'input> Infix_arrowsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_arrowsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_arrowsContextExt { ph: PhantomData }))
    }
}

pub trait Infix_arrowsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_arrowsContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_ARROW
    /// Returns `None` if there is no child corresponding to token OP_ARROW
    fn OP_ARROW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW2
    /// Returns `None` if there is no child corresponding to token OP_ARROW2
    fn OP_ARROW2(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW2, 0)
    }
}

impl<'input> Infix_arrowsContextAttrs<'input> for Infix_arrowsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_arrows(&mut self) -> Result<Rc<Infix_arrowsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_arrowsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_infix_arrows);
        let mut _localctx: Rc<Infix_arrowsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1353);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ARROW || _la == OP_ARROW2) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_multiple ----------------
pub type Op_multipleContextAll<'input> = Op_multipleContext<'input>;

pub type Op_multipleContext<'input> = BaseParserRuleContext<'input, Op_multipleContextExt<'input>>;

#[derive(Clone)]
pub struct Op_multipleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_multipleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_multipleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_multiple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_multiple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_multipleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_multiple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_multipleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_multiple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_multiple }
}
antlr_rust::tid! {Op_multipleContextExt<'a>}

impl<'input> Op_multipleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_multipleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_multipleContextExt { ph: PhantomData }))
    }
}

pub trait Op_multipleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Op_multipleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_MUL
    /// Returns `None` if there is no child corresponding to token OP_MUL
    fn OP_MUL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV
    /// Returns `None` if there is no child corresponding to token OP_DIV
    fn OP_DIV(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REM
    /// Returns `None` if there is no child corresponding to token OP_REM
    fn OP_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV_REM
    /// Returns `None` if there is no child corresponding to token OP_DIV_REM
    fn OP_DIV_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV_REM, 0)
    }
}

impl<'input> Op_multipleContextAttrs<'input> for Op_multipleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_multiple(&mut self) -> Result<Rc<Op_multipleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_multipleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_op_multiple);
        let mut _localctx: Rc<Op_multipleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1355);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 30) & !0x3f) == 0
                        && ((1usize << (_la - 30))
                            & ((1usize << (OP_MUL - 30))
                                | (1usize << (OP_DIV - 30))
                                | (1usize << (OP_REM - 30))
                                | (1usize << (OP_DIV_REM - 30))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_plus ----------------
pub type Op_plusContextAll<'input> = Op_plusContext<'input>;

pub type Op_plusContext<'input> = BaseParserRuleContext<'input, Op_plusContextExt<'input>>;

#[derive(Clone)]
pub struct Op_plusContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_plusContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_plusContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_plus(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_plus(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_plusContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_plus(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_plusContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_plus
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_plus }
}
antlr_rust::tid! {Op_plusContextExt<'a>}

impl<'input> Op_plusContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_plusContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_plusContextExt { ph: PhantomData }))
    }
}

pub trait Op_plusContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_plusContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB
    /// Returns `None` if there is no child corresponding to token OP_SUB
    fn OP_SUB(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB, 0)
    }
}

impl<'input> Op_plusContextAttrs<'input> for Op_plusContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_plus(&mut self) -> Result<Rc<Op_plusContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_plusContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_op_plus);
        let mut _localctx: Rc<Op_plusContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1357);
                _la = recog.base.input.la(1);
                if { !(_la == OP_ADD || _la == OP_SUB) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_logic ----------------
pub type Op_logicContextAll<'input> = Op_logicContext<'input>;

pub type Op_logicContext<'input> = BaseParserRuleContext<'input, Op_logicContextExt<'input>>;

#[derive(Clone)]
pub struct Op_logicContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_logicContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_logicContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_logic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_logic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_logicContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_logic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_logicContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_logic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_logic }
}
antlr_rust::tid! {Op_logicContextExt<'a>}

impl<'input> Op_logicContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_logicContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_logicContextExt { ph: PhantomData }))
    }
}

pub trait Op_logicContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_logicContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token LOGIC_OR
    /// Returns `None` if there is no child corresponding to token LOGIC_OR
    fn LOGIC_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_AND
    /// Returns `None` if there is no child corresponding to token LOGIC_AND
    fn LOGIC_AND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_AND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_XOR
    /// Returns `None` if there is no child corresponding to token LOGIC_XOR
    fn LOGIC_XOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_XOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NOR
    /// Returns `None` if there is no child corresponding to token LOGIC_NOR
    fn LOGIC_NOR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NOR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_NAND
    /// Returns `None` if there is no child corresponding to token LOGIC_NAND
    fn LOGIC_NAND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_NAND, 0)
    }
    /// Retrieves first TerminalNode corresponding to token LOGIC_XAND
    /// Returns `None` if there is no child corresponding to token LOGIC_XAND
    fn LOGIC_XAND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LOGIC_XAND, 0)
    }
}

impl<'input> Op_logicContextAttrs<'input> for Op_logicContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_logic(&mut self) -> Result<Rc<Op_logicContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_logicContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_op_logic);
        let mut _localctx: Rc<Op_logicContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1359);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 61) & !0x3f) == 0
                        && ((1usize << (_la - 61))
                            & ((1usize << (LOGIC_AND - 61))
                                | (1usize << (LOGIC_XAND - 61))
                                | (1usize << (LOGIC_NAND - 61))
                                | (1usize << (LOGIC_OR - 61))
                                | (1usize << (LOGIC_XOR - 61))
                                | (1usize << (LOGIC_NOR - 61))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_pipeline ----------------
pub type Op_pipelineContextAll<'input> = Op_pipelineContext<'input>;

pub type Op_pipelineContext<'input> = BaseParserRuleContext<'input, Op_pipelineContextExt<'input>>;

#[derive(Clone)]
pub struct Op_pipelineContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_pipelineContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_pipelineContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_pipeline(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_pipeline(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_pipelineContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_pipeline(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_pipelineContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_pipeline
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_pipeline }
}
antlr_rust::tid! {Op_pipelineContextExt<'a>}

impl<'input> Op_pipelineContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_pipelineContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_pipelineContextExt { ph: PhantomData }))
    }
}

pub trait Op_pipelineContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Op_pipelineContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LL
    /// Returns `None` if there is no child corresponding to token OP_LL
    fn OP_LL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LLE
    /// Returns `None` if there is no child corresponding to token OP_LLE
    fn OP_LLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LLL
    /// Returns `None` if there is no child corresponding to token OP_LLL
    fn OP_LLL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LLL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GG
    /// Returns `None` if there is no child corresponding to token OP_GG
    fn OP_GG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GGG
    /// Returns `None` if there is no child corresponding to token OP_GGG
    fn OP_GGG(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GGG, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ARROW3
    /// Returns `None` if there is no child corresponding to token OP_ARROW3
    fn OP_ARROW3(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ARROW3, 0)
    }
}

impl<'input> Op_pipelineContextAttrs<'input> for Op_pipelineContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_pipeline(&mut self) -> Result<Rc<Op_pipelineContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_pipelineContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_op_pipeline);
        let mut _localctx: Rc<Op_pipelineContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1361);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 40) & !0x3f) == 0
                        && ((1usize << (_la - 40))
                            & ((1usize << (OP_LLE - 40))
                                | (1usize << (OP_LLL - 40))
                                | (1usize << (OP_LL - 40))
                                | (1usize << (OP_GGG - 40))
                                | (1usize << (OP_GG - 40))
                                | (1usize << (OP_ARROW3 - 40))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- op_assign ----------------
pub type Op_assignContextAll<'input> = Op_assignContext<'input>;

pub type Op_assignContext<'input> = BaseParserRuleContext<'input, Op_assignContextExt<'input>>;

#[derive(Clone)]
pub struct Op_assignContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Op_assignContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Op_assignContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_op_assign(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_op_assign(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Op_assignContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_op_assign(self);
    }
}

impl<'input> CustomRuleContext<'input> for Op_assignContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_op_assign
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_op_assign }
}
antlr_rust::tid! {Op_assignContextExt<'a>}

impl<'input> Op_assignContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Op_assignContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Op_assignContextExt { ph: PhantomData }))
    }
}

pub trait Op_assignContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Op_assignContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ASSIGN
    fn OP_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_ADD_ASSIGN
    fn OP_ADD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_SUB_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_SUB_ASSIGN
    fn OP_SUB_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_SUB_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MUL_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MUL_ASSIGN
    fn OP_MUL_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MUL_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_DIV_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_DIV_ASSIGN
    fn OP_DIV_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_DIV_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_MAY_ASSIGN
    /// Returns `None` if there is no child corresponding to token OP_MAY_ASSIGN
    fn OP_MAY_ASSIGN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_MAY_ASSIGN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GGE
    /// Returns `None` if there is no child corresponding to token OP_GGE
    fn OP_GGE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GGE, 0)
    }
}

impl<'input> Op_assignContextAttrs<'input> for Op_assignContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn op_assign(&mut self) -> Result<Rc<Op_assignContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Op_assignContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_op_assign);
        let mut _localctx: Rc<Op_assignContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1363);
                _la = recog.base.input.la(1);
                if {
                    !(((_la - 45) & !0x3f) == 0
                        && ((1usize << (_la - 45))
                            & ((1usize << (OP_GGE - 45))
                                | (1usize << (OP_ASSIGN - 45))
                                | (1usize << (OP_MAY_ASSIGN - 45))
                                | (1usize << (OP_ADD_ASSIGN - 45))
                                | (1usize << (OP_SUB_ASSIGN - 45))
                                | (1usize << (OP_MUL_ASSIGN - 45))
                                | (1usize << (OP_DIV_ASSIGN - 45))))
                            != 0)
                } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_is ----------------
pub type Infix_isContextAll<'input> = Infix_isContext<'input>;

pub type Infix_isContext<'input> = BaseParserRuleContext<'input, Infix_isContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_isContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_isContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_isContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_is(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_is(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_isContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_is(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_isContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_is
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_is }
}
antlr_rust::tid! {Infix_isContextExt<'a>}

impl<'input> Infix_isContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_isContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_isContextExt { ph: PhantomData }))
    }
}

pub trait Infix_isContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_isContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IS
    /// Returns `None` if there is no child corresponding to token KW_IS
    fn KW_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IS
    /// Returns `None` if there is no child corresponding to token OP_IS
    fn OP_IS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IS, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IS_NOT
    /// Returns `None` if there is no child corresponding to token OP_IS_NOT
    fn OP_IS_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IS_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_CONTINUES
    /// Returns `None` if there is no child corresponding to token OP_CONTINUES
    fn OP_CONTINUES(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_CONTINUES, 0)
    }
}

impl<'input> Infix_isContextAttrs<'input> for Infix_isContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_is(&mut self) -> Result<Rc<Infix_isContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_isContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_infix_is);
        let mut _localctx: Rc<Infix_isContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1371);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(177, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1365);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1366);
                        recog.base.match_token(KW_IS, &mut recog.err_handler)?;

                        recog.base.set_state(1367);
                        recog.base.match_token(KW_NOT, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1368);
                        recog.base.match_token(OP_IS, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1369);
                        recog.base.match_token(OP_IS_NOT, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1370);
                        recog.base.match_token(OP_CONTINUES, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_as ----------------
pub type Infix_asContextAll<'input> = Infix_asContext<'input>;

pub type Infix_asContext<'input> = BaseParserRuleContext<'input, Infix_asContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_asContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_asContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_asContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_as(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_as(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_asContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_as(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_asContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_as
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_as }
}
antlr_rust::tid! {Infix_asContextExt<'a>}

impl<'input> Infix_asContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_asContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_asContextExt { ph: PhantomData }))
    }
}

pub trait Infix_asContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_asContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_AS
    /// Returns `None` if there is no child corresponding to token KW_AS
    fn KW_AS(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_AS, 0)
    }
}

impl<'input> Infix_asContextAttrs<'input> for Infix_asContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_as(&mut self) -> Result<Rc<Infix_asContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_asContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_infix_as);
        let mut _localctx: Rc<Infix_asContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1373);
                recog.base.match_token(KW_AS, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- infix_in ----------------
pub type Infix_inContextAll<'input> = Infix_inContext<'input>;

pub type Infix_inContext<'input> = BaseParserRuleContext<'input, Infix_inContextExt<'input>>;

#[derive(Clone)]
pub struct Infix_inContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Infix_inContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Infix_inContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_infix_in(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_infix_in(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Infix_inContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_infix_in(self);
    }
}

impl<'input> CustomRuleContext<'input> for Infix_inContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_infix_in
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_infix_in }
}
antlr_rust::tid! {Infix_inContextExt<'a>}

impl<'input> Infix_inContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Infix_inContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Infix_inContextExt { ph: PhantomData }))
    }
}

pub trait Infix_inContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Infix_inContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token KW_IN
    /// Returns `None` if there is no child corresponding to token KW_IN
    fn KW_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_NOT
    /// Returns `None` if there is no child corresponding to token KW_NOT
    fn KW_NOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NOT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_IN
    /// Returns `None` if there is no child corresponding to token OP_IN
    fn OP_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_IN, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_NOT_IN
    /// Returns `None` if there is no child corresponding to token OP_NOT_IN
    fn OP_NOT_IN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_NOT_IN, 0)
    }
}

impl<'input> Infix_inContextAttrs<'input> for Infix_inContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn infix_in(&mut self) -> Result<Rc<Infix_inContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Infix_inContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_infix_in);
        let mut _localctx: Rc<Infix_inContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1380);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                KW_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1375);
                        recog.base.match_token(KW_IN, &mut recog.err_handler)?;
                    }
                }

                KW_NOT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1376);
                        recog.base.match_token(KW_NOT, &mut recog.err_handler)?;

                        recog.base.set_state(1377);
                        recog.base.match_token(KW_IN, &mut recog.err_handler)?;
                    }
                }

                OP_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1378);
                        recog.base.match_token(OP_IN, &mut recog.err_handler)?;
                    }
                }

                OP_NOT_IN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1379);
                        recog.base.match_token(OP_NOT_IN, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_generic ----------------
pub type Define_genericContextAll<'input> = Define_genericContext<'input>;

pub type Define_genericContext<'input> = BaseParserRuleContext<'input, Define_genericContextExt<'input>>;

#[derive(Clone)]
pub struct Define_genericContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_genericContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_genericContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_generic(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_generic(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_genericContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_generic(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_genericContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_generic
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_generic }
}
antlr_rust::tid! {Define_genericContextExt<'a>}

impl<'input> Define_genericContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_genericContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_genericContextExt { ph: PhantomData }))
    }
}

pub trait Define_genericContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_genericContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
    fn generic_item_all(&self) -> Vec<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_item(&self, i: usize) -> Option<Rc<Generic_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
}

impl<'input> Define_genericContextAttrs<'input> for Define_genericContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_generic(&mut self) -> Result<Rc<Define_genericContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_genericContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_define_generic);
        let mut _localctx: Rc<Define_genericContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1420);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(185, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1382);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1383);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1384);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1385);
                        recog.generic_item()?;

                        recog.base.set_state(1390);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(179, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1386);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1387);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1392);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(179, &mut recog.base)?;
                        }
                        recog.base.set_state(1394);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1393);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1396);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1399);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1398);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1401);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1402);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1404);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1403);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1406);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_item */
                        recog.base.set_state(1407);
                        recog.generic_item()?;

                        recog.base.set_state(1412);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(183, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1408);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_item */
                                        recog.base.set_state(1409);
                                        recog.generic_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1414);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(183, &mut recog.base)?;
                        }
                        recog.base.set_state(1416);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1415);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1418);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_item ----------------
pub type Generic_itemContextAll<'input> = Generic_itemContext<'input>;

pub type Generic_itemContext<'input> = BaseParserRuleContext<'input, Generic_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_item }
}
antlr_rust::tid! {Generic_itemContextExt<'a>}

impl<'input> Generic_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_itemContextExt { ph: PhantomData }))
    }
}

pub trait Generic_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_itemContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_itemContextAttrs<'input> for Generic_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_item(&mut self) -> Result<Rc<Generic_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_generic_item);
        let mut _localctx: Rc<Generic_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1425);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(186, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1422);
                            recog.identifier()?;

                            recog.base.set_state(1423);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1427);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call ----------------
pub type Generic_callContextAll<'input> = Generic_callContext<'input>;

pub type Generic_callContext<'input> = BaseParserRuleContext<'input, Generic_callContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call }
}
antlr_rust::tid! {Generic_callContextExt<'a>}

impl<'input> Generic_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_callContextExt { ph: PhantomData }))
    }
}

pub trait Generic_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_callContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_callContextAttrs<'input> for Generic_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call(&mut self) -> Result<Rc<Generic_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_generic_call);
        let mut _localctx: Rc<Generic_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1463);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(191, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1429);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1430);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        recog.base.set_state(1431);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1432);
                        recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                        recog.base.set_state(1433);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1434);
                        recog.generic_pair()?;

                        recog.base.set_state(1439);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(187, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1435);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1436);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1441);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(187, &mut recog.base)?;
                        }
                        recog.base.set_state(1443);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1442);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1445);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1447);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        recog.base.set_state(1448);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1449);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1450);
                        recog.generic_pair()?;

                        recog.base.set_state(1455);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(189, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1451);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule generic_pair */
                                        recog.base.set_state(1452);
                                        recog.generic_pair()?;
                                    }
                                }
                            }
                            recog.base.set_state(1457);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(189, &mut recog.base)?;
                        }
                        recog.base.set_state(1459);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1458);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1461);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_call_in_type ----------------
pub type Generic_call_in_typeContextAll<'input> = Generic_call_in_typeContext<'input>;

pub type Generic_call_in_typeContext<'input> = BaseParserRuleContext<'input, Generic_call_in_typeContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_call_in_typeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_call_in_type(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_call_in_type(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_call_in_typeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_call_in_type(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_call_in_typeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_call_in_type
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_call_in_type }
}
antlr_rust::tid! {Generic_call_in_typeContextExt<'a>}

impl<'input> Generic_call_in_typeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_call_in_typeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Generic_call_in_typeContextExt { ph: PhantomData },
        ))
    }
}

pub trait Generic_call_in_typeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_call_in_typeContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LT
    /// Returns `None` if there is no child corresponding to token OP_LT
    fn OP_LT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LT, 0)
    }
    fn generic_pair_all(&self) -> Vec<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn generic_pair(&self, i: usize) -> Option<Rc<Generic_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_GT
    /// Returns `None` if there is no child corresponding to token OP_GT
    fn OP_GT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_GT, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_L
    /// Returns `None` if there is no child corresponding to token GENERIC_L
    fn GENERIC_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token GENERIC_R
    /// Returns `None` if there is no child corresponding to token GENERIC_R
    fn GENERIC_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(GENERIC_R, 0)
    }
}

impl<'input> Generic_call_in_typeContextAttrs<'input> for Generic_call_in_typeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_call_in_type(&mut self) -> Result<Rc<Generic_call_in_typeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_call_in_typeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_generic_call_in_type);
        let mut _localctx: Rc<Generic_call_in_typeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1490);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                OP_PROPORTION | OP_LT => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1466);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION {
                            {
                                recog.base.set_state(1465);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1468);
                        recog.base.match_token(OP_LT, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1469);
                        recog.generic_pair()?;

                        recog.base.set_state(1474);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1470);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1471);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1476);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1477);
                        recog.base.match_token(OP_GT, &mut recog.err_handler)?;
                    }
                }

                GENERIC_L => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1479);
                        recog.base.match_token(GENERIC_L, &mut recog.err_handler)?;

                        /* InvokeRule generic_pair */
                        recog.base.set_state(1480);
                        recog.generic_pair()?;

                        recog.base.set_state(1485);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1481);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule generic_pair */
                                    recog.base.set_state(1482);
                                    recog.generic_pair()?;
                                }
                            }
                            recog.base.set_state(1487);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1488);
                        recog.base.match_token(GENERIC_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- generic_pair ----------------
pub type Generic_pairContextAll<'input> = Generic_pairContext<'input>;

pub type Generic_pairContext<'input> = BaseParserRuleContext<'input, Generic_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Generic_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Generic_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Generic_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_generic_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_generic_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Generic_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_generic_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Generic_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_generic_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_generic_pair }
}
antlr_rust::tid! {Generic_pairContextExt<'a>}

impl<'input> Generic_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Generic_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Generic_pairContextExt { ph: PhantomData }))
    }
}

pub trait Generic_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Generic_pairContextExt<'input>>
{
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Generic_pairContextAttrs<'input> for Generic_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn generic_pair(&mut self) -> Result<Rc<Generic_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Generic_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_generic_pair);
        let mut _localctx: Rc<Generic_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1495);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(196, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1492);
                            recog.identifier()?;

                            recog.base.set_state(1493);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule type_expression */
                recog.base.set_state(1497);
                recog.type_expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- define_label ----------------
pub type Define_labelContextAll<'input> = Define_labelContext<'input>;

pub type Define_labelContext<'input> = BaseParserRuleContext<'input, Define_labelContextExt<'input>>;

#[derive(Clone)]
pub struct Define_labelContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Define_labelContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Define_labelContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_define_label(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_define_label(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Define_labelContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_define_label(self);
    }
}

impl<'input> CustomRuleContext<'input> for Define_labelContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_define_label
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_define_label }
}
antlr_rust::tid! {Define_labelContextExt<'a>}

impl<'input> Define_labelContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Define_labelContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Define_labelContextExt { ph: PhantomData }))
    }
}

pub trait Define_labelContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Define_labelContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token OP_LABEL
    /// Returns `None` if there is no child corresponding to token OP_LABEL
    fn OP_LABEL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LABEL, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Define_labelContextAttrs<'input> for Define_labelContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn define_label(&mut self) -> Result<Rc<Define_labelContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Define_labelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_define_label);
        let mut _localctx: Rc<Define_labelContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1499);
                recog.base.match_token(OP_LABEL, &mut recog.err_handler)?;

                /* InvokeRule identifier */
                recog.base.set_state(1500);
                recog.identifier()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_call ----------------
pub type Template_callContextAll<'input> = Template_callContext<'input>;

pub type Template_callContext<'input> = BaseParserRuleContext<'input, Template_callContextExt<'input>>;

#[derive(Clone)]
pub struct Template_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_call }
}
antlr_rust::tid! {Template_callContextExt<'a>}

impl<'input> Template_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_callContextExt { ph: PhantomData }))
    }
}

pub trait Template_callContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_callContextExt<'input>>
{
    fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_TEMPLATE
    /// Returns `None` if there is no child corresponding to token KW_TEMPLATE
    fn KW_TEMPLATE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TEMPLATE, 0)
    }
    fn template_block(&self) -> Option<Rc<Template_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Template_callContextAttrs<'input> for Template_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_call(&mut self) -> Result<Rc<Template_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_template_call);
        let mut _localctx: Rc<Template_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1533);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(201, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1505);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1502);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1507);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1508);
                        recog.modifiers()?;

                        recog.base.set_state(1509);
                        recog.base.match_token(KW_TEMPLATE, &mut recog.err_handler)?;

                        /* InvokeRule template_block */
                        recog.base.set_state(1510);
                        recog.template_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1515);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1512);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1517);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        /* InvokeRule modifiers */
                        recog.base.set_state(1518);
                        recog.modifiers()?;

                        recog.base.set_state(1519);
                        recog.base.match_token(KW_TEMPLATE, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1520);
                        recog.identifier()?;

                        recog.base.set_state(1525);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(199, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1521);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule identifier */
                                        recog.base.set_state(1522);
                                        recog.identifier()?;
                                    }
                                }
                            }
                            recog.base.set_state(1527);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(199, &mut recog.base)?;
                        }
                        recog.base.set_state(1529);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1528);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        /* InvokeRule template_block */
                        recog.base.set_state(1531);
                        recog.template_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_block ----------------
pub type Template_blockContextAll<'input> = Template_blockContext<'input>;

pub type Template_blockContext<'input> = BaseParserRuleContext<'input, Template_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Template_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_block }
}
antlr_rust::tid! {Template_blockContextExt<'a>}

impl<'input> Template_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Template_blockContextExt { ph: PhantomData }))
    }
}

pub trait Template_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn template_statements_all(&self) -> Vec<Rc<Template_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn template_statements(&self, i: usize) -> Option<Rc<Template_statementsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Template_blockContextAttrs<'input> for Template_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_block(&mut self) -> Result<Rc<Template_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_template_block);
        let mut _localctx: Rc<Template_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1535);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1540);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la)
                        & ((1usize << T__0) | (1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON)))
                        != 0)
                    || (((_la - 140) & !0x3f) == 0
                        && ((1usize << (_la - 140))
                            & ((1usize << (RETURN - 140)) | (1usize << (RAW_ID - 140)) | (1usize << (UNICODE_ID - 140))))
                            != 0)
                {
                    {
                        recog.base.set_state(1538);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            T__0 | RETURN | RAW_ID | UNICODE_ID => {
                                {
                                    /* InvokeRule template_statements */
                                    recog.base.set_state(1536);
                                    recog.template_statements()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1537);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1542);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1543);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- template_statements ----------------
pub type Template_statementsContextAll<'input> = Template_statementsContext<'input>;

pub type Template_statementsContext<'input> = BaseParserRuleContext<'input, Template_statementsContextExt<'input>>;

#[derive(Clone)]
pub struct Template_statementsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Template_statementsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Template_statementsContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_template_statements(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_template_statements(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Template_statementsContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_template_statements(self);
    }
}

impl<'input> CustomRuleContext<'input> for Template_statementsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_template_statements
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_template_statements }
}
antlr_rust::tid! {Template_statementsContextExt<'a>}

impl<'input> Template_statementsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Template_statementsContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Template_statementsContextExt { ph: PhantomData },
        ))
    }
}

pub trait Template_statementsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Template_statementsContextExt<'input>>
{
    fn where_block(&self) -> Option<Rc<Where_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token RETURN
    /// Returns `None` if there is no child corresponding to token RETURN
    fn RETURN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RETURN, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn require_block(&self) -> Option<Rc<Require_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Template_statementsContextAttrs<'input> for Template_statementsContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn template_statements(&mut self) -> Result<Rc<Template_statementsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Template_statementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_template_statements);
        let mut _localctx: Rc<Template_statementsContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1552);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                T__0 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1545);
                        recog.base.match_token(T__0, &mut recog.err_handler)?;

                        /* InvokeRule where_block */
                        recog.base.set_state(1546);
                        recog.where_block()?;
                    }
                }

                RETURN => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1547);
                        recog.base.match_token(RETURN, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1548);
                        recog.type_expression_rec(0)?;
                    }
                }

                RAW_ID | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1549);
                        recog.identifier()?;

                        /* InvokeRule require_block */
                        recog.base.set_state(1550);
                        recog.require_block()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_block ----------------
pub type Where_blockContextAll<'input> = Where_blockContext<'input>;

pub type Where_blockContext<'input> = BaseParserRuleContext<'input, Where_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Where_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_block }
}
antlr_rust::tid! {Where_blockContextExt<'a>}

impl<'input> Where_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_blockContextExt { ph: PhantomData }))
    }
}

pub trait Where_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn where_bound_all(&self) -> Vec<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn where_bound(&self, i: usize) -> Option<Rc<Where_boundContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Where_blockContextAttrs<'input> for Where_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_block(&mut self) -> Result<Rc<Where_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_where_block);
        let mut _localctx: Rc<Where_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1554);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1558);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == RAW_ID
                    || _la == UNICODE_ID
                {
                    {
                        {
                            /* InvokeRule where_bound */
                            recog.base.set_state(1555);
                            recog.where_bound()?;
                        }
                    }
                    recog.base.set_state(1560);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1561);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- where_bound ----------------
pub type Where_boundContextAll<'input> = Where_boundContext<'input>;

pub type Where_boundContext<'input> = BaseParserRuleContext<'input, Where_boundContextExt<'input>>;

#[derive(Clone)]
pub struct Where_boundContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Where_boundContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Where_boundContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_where_bound(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_where_bound(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Where_boundContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_where_bound(self);
    }
}

impl<'input> CustomRuleContext<'input> for Where_boundContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_where_bound
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_where_bound }
}
antlr_rust::tid! {Where_boundContextExt<'a>}

impl<'input> Where_boundContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Where_boundContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Where_boundContextExt { ph: PhantomData }))
    }
}

pub trait Where_boundContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Where_boundContextExt<'input>>
{
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn eos_free(&self) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Where_boundContextAttrs<'input> for Where_boundContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn where_bound(&mut self) -> Result<Rc<Where_boundContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Where_boundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_where_bound);
        let mut _localctx: Rc<Where_boundContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1568);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                RAW_ID | UNICODE_ID => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1563);
                        recog.identifier()?;

                        recog.base.set_state(1564);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1565);
                        recog.type_expression_rec(0)?;
                    }
                }

                COMMA | SEMICOLON | FAKE_COLON => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule eos_free */
                        recog.base.set_state(1567);
                        recog.eos_free()?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- require_block ----------------
pub type Require_blockContextAll<'input> = Require_blockContext<'input>;

pub type Require_blockContext<'input> = BaseParserRuleContext<'input, Require_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Require_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Require_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Require_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_require_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_require_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Require_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_require_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Require_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_require_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_require_block }
}
antlr_rust::tid! {Require_blockContextExt<'a>}

impl<'input> Require_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Require_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Require_blockContextExt { ph: PhantomData }))
    }
}

pub trait Require_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Require_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn expression_root_all(&self) -> Vec<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression_root(&self, i: usize) -> Option<Rc<Expression_rootContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Require_blockContextAttrs<'input> for Require_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn require_block(&mut self) -> Result<Rc<Require_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Require_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_require_block);
        let mut _localctx: Rc<Require_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1570);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1575);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la - 3) & !0x3f) == 0
                    && ((1usize << (_la - 3))
                        & ((1usize << (COMMA - 3))
                            | (1usize << (SEMICOLON - 3))
                            | (1usize << (FAKE_COLON - 3))
                            | (1usize << (PARENTHESES_L - 3))
                            | (1usize << (BRACKET_L - 3))
                            | (1usize << (BRACE_L - 3))
                            | (1usize << (OFFSET_L - 3))
                            | (1usize << (CEILING_L - 3))
                            | (1usize << (FLOOR_L - 3))
                            | (1usize << (OP_ADD - 3))
                            | (1usize << (OP_SUB - 3))
                            | (1usize << (OP_MUL - 3))
                            | (1usize << (OP_REM - 3))
                            | (1usize << (OP_LAST - 3))))
                        != 0)
                    || (((_la - 69) & !0x3f) == 0
                        && ((1usize << (_la - 69))
                            & ((1usize << (OP_AND - 69))
                                | (1usize << (OP_AT - 69))
                                | (1usize << (OP_HASH - 69))
                                | (1usize << (LAMBDA_SLOT - 69))
                                | (1usize << (OP_NOT - 69))
                                | (1usize << (OP_DOT3 - 69))
                                | (1usize << (OP_DOT2 - 69))
                                | (1usize << (OP_INVERSE - 69))
                                | (1usize << (OP_ROOT2 - 69))
                                | (1usize << (OP_ROOT3 - 69))))
                            != 0)
                    || (((_la - 101) & !0x3f) == 0
                        && ((1usize << (_la - 101))
                            & ((1usize << (OP_ROOT4 - 101))
                                | (1usize << (OP_REFERENCE - 101))
                                | (1usize << (OP_LABEL - 101))
                                | (1usize << (KW_NEW - 101))
                                | (1usize << (KW_OBJECT - 101))
                                | (1usize << (KW_LAMBDA - 101))
                                | (1usize << (KW_TRY - 101))
                                | (1usize << (KW_MATCH - 101))
                                | (1usize << (KW_CATCH - 101))
                                | (1usize << (INTEGER - 101))))
                            != 0)
                    || (((_la - 133) & !0x3f) == 0
                        && ((1usize << (_la - 133))
                            & ((1usize << (DECIMAL - 133))
                                | (1usize << (STRING_SINGLE - 133))
                                | (1usize << (STRING_DOUBLE - 133))
                                | (1usize << (STRING_BLOCK - 133))
                                | (1usize << (KW_IF - 133))
                                | (1usize << (RETURN - 133))
                                | (1usize << (RESUME - 133))
                                | (1usize << (YIELD - 133))
                                | (1usize << (BREAK - 133))
                                | (1usize << (CONTINUE - 133))
                                | (1usize << (RAISE - 133))
                                | (1usize << (SPECIAL - 133))
                                | (1usize << (RAW_ID - 133))
                                | (1usize << (UNICODE_ID - 133))))
                            != 0)
                {
                    {
                        recog.base.set_state(1573);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | BRACE_L | OFFSET_L | CEILING_L | FLOOR_L | OP_ADD | OP_SUB | OP_MUL
                            | OP_REM | OP_LAST | OP_AND | OP_AT | OP_HASH | LAMBDA_SLOT | OP_NOT | OP_DOT3 | OP_DOT2
                            | OP_INVERSE | OP_ROOT2 | OP_ROOT3 | OP_ROOT4 | OP_REFERENCE | OP_LABEL | KW_NEW | KW_OBJECT
                            | KW_LAMBDA | KW_TRY | KW_MATCH | KW_CATCH | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE
                            | STRING_BLOCK | KW_IF | RETURN | RESUME | YIELD | BREAK | CONTINUE | RAISE | SPECIAL | RAW_ID
                            | UNICODE_ID => {
                                {
                                    /* InvokeRule expression_root */
                                    recog.base.set_state(1571);
                                    recog.expression_root()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1572);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1577);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1578);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- macro_call ----------------
pub type Macro_callContextAll<'input> = Macro_callContext<'input>;

pub type Macro_callContext<'input> = BaseParserRuleContext<'input, Macro_callContextExt<'input>>;

#[derive(Clone)]
pub struct Macro_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Macro_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Macro_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_macro_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_macro_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Macro_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_macro_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Macro_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_macro_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_macro_call }
}
antlr_rust::tid! {Macro_callContextExt<'a>}

impl<'input> Macro_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Macro_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Macro_callContextExt { ph: PhantomData }))
    }
}

pub trait Macro_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Macro_callContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_AT
    /// Returns `None` if there is no child corresponding to token OP_AT
    fn OP_AT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AT, 0)
    }
    fn annotation_call_item_all(&self) -> Vec<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation_call_item(&self, i: usize) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Macro_callContextAttrs<'input> for Macro_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn macro_call(&mut self) -> Result<Rc<Macro_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Macro_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_macro_call);
        let mut _localctx: Rc<Macro_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1599);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(212, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1580);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1581);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1583);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(209, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1582);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1585);
                        recog.base.match_token(OP_AT, &mut recog.err_handler)?;

                        recog.base.set_state(1586);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1587);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1592);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1588);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule annotation_call_item */
                                    recog.base.set_state(1589);
                                    recog.annotation_call_item()?;
                                }
                            }
                            recog.base.set_state(1594);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1595);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;

                        recog.base.set_state(1597);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(211, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1596);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;

pub type AnnotationContext<'input> = BaseParserRuleContext<'input, AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for AnnotationContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for AnnotationContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for AnnotationContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation(self);
    }
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::tid! {AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<AnnotationContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, AnnotationContextExt { ph: PhantomData }))
    }
}

pub trait AnnotationContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<AnnotationContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token OP_HASH
    /// Returns `None` if there is no child corresponding to token OP_HASH
    fn OP_HASH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_HASH, 0)
    }
    fn annotation_call_item_all(&self) -> Vec<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation_call_item(&self, i: usize) -> Option<Rc<Annotation_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation(&mut self) -> Result<Rc<AnnotationContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1620);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(216, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1601);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1602);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1604);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(213, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1603);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1606);
                        recog.base.match_token(OP_HASH, &mut recog.err_handler)?;

                        recog.base.set_state(1607);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule annotation_call_item */
                        recog.base.set_state(1608);
                        recog.annotation_call_item()?;

                        recog.base.set_state(1613);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == COMMA {
                            {
                                {
                                    recog.base.set_state(1609);
                                    recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                    /* InvokeRule annotation_call_item */
                                    recog.base.set_state(1610);
                                    recog.annotation_call_item()?;
                                }
                            }
                            recog.base.set_state(1615);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1616);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;

                        recog.base.set_state(1618);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(215, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule class_block */
                                    recog.base.set_state(1617);
                                    recog.class_block()?;
                                }
                            }

                            _ => {}
                        }
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- annotation_call_item ----------------
pub type Annotation_call_itemContextAll<'input> = Annotation_call_itemContext<'input>;

pub type Annotation_call_itemContext<'input> = BaseParserRuleContext<'input, Annotation_call_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Annotation_call_itemContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Annotation_call_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_annotation_call_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_annotation_call_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Annotation_call_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_annotation_call_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Annotation_call_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_annotation_call_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_annotation_call_item }
}
antlr_rust::tid! {Annotation_call_itemContextExt<'a>}

impl<'input> Annotation_call_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Annotation_call_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Annotation_call_itemContextExt { ph: PhantomData },
        ))
    }
}

pub trait Annotation_call_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Annotation_call_itemContextExt<'input>>
{
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Annotation_call_itemContextAttrs<'input> for Annotation_call_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn annotation_call_item(&mut self) -> Result<Rc<Annotation_call_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Annotation_call_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_annotation_call_item);
        let mut _localctx: Rc<Annotation_call_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule namepath */
                recog.base.set_state(1622);
                recog.namepath()?;

                recog.base.set_state(1624);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(217, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule tuple_call_body */
                            recog.base.set_state(1623);
                            recog.tuple_call_body()?;
                        }
                    }

                    _ => {}
                }
                recog.base.set_state(1627);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(218, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule class_block */
                            recog.base.set_state(1626);
                            recog.class_block()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- try_statement ----------------
pub type Try_statementContextAll<'input> = Try_statementContext<'input>;

pub type Try_statementContext<'input> = BaseParserRuleContext<'input, Try_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Try_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Try_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Try_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_try_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_try_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Try_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_try_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Try_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_try_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_try_statement }
}
antlr_rust::tid! {Try_statementContextExt<'a>}

impl<'input> Try_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Try_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Try_statementContextExt { ph: PhantomData }))
    }
}

pub trait Try_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Try_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_TRY
    /// Returns `None` if there is no child corresponding to token KW_TRY
    fn KW_TRY(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TRY, 0)
    }
    fn function_block(&self) -> Option<Rc<Function_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Try_statementContextAttrs<'input> for Try_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn try_statement(&mut self) -> Result<Rc<Try_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Try_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_try_statement);
        let mut _localctx: Rc<Try_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1632);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1629);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1634);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1635);
                recog.base.match_token(KW_TRY, &mut recog.err_handler)?;

                recog.base.set_state(1637);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if (((_la - 8) & !0x3f) == 0
                    && ((1usize << (_la - 8))
                        & ((1usize << (PARENTHESES_L - 8))
                            | (1usize << (OP_ADD - 8))
                            | (1usize << (OP_SUB - 8))
                            | (1usize << (OP_MUL - 8))
                            | (1usize << (OP_REM - 8))
                            | (1usize << (OP_LAST - 8))))
                        != 0)
                    || (((_la - 69) & !0x3f) == 0
                        && ((1usize << (_la - 69))
                            & ((1usize << (OP_AND - 69))
                                | (1usize << (LAMBDA_SLOT - 69))
                                | (1usize << (OP_NOT - 69))
                                | (1usize << (OP_DOT3 - 69))
                                | (1usize << (OP_DOT2 - 69))
                                | (1usize << (OP_INVERSE - 69))
                                | (1usize << (OP_ROOT2 - 69))
                                | (1usize << (OP_ROOT3 - 69))))
                            != 0)
                    || (((_la - 101) & !0x3f) == 0
                        && ((1usize << (_la - 101))
                            & ((1usize << (OP_ROOT4 - 101)) | (1usize << (OP_REFERENCE - 101)) | (1usize << (INTEGER - 101))))
                            != 0)
                    || (((_la - 133) & !0x3f) == 0
                        && ((1usize << (_la - 133))
                            & ((1usize << (DECIMAL - 133))
                                | (1usize << (STRING_SINGLE - 133))
                                | (1usize << (STRING_DOUBLE - 133))
                                | (1usize << (STRING_BLOCK - 133))
                                | (1usize << (SPECIAL - 133))
                                | (1usize << (RAW_ID - 133))
                                | (1usize << (UNICODE_ID - 133))))
                            != 0)
                {
                    {
                        /* InvokeRule type_expression */
                        recog.base.set_state(1636);
                        recog.type_expression_rec(0)?;
                    }
                }

                /* InvokeRule function_block */
                recog.base.set_state(1639);
                recog.function_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_statement ----------------
pub type Match_statementContextAll<'input> = Match_statementContext<'input>;

pub type Match_statementContext<'input> = BaseParserRuleContext<'input, Match_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Match_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_statement }
}
antlr_rust::tid! {Match_statementContextExt<'a>}

impl<'input> Match_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_statementContextExt { ph: PhantomData }))
    }
}

pub trait Match_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_statementContextExt<'input>>
{
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_block(&self) -> Option<Rc<Match_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_MATCH
    /// Returns `None` if there is no child corresponding to token KW_MATCH
    fn KW_MATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_MATCH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token KW_CATCH
    /// Returns `None` if there is no child corresponding to token KW_CATCH
    fn KW_CATCH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CATCH, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
}

impl<'input> Match_statementContextAttrs<'input> for Match_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_statement(&mut self) -> Result<Rc<Match_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_match_statement);
        let mut _localctx: Rc<Match_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1644);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == OP_HASH {
                    {
                        {
                            /* InvokeRule annotation */
                            recog.base.set_state(1641);
                            recog.annotation()?;
                        }
                    }
                    recog.base.set_state(1646);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1647);
                _la = recog.base.input.la(1);
                if { !(_la == KW_MATCH || _la == KW_CATCH) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(1651);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(222, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1648);
                            recog.identifier()?;

                            recog.base.set_state(1649);
                            recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule inline_expression */
                recog.base.set_state(1653);
                recog.inline_expression_rec(0)?;

                /* InvokeRule match_block */
                recog.base.set_state(1654);
                recog.match_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_block ----------------
pub type Match_blockContextAll<'input> = Match_blockContext<'input>;

pub type Match_blockContext<'input> = BaseParserRuleContext<'input, Match_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_block }
}
antlr_rust::tid! {Match_blockContextExt<'a>}

impl<'input> Match_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn match_terms_all(&self) -> Vec<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn match_terms(&self, i: usize) -> Option<Rc<Match_termsContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_blockContextAttrs<'input> for Match_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_block(&mut self) -> Result<Rc<Match_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_match_block);
        let mut _localctx: Rc<Match_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1656);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1661);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la) & !0x3f) == 0
                    && ((1usize << _la) & ((1usize << COMMA) | (1usize << SEMICOLON) | (1usize << FAKE_COLON))) != 0)
                    || _la == OP_HASH
                    || (((_la - 114) & !0x3f) == 0
                        && ((1usize << (_la - 114))
                            & ((1usize << (KW_TYPE - 114))
                                | (1usize << (KW_WITH - 114))
                                | (1usize << (KW_CASE - 114))
                                | (1usize << (KW_WHEN - 114))
                                | (1usize << (KW_ELSE - 114))))
                            != 0)
                {
                    {
                        recog.base.set_state(1659);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_HASH | KW_TYPE | KW_WITH | KW_CASE | KW_WHEN | KW_ELSE => {
                                {
                                    /* InvokeRule match_terms */
                                    recog.base.set_state(1657);
                                    recog.match_terms()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1658);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1663);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1664);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_terms ----------------
#[derive(Debug)]
pub enum Match_termsContextAll<'input> {
    MatchWhenContext(MatchWhenContext<'input>),
    MatchTypeContext(MatchTypeContext<'input>),
    MatchCaseContext(MatchCaseContext<'input>),
    MatchWithContext(MatchWithContext<'input>),
    MatchWithManyContext(MatchWithManyContext<'input>),
    MatchElseContext(MatchElseContext<'input>),
    Error(Match_termsContext<'input>),
}
antlr_rust::tid! {Match_termsContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Match_termsContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContextAll<'input> {}

impl<'input> Deref for Match_termsContextAll<'input> {
    type Target = dyn Match_termsContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Match_termsContextAll::*;
        match self {
            MatchWhenContext(inner) => inner,
            MatchTypeContext(inner) => inner,
            MatchCaseContext(inner) => inner,
            MatchWithContext(inner) => inner,
            MatchWithManyContext(inner) => inner,
            MatchElseContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Match_termsContext<'input> = BaseParserRuleContext<'input, Match_termsContextExt<'input>>;

#[derive(Clone)]
pub struct Match_termsContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_termsContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_termsContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_termsContext<'input> {}

impl<'input> CustomRuleContext<'input> for Match_termsContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}
antlr_rust::tid! {Match_termsContextExt<'a>}

impl<'input> Match_termsContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Match_termsContextExt { ph: PhantomData },
        )))
    }
}

pub trait Match_termsContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_termsContextExt<'input>>
{
}

impl<'input> Match_termsContextAttrs<'input> for Match_termsContext<'input> {}

pub type MatchWhenContext<'input> = BaseParserRuleContext<'input, MatchWhenContextExt<'input>>;

pub trait MatchWhenContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WHEN
    /// Returns `None` if there is no child corresponding to token KW_WHEN
    fn KW_WHEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WHEN, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWhenContextAttrs<'input> for MatchWhenContext<'input> {}

pub struct MatchWhenContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWhenContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWhenContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWhenContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWhen(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWhen(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWhenContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWhen(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWhenContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWhenContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWhenContext<'input> {}

impl<'input> MatchWhenContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWhenContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWhenContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchTypeContext<'input> = BaseParserRuleContext<'input, MatchTypeContextExt<'input>>;

pub trait MatchTypeContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_TYPE
    /// Returns `None` if there is no child corresponding to token KW_TYPE
    fn KW_TYPE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_TYPE, 0)
    }
    fn type_expression(&self) -> Option<Rc<Type_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchTypeContextAttrs<'input> for MatchTypeContext<'input> {}

pub struct MatchTypeContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchTypeContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchTypeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchTypeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchType(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchType(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchTypeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchType(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchTypeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchTypeContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchTypeContext<'input> {}

impl<'input> MatchTypeContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchTypeContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchTypeContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchCaseContext<'input> = BaseParserRuleContext<'input, MatchCaseContextExt<'input>>;

pub trait MatchCaseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_CASE
    /// Returns `None` if there is no child corresponding to token KW_CASE
    fn KW_CASE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_CASE, 0)
    }
    fn case_pattern(&self) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token KW_IF
    /// Returns `None` if there is no child corresponding to token KW_IF
    fn KW_IF(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_IF, 0)
    }
    fn inline_expression(&self) -> Option<Rc<Inline_expressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> MatchCaseContextAttrs<'input> for MatchCaseContext<'input> {}

pub struct MatchCaseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchCaseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchCaseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchCaseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchCase(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchCase(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchCaseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchCase(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchCaseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchCaseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchCaseContext<'input> {}

impl<'input> MatchCaseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchCaseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchCaseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithContext<'input> = BaseParserRuleContext<'input, MatchWithContextExt<'input>>;

pub trait MatchWithContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchWithContextAttrs<'input> for MatchWithContext<'input> {}

pub struct MatchWithContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWith(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWith(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWith(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithContext<'input> {}

impl<'input> MatchWithContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchWithManyContext<'input> = BaseParserRuleContext<'input, MatchWithManyContextExt<'input>>;

pub trait MatchWithManyContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_WITH
    /// Returns `None` if there is no child corresponding to token KW_WITH
    fn KW_WITH(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_WITH, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> MatchWithManyContextAttrs<'input> for MatchWithManyContext<'input> {}

pub struct MatchWithManyContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchWithManyContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchWithManyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchWithManyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchWithMany(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchWithMany(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchWithManyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchWithMany(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchWithManyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchWithManyContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchWithManyContext<'input> {}

impl<'input> MatchWithManyContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchWithManyContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchWithManyContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type MatchElseContext<'input> = BaseParserRuleContext<'input, MatchElseContextExt<'input>>;

pub trait MatchElseContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token KW_ELSE
    /// Returns `None` if there is no child corresponding to token KW_ELSE
    fn KW_ELSE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_ELSE, 0)
    }
    fn match_case_block(&self) -> Option<Rc<Match_case_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn annotation_all(&self) -> Vec<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> MatchElseContextAttrs<'input> for MatchElseContext<'input> {}

pub struct MatchElseContextExt<'input> {
    base: Match_termsContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {MatchElseContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for MatchElseContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for MatchElseContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_MatchElse(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_MatchElse(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for MatchElseContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_MatchElse(self);
    }
}

impl<'input> CustomRuleContext<'input> for MatchElseContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_terms
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_terms }
}

impl<'input> Borrow<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow(&self) -> &Match_termsContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Match_termsContextExt<'input>> for MatchElseContext<'input> {
    fn borrow_mut(&mut self) -> &mut Match_termsContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Match_termsContextAttrs<'input> for MatchElseContext<'input> {}

impl<'input> MatchElseContextExt<'input> {
    fn new(ctx: &dyn Match_termsContextAttrs<'input>) -> Rc<Match_termsContextAll<'input>> {
        Rc::new(Match_termsContextAll::MatchElseContext(BaseParserRuleContext::copy_from(
            ctx,
            MatchElseContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_terms(&mut self) -> Result<Rc<Match_termsContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_termsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_match_terms);
        let mut _localctx: Rc<Match_termsContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1742);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(236, &mut recog.base)? {
                1 => {
                    let tmp = MatchWithContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1669);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1666);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1671);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1672);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        /* InvokeRule identifier */
                        recog.base.set_state(1673);
                        recog.identifier()?;
                    }
                }
                2 => {
                    let tmp = MatchWithManyContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1677);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1674);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1679);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1680);
                        recog.base.match_token(KW_WITH, &mut recog.err_handler)?;

                        recog.base.set_state(1681);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1693);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(1682);
                                recog.identifier()?;

                                recog.base.set_state(1687);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(227, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1683);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule identifier */
                                                recog.base.set_state(1684);
                                                recog.identifier()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1689);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(227, &mut recog.base)?;
                                }
                                recog.base.set_state(1691);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1690);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1695);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    let tmp = MatchTypeContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 3);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1699);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1696);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1701);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1702);
                        recog.base.match_token(KW_TYPE, &mut recog.err_handler)?;

                        /* InvokeRule type_expression */
                        recog.base.set_state(1703);
                        recog.type_expression_rec(0)?;

                        recog.base.set_state(1706);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1704);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1705);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1708);
                        recog.match_case_block()?;
                    }
                }
                4 => {
                    let tmp = MatchWhenContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 4);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1713);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1710);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1715);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1716);
                        recog.base.match_token(KW_WHEN, &mut recog.err_handler)?;

                        /* InvokeRule inline_expression */
                        recog.base.set_state(1717);
                        recog.inline_expression_rec(0)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1718);
                        recog.match_case_block()?;
                    }
                }
                5 => {
                    let tmp = MatchElseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 5);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1723);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1720);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1725);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1726);
                        recog.base.match_token(KW_ELSE, &mut recog.err_handler)?;

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1727);
                        recog.match_case_block()?;
                    }
                }
                6 => {
                    let tmp = MatchCaseContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 6);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1731);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        while _la == OP_HASH {
                            {
                                {
                                    /* InvokeRule annotation */
                                    recog.base.set_state(1728);
                                    recog.annotation()?;
                                }
                            }
                            recog.base.set_state(1733);
                            recog.err_handler.sync(&mut recog.base)?;
                            _la = recog.base.input.la(1);
                        }
                        recog.base.set_state(1734);
                        recog.base.match_token(KW_CASE, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern */
                        recog.base.set_state(1735);
                        recog.case_pattern_rec(0)?;

                        recog.base.set_state(1738);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == KW_IF {
                            {
                                recog.base.set_state(1736);
                                recog.base.match_token(KW_IF, &mut recog.err_handler)?;

                                /* InvokeRule inline_expression */
                                recog.base.set_state(1737);
                                recog.inline_expression_rec(0)?;
                            }
                        }

                        /* InvokeRule match_case_block */
                        recog.base.set_state(1740);
                        recog.match_case_block()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- match_case_block ----------------
pub type Match_case_blockContextAll<'input> = Match_case_blockContext<'input>;

pub type Match_case_blockContext<'input> = BaseParserRuleContext<'input, Match_case_blockContextExt<'input>>;

#[derive(Clone)]
pub struct Match_case_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Match_case_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Match_case_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_match_case_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_match_case_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Match_case_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_match_case_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for Match_case_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_match_case_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_match_case_block }
}
antlr_rust::tid! {Match_case_blockContextExt<'a>}

impl<'input> Match_case_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Match_case_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Match_case_blockContextExt { ph: PhantomData }))
    }
}

pub trait Match_case_blockContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Match_case_blockContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Match_case_blockContextAttrs<'input> for Match_case_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn match_case_block(&mut self) -> Result<Rc<Match_case_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Match_case_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_match_case_block);
        let mut _localctx: Rc<Match_case_blockContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1744);
                recog.base.match_token(COLON, &mut recog.err_handler)?;

                recog.base.set_state(1748);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(237, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule expression */
                                recog.base.set_state(1745);
                                recog.expression_rec(0)?;
                            }
                        }
                    }
                    recog.base.set_state(1750);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(237, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern ----------------
#[derive(Debug)]
pub enum Case_patternContextAll<'input> {
    CaseORContext(CaseORContext<'input>),
    CaseAtomContext(CaseAtomContext<'input>),
    CaseUntilContext(CaseUntilContext<'input>),
    Error(Case_patternContext<'input>),
}
antlr_rust::tid! {Case_patternContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Case_patternContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContextAll<'input> {}

impl<'input> Deref for Case_patternContextAll<'input> {
    type Target = dyn Case_patternContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Case_patternContextAll::*;
        match self {
            CaseORContext(inner) => inner,
            CaseAtomContext(inner) => inner,
            CaseUntilContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Case_patternContext<'input> = BaseParserRuleContext<'input, Case_patternContextExt<'input>>;

#[derive(Clone)]
pub struct Case_patternContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_patternContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_patternContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_patternContext<'input> {}

impl<'input> CustomRuleContext<'input> for Case_patternContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}
antlr_rust::tid! {Case_patternContextExt<'a>}

impl<'input> Case_patternContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_patternContextExt { ph: PhantomData },
        )))
    }
}

pub trait Case_patternContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_patternContextExt<'input>>
{
}

impl<'input> Case_patternContextAttrs<'input> for Case_patternContext<'input> {}

pub type CaseORContext<'input> = BaseParserRuleContext<'input, CaseORContextExt<'input>>;

pub trait CaseORContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_OR
    /// Returns `None` if there is no child corresponding to token OP_OR
    fn OP_OR(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_OR, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_ADD
    /// Returns `None` if there is no child corresponding to token OP_ADD
    fn OP_ADD(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_ADD, 0)
    }
}

impl<'input> CaseORContextAttrs<'input> for CaseORContext<'input> {}

pub struct CaseORContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseORContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseORContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseORContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseOR(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseOR(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseORContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseOR(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseORContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseORContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseORContext<'input> {}

impl<'input> CaseORContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseORContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseORContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseAtomContext<'input> = BaseParserRuleContext<'input, CaseAtomContextExt<'input>>;

pub trait CaseAtomContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> CaseAtomContextAttrs<'input> for CaseAtomContext<'input> {}

pub struct CaseAtomContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseAtomContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseAtomContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseAtomContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseAtom(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseAtom(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseAtomContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseAtom(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseAtomContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseAtomContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseAtomContext<'input> {}

impl<'input> CaseAtomContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseAtomContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseAtomContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type CaseUntilContext<'input> = BaseParserRuleContext<'input, CaseUntilContextExt<'input>>;

pub trait CaseUntilContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    fn case_pattern_all(&self) -> Vec<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern(&self, i: usize) -> Option<Rc<Case_patternContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_UNTIL
    /// Returns `None` if there is no child corresponding to token OP_UNTIL
    fn OP_UNTIL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_UNTIL, 0)
    }
}

impl<'input> CaseUntilContextAttrs<'input> for CaseUntilContext<'input> {}

pub struct CaseUntilContextExt<'input> {
    base: Case_patternContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {CaseUntilContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for CaseUntilContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for CaseUntilContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_CaseUntil(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_CaseUntil(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for CaseUntilContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_CaseUntil(self);
    }
}

impl<'input> CustomRuleContext<'input> for CaseUntilContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern }
}

impl<'input> Borrow<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow(&self) -> &Case_patternContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Case_patternContextExt<'input>> for CaseUntilContext<'input> {
    fn borrow_mut(&mut self) -> &mut Case_patternContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Case_patternContextAttrs<'input> for CaseUntilContext<'input> {}

impl<'input> CaseUntilContextExt<'input> {
    fn new(ctx: &dyn Case_patternContextAttrs<'input>) -> Rc<Case_patternContextAll<'input>> {
        Rc::new(Case_patternContextAll::CaseUntilContext(BaseParserRuleContext::copy_from(
            ctx,
            CaseUntilContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern(&mut self) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        self.case_pattern_rec(0)
    }

    fn case_pattern_rec(&mut self, _p: isize) -> Result<Rc<Case_patternContextAll<'input>>, ANTLRError> {
        let recog = self;
        let _parentctx = recog.ctx.take();
        let _parentState = recog.base.get_state();
        let mut _localctx = Case_patternContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_recursion_rule(_localctx.clone(), 190, RULE_case_pattern, _p);
        let mut _localctx: Rc<Case_patternContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
        let _startState = 190;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                {
                    let mut tmp = CaseAtomContextExt::new(&**_localctx);
                    recog.ctx = Some(tmp.clone());
                    _localctx = tmp;
                    _prevctx = _localctx.clone();

                    /* InvokeRule case_pattern_item */
                    recog.base.set_state(1752);
                    recog.case_pattern_item()?;
                }

                let tmp = recog.input.lt(-1).cloned();
                recog.ctx.as_ref().unwrap().set_stop(tmp);
                recog.base.set_state(1762);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(239, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        recog.trigger_exit_rule_event();
                        _prevctx = _localctx.clone();
                        {
                            recog.base.set_state(1760);
                            recog.err_handler.sync(&mut recog.base)?;
                            match recog.interpreter.adaptive_predict(238, &mut recog.base)? {
                                1 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseORContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1754);
                                        if !({ recog.precpred(None, 3) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 3)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        recog.base.set_state(1755);
                                        _la = recog.base.input.la(1);
                                        if { !(_la == OP_ADD || _la == OP_OR) } {
                                            recog.err_handler.recover_inline(&mut recog.base)?;
                                        }
                                        else {
                                            if recog.base.input.la(1) == TOKEN_EOF {
                                                recog.base.matched_eof = true
                                            };
                                            recog.err_handler.report_match(&mut recog.base);
                                            recog.base.consume(&mut recog.err_handler);
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1756);
                                        recog.case_pattern_rec(4)?;
                                    }
                                }
                                2 => {
                                    {
                                        /* recRuleLabeledAltStartAction */
                                        let mut tmp = CaseUntilContextExt::new(&**Case_patternContextExt::new(
                                            _parentctx.clone(),
                                            _parentState,
                                        ));
                                        recog.push_new_recursion_context(tmp.clone(), _startState, RULE_case_pattern);
                                        _localctx = tmp;
                                        recog.base.set_state(1757);
                                        if !({ recog.precpred(None, 2) }) {
                                            Err(FailedPredicateError::new(
                                                &mut recog.base,
                                                Some("recog.precpred(None, 2)".to_owned()),
                                                None,
                                            ))?;
                                        }
                                        {
                                            recog.base.set_state(1758);
                                            recog.base.match_token(OP_UNTIL, &mut recog.err_handler)?;
                                        }
                                        /* InvokeRule case_pattern */
                                        recog.base.set_state(1759);
                                        recog.case_pattern_rec(3)?;
                                    }
                                }

                                _ => {}
                            }
                        }
                    }
                    recog.base.set_state(1764);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(239, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.unroll_recursion_context(_parentctx);

        Ok(_localctx)
    }
}
//------------------- case_pattern_item ----------------
pub type Case_pattern_itemContextAll<'input> = Case_pattern_itemContext<'input>;

pub type Case_pattern_itemContext<'input> = BaseParserRuleContext<'input, Case_pattern_itemContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_itemContextExt<'input> {
    pub bind: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_itemContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_item(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_item(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_itemContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_item(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_itemContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_item
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_item }
}
antlr_rust::tid! {Case_pattern_itemContextExt<'a>}

impl<'input> Case_pattern_itemContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_itemContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Case_pattern_itemContextExt { bind: None, ph: PhantomData },
        ))
    }
}

pub trait Case_pattern_itemContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_itemContextExt<'input>>
{
    fn case_pattern_tuple(&self) -> Option<Rc<Case_pattern_tupleContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_BIND
    /// Returns `None` if there is no child corresponding to token OP_BIND
    fn OP_BIND(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_BIND, 0)
    }
    fn case_pattern_item(&self) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn modified_identifier(&self) -> Option<Rc<Modified_identifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number_literal(&self) -> Option<Rc<Number_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn string_literal(&self) -> Option<Rc<String_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token SPECIAL
    /// Returns `None` if there is no child corresponding to token SPECIAL
    fn SPECIAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(SPECIAL, 0)
    }
}

impl<'input> Case_pattern_itemContextAttrs<'input> for Case_pattern_itemContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_item(&mut self) -> Result<Rc<Case_pattern_itemContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_itemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_case_pattern_item);
        let mut _localctx: Rc<Case_pattern_itemContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1784);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(241, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        /* InvokeRule case_pattern_tuple */
                        recog.base.set_state(1765);
                        recog.case_pattern_tuple()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule identifier */
                        recog.base.set_state(1766);
                        let tmp = recog.identifier()?;
                        cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                        recog.base.set_state(1767);
                        recog.base.match_token(OP_BIND, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1768);
                        recog.case_pattern_item()?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1770);
                        recog.modified_identifier()?;

                        recog.base.set_state(1771);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        recog.base.set_state(1775);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.interpreter.adaptive_predict(240, &mut recog.base)? {
                            x if x == 1 => {
                                {
                                    /* InvokeRule identifier */
                                    recog.base.set_state(1772);
                                    let tmp = recog.identifier()?;
                                    cast_mut::<_, Case_pattern_itemContext>(&mut _localctx).bind = Some(tmp.clone());

                                    recog.base.set_state(1773);
                                    recog.base.match_token(OP_BIND, &mut recog.err_handler)?;
                                }
                            }

                            _ => {}
                        }
                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1777);
                        recog.case_pattern_item()?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        /* InvokeRule modified_identifier */
                        recog.base.set_state(1779);
                        recog.modified_identifier()?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1780);
                        recog.namepath()?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule number_literal */
                        recog.base.set_state(1781);
                        recog.number_literal()?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule string_literal */
                        recog.base.set_state(1782);
                        recog.string_literal()?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1783);
                        recog.base.match_token(SPECIAL, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- case_pattern_tuple ----------------
pub type Case_pattern_tupleContextAll<'input> = Case_pattern_tupleContext<'input>;

pub type Case_pattern_tupleContext<'input> = BaseParserRuleContext<'input, Case_pattern_tupleContextExt<'input>>;

#[derive(Clone)]
pub struct Case_pattern_tupleContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_case_pattern_tuple(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_case_pattern_tuple(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Case_pattern_tupleContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_case_pattern_tuple(self);
    }
}

impl<'input> CustomRuleContext<'input> for Case_pattern_tupleContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_case_pattern_tuple
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_case_pattern_tuple }
}
antlr_rust::tid! {Case_pattern_tupleContextExt<'a>}

impl<'input> Case_pattern_tupleContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Case_pattern_tupleContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Case_pattern_tupleContextExt { ph: PhantomData }))
    }
}

pub trait Case_pattern_tupleContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Case_pattern_tupleContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn namepath(&self) -> Option<Rc<NamepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn case_pattern_item_all(&self) -> Vec<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn case_pattern_item(&self, i: usize) -> Option<Rc<Case_pattern_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Case_pattern_tupleContextAttrs<'input> for Case_pattern_tupleContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn case_pattern_tuple(&mut self) -> Result<Rc<Case_pattern_tupleContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Case_pattern_tupleContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_case_pattern_tuple);
        let mut _localctx: Rc<Case_pattern_tupleContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1868);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(255, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1787);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1786);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1789);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(1790);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1792);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1791);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1794);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1795);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1797);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1796);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1799);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        recog.base.set_state(1800);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1801);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1802);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1803);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(1804);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        recog.base.set_state(1806);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1807);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1810);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1808);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1809);
                                        recog.case_pattern_item()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(1812);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(245, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(1815);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1814);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1817);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        /* InvokeRule namepath */
                        recog.base.set_state(1819);
                        recog.namepath()?;

                        recog.base.set_state(1820);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1821);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1826);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(247, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1822);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1823);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1828);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(247, &mut recog.base)?;
                        }
                        recog.base.set_state(1830);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1829);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1832);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        recog.base.set_state(1835);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1834);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1837);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1838);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1843);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(250, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1839);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1840);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1845);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(250, &mut recog.base)?;
                        }
                        recog.base.set_state(1847);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1846);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1849);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(1852);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule namepath */
                                recog.base.set_state(1851);
                                recog.namepath()?;
                            }
                        }

                        recog.base.set_state(1854);
                        recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                        /* InvokeRule case_pattern_item */
                        recog.base.set_state(1855);
                        recog.case_pattern_item()?;

                        recog.base.set_state(1860);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = recog.interpreter.adaptive_predict(253, &mut recog.base)?;
                        while { _alt != 2 && _alt != INVALID_ALT } {
                            if _alt == 1 {
                                {
                                    {
                                        recog.base.set_state(1856);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule case_pattern_item */
                                        recog.base.set_state(1857);
                                        recog.case_pattern_item()?;
                                    }
                                }
                            }
                            recog.base.set_state(1862);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(253, &mut recog.base)?;
                        }
                        recog.base.set_state(1864);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1863);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1866);
                        recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- object_statement ----------------
pub type Object_statementContextAll<'input> = Object_statementContext<'input>;

pub type Object_statementContext<'input> = BaseParserRuleContext<'input, Object_statementContextExt<'input>>;

#[derive(Clone)]
pub struct Object_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Object_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Object_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_object_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_object_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Object_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_object_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for Object_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_object_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_object_statement }
}
antlr_rust::tid! {Object_statementContextExt<'a>}

impl<'input> Object_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Object_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Object_statementContextExt { ph: PhantomData }))
    }
}

pub trait Object_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Object_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_OBJECT
    /// Returns `None` if there is no child corresponding to token KW_OBJECT
    fn KW_OBJECT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_OBJECT, 0)
    }
    fn class_block(&self) -> Option<Rc<Class_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn define_generic(&self) -> Option<Rc<Define_genericContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn class_inherit(&self) -> Option<Rc<Class_inheritContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn type_hint(&self) -> Option<Rc<Type_hintContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Object_statementContextAttrs<'input> for Object_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn object_statement(&mut self) -> Result<Rc<Object_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Object_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_object_statement);
        let mut _localctx: Rc<Object_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1870);
                recog.base.match_token(KW_OBJECT, &mut recog.err_handler)?;

                recog.base.set_state(1872);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                    {
                        /* InvokeRule define_generic */
                        recog.base.set_state(1871);
                        recog.define_generic()?;
                    }
                }

                recog.base.set_state(1875);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == PARENTHESES_L {
                    {
                        /* InvokeRule class_inherit */
                        recog.base.set_state(1874);
                        recog.class_inherit()?;
                    }
                }

                recog.base.set_state(1878);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == COLON || _la == OP_ARROW {
                    {
                        /* InvokeRule type_hint */
                        recog.base.set_state(1877);
                        recog.type_hint()?;
                    }
                }

                /* InvokeRule class_block */
                recog.base.set_state(1880);
                recog.class_block()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_statement ----------------
pub type New_statementContextAll<'input> = New_statementContext<'input>;

pub type New_statementContext<'input> = BaseParserRuleContext<'input, New_statementContextExt<'input>>;

#[derive(Clone)]
pub struct New_statementContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_statementContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_statementContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_statement(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_statement(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_statementContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_statement(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_statementContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_statement
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_statement }
}
antlr_rust::tid! {New_statementContextExt<'a>}

impl<'input> New_statementContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_statementContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_statementContextExt { ph: PhantomData }))
    }
}

pub trait New_statementContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<New_statementContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token KW_NEW
    /// Returns `None` if there is no child corresponding to token KW_NEW
    fn KW_NEW(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(KW_NEW, 0)
    }
    fn modified_namepath(&self) -> Option<Rc<Modified_namepathContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn new_block(&self) -> Option<Rc<New_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn generic_call_in_type(&self) -> Option<Rc<Generic_call_in_typeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_statementContextAttrs<'input> for New_statementContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_statement(&mut self) -> Result<Rc<New_statementContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_statementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_new_statement);
        let mut _localctx: Rc<New_statementContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1899);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(262, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1882);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(1883);
                        recog.modified_namepath()?;

                        recog.base.set_state(1885);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(1884);
                                recog.generic_call_in_type()?;
                            }
                        }

                        recog.base.set_state(1888);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == PARENTHESES_L {
                            {
                                /* InvokeRule tuple_call_body */
                                recog.base.set_state(1887);
                                recog.tuple_call_body()?;
                            }
                        }

                        /* InvokeRule new_block */
                        recog.base.set_state(1890);
                        recog.new_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1892);
                        recog.base.match_token(KW_NEW, &mut recog.err_handler)?;

                        /* InvokeRule modified_namepath */
                        recog.base.set_state(1893);
                        recog.modified_namepath()?;

                        recog.base.set_state(1895);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == OP_PROPORTION || _la == GENERIC_L || _la == OP_LT {
                            {
                                /* InvokeRule generic_call_in_type */
                                recog.base.set_state(1894);
                                recog.generic_call_in_type()?;
                            }
                        }

                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(1897);
                        recog.tuple_call_body()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_body ----------------
pub type New_bodyContextAll<'input> = New_bodyContext<'input>;

pub type New_bodyContext<'input> = BaseParserRuleContext<'input, New_bodyContextExt<'input>>;

#[derive(Clone)]
pub struct New_bodyContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_bodyContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_bodyContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_body(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_body(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_bodyContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_body(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_bodyContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_body
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_body }
}
antlr_rust::tid! {New_bodyContextExt<'a>}

impl<'input> New_bodyContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_bodyContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_bodyContextExt { ph: PhantomData }))
    }
}

pub trait New_bodyContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<New_bodyContextExt<'input>> {
    fn new_block(&self) -> Option<Rc<New_blockContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn tuple_call_body(&self) -> Option<Rc<Tuple_call_bodyContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> New_bodyContextAttrs<'input> for New_bodyContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_body(&mut self) -> Result<Rc<New_bodyContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_bodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_new_body);
        let mut _localctx: Rc<New_bodyContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(1906);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(264, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1902);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == PARENTHESES_L {
                            {
                                /* InvokeRule tuple_call_body */
                                recog.base.set_state(1901);
                                recog.tuple_call_body()?;
                            }
                        }

                        /* InvokeRule new_block */
                        recog.base.set_state(1904);
                        recog.new_block()?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule tuple_call_body */
                        recog.base.set_state(1905);
                        recog.tuple_call_body()?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- new_block ----------------
pub type New_blockContextAll<'input> = New_blockContext<'input>;

pub type New_blockContext<'input> = BaseParserRuleContext<'input, New_blockContextExt<'input>>;

#[derive(Clone)]
pub struct New_blockContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for New_blockContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for New_blockContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_new_block(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_new_block(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for New_blockContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_new_block(self);
    }
}

impl<'input> CustomRuleContext<'input> for New_blockContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_new_block
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_new_block }
}
antlr_rust::tid! {New_blockContextExt<'a>}

impl<'input> New_blockContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<New_blockContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, New_blockContextExt { ph: PhantomData }))
    }
}

pub trait New_blockContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<New_blockContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token BRACE_L
    /// Returns `None` if there is no child corresponding to token BRACE_L
    fn BRACE_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACE_R
    /// Returns `None` if there is no child corresponding to token BRACE_R
    fn BRACE_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACE_R, 0)
    }
    fn tuple_call_item_all(&self) -> Vec<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn tuple_call_item(&self, i: usize) -> Option<Rc<Tuple_call_itemContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    fn eos_free_all(&self) -> Vec<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn eos_free(&self, i: usize) -> Option<Rc<Eos_freeContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> New_blockContextAttrs<'input> for New_blockContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn new_block(&mut self) -> Result<Rc<New_blockContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = New_blockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_new_block);
        let mut _localctx: Rc<New_blockContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1908);
                recog.base.match_token(BRACE_L, &mut recog.err_handler)?;

                recog.base.set_state(1913);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while (((_la - 3) & !0x3f) == 0
                    && ((1usize << (_la - 3))
                        & ((1usize << (COMMA - 3))
                            | (1usize << (SEMICOLON - 3))
                            | (1usize << (FAKE_COLON - 3))
                            | (1usize << (PARENTHESES_L - 3))
                            | (1usize << (BRACKET_L - 3))
                            | (1usize << (BRACE_L - 3))
                            | (1usize << (OFFSET_L - 3))
                            | (1usize << (CEILING_L - 3))
                            | (1usize << (FLOOR_L - 3))
                            | (1usize << (OP_ADD - 3))
                            | (1usize << (OP_SUB - 3))
                            | (1usize << (OP_MUL - 3))
                            | (1usize << (OP_REM - 3))
                            | (1usize << (OP_LAST - 3))))
                        != 0)
                    || (((_la - 69) & !0x3f) == 0
                        && ((1usize << (_la - 69))
                            & ((1usize << (OP_AND - 69))
                                | (1usize << (OP_AT - 69))
                                | (1usize << (OP_HASH - 69))
                                | (1usize << (LAMBDA_SLOT - 69))
                                | (1usize << (OP_NOT - 69))
                                | (1usize << (OP_DOT3 - 69))
                                | (1usize << (OP_DOT2 - 69))
                                | (1usize << (OP_INVERSE - 69))
                                | (1usize << (OP_ROOT2 - 69))
                                | (1usize << (OP_ROOT3 - 69))))
                            != 0)
                    || (((_la - 101) & !0x3f) == 0
                        && ((1usize << (_la - 101))
                            & ((1usize << (OP_ROOT4 - 101))
                                | (1usize << (OP_REFERENCE - 101))
                                | (1usize << (OP_LABEL - 101))
                                | (1usize << (KW_NEW - 101))
                                | (1usize << (KW_OBJECT - 101))
                                | (1usize << (KW_LAMBDA - 101))
                                | (1usize << (KW_TRY - 101))
                                | (1usize << (KW_MATCH - 101))
                                | (1usize << (KW_CATCH - 101))
                                | (1usize << (INTEGER - 101))))
                            != 0)
                    || (((_la - 133) & !0x3f) == 0
                        && ((1usize << (_la - 133))
                            & ((1usize << (DECIMAL - 133))
                                | (1usize << (STRING_SINGLE - 133))
                                | (1usize << (STRING_DOUBLE - 133))
                                | (1usize << (STRING_BLOCK - 133))
                                | (1usize << (KW_IF - 133))
                                | (1usize << (RETURN - 133))
                                | (1usize << (RESUME - 133))
                                | (1usize << (YIELD - 133))
                                | (1usize << (BREAK - 133))
                                | (1usize << (CONTINUE - 133))
                                | (1usize << (RAISE - 133))
                                | (1usize << (SPECIAL - 133))
                                | (1usize << (RAW_ID - 133))
                                | (1usize << (UNICODE_ID - 133))))
                            != 0)
                {
                    {
                        recog.base.set_state(1911);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            PARENTHESES_L | BRACKET_L | BRACE_L | OFFSET_L | CEILING_L | FLOOR_L | OP_ADD | OP_SUB | OP_MUL
                            | OP_REM | OP_LAST | OP_AND | OP_AT | OP_HASH | LAMBDA_SLOT | OP_NOT | OP_DOT3 | OP_DOT2
                            | OP_INVERSE | OP_ROOT2 | OP_ROOT3 | OP_ROOT4 | OP_REFERENCE | OP_LABEL | KW_NEW | KW_OBJECT
                            | KW_LAMBDA | KW_TRY | KW_MATCH | KW_CATCH | INTEGER | DECIMAL | STRING_SINGLE | STRING_DOUBLE
                            | STRING_BLOCK | KW_IF | RETURN | RESUME | YIELD | BREAK | CONTINUE | RAISE | SPECIAL | RAW_ID
                            | UNICODE_ID => {
                                {
                                    /* InvokeRule tuple_call_item */
                                    recog.base.set_state(1909);
                                    recog.tuple_call_item()?;
                                }
                            }

                            COMMA | SEMICOLON | FAKE_COLON => {
                                {
                                    /* InvokeRule eos_free */
                                    recog.base.set_state(1910);
                                    recog.eos_free()?;
                                }
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                    recog.base.set_state(1915);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
                recog.base.set_state(1916);
                recog.base.match_token(BRACE_R, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- tuple_literal ----------------
pub type Tuple_literalContextAll<'input> = Tuple_literalContext<'input>;

pub type Tuple_literalContext<'input> = BaseParserRuleContext<'input, Tuple_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Tuple_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Tuple_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Tuple_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_tuple_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_tuple_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Tuple_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_tuple_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Tuple_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_tuple_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_tuple_literal }
}
antlr_rust::tid! {Tuple_literalContextExt<'a>}

impl<'input> Tuple_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Tuple_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Tuple_literalContextExt { ph: PhantomData }))
    }
}

pub trait Tuple_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Tuple_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_L
    /// Returns `None` if there is no child corresponding to token PARENTHESES_L
    fn PARENTHESES_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token PARENTHESES_R
    /// Returns `None` if there is no child corresponding to token PARENTHESES_R
    fn PARENTHESES_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(PARENTHESES_R, 0)
    }
    fn collection_pair_all(&self) -> Vec<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn collection_pair(&self, i: usize) -> Option<Rc<Collection_pairContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> Tuple_literalContextAttrs<'input> for Tuple_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn tuple_literal(&mut self) -> Result<Rc<Tuple_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Tuple_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_tuple_literal);
        let mut _localctx: Rc<Tuple_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1938);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(269, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1918);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        recog.base.set_state(1919);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(1920);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(1921);
                        recog.collection_pair()?;

                        recog.base.set_state(1924);
                        recog.err_handler.sync(&mut recog.base)?;
                        _alt = 1;
                        loop {
                            match _alt {
                                x if x == 1 => {
                                    {
                                        recog.base.set_state(1922);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                        /* InvokeRule collection_pair */
                                        recog.base.set_state(1923);
                                        recog.collection_pair()?;
                                    }
                                }

                                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                            }
                            recog.base.set_state(1926);
                            recog.err_handler.sync(&mut recog.base)?;
                            _alt = recog.interpreter.adaptive_predict(267, &mut recog.base)?;
                            if _alt == 2 || _alt == INVALID_ALT {
                                break;
                            }
                        }
                        recog.base.set_state(1929);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == COMMA {
                            {
                                recog.base.set_state(1928);
                                recog.base.match_token(COMMA, &mut recog.err_handler)?;
                            }
                        }

                        recog.base.set_state(1931);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(1933);
                        recog.base.match_token(PARENTHESES_L, &mut recog.err_handler)?;

                        /* InvokeRule collection_pair */
                        recog.base.set_state(1934);
                        recog.collection_pair()?;

                        recog.base.set_state(1935);
                        recog.base.match_token(COMMA, &mut recog.err_handler)?;

                        recog.base.set_state(1936);
                        recog.base.match_token(PARENTHESES_R, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- collection_pair ----------------
pub type Collection_pairContextAll<'input> = Collection_pairContext<'input>;

pub type Collection_pairContext<'input> = BaseParserRuleContext<'input, Collection_pairContextExt<'input>>;

#[derive(Clone)]
pub struct Collection_pairContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Collection_pairContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Collection_pairContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_collection_pair(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_collection_pair(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Collection_pairContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_collection_pair(self);
    }
}

impl<'input> CustomRuleContext<'input> for Collection_pairContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_collection_pair
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_collection_pair }
}
antlr_rust::tid! {Collection_pairContextExt<'a>}

impl<'input> Collection_pairContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Collection_pairContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Collection_pairContextExt { ph: PhantomData }))
    }
}

pub trait Collection_pairContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Collection_pairContextExt<'input>>
{
    fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token COLON
    /// Returns `None` if there is no child corresponding to token COLON
    fn COLON(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, 0)
    }
}

impl<'input> Collection_pairContextAttrs<'input> for Collection_pairContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn collection_pair(&mut self) -> Result<Rc<Collection_pairContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Collection_pairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_collection_pair);
        let mut _localctx: Rc<Collection_pairContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1943);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(270, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(1940);
                            recog.identifier()?;

                            recog.base.set_state(1941);
                            recog.base.match_token(COLON, &mut recog.err_handler)?;
                        }
                    }

                    _ => {}
                }
                /* InvokeRule expression */
                recog.base.set_state(1945);
                recog.expression_rec(0)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- slice_call ----------------
pub type Slice_callContextAll<'input> = Slice_callContext<'input>;

pub type Slice_callContext<'input> = BaseParserRuleContext<'input, Slice_callContextExt<'input>>;

#[derive(Clone)]
pub struct Slice_callContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Slice_callContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Slice_callContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_slice_call(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_slice_call(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Slice_callContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_slice_call(self);
    }
}

impl<'input> CustomRuleContext<'input> for Slice_callContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_slice_call
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_slice_call }
}
antlr_rust::tid! {Slice_callContextExt<'a>}

impl<'input> Slice_callContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Slice_callContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Slice_callContextExt { ph: PhantomData }))
    }
}

pub trait Slice_callContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Slice_callContextExt<'input>> {
    fn range_literal(&self) -> Option<Rc<Range_literalContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_AND_THEN
    /// Returns `None` if there is no child corresponding to token OP_AND_THEN
    fn OP_AND_THEN(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_AND_THEN, 0)
    }
}

impl<'input> Slice_callContextAttrs<'input> for Slice_callContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn slice_call(&mut self) -> Result<Rc<Slice_callContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Slice_callContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_slice_call);
        let mut _localctx: Rc<Slice_callContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(1948);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                if _la == OP_AND_THEN {
                    {
                        recog.base.set_state(1947);
                        recog.base.match_token(OP_AND_THEN, &mut recog.err_handler)?;
                    }
                }

                /* InvokeRule range_literal */
                recog.base.set_state(1950);
                recog.range_literal()?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_literal ----------------
#[derive(Debug)]
pub enum Range_literalContextAll<'input> {
    OrdinalContext(OrdinalContext<'input>),
    OffsetContext(OffsetContext<'input>),
    Error(Range_literalContext<'input>),
}
antlr_rust::tid! {Range_literalContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Range_literalContextAll<'input> {}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_literalContextAll<'input> {}

impl<'input> Deref for Range_literalContextAll<'input> {
    type Target = dyn Range_literalContextAttrs<'input> + 'input;
    fn deref(&self) -> &Self::Target {
        use Range_literalContextAll::*;
        match self {
            OrdinalContext(inner) => inner,
            OffsetContext(inner) => inner,
            Error(inner) => inner,
        }
    }
}
impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_literalContextAll<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        self.deref().accept(visitor)
    }
}
impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_literalContextAll<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().enter(listener)
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        self.deref().exit(listener)
    }
}

pub type Range_literalContext<'input> = BaseParserRuleContext<'input, Range_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Range_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_literalContext<'input> {}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_literalContext<'input> {}

impl<'input> CustomRuleContext<'input> for Range_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}
antlr_rust::tid! {Range_literalContextExt<'a>}

impl<'input> Range_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::Error(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Range_literalContextExt { ph: PhantomData },
        )))
    }
}

pub trait Range_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Range_literalContextExt<'input>>
{
}

impl<'input> Range_literalContextAttrs<'input> for Range_literalContext<'input> {}

pub type OrdinalContext<'input> = BaseParserRuleContext<'input, OrdinalContextExt<'input>>;

pub trait OrdinalContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token BRACKET_L
    /// Returns `None` if there is no child corresponding to token BRACKET_L
    fn BRACKET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token BRACKET_R
    /// Returns `None` if there is no child corresponding to token BRACKET_R
    fn BRACKET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(BRACKET_R, 0)
    }
    fn range_axis_all(&self) -> Vec<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn range_axis(&self, i: usize) -> Option<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> OrdinalContextAttrs<'input> for OrdinalContext<'input> {}

pub struct OrdinalContextExt<'input> {
    base: Range_literalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OrdinalContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for OrdinalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for OrdinalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_Ordinal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_Ordinal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for OrdinalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_Ordinal(self);
    }
}

impl<'input> CustomRuleContext<'input> for OrdinalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}

impl<'input> Borrow<Range_literalContextExt<'input>> for OrdinalContext<'input> {
    fn borrow(&self) -> &Range_literalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Range_literalContextExt<'input>> for OrdinalContext<'input> {
    fn borrow_mut(&mut self) -> &mut Range_literalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Range_literalContextAttrs<'input> for OrdinalContext<'input> {}

impl<'input> OrdinalContextExt<'input> {
    fn new(ctx: &dyn Range_literalContextAttrs<'input>) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::OrdinalContext(BaseParserRuleContext::copy_from(
            ctx,
            OrdinalContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

pub type OffsetContext<'input> = BaseParserRuleContext<'input, OffsetContextExt<'input>>;

pub trait OffsetContextAttrs<'input>: ValkyrieAntlrParserContext<'input> {
    /// Retrieves first TerminalNode corresponding to token OFFSET_L
    /// Returns `None` if there is no child corresponding to token OFFSET_L
    fn OFFSET_L(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_L, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OFFSET_R
    /// Returns `None` if there is no child corresponding to token OFFSET_R
    fn OFFSET_R(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OFFSET_R, 0)
    }
    fn range_axis_all(&self) -> Vec<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn range_axis(&self, i: usize) -> Option<Rc<Range_axisContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
    fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
    /// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
    fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COMMA, i)
    }
}

impl<'input> OffsetContextAttrs<'input> for OffsetContext<'input> {}

pub struct OffsetContextExt<'input> {
    base: Range_literalContextExt<'input>,
    ph: PhantomData<&'input str>,
}

antlr_rust::tid! {OffsetContextExt<'a>}

impl<'input> ValkyrieAntlrParserContext<'input> for OffsetContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for OffsetContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_Offset(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_Offset(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for OffsetContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_Offset(self);
    }
}

impl<'input> CustomRuleContext<'input> for OffsetContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_literal }
}

impl<'input> Borrow<Range_literalContextExt<'input>> for OffsetContext<'input> {
    fn borrow(&self) -> &Range_literalContextExt<'input> {
        &self.base
    }
}
impl<'input> BorrowMut<Range_literalContextExt<'input>> for OffsetContext<'input> {
    fn borrow_mut(&mut self) -> &mut Range_literalContextExt<'input> {
        &mut self.base
    }
}

impl<'input> Range_literalContextAttrs<'input> for OffsetContext<'input> {}

impl<'input> OffsetContextExt<'input> {
    fn new(ctx: &dyn Range_literalContextAttrs<'input>) -> Rc<Range_literalContextAll<'input>> {
        Rc::new(Range_literalContextAll::OffsetContext(BaseParserRuleContext::copy_from(
            ctx,
            OffsetContextExt { base: ctx.borrow().clone(), ph: PhantomData },
        )))
    }
}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_literal(&mut self) -> Result<Rc<Range_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_range_literal);
        let mut _localctx: Rc<Range_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            recog.base.set_state(1982);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.base.input.la(1) {
                BRACKET_L => {
                    let tmp = OrdinalContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 1);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1952);
                        recog.base.match_token(BRACKET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1964);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la - 6) & !0x3f) == 0
                            && ((1usize << (_la - 6))
                                & ((1usize << (OP_PROPORTION - 6))
                                    | (1usize << (COLON - 6))
                                    | (1usize << (PARENTHESES_L - 6))
                                    | (1usize << (BRACKET_L - 6))
                                    | (1usize << (BRACE_L - 6))
                                    | (1usize << (OFFSET_L - 6))
                                    | (1usize << (CEILING_L - 6))
                                    | (1usize << (FLOOR_L - 6))
                                    | (1usize << (OP_ADD - 6))
                                    | (1usize << (OP_SUB - 6))
                                    | (1usize << (OP_MUL - 6))
                                    | (1usize << (OP_REM - 6))
                                    | (1usize << (OP_LAST - 6))))
                                != 0)
                            || (((_la - 69) & !0x3f) == 0
                                && ((1usize << (_la - 69))
                                    & ((1usize << (OP_AND - 69))
                                        | (1usize << (OP_AT - 69))
                                        | (1usize << (OP_HASH - 69))
                                        | (1usize << (LAMBDA_SLOT - 69))
                                        | (1usize << (OP_NOT - 69))
                                        | (1usize << (OP_DOT3 - 69))
                                        | (1usize << (OP_DOT2 - 69))
                                        | (1usize << (OP_INVERSE - 69))
                                        | (1usize << (OP_ROOT2 - 69))
                                        | (1usize << (OP_ROOT3 - 69))))
                                    != 0)
                            || (((_la - 101) & !0x3f) == 0
                                && ((1usize << (_la - 101))
                                    & ((1usize << (OP_ROOT4 - 101))
                                        | (1usize << (OP_REFERENCE - 101))
                                        | (1usize << (OP_LABEL - 101))
                                        | (1usize << (KW_NEW - 101))
                                        | (1usize << (KW_OBJECT - 101))
                                        | (1usize << (KW_LAMBDA - 101))
                                        | (1usize << (KW_TRY - 101))
                                        | (1usize << (KW_MATCH - 101))
                                        | (1usize << (KW_CATCH - 101))
                                        | (1usize << (INTEGER - 101))))
                                    != 0)
                            || (((_la - 133) & !0x3f) == 0
                                && ((1usize << (_la - 133))
                                    & ((1usize << (DECIMAL - 133))
                                        | (1usize << (STRING_SINGLE - 133))
                                        | (1usize << (STRING_DOUBLE - 133))
                                        | (1usize << (STRING_BLOCK - 133))
                                        | (1usize << (KW_IF - 133))
                                        | (1usize << (RETURN - 133))
                                        | (1usize << (RESUME - 133))
                                        | (1usize << (YIELD - 133))
                                        | (1usize << (BREAK - 133))
                                        | (1usize << (CONTINUE - 133))
                                        | (1usize << (RAISE - 133))
                                        | (1usize << (SPECIAL - 133))
                                        | (1usize << (RAW_ID - 133))
                                        | (1usize << (UNICODE_ID - 133))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(1953);
                                recog.range_axis()?;

                                recog.base.set_state(1958);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(272, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1954);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(1955);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1960);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(272, &mut recog.base)?;
                                }
                                recog.base.set_state(1962);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1961);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1966);
                        recog.base.match_token(BRACKET_R, &mut recog.err_handler)?;
                    }
                }

                OFFSET_L => {
                    let tmp = OffsetContextExt::new(&**_localctx);
                    recog.base.enter_outer_alt(Some(tmp.clone()), 2);
                    _localctx = tmp;
                    {
                        recog.base.set_state(1967);
                        recog.base.match_token(OFFSET_L, &mut recog.err_handler)?;

                        recog.base.set_state(1979);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if (((_la - 6) & !0x3f) == 0
                            && ((1usize << (_la - 6))
                                & ((1usize << (OP_PROPORTION - 6))
                                    | (1usize << (COLON - 6))
                                    | (1usize << (PARENTHESES_L - 6))
                                    | (1usize << (BRACKET_L - 6))
                                    | (1usize << (BRACE_L - 6))
                                    | (1usize << (OFFSET_L - 6))
                                    | (1usize << (CEILING_L - 6))
                                    | (1usize << (FLOOR_L - 6))
                                    | (1usize << (OP_ADD - 6))
                                    | (1usize << (OP_SUB - 6))
                                    | (1usize << (OP_MUL - 6))
                                    | (1usize << (OP_REM - 6))
                                    | (1usize << (OP_LAST - 6))))
                                != 0)
                            || (((_la - 69) & !0x3f) == 0
                                && ((1usize << (_la - 69))
                                    & ((1usize << (OP_AND - 69))
                                        | (1usize << (OP_AT - 69))
                                        | (1usize << (OP_HASH - 69))
                                        | (1usize << (LAMBDA_SLOT - 69))
                                        | (1usize << (OP_NOT - 69))
                                        | (1usize << (OP_DOT3 - 69))
                                        | (1usize << (OP_DOT2 - 69))
                                        | (1usize << (OP_INVERSE - 69))
                                        | (1usize << (OP_ROOT2 - 69))
                                        | (1usize << (OP_ROOT3 - 69))))
                                    != 0)
                            || (((_la - 101) & !0x3f) == 0
                                && ((1usize << (_la - 101))
                                    & ((1usize << (OP_ROOT4 - 101))
                                        | (1usize << (OP_REFERENCE - 101))
                                        | (1usize << (OP_LABEL - 101))
                                        | (1usize << (KW_NEW - 101))
                                        | (1usize << (KW_OBJECT - 101))
                                        | (1usize << (KW_LAMBDA - 101))
                                        | (1usize << (KW_TRY - 101))
                                        | (1usize << (KW_MATCH - 101))
                                        | (1usize << (KW_CATCH - 101))
                                        | (1usize << (INTEGER - 101))))
                                    != 0)
                            || (((_la - 133) & !0x3f) == 0
                                && ((1usize << (_la - 133))
                                    & ((1usize << (DECIMAL - 133))
                                        | (1usize << (STRING_SINGLE - 133))
                                        | (1usize << (STRING_DOUBLE - 133))
                                        | (1usize << (STRING_BLOCK - 133))
                                        | (1usize << (KW_IF - 133))
                                        | (1usize << (RETURN - 133))
                                        | (1usize << (RESUME - 133))
                                        | (1usize << (YIELD - 133))
                                        | (1usize << (BREAK - 133))
                                        | (1usize << (CONTINUE - 133))
                                        | (1usize << (RAISE - 133))
                                        | (1usize << (SPECIAL - 133))
                                        | (1usize << (RAW_ID - 133))
                                        | (1usize << (UNICODE_ID - 133))))
                                    != 0)
                        {
                            {
                                /* InvokeRule range_axis */
                                recog.base.set_state(1968);
                                recog.range_axis()?;

                                recog.base.set_state(1973);
                                recog.err_handler.sync(&mut recog.base)?;
                                _alt = recog.interpreter.adaptive_predict(275, &mut recog.base)?;
                                while { _alt != 2 && _alt != INVALID_ALT } {
                                    if _alt == 1 {
                                        {
                                            {
                                                recog.base.set_state(1969);
                                                recog.base.match_token(COMMA, &mut recog.err_handler)?;

                                                /* InvokeRule range_axis */
                                                recog.base.set_state(1970);
                                                recog.range_axis()?;
                                            }
                                        }
                                    }
                                    recog.base.set_state(1975);
                                    recog.err_handler.sync(&mut recog.base)?;
                                    _alt = recog.interpreter.adaptive_predict(275, &mut recog.base)?;
                                }
                                recog.base.set_state(1977);
                                recog.err_handler.sync(&mut recog.base)?;
                                _la = recog.base.input.la(1);
                                if _la == COMMA {
                                    {
                                        recog.base.set_state(1976);
                                        recog.base.match_token(COMMA, &mut recog.err_handler)?;
                                    }
                                }
                            }
                        }

                        recog.base.set_state(1981);
                        recog.base.match_token(OFFSET_R, &mut recog.err_handler)?;
                    }
                }

                _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- range_axis ----------------
pub type Range_axisContextAll<'input> = Range_axisContext<'input>;

pub type Range_axisContext<'input> = BaseParserRuleContext<'input, Range_axisContextExt<'input>>;

#[derive(Clone)]
pub struct Range_axisContextExt<'input> {
    pub index: Option<Rc<ExpressionContextAll<'input>>>,
    pub head: Option<Rc<ExpressionContextAll<'input>>>,
    pub tail: Option<Rc<ExpressionContextAll<'input>>>,
    pub step: Option<Rc<ExpressionContextAll<'input>>>,
    pub setp: Option<Rc<ExpressionContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Range_axisContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Range_axisContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_range_axis(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_range_axis(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Range_axisContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_range_axis(self);
    }
}

impl<'input> CustomRuleContext<'input> for Range_axisContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_range_axis
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_range_axis }
}
antlr_rust::tid! {Range_axisContextExt<'a>}

impl<'input> Range_axisContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Range_axisContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Range_axisContextExt { index: None, head: None, tail: None, step: None, setp: None, ph: PhantomData },
        ))
    }
}

pub trait Range_axisContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<Range_axisContextExt<'input>> {
    /// Retrieves all `TerminalNode`s corresponding to token COLON in current rule
    fn COLON_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token COLON, starting from 0.
    /// Returns `None` if number of children corresponding to token COLON is less or equal than `i`.
    fn COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(COLON, i)
    }
    fn expression_all(&self) -> Vec<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves first TerminalNode corresponding to token OP_PROPORTION
    /// Returns `None` if there is no child corresponding to token OP_PROPORTION
    fn OP_PROPORTION(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, 0)
    }
}

impl<'input> Range_axisContextAttrs<'input> for Range_axisContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn range_axis(&mut self) -> Result<Rc<Range_axisContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Range_axisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_range_axis);
        let mut _localctx: Rc<Range_axisContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2040);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(283, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(1984);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(1985);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).index = Some(tmp.clone());
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(1986);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(1987);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                4 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 4);
                    recog.base.enter_outer_alt(None, 4);
                    {
                        recog.base.set_state(1989);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1990);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());
                    }
                }
                5 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 5);
                    recog.base.enter_outer_alt(None, 5);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(1991);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(1992);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(1993);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());
                    }
                }
                6 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 6);
                    recog.base.enter_outer_alt(None, 6);
                    {
                        recog.base.set_state(1998);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(1995);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(1996);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(1997);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                7 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 7);
                    recog.base.enter_outer_alt(None, 7);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2000);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2004);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(2001);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(2002);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(2003);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                    }
                }
                8 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 8);
                    recog.base.enter_outer_alt(None, 8);
                    {
                        recog.base.set_state(2006);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2007);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2008);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                9 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 9);
                    recog.base.enter_outer_alt(None, 9);
                    {
                        recog.base.set_state(2013);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(2010);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(2011);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(2012);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                        /* InvokeRule expression */
                        recog.base.set_state(2015);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).step = Some(tmp.clone());
                    }
                }
                10 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 10);
                    recog.base.enter_outer_alt(None, 10);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2016);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2017);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2018);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2019);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;
                    }
                }
                11 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 11);
                    recog.base.enter_outer_alt(None, 11);
                    {
                        recog.base.set_state(2021);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2022);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2023);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2024);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).step = Some(tmp.clone());
                    }
                }
                12 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 12);
                    recog.base.enter_outer_alt(None, 12);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2026);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2030);
                        recog.err_handler.sync(&mut recog.base)?;
                        match recog.base.input.la(1) {
                            OP_PROPORTION => {
                                recog.base.set_state(2027);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;
                            }

                            COLON => {
                                recog.base.set_state(2028);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;

                                recog.base.set_state(2029);
                                recog.base.match_token(COLON, &mut recog.err_handler)?;
                            }

                            _ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?,
                        }
                        /* InvokeRule expression */
                        recog.base.set_state(2032);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).setp = Some(tmp.clone());
                    }
                }
                13 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 13);
                    recog.base.enter_outer_alt(None, 13);
                    {
                        /* InvokeRule expression */
                        recog.base.set_state(2034);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).head = Some(tmp.clone());

                        recog.base.set_state(2035);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2036);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).tail = Some(tmp.clone());

                        recog.base.set_state(2037);
                        recog.base.match_token(COLON, &mut recog.err_handler)?;

                        /* InvokeRule expression */
                        recog.base.set_state(2038);
                        let tmp = recog.expression_rec(0)?;
                        cast_mut::<_, Range_axisContext>(&mut _localctx).step = Some(tmp.clone());
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modifiers ----------------
pub type ModifiersContextAll<'input> = ModifiersContext<'input>;

pub type ModifiersContext<'input> = BaseParserRuleContext<'input, ModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ModifiersContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for ModifiersContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for ModifiersContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modifiers(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modifiers(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for ModifiersContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modifiers(self);
    }
}

impl<'input> CustomRuleContext<'input> for ModifiersContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modifiers
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modifiers }
}
antlr_rust::tid! {ModifiersContextExt<'a>}

impl<'input> ModifiersContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<ModifiersContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            ModifiersContextExt { identifier: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait ModifiersContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<ModifiersContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> ModifiersContextAttrs<'input> for ModifiersContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modifiers(&mut self) -> Result<Rc<ModifiersContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = ModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_modifiers);
        let mut _localctx: Rc<ModifiersContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2045);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == RAW_ID || _la == UNICODE_ID {
                    {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(2042);
                            let tmp = recog.identifier()?;
                            cast_mut::<_, ModifiersContext>(&mut _localctx).identifier = Some(tmp.clone());

                            let temp = cast_mut::<_, ModifiersContext>(&mut _localctx).identifier.clone().unwrap();
                            cast_mut::<_, ModifiersContext>(&mut _localctx).mods.push(temp);
                        }
                    }
                    recog.base.set_state(2047);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_identifier ----------------
pub type Modified_identifierContextAll<'input> = Modified_identifierContext<'input>;

pub type Modified_identifierContext<'input> = BaseParserRuleContext<'input, Modified_identifierContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_identifierContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub id: Option<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_identifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_identifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_identifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_identifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_identifier }
}
antlr_rust::tid! {Modified_identifierContextExt<'a>}

impl<'input> Modified_identifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_identifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_identifierContextExt { identifier: None, id: None, mods: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_identifierContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_identifierContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
}

impl<'input> Modified_identifierContextAttrs<'input> for Modified_identifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_identifier(&mut self) -> Result<Rc<Modified_identifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_identifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_modified_identifier);
        let mut _localctx: Rc<Modified_identifierContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2051);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(285, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(2048);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp =
                                    cast_mut::<_, Modified_identifierContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_identifierContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(2053);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(285, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(2054);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_identifierContext>(&mut _localctx).id = Some(tmp.clone());
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- modified_namepath ----------------
pub type Modified_namepathContextAll<'input> = Modified_namepathContext<'input>;

pub type Modified_namepathContext<'input> = BaseParserRuleContext<'input, Modified_namepathContextExt<'input>>;

#[derive(Clone)]
pub struct Modified_namepathContextExt<'input> {
    pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
    pub mods: Vec<Rc<IdentifierContextAll<'input>>>,
    pub path: Vec<Rc<IdentifierContextAll<'input>>>,
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Modified_namepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Modified_namepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_modified_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_modified_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Modified_namepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_modified_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for Modified_namepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_modified_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_modified_namepath }
}
antlr_rust::tid! {Modified_namepathContextExt<'a>}

impl<'input> Modified_namepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Modified_namepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(
            parent,
            invoking_state,
            Modified_namepathContextExt { identifier: None, mods: Vec::new(), path: Vec::new(), ph: PhantomData },
        ))
    }
}

pub trait Modified_namepathContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Modified_namepathContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> Modified_namepathContextAttrs<'input> for Modified_namepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn modified_namepath(&mut self) -> Result<Rc<Modified_namepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Modified_namepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_modified_namepath);
        let mut _localctx: Rc<Modified_namepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2059);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(286, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(2056);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).mods.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(2061);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(286, &mut recog.base)?;
                }
                /* InvokeRule identifier */
                recog.base.set_state(2062);
                let tmp = recog.identifier()?;
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);

                recog.base.set_state(2067);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(287, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(2063);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(2064);
                                let tmp = recog.identifier()?;
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier = Some(tmp.clone());

                                let temp = cast_mut::<_, Modified_namepathContext>(&mut _localctx).identifier.clone().unwrap();
                                cast_mut::<_, Modified_namepathContext>(&mut _localctx).path.push(temp);
                            }
                        }
                    }
                    recog.base.set_state(2069);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(287, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- lambda_name ----------------
pub type Lambda_nameContextAll<'input> = Lambda_nameContext<'input>;

pub type Lambda_nameContext<'input> = BaseParserRuleContext<'input, Lambda_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Lambda_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Lambda_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Lambda_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_lambda_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_lambda_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Lambda_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_lambda_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Lambda_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_lambda_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_lambda_name }
}
antlr_rust::tid! {Lambda_nameContextExt<'a>}

impl<'input> Lambda_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Lambda_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Lambda_nameContextExt { ph: PhantomData }))
    }
}

pub trait Lambda_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Lambda_nameContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token LAMBDA_SLOT
    /// Returns `None` if there is no child corresponding to token LAMBDA_SLOT
    fn LAMBDA_SLOT(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(LAMBDA_SLOT, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Lambda_nameContextAttrs<'input> for Lambda_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn lambda_name(&mut self) -> Result<Rc<Lambda_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Lambda_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_lambda_name);
        let mut _localctx: Rc<Lambda_nameContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2070);
                recog.base.match_token(LAMBDA_SLOT, &mut recog.err_handler)?;

                recog.base.set_state(2073);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(288, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(2071);
                            recog.identifier()?;
                        }
                    }

                    x if x == 2 => {
                        {
                            /* InvokeRule number */
                            recog.base.set_state(2072);
                            recog.number()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- output_name ----------------
pub type Output_nameContextAll<'input> = Output_nameContext<'input>;

pub type Output_nameContext<'input> = BaseParserRuleContext<'input, Output_nameContextExt<'input>>;

#[derive(Clone)]
pub struct Output_nameContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Output_nameContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Output_nameContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_output_name(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_output_name(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Output_nameContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_output_name(self);
    }
}

impl<'input> CustomRuleContext<'input> for Output_nameContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_output_name
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_output_name }
}
antlr_rust::tid! {Output_nameContextExt<'a>}

impl<'input> Output_nameContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Output_nameContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Output_nameContextExt { ph: PhantomData }))
    }
}

pub trait Output_nameContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Output_nameContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_REM
    /// Returns `None` if there is no child corresponding to token OP_REM
    fn OP_REM(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_REM, 0)
    }
    /// Retrieves first TerminalNode corresponding to token OP_LAST
    /// Returns `None` if there is no child corresponding to token OP_LAST
    fn OP_LAST(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_LAST, 0)
    }
}

impl<'input> Output_nameContextAttrs<'input> for Output_nameContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn output_name(&mut self) -> Result<Rc<Output_nameContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Output_nameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_output_name);
        let mut _localctx: Rc<Output_nameContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2075);
                _la = recog.base.input.la(1);
                if { !(_la == OP_REM || _la == OP_LAST) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
                recog.base.set_state(2076);
                recog.base.match_token(INTEGER, &mut recog.err_handler)?;
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath_free ----------------
pub type Namepath_freeContextAll<'input> = Namepath_freeContext<'input>;

pub type Namepath_freeContext<'input> = BaseParserRuleContext<'input, Namepath_freeContextExt<'input>>;

#[derive(Clone)]
pub struct Namepath_freeContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Namepath_freeContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Namepath_freeContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath_free(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath_free(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Namepath_freeContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath_free(self);
    }
}

impl<'input> CustomRuleContext<'input> for Namepath_freeContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath_free
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath_free }
}
antlr_rust::tid! {Namepath_freeContextExt<'a>}

impl<'input> Namepath_freeContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Namepath_freeContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Namepath_freeContextExt { ph: PhantomData }))
    }
}

pub trait Namepath_freeContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Namepath_freeContextExt<'input>>
{
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
    fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
    /// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
    fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DOT, i)
    }
}

impl<'input> Namepath_freeContextAttrs<'input> for Namepath_freeContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath_free(&mut self) -> Result<Rc<Namepath_freeContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Namepath_freeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_namepath_free);
        let mut _localctx: Rc<Namepath_freeContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(2078);
                recog.identifier()?;

                recog.base.set_state(2083);
                recog.err_handler.sync(&mut recog.base)?;
                _la = recog.base.input.la(1);
                while _la == DOT || _la == OP_PROPORTION {
                    {
                        {
                            recog.base.set_state(2079);
                            _la = recog.base.input.la(1);
                            if { !(_la == DOT || _la == OP_PROPORTION) } {
                                recog.err_handler.recover_inline(&mut recog.base)?;
                            }
                            else {
                                if recog.base.input.la(1) == TOKEN_EOF {
                                    recog.base.matched_eof = true
                                };
                                recog.err_handler.report_match(&mut recog.base);
                                recog.base.consume(&mut recog.err_handler);
                            }
                            /* InvokeRule identifier */
                            recog.base.set_state(2080);
                            recog.identifier()?;
                        }
                    }
                    recog.base.set_state(2085);
                    recog.err_handler.sync(&mut recog.base)?;
                    _la = recog.base.input.la(1);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- namepath ----------------
pub type NamepathContextAll<'input> = NamepathContext<'input>;

pub type NamepathContext<'input> = BaseParserRuleContext<'input, NamepathContextExt<'input>>;

#[derive(Clone)]
pub struct NamepathContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NamepathContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NamepathContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_namepath(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_namepath(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NamepathContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_namepath(self);
    }
}

impl<'input> CustomRuleContext<'input> for NamepathContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_namepath
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_namepath }
}
antlr_rust::tid! {NamepathContextExt<'a>}

impl<'input> NamepathContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NamepathContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NamepathContextExt { ph: PhantomData }))
    }
}

pub trait NamepathContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NamepathContextExt<'input>> {
    fn identifier_all(&self) -> Vec<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(i)
    }
    /// Retrieves all `TerminalNode`s corresponding to token OP_PROPORTION in current rule
    fn OP_PROPORTION_all(&self) -> Vec<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.children_of_type()
    }
    /// Retrieves 'i's TerminalNode corresponding to token OP_PROPORTION, starting from 0.
    /// Returns `None` if number of children corresponding to token OP_PROPORTION is less or equal than `i`.
    fn OP_PROPORTION(&self, i: usize) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(OP_PROPORTION, i)
    }
}

impl<'input> NamepathContextAttrs<'input> for NamepathContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn namepath(&mut self) -> Result<Rc<NamepathContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NamepathContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_namepath);
        let mut _localctx: Rc<NamepathContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            let mut _alt: isize;
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule identifier */
                recog.base.set_state(2086);
                recog.identifier()?;

                recog.base.set_state(2091);
                recog.err_handler.sync(&mut recog.base)?;
                _alt = recog.interpreter.adaptive_predict(290, &mut recog.base)?;
                while { _alt != 2 && _alt != INVALID_ALT } {
                    if _alt == 1 {
                        {
                            {
                                recog.base.set_state(2087);
                                recog.base.match_token(OP_PROPORTION, &mut recog.err_handler)?;

                                /* InvokeRule identifier */
                                recog.base.set_state(2088);
                                recog.identifier()?;
                            }
                        }
                    }
                    recog.base.set_state(2093);
                    recog.err_handler.sync(&mut recog.base)?;
                    _alt = recog.interpreter.adaptive_predict(290, &mut recog.base)?;
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;

pub type IdentifierContext<'input> = BaseParserRuleContext<'input, IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for IdentifierContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for IdentifierContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_identifier(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_identifier(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for IdentifierContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_identifier(self);
    }
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_identifier
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid! {IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<IdentifierContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, IdentifierContextExt { ph: PhantomData }))
    }
}

pub trait IdentifierContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<IdentifierContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token UNICODE_ID
    /// Returns `None` if there is no child corresponding to token UNICODE_ID
    fn UNICODE_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(UNICODE_ID, 0)
    }
    /// Retrieves first TerminalNode corresponding to token RAW_ID
    /// Returns `None` if there is no child corresponding to token RAW_ID
    fn RAW_ID(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(RAW_ID, 0)
    }
}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn identifier(&mut self) -> Result<Rc<IdentifierContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2094);
                _la = recog.base.input.la(1);
                if { !(_la == RAW_ID || _la == UNICODE_ID) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number ----------------
pub type NumberContextAll<'input> = NumberContext<'input>;

pub type NumberContext<'input> = BaseParserRuleContext<'input, NumberContextExt<'input>>;

#[derive(Clone)]
pub struct NumberContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for NumberContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for NumberContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for NumberContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number(self);
    }
}

impl<'input> CustomRuleContext<'input> for NumberContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number }
}
antlr_rust::tid! {NumberContextExt<'a>}

impl<'input> NumberContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<NumberContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, NumberContextExt { ph: PhantomData }))
    }
}

pub trait NumberContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<NumberContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token DECIMAL
    /// Returns `None` if there is no child corresponding to token DECIMAL
    fn DECIMAL(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(DECIMAL, 0)
    }
    /// Retrieves first TerminalNode corresponding to token INTEGER
    /// Returns `None` if there is no child corresponding to token INTEGER
    fn INTEGER(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(INTEGER, 0)
    }
}

impl<'input> NumberContextAttrs<'input> for NumberContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number(&mut self) -> Result<Rc<NumberContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = NumberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_number);
        let mut _localctx: Rc<NumberContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2096);
                _la = recog.base.input.la(1);
                if { !(_la == INTEGER || _la == DECIMAL) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- number_literal ----------------
pub type Number_literalContextAll<'input> = Number_literalContext<'input>;

pub type Number_literalContext<'input> = BaseParserRuleContext<'input, Number_literalContextExt<'input>>;

#[derive(Clone)]
pub struct Number_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for Number_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for Number_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_number_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_number_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for Number_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_number_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for Number_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_number_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_number_literal }
}
antlr_rust::tid! {Number_literalContextExt<'a>}

impl<'input> Number_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<Number_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, Number_literalContextExt { ph: PhantomData }))
    }
}

pub trait Number_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<Number_literalContextExt<'input>>
{
    fn number(&self) -> Option<Rc<NumberContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
}

impl<'input> Number_literalContextAttrs<'input> for Number_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn number_literal(&mut self) -> Result<Rc<Number_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = Number_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_number_literal);
        let mut _localctx: Rc<Number_literalContextAll> = _localctx;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                /* InvokeRule number */
                recog.base.set_state(2098);
                recog.number()?;

                recog.base.set_state(2100);
                recog.err_handler.sync(&mut recog.base)?;
                match recog.interpreter.adaptive_predict(291, &mut recog.base)? {
                    x if x == 1 => {
                        {
                            /* InvokeRule identifier */
                            recog.base.set_state(2099);
                            recog.identifier()?;
                        }
                    }

                    _ => {}
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string ----------------
pub type StringContextAll<'input> = StringContext<'input>;

pub type StringContext<'input> = BaseParserRuleContext<'input, StringContextExt<'input>>;

#[derive(Clone)]
pub struct StringContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for StringContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for StringContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for StringContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string(self);
    }
}

impl<'input> CustomRuleContext<'input> for StringContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string }
}
antlr_rust::tid! {StringContextExt<'a>}

impl<'input> StringContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<StringContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, StringContextExt { ph: PhantomData }))
    }
}

pub trait StringContextAttrs<'input>: ValkyrieAntlrParserContext<'input> + BorrowMut<StringContextExt<'input>> {
    /// Retrieves first TerminalNode corresponding to token STRING_SINGLE
    /// Returns `None` if there is no child corresponding to token STRING_SINGLE
    fn STRING_SINGLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_SINGLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_DOUBLE
    /// Returns `None` if there is no child corresponding to token STRING_DOUBLE
    fn STRING_DOUBLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_DOUBLE, 0)
    }
}

impl<'input> StringContextAttrs<'input> for StringContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string(&mut self) -> Result<Rc<StringContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = StringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_string);
        let mut _localctx: Rc<StringContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            //recog.base.enter_outer_alt(_localctx.clone(), 1);
            recog.base.enter_outer_alt(None, 1);
            {
                recog.base.set_state(2102);
                _la = recog.base.input.la(1);
                if { !(_la == STRING_SINGLE || _la == STRING_DOUBLE) } {
                    recog.err_handler.recover_inline(&mut recog.base)?;
                }
                else {
                    if recog.base.input.la(1) == TOKEN_EOF {
                        recog.base.matched_eof = true
                    };
                    recog.err_handler.report_match(&mut recog.base);
                    recog.base.consume(&mut recog.err_handler);
                }
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}
//------------------- string_literal ----------------
pub type String_literalContextAll<'input> = String_literalContext<'input>;

pub type String_literalContext<'input> = BaseParserRuleContext<'input, String_literalContextExt<'input>>;

#[derive(Clone)]
pub struct String_literalContextExt<'input> {
    ph: PhantomData<&'input str>,
}

impl<'input> ValkyrieAntlrParserContext<'input> for String_literalContext<'input> {}

impl<'input, 'a> Listenable<dyn ValkyrieAntlrListener<'input> + 'a> for String_literalContext<'input> {
    fn enter(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.enter_every_rule(self);
        listener.enter_string_literal(self);
    }
    fn exit(&self, listener: &mut (dyn ValkyrieAntlrListener<'input> + 'a)) {
        listener.exit_string_literal(self);
        listener.exit_every_rule(self);
    }
}

impl<'input, 'a> Visitable<dyn ValkyrieAntlrVisitor<'input> + 'a> for String_literalContext<'input> {
    fn accept(&self, visitor: &mut (dyn ValkyrieAntlrVisitor<'input> + 'a)) {
        visitor.visit_string_literal(self);
    }
}

impl<'input> CustomRuleContext<'input> for String_literalContextExt<'input> {
    type TF = LocalTokenFactory<'input>;
    type Ctx = ValkyrieAntlrParserContextType;
    fn get_rule_index(&self) -> usize {
        RULE_string_literal
    }
    //fn type_rule_index() -> usize where Self: Sized { RULE_string_literal }
}
antlr_rust::tid! {String_literalContextExt<'a>}

impl<'input> String_literalContextExt<'input> {
    fn new(
        parent: Option<Rc<dyn ValkyrieAntlrParserContext<'input> + 'input>>,
        invoking_state: isize,
    ) -> Rc<String_literalContextAll<'input>> {
        Rc::new(BaseParserRuleContext::new_parser_ctx(parent, invoking_state, String_literalContextExt { ph: PhantomData }))
    }
}

pub trait String_literalContextAttrs<'input>:
    ValkyrieAntlrParserContext<'input> + BorrowMut<String_literalContextExt<'input>>
{
    /// Retrieves first TerminalNode corresponding to token STRING_SINGLE
    /// Returns `None` if there is no child corresponding to token STRING_SINGLE
    fn STRING_SINGLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_SINGLE, 0)
    }
    fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>>
    where
        Self: Sized,
    {
        self.child_of_type(0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_DOUBLE
    /// Returns `None` if there is no child corresponding to token STRING_DOUBLE
    fn STRING_DOUBLE(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_DOUBLE, 0)
    }
    /// Retrieves first TerminalNode corresponding to token STRING_BLOCK
    /// Returns `None` if there is no child corresponding to token STRING_BLOCK
    fn STRING_BLOCK(&self) -> Option<Rc<TerminalNode<'input, ValkyrieAntlrParserContextType>>>
    where
        Self: Sized,
    {
        self.get_token(STRING_BLOCK, 0)
    }
}

impl<'input> String_literalContextAttrs<'input> for String_literalContext<'input> {}

impl<'input, I, H> ValkyrieAntlrParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input>> + TidAble<'input>,
    H: ErrorStrategy<'input, BaseParserType<'input, I>>,
{
    pub fn string_literal(&mut self) -> Result<Rc<String_literalContextAll<'input>>, ANTLRError> {
        let mut recog = self;
        let _parentctx = recog.ctx.take();
        let mut _localctx = String_literalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_string_literal);
        let mut _localctx: Rc<String_literalContextAll> = _localctx;
        let mut _la: isize = -1;
        let result: Result<(), ANTLRError> = (|| {
            recog.base.set_state(2116);
            recog.err_handler.sync(&mut recog.base)?;
            match recog.interpreter.adaptive_predict(295, &mut recog.base)? {
                1 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 1);
                    recog.base.enter_outer_alt(None, 1);
                    {
                        recog.base.set_state(2105);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(2104);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(2107);
                        recog.base.match_token(STRING_SINGLE, &mut recog.err_handler)?;
                    }
                }
                2 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 2);
                    recog.base.enter_outer_alt(None, 2);
                    {
                        recog.base.set_state(2109);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(2108);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(2111);
                        recog.base.match_token(STRING_DOUBLE, &mut recog.err_handler)?;
                    }
                }
                3 => {
                    //recog.base.enter_outer_alt(_localctx.clone(), 3);
                    recog.base.enter_outer_alt(None, 3);
                    {
                        recog.base.set_state(2113);
                        recog.err_handler.sync(&mut recog.base)?;
                        _la = recog.base.input.la(1);
                        if _la == RAW_ID || _la == UNICODE_ID {
                            {
                                /* InvokeRule identifier */
                                recog.base.set_state(2112);
                                recog.identifier()?;
                            }
                        }

                        recog.base.set_state(2115);
                        recog.base.match_token(STRING_BLOCK, &mut recog.err_handler)?;
                    }
                }

                _ => {}
            }
            Ok(())
        })();
        match result {
            Ok(_) => {}
            Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
            Err(ref re) => {
                //_localctx.exception = re;
                recog.err_handler.report_error(&mut recog.base, re);
                recog.err_handler.recover(&mut recog.base, re)?;
            }
        }
        recog.base.exit_rule();

        Ok(_localctx)
    }
}

lazy_static! {
    static ref _ATN: Arc<ATN> = Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(_ATN.clone(), _ATN.get_decision_state(i), i as isize).into())
        }
        Arc::new(dfa)
    };
}

const _serializedATN: &'static str = "\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{9a}\u{849}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x03\x02\x03\x02\x03\x02\x03\
	\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\x02\x03\
	\x02\x03\x02\x03\x02\x07\x02\u{100}\x0a\x02\x0c\x02\x0e\x02\u{103}\x0b\x02\
	\x03\x02\x03\x02\x03\x03\x03\x03\x03\x04\x03\x04\x03\x05\x03\x05\x03\x05\
	\x05\x05\u{10e}\x0a\x05\x03\x06\x03\x06\x03\x06\x03\x07\x03\x07\x05\x07\
	\u{115}\x0a\x07\x03\x07\x03\x07\x03\x08\x03\x08\x03\x08\x03\x08\x05\x08\
	\u{11d}\x0a\x08\x03\x08\x03\x08\x03\x08\x05\x08\u{122}\x0a\x08\x03\x08\x05\
	\x08\u{125}\x0a\x08\x03\x08\x03\x08\x03\x08\x05\x08\u{12a}\x0a\x08\x03\x08\
	\x03\x08\x03\x08\x05\x08\u{12f}\x0a\x08\x03\x08\x05\x08\u{132}\x0a\x08\x03\
	\x08\x03\x08\x05\x08\u{136}\x0a\x08\x03\x08\x03\x08\x05\x08\u{13a}\x0a\x08\
	\x03\x08\x05\x08\u{13d}\x0a\x08\x03\x08\x05\x08\u{140}\x0a\x08\x03\x09\x03\
	\x09\x03\x09\x07\x09\u{145}\x0a\x09\x0c\x09\x0e\x09\u{148}\x0b\x09\x03\x09\
	\x03\x09\x03\x09\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x07\x0a\u{151}\x0a\x0a\
	\x0c\x0a\x0e\x0a\u{154}\x0b\x0a\x03\x0a\x05\x0a\u{157}\x0a\x0a\x03\x0b\x03\
	\x0b\x03\x0c\x05\x0c\u{15c}\x0a\x0c\x03\x0c\x07\x0c\u{15f}\x0a\x0c\x0c\x0c\
	\x0e\x0c\u{162}\x0b\x0c\x03\x0c\x03\x0c\x03\x0c\x03\x0c\x05\x0c\u{168}\x0a\
	\x0c\x03\x0c\x05\x0c\u{16b}\x0a\x0c\x03\x0c\x05\x0c\u{16e}\x0a\x0c\x03\x0c\
	\x03\x0c\x05\x0c\u{172}\x0a\x0c\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x03\x0d\
	\x07\x0d\u{179}\x0a\x0d\x0c\x0d\x0e\x0d\u{17c}\x0b\x0d\x03\x0d\x03\x0d\x03\
	\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x03\x0e\x07\x0e\u{186}\x0a\x0e\x0c\
	\x0e\x0e\x0e\u{189}\x0b\x0e\x03\x0e\x05\x0e\u{18c}\x0a\x0e\x03\x0e\x03\x0e\
	\x05\x0e\u{190}\x0a\x0e\x03\x0f\x03\x0f\x03\x10\x07\x10\u{195}\x0a\x10\x0c\
	\x10\x0e\x10\u{198}\x0b\x10\x03\x10\x03\x10\x05\x10\u{19c}\x0a\x10\x03\x10\
	\x05\x10\u{19f}\x0a\x10\x03\x11\x07\x11\u{1a2}\x0a\x11\x0c\x11\x0e\x11\u{1a5}\
	\x0b\x11\x03\x11\x03\x11\x05\x11\u{1a9}\x0a\x11\x03\x11\x03\x11\x05\x11\
	\u{1ad}\x0a\x11\x03\x11\x05\x11\u{1b0}\x0a\x11\x03\x11\x05\x11\u{1b3}\x0a\
	\x11\x03\x12\x07\x12\u{1b6}\x0a\x12\x0c\x12\x0e\x12\u{1b9}\x0b\x12\x03\x12\
	\x03\x12\x03\x12\x03\x13\x05\x13\u{1bf}\x0a\x13\x03\x13\x07\x13\u{1c2}\x0a\
	\x13\x0c\x13\x0e\x13\u{1c5}\x0b\x13\x03\x13\x03\x13\x03\x13\x03\x13\x05\
	\x13\u{1cb}\x0a\x13\x03\x13\x05\x13\u{1ce}\x0a\x13\x03\x13\x03\x13\x05\x13\
	\u{1d2}\x0a\x13\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x07\x14\u{1d9}\x0a\
	\x14\x0c\x14\x0e\x14\u{1dc}\x0b\x14\x03\x14\x03\x14\x03\x15\x03\x15\x03\
	\x15\x03\x15\x05\x15\u{1e4}\x0a\x15\x03\x16\x05\x16\u{1e7}\x0a\x16\x03\x16\
	\x07\x16\u{1ea}\x0a\x16\x0c\x16\x0e\x16\u{1ed}\x0b\x16\x03\x16\x03\x16\x03\
	\x16\x03\x16\x05\x16\u{1f3}\x0a\x16\x03\x16\x05\x16\u{1f6}\x0a\x16\x03\x16\
	\x03\x16\x03\x17\x03\x17\x03\x17\x03\x17\x07\x17\u{1fe}\x0a\x17\x0c\x17\
	\x0e\x17\u{201}\x0b\x17\x03\x17\x03\x17\x03\x18\x03\x18\x03\x18\x03\x19\
	\x07\x19\u{209}\x0a\x19\x0c\x19\x0e\x19\u{20c}\x0b\x19\x03\x19\x03\x19\x03\
	\x19\x03\x19\x05\x19\u{212}\x0a\x19\x03\x19\x05\x19\u{215}\x0a\x19\x03\x19\
	\x03\x19\x03\x1a\x03\x1a\x05\x1a\u{21b}\x0a\x1a\x03\x1a\x03\x1a\x03\x1b\
	\x03\x1b\x03\x1b\x03\x1b\x07\x1b\u{223}\x0a\x1b\x0c\x1b\x0e\x1b\u{226}\x0b\
	\x1b\x03\x1b\x03\x1b\x03\x1c\x03\x1c\x05\x1c\u{22c}\x0a\x1c\x03\x1d\x03\
	\x1d\x03\x1d\x07\x1d\u{231}\x0a\x1d\x0c\x1d\x0e\x1d\u{234}\x0b\x1d\x03\x1d\
	\x03\x1d\x03\x1e\x07\x1e\u{239}\x0a\x1e\x0c\x1e\x0e\x1e\u{23c}\x0b\x1e\x03\
	\x1e\x03\x1e\x03\x1e\x03\x1e\x05\x1e\u{242}\x0a\x1e\x03\x1e\x05\x1e\u{245}\
	\x0a\x1e\x03\x1e\x03\x1e\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x07\x1f\u{24d}\
	\x0a\x1f\x0c\x1f\x0e\x1f\u{250}\x0b\x1f\x03\x1f\x03\x1f\x03\x20\x07\x20\
	\u{255}\x0a\x20\x0c\x20\x0e\x20\u{258}\x0b\x20\x03\x20\x03\x20\x03\x20\x05\
	\x20\u{25d}\x0a\x20\x03\x21\x05\x21\u{260}\x0a\x21\x03\x21\x07\x21\u{263}\
	\x0a\x21\x0c\x21\x0e\x21\u{266}\x0b\x21\x03\x21\x03\x21\x03\x21\x03\x21\
	\x05\x21\u{26c}\x0a\x21\x03\x21\x03\x21\x05\x21\u{270}\x0a\x21\x03\x21\x05\
	\x21\u{273}\x0a\x21\x03\x21\x03\x21\x03\x22\x03\x22\x03\x22\x03\x22\x03\
	\x22\x03\x22\x07\x22\u{27d}\x0a\x22\x0c\x22\x0e\x22\u{280}\x0b\x22\x03\x22\
	\x03\x22\x05\x22\u{284}\x0a\x22\x03\x23\x07\x23\u{287}\x0a\x23\x0c\x23\x0e\
	\x23\u{28a}\x0b\x23\x03\x23\x07\x23\u{28d}\x0a\x23\x0c\x23\x0e\x23\u{290}\
	\x0b\x23\x03\x23\x03\x23\x05\x23\u{294}\x0a\x23\x03\x23\x05\x23\u{297}\x0a\
	\x23\x03\x23\x05\x23\u{29a}\x0a\x23\x03\x23\x07\x23\u{29d}\x0a\x23\x0c\x23\
	\x0e\x23\u{2a0}\x0b\x23\x03\x23\x07\x23\u{2a3}\x0a\x23\x0c\x23\x0e\x23\u{2a6}\
	\x0b\x23\x03\x23\x03\x23\x05\x23\u{2aa}\x0a\x23\x03\x23\x05\x23\u{2ad}\x0a\
	\x23\x03\x23\x05\x23\u{2b0}\x0a\x23\x03\x23\x07\x23\u{2b3}\x0a\x23\x0c\x23\
	\x0e\x23\u{2b6}\x0b\x23\x03\x23\x07\x23\u{2b9}\x0a\x23\x0c\x23\x0e\x23\u{2bc}\
	\x0b\x23\x03\x23\x03\x23\x05\x23\u{2c0}\x0a\x23\x03\x23\x05\x23\u{2c3}\x0a\
	\x23\x03\x23\x03\x23\x05\x23\u{2c7}\x0a\x23\x03\x24\x03\x24\x03\x24\x03\
	\x25\x05\x25\u{2cd}\x0a\x25\x03\x25\x03\x25\x05\x25\u{2d1}\x0a\x25\x03\x25\
	\x03\x25\x03\x25\x05\x25\u{2d6}\x0a\x25\x03\x25\x05\x25\u{2d9}\x0a\x25\x03\
	\x25\x03\x25\x05\x25\u{2dd}\x0a\x25\x03\x25\x03\x25\x05\x25\u{2e1}\x0a\x25\
	\x05\x25\u{2e3}\x0a\x25\x03\x26\x03\x26\x03\x26\x03\x26\x03\x26\x03\x26\
	\x07\x26\u{2eb}\x0a\x26\x0c\x26\x0e\x26\u{2ee}\x0b\x26\x03\x26\x05\x26\u{2f1}\
	\x0a\x26\x03\x26\x03\x26\x05\x26\u{2f5}\x0a\x26\x03\x27\x03\x27\x03\x27\
	\x03\x27\x03\x27\x05\x27\u{2fc}\x0a\x27\x03\x28\x07\x28\u{2ff}\x0a\x28\x0c\
	\x28\x0e\x28\u{302}\x0b\x28\x03\x28\x03\x28\x03\x28\x05\x28\u{307}\x0a\x28\
	\x03\x28\x03\x28\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\x03\x29\
	\x07\x29\u{312}\x0a\x29\x0c\x29\x0e\x29\u{315}\x0b\x29\x03\x29\x03\x29\x03\
	\x2a\x07\x2a\u{31a}\x0a\x2a\x0c\x2a\x0e\x2a\u{31d}\x0b\x2a\x03\x2a\x03\x2a\
	\x03\x2a\x05\x2a\u{322}\x0a\x2a\x03\x2a\x03\x2a\x05\x2a\u{326}\x0a\x2a\x03\
	\x2b\x03\x2b\x05\x2b\u{32a}\x0a\x2b\x03\x2c\x03\x2c\x03\x2c\x07\x2c\u{32f}\
	\x0a\x2c\x0c\x2c\x0e\x2c\u{332}\x0b\x2c\x03\x2c\x05\x2c\u{335}\x0a\x2c\x03\
	\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x06\x2d\u{33e}\x0a\
	\x2d\x0d\x2d\x0e\x2d\u{33f}\x03\x2d\x05\x2d\u{343}\x0a\x2d\x05\x2d\u{345}\
	\x0a\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x07\x2d\u{34d}\
	\x0a\x2d\x0c\x2d\x0e\x2d\u{350}\x0b\x2d\x03\x2d\x05\x2d\u{353}\x0a\x2d\x05\
	\x2d\u{355}\x0a\x2d\x03\x2d\x03\x2d\x03\x2d\x05\x2d\u{35a}\x0a\x2d\x03\x2d\
	\x03\x2d\x03\x2d\x03\x2d\x07\x2d\u{360}\x0a\x2d\x0c\x2d\x0e\x2d\u{363}\x0b\
	\x2d\x03\x2d\x05\x2d\u{366}\x0a\x2d\x05\x2d\u{368}\x0a\x2d\x03\x2d\x03\x2d\
	\x05\x2d\u{36c}\x0a\x2d\x03\x2d\x03\x2d\x03\x2d\x03\x2d\x07\x2d\u{372}\x0a\
	\x2d\x0c\x2d\x0e\x2d\u{375}\x0b\x2d\x03\x2d\x05\x2d\u{378}\x0a\x2d\x05\x2d\
	\u{37a}\x0a\x2d\x03\x2d\x05\x2d\u{37d}\x0a\x2d\x03\x2e\x03\x2e\x03\x2e\x05\
	\x2e\u{382}\x0a\x2e\x03\x2e\x03\x2e\x03\x2e\x05\x2e\u{387}\x0a\x2e\x03\x2e\
	\x03\x2e\x03\x2e\x03\x2e\x05\x2e\u{38d}\x0a\x2e\x03\x2e\x03\x2e\x03\x2e\
	\x05\x2e\u{392}\x0a\x2e\x03\x2e\x03\x2e\x05\x2e\u{396}\x0a\x2e\x03\x2e\x03\
	\x2e\x05\x2e\u{39a}\x0a\x2e\x03\x2e\x05\x2e\u{39d}\x0a\x2e\x03\x2f\x07\x2f\
	\u{3a0}\x0a\x2f\x0c\x2f\x0e\x2f\u{3a3}\x0b\x2f\x03\x2f\x03\x2f\x03\x2f\x03\
	\x2f\x05\x2f\u{3a9}\x0a\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\x07\x2f\u{3af}\
	\x0a\x2f\x0c\x2f\x0e\x2f\u{3b2}\x0b\x2f\x03\x2f\x03\x2f\x03\x2f\x03\x2f\
	\x05\x2f\u{3b8}\x0a\x2f\x03\x2f\x03\x2f\x05\x2f\u{3bc}\x0a\x2f\x03\x30\x03\
	\x30\x03\x30\x03\x31\x03\x31\x03\x31\x03\x32\x07\x32\u{3c5}\x0a\x32\x0c\
	\x32\x0e\x32\u{3c8}\x0b\x32\x03\x32\x03\x32\x03\x32\x03\x32\x07\x32\u{3ce}\
	\x0a\x32\x0c\x32\x0e\x32\u{3d1}\x0b\x32\x03\x32\x03\x32\x05\x32\u{3d5}\x0a\
	\x32\x03\x33\x07\x33\u{3d8}\x0a\x33\x0c\x33\x0e\x33\u{3db}\x0b\x33\x03\x33\
	\x03\x33\x03\x33\x03\x33\x03\x33\x05\x33\u{3e2}\x0a\x33\x03\x33\x03\x33\
	\x03\x33\x03\x33\x03\x33\x07\x33\u{3e9}\x0a\x33\x0c\x33\x0e\x33\u{3ec}\x0b\
	\x33\x03\x33\x03\x33\x03\x33\x03\x33\x03\x33\x05\x33\u{3f3}\x0a\x33\x03\
	\x34\x03\x34\x03\x34\x03\x34\x03\x34\x03\x35\x07\x35\u{3fb}\x0a\x35\x0c\
	\x35\x0e\x35\u{3fe}\x0b\x35\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x07\
	\x35\u{405}\x0a\x35\x0c\x35\x0e\x35\u{408}\x0b\x35\x03\x35\x03\x35\x03\x35\
	\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x07\x35\u{412}\x0a\x35\x0c\x35\
	\x0e\x35\u{415}\x0b\x35\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\x03\x35\
	\x05\x35\u{41d}\x0a\x35\x03\x35\x03\x35\x05\x35\u{421}\x0a\x35\x03\x36\x03\
	\x36\x03\x36\x03\x37\x07\x37\u{427}\x0a\x37\x0c\x37\x0e\x37\u{42a}\x0b\x37\
	\x03\x37\x03\x37\x05\x37\u{42e}\x0a\x37\x03\x37\x05\x37\u{431}\x0a\x37\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x05\x38\u{450}\x0a\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x05\x38\u{484}\x0a\x38\x03\x38\x05\x38\u{487}\x0a\x38\x03\x38\x03\x38\
	\x03\x38\x05\x38\u{48c}\x0a\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\
	\x05\x38\u{493}\x0a\x38\x05\x38\u{495}\x0a\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x07\
	\x38\u{4a3}\x0a\x38\x0c\x38\x0e\x38\u{4a6}\x0b\x38\x03\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x05\x39\u{4bb}\
	\x0a\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x07\x39\u{4e3}\x0a\x39\x0c\x39\x0e\x39\u{4e6}\x0b\
	\x39\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\
	\x3a\x03\x3a\x03\x3a\x06\x3a\u{4f3}\x0a\x3a\x0d\x3a\x0e\x3a\u{4f4}\x03\x3a\
	\x05\x3a\u{4f8}\x0a\x3a\x05\x3a\u{4fa}\x0a\x3a\x03\x3a\x03\x3a\x05\x3a\u{4fe}\
	\x0a\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\
	\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x07\x3a\u{50f}\
	\x0a\x3a\x0c\x3a\x0e\x3a\u{512}\x0b\x3a\x03\x3b\x03\x3b\x03\x3b\x03\x3b\
	\x03\x3b\x03\x3b\x05\x3b\u{51a}\x0a\x3b\x03\x3c\x03\x3c\x03\x3c\x05\x3c\
	\u{51f}\x0a\x3c\x05\x3c\u{521}\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{526}\
	\x0a\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{52b}\x0a\x3c\x03\x3c\x03\x3c\
	\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{532}\x0a\x3c\x03\x3c\x05\x3c\u{535}\x0a\
	\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{53c}\x0a\x3c\x03\
	\x3d\x03\x3d\x03\x3e\x03\x3e\x03\x3f\x03\x3f\x03\x40\x03\x40\x03\x41\x03\
	\x41\x03\x42\x03\x42\x03\x43\x03\x43\x03\x44\x03\x44\x03\x45\x03\x45\x03\
	\x46\x03\x46\x03\x47\x03\x47\x03\x48\x03\x48\x03\x49\x03\x49\x03\x4a\x03\
	\x4a\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x05\x4a\u{55e}\x0a\x4a\x03\x4b\x03\
	\x4b\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x05\x4c\u{567}\x0a\x4c\x03\
	\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x07\x4d\u{56f}\x0a\x4d\x0c\
	\x4d\x0e\x4d\u{572}\x0b\x4d\x03\x4d\x05\x4d\u{575}\x0a\x4d\x03\x4d\x03\x4d\
	\x03\x4d\x05\x4d\u{57a}\x0a\x4d\x03\x4d\x03\x4d\x03\x4d\x05\x4d\u{57f}\x0a\
	\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x07\x4d\u{585}\x0a\x4d\x0c\x4d\x0e\
	\x4d\u{588}\x0b\x4d\x03\x4d\x05\x4d\u{58b}\x0a\x4d\x03\x4d\x03\x4d\x05\x4d\
	\u{58f}\x0a\x4d\x03\x4e\x03\x4e\x03\x4e\x05\x4e\u{594}\x0a\x4e\x03\x4e\x03\
	\x4e\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x07\
	\x4f\u{5a0}\x0a\x4f\x0c\x4f\x0e\x4f\u{5a3}\x0b\x4f\x03\x4f\x05\x4f\u{5a6}\
	\x0a\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\
	\x07\x4f\u{5b0}\x0a\x4f\x0c\x4f\x0e\x4f\u{5b3}\x0b\x4f\x03\x4f\x05\x4f\u{5b6}\
	\x0a\x4f\x03\x4f\x03\x4f\x05\x4f\u{5ba}\x0a\x4f\x03\x50\x05\x50\u{5bd}\x0a\
	\x50\x03\x50\x03\x50\x03\x50\x03\x50\x07\x50\u{5c3}\x0a\x50\x0c\x50\x0e\
	\x50\u{5c6}\x0b\x50\x03\x50\x03\x50\x03\x50\x03\x50\x03\x50\x03\x50\x07\
	\x50\u{5ce}\x0a\x50\x0c\x50\x0e\x50\u{5d1}\x0b\x50\x03\x50\x03\x50\x05\x50\
	\u{5d5}\x0a\x50\x03\x51\x03\x51\x03\x51\x05\x51\u{5da}\x0a\x51\x03\x51\x03\
	\x51\x03\x52\x03\x52\x03\x52\x03\x53\x07\x53\u{5e2}\x0a\x53\x0c\x53\x0e\
	\x53\u{5e5}\x0b\x53\x03\x53\x03\x53\x03\x53\x03\x53\x03\x53\x07\x53\u{5ec}\
	\x0a\x53\x0c\x53\x0e\x53\u{5ef}\x0b\x53\x03\x53\x03\x53\x03\x53\x03\x53\
	\x03\x53\x07\x53\u{5f6}\x0a\x53\x0c\x53\x0e\x53\u{5f9}\x0b\x53\x03\x53\x05\
	\x53\u{5fc}\x0a\x53\x03\x53\x03\x53\x05\x53\u{600}\x0a\x53\x03\x54\x03\x54\
	\x03\x54\x07\x54\u{605}\x0a\x54\x0c\x54\x0e\x54\u{608}\x0b\x54\x03\x54\x03\
	\x54\x03\x55\x03\x55\x03\x55\x03\x55\x03\x55\x03\x55\x03\x55\x05\x55\u{613}\
	\x0a\x55\x03\x56\x03\x56\x07\x56\u{617}\x0a\x56\x0c\x56\x0e\x56\u{61a}\x0b\
	\x56\x03\x56\x03\x56\x03\x57\x03\x57\x03\x57\x03\x57\x03\x57\x05\x57\u{623}\
	\x0a\x57\x03\x58\x03\x58\x03\x58\x07\x58\u{628}\x0a\x58\x0c\x58\x0e\x58\
	\u{62b}\x0b\x58\x03\x58\x03\x58\x03\x59\x03\x59\x03\x59\x05\x59\u{632}\x0a\
	\x59\x03\x59\x03\x59\x03\x59\x03\x59\x03\x59\x07\x59\u{639}\x0a\x59\x0c\
	\x59\x0e\x59\u{63c}\x0b\x59\x03\x59\x03\x59\x05\x59\u{640}\x0a\x59\x05\x59\
	\u{642}\x0a\x59\x03\x5a\x03\x5a\x03\x5a\x05\x5a\u{647}\x0a\x5a\x03\x5a\x03\
	\x5a\x03\x5a\x03\x5a\x03\x5a\x07\x5a\u{64e}\x0a\x5a\x0c\x5a\x0e\x5a\u{651}\
	\x0b\x5a\x03\x5a\x03\x5a\x05\x5a\u{655}\x0a\x5a\x05\x5a\u{657}\x0a\x5a\x03\
	\x5b\x03\x5b\x05\x5b\u{65b}\x0a\x5b\x03\x5b\x05\x5b\u{65e}\x0a\x5b\x03\x5c\
	\x07\x5c\u{661}\x0a\x5c\x0c\x5c\x0e\x5c\u{664}\x0b\x5c\x03\x5c\x03\x5c\x05\
	\x5c\u{668}\x0a\x5c\x03\x5c\x03\x5c\x03\x5d\x07\x5d\u{66d}\x0a\x5d\x0c\x5d\
	\x0e\x5d\u{670}\x0b\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x05\x5d\u{676}\x0a\
	\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5e\x03\x5e\x03\x5e\x07\x5e\u{67e}\x0a\
	\x5e\x0c\x5e\x0e\x5e\u{681}\x0b\x5e\x03\x5e\x03\x5e\x03\x5f\x07\x5f\u{686}\
	\x0a\x5f\x0c\x5f\x0e\x5f\u{689}\x0b\x5f\x03\x5f\x03\x5f\x03\x5f\x07\x5f\
	\u{68e}\x0a\x5f\x0c\x5f\x0e\x5f\u{691}\x0b\x5f\x03\x5f\x03\x5f\x03\x5f\x03\
	\x5f\x03\x5f\x07\x5f\u{698}\x0a\x5f\x0c\x5f\x0e\x5f\u{69b}\x0b\x5f\x03\x5f\
	\x05\x5f\u{69e}\x0a\x5f\x05\x5f\u{6a0}\x0a\x5f\x03\x5f\x03\x5f\x07\x5f\u{6a4}\
	\x0a\x5f\x0c\x5f\x0e\x5f\u{6a7}\x0b\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\
	\x05\x5f\u{6ad}\x0a\x5f\x03\x5f\x03\x5f\x03\x5f\x07\x5f\u{6b2}\x0a\x5f\x0c\
	\x5f\x0e\x5f\u{6b5}\x0b\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x07\
	\x5f\u{6bc}\x0a\x5f\x0c\x5f\x0e\x5f\u{6bf}\x0b\x5f\x03\x5f\x03\x5f\x03\x5f\
	\x07\x5f\u{6c4}\x0a\x5f\x0c\x5f\x0e\x5f\u{6c7}\x0b\x5f\x03\x5f\x03\x5f\x03\
	\x5f\x03\x5f\x05\x5f\u{6cd}\x0a\x5f\x03\x5f\x03\x5f\x05\x5f\u{6d1}\x0a\x5f\
	\x03\x60\x03\x60\x07\x60\u{6d5}\x0a\x60\x0c\x60\x0e\x60\u{6d8}\x0b\x60\x03\
	\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x07\
	\x61\u{6e3}\x0a\x61\x0c\x61\x0e\x61\u{6e6}\x0b\x61\x03\x62\x03\x62\x03\x62\
	\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x05\x62\u{6f2}\
	\x0a\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x05\x62\
	\u{6fb}\x0a\x62\x03\x63\x05\x63\u{6fe}\x0a\x63\x03\x63\x03\x63\x03\x63\x05\
	\x63\u{703}\x0a\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{708}\x0a\x63\x03\x63\
	\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\
	\x03\x63\x06\x63\u{715}\x0a\x63\x0d\x63\x0e\x63\u{716}\x03\x63\x05\x63\u{71a}\
	\x0a\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x07\x63\
	\u{723}\x0a\x63\x0c\x63\x0e\x63\u{726}\x0b\x63\x03\x63\x05\x63\u{729}\x0a\
	\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{72e}\x0a\x63\x03\x63\x03\x63\x03\
	\x63\x03\x63\x07\x63\u{734}\x0a\x63\x0c\x63\x0e\x63\u{737}\x0b\x63\x03\x63\
	\x05\x63\u{73a}\x0a\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{73f}\x0a\x63\x03\
	\x63\x03\x63\x03\x63\x03\x63\x07\x63\u{745}\x0a\x63\x0c\x63\x0e\x63\u{748}\
	\x0b\x63\x03\x63\x05\x63\u{74b}\x0a\x63\x03\x63\x03\x63\x05\x63\u{74f}\x0a\
	\x63\x03\x64\x03\x64\x05\x64\u{753}\x0a\x64\x03\x64\x05\x64\u{756}\x0a\x64\
	\x03\x64\x05\x64\u{759}\x0a\x64\x03\x64\x03\x64\x03\x65\x03\x65\x03\x65\
	\x05\x65\u{760}\x0a\x65\x03\x65\x05\x65\u{763}\x0a\x65\x03\x65\x03\x65\x03\
	\x65\x03\x65\x03\x65\x05\x65\u{76a}\x0a\x65\x03\x65\x03\x65\x05\x65\u{76e}\
	\x0a\x65\x03\x66\x05\x66\u{771}\x0a\x66\x03\x66\x03\x66\x05\x66\u{775}\x0a\
	\x66\x03\x67\x03\x67\x03\x67\x07\x67\u{77a}\x0a\x67\x0c\x67\x0e\x67\u{77d}\
	\x0b\x67\x03\x67\x03\x67\x03\x68\x03\x68\x03\x68\x03\x68\x03\x68\x03\x68\
	\x06\x68\u{787}\x0a\x68\x0d\x68\x0e\x68\u{788}\x03\x68\x05\x68\u{78c}\x0a\
	\x68\x03\x68\x03\x68\x03\x68\x03\x68\x03\x68\x03\x68\x03\x68\x05\x68\u{795}\
	\x0a\x68\x03\x69\x03\x69\x03\x69\x05\x69\u{79a}\x0a\x69\x03\x69\x03\x69\
	\x03\x6a\x05\x6a\u{79f}\x0a\x6a\x03\x6a\x03\x6a\x03\x6b\x03\x6b\x03\x6b\
	\x03\x6b\x07\x6b\u{7a7}\x0a\x6b\x0c\x6b\x0e\x6b\u{7aa}\x0b\x6b\x03\x6b\x05\
	\x6b\u{7ad}\x0a\x6b\x05\x6b\u{7af}\x0a\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\
	\x03\x6b\x07\x6b\u{7b6}\x0a\x6b\x0c\x6b\x0e\x6b\u{7b9}\x0b\x6b\x03\x6b\x05\
	\x6b\u{7bc}\x0a\x6b\x05\x6b\u{7be}\x0a\x6b\x03\x6b\x05\x6b\u{7c1}\x0a\x6b\
	\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x05\x6c\u{7d1}\x0a\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x05\x6c\u{7d7}\x0a\x6c\x03\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x05\x6c\u{7e0}\x0a\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x05\x6c\u{7f1}\x0a\x6c\x03\x6c\x03\x6c\
	\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x05\x6c\u{7fb}\x0a\x6c\
	\x03\x6d\x07\x6d\u{7fe}\x0a\x6d\x0c\x6d\x0e\x6d\u{801}\x0b\x6d\x03\x6e\x07\
	\x6e\u{804}\x0a\x6e\x0c\x6e\x0e\x6e\u{807}\x0b\x6e\x03\x6e\x03\x6e\x03\x6f\
	\x07\x6f\u{80c}\x0a\x6f\x0c\x6f\x0e\x6f\u{80f}\x0b\x6f\x03\x6f\x03\x6f\x03\
	\x6f\x07\x6f\u{814}\x0a\x6f\x0c\x6f\x0e\x6f\u{817}\x0b\x6f\x03\x70\x03\x70\
	\x03\x70\x05\x70\u{81c}\x0a\x70\x03\x71\x03\x71\x03\x71\x03\x72\x03\x72\
	\x03\x72\x07\x72\u{824}\x0a\x72\x0c\x72\x0e\x72\u{827}\x0b\x72\x03\x73\x03\
	\x73\x03\x73\x07\x73\u{82c}\x0a\x73\x0c\x73\x0e\x73\u{82f}\x0b\x73\x03\x74\
	\x03\x74\x03\x75\x03\x75\x03\x76\x03\x76\x05\x76\u{837}\x0a\x76\x03\x77\
	\x03\x77\x03\x78\x05\x78\u{83c}\x0a\x78\x03\x78\x03\x78\x05\x78\u{840}\x0a\
	\x78\x03\x78\x03\x78\x05\x78\u{844}\x0a\x78\x03\x78\x05\x78\u{847}\x0a\x78\
	\x03\x78\x02\x06\x6e\x70\x72\u{c0}\x79\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\
	\x14\x16\x18\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\
	\x38\x3a\x3c\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\
	\x5c\x5e\x60\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\
	\u{80}\u{82}\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\
	\u{98}\u{9a}\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\
	\u{b0}\u{b2}\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\
	\u{c8}\u{ca}\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\
	\u{e0}\u{e2}\u{e4}\u{e6}\u{e8}\u{ea}\u{ec}\u{ee}\x02\x1b\x03\x02\x06\x07\
	\x03\x02\x05\x07\x03\x02\x4e\x4f\x04\x02\x04\x04\x08\x08\x04\x02\x09\x09\
	\x77\x77\x04\x02\x09\x09\x34\x34\x04\x02\x57\x57\x7a\x7a\x03\x02\u{81}\u{82}\
	\x09\x02\x1c\x1d\x20\x20\x47\x47\x56\x56\x60\x61\x64\x67\x6b\x6b\x07\x02\
	\x1e\x1f\x22\x22\x53\x53\x56\x56\x68\x6a\x05\x02\x25\x29\x2d\x2e\x32\x32\
	\x03\x02\x47\x48\x03\x02\x4b\x4d\x04\x02\x63\x63\x65\x65\x03\x02\x34\x35\
	\x03\x02\x20\x23\x03\x02\x1c\x1d\x03\x02\x3f\x44\x05\x02\x2a\x2c\x30\x31\
	\x36\x36\x05\x02\x2f\x2f\x37\x37\x39\x3d\x04\x02\x1c\x1c\x48\x48\x04\x02\
	\x22\x22\x24\x24\x03\x02\u{95}\u{96}\x03\x02\u{86}\u{87}\x03\x02\u{88}\u{89}\
	\x02\u{986}\x02\u{101}\x03\x02\x02\x02\x04\u{106}\x03\x02\x02\x02\x06\u{108}\
	\x03\x02\x02\x02\x08\u{10a}\x03\x02\x02\x02\x0a\u{10f}\x03\x02\x02\x02\x0c\
	\u{112}\x03\x02\x02\x02\x0e\u{13f}\x03\x02\x02\x02\x10\u{141}\x03\x02\x02\
	\x02\x12\u{156}\x03\x02\x02\x02\x14\u{158}\x03\x02\x02\x02\x16\u{15b}\x03\
	\x02\x02\x02\x18\u{173}\x03\x02\x02\x02\x1a\u{18f}\x03\x02\x02\x02\x1c\u{191}\
	\x03\x02\x02\x02\x1e\u{196}\x03\x02\x02\x02\x20\u{1a3}\x03\x02\x02\x02\x22\
	\u{1b7}\x03\x02\x02\x02\x24\u{1be}\x03\x02\x02\x02\x26\u{1d3}\x03\x02\x02\
	\x02\x28\u{1df}\x03\x02\x02\x02\x2a\u{1e6}\x03\x02\x02\x02\x2c\u{1f9}\x03\
	\x02\x02\x02\x2e\u{204}\x03\x02\x02\x02\x30\u{20a}\x03\x02\x02\x02\x32\u{218}\
	\x03\x02\x02\x02\x34\u{21e}\x03\x02\x02\x02\x36\u{229}\x03\x02\x02\x02\x38\
	\u{22d}\x03\x02\x02\x02\x3a\u{23a}\x03\x02\x02\x02\x3c\u{248}\x03\x02\x02\
	\x02\x3e\u{256}\x03\x02\x02\x02\x40\u{25f}\x03\x02\x02\x02\x42\u{283}\x03\
	\x02\x02\x02\x44\u{2c6}\x03\x02\x02\x02\x46\u{2c8}\x03\x02\x02\x02\x48\u{2e2}\
	\x03\x02\x02\x02\x4a\u{2f4}\x03\x02\x02\x02\x4c\u{2fb}\x03\x02\x02\x02\x4e\
	\u{300}\x03\x02\x02\x02\x50\u{30a}\x03\x02\x02\x02\x52\u{31b}\x03\x02\x02\
	\x02\x54\u{329}\x03\x02\x02\x02\x56\u{32b}\x03\x02\x02\x02\x58\u{37c}\x03\
	\x02\x02\x02\x5a\u{39c}\x03\x02\x02\x02\x5c\u{3bb}\x03\x02\x02\x02\x5e\u{3bd}\
	\x03\x02\x02\x02\x60\u{3c0}\x03\x02\x02\x02\x62\u{3c6}\x03\x02\x02\x02\x64\
	\u{3f2}\x03\x02\x02\x02\x66\u{3f4}\x03\x02\x02\x02\x68\u{420}\x03\x02\x02\
	\x02\x6a\u{422}\x03\x02\x02\x02\x6c\u{428}\x03\x02\x02\x02\x6e\u{44f}\x03\
	\x02\x02\x02\x70\u{4ba}\x03\x02\x02\x02\x72\u{4fd}\x03\x02\x02\x02\x74\u{519}\
	\x03\x02\x02\x02\x76\u{53b}\x03\x02\x02\x02\x78\u{53d}\x03\x02\x02\x02\x7a\
	\u{53f}\x03\x02\x02\x02\x7c\u{541}\x03\x02\x02\x02\x7e\u{543}\x03\x02\x02\
	\x02\u{80}\u{545}\x03\x02\x02\x02\u{82}\u{547}\x03\x02\x02\x02\u{84}\u{549}\
	\x03\x02\x02\x02\u{86}\u{54b}\x03\x02\x02\x02\u{88}\u{54d}\x03\x02\x02\x02\
	\u{8a}\u{54f}\x03\x02\x02\x02\u{8c}\u{551}\x03\x02\x02\x02\u{8e}\u{553}\
	\x03\x02\x02\x02\u{90}\u{555}\x03\x02\x02\x02\u{92}\u{55d}\x03\x02\x02\x02\
	\u{94}\u{55f}\x03\x02\x02\x02\u{96}\u{566}\x03\x02\x02\x02\u{98}\u{58e}\
	\x03\x02\x02\x02\u{9a}\u{593}\x03\x02\x02\x02\u{9c}\u{5b9}\x03\x02\x02\x02\
	\u{9e}\u{5d4}\x03\x02\x02\x02\u{a0}\u{5d9}\x03\x02\x02\x02\u{a2}\u{5dd}\
	\x03\x02\x02\x02\u{a4}\u{5ff}\x03\x02\x02\x02\u{a6}\u{601}\x03\x02\x02\x02\
	\u{a8}\u{612}\x03\x02\x02\x02\u{aa}\u{614}\x03\x02\x02\x02\u{ac}\u{622}\
	\x03\x02\x02\x02\u{ae}\u{624}\x03\x02\x02\x02\u{b0}\u{641}\x03\x02\x02\x02\
	\u{b2}\u{656}\x03\x02\x02\x02\u{b4}\u{658}\x03\x02\x02\x02\u{b6}\u{662}\
	\x03\x02\x02\x02\u{b8}\u{66e}\x03\x02\x02\x02\u{ba}\u{67a}\x03\x02\x02\x02\
	\u{bc}\u{6d0}\x03\x02\x02\x02\u{be}\u{6d2}\x03\x02\x02\x02\u{c0}\u{6d9}\
	\x03\x02\x02\x02\u{c2}\u{6fa}\x03\x02\x02\x02\u{c4}\u{74e}\x03\x02\x02\x02\
	\u{c6}\u{750}\x03\x02\x02\x02\u{c8}\u{76d}\x03\x02\x02\x02\u{ca}\u{774}\
	\x03\x02\x02\x02\u{cc}\u{776}\x03\x02\x02\x02\u{ce}\u{794}\x03\x02\x02\x02\
	\u{d0}\u{799}\x03\x02\x02\x02\u{d2}\u{79e}\x03\x02\x02\x02\u{d4}\u{7c0}\
	\x03\x02\x02\x02\u{d6}\u{7fa}\x03\x02\x02\x02\u{d8}\u{7ff}\x03\x02\x02\x02\
	\u{da}\u{805}\x03\x02\x02\x02\u{dc}\u{80d}\x03\x02\x02\x02\u{de}\u{818}\
	\x03\x02\x02\x02\u{e0}\u{81d}\x03\x02\x02\x02\u{e2}\u{820}\x03\x02\x02\x02\
	\u{e4}\u{828}\x03\x02\x02\x02\u{e6}\u{830}\x03\x02\x02\x02\u{e8}\u{832}\
	\x03\x02\x02\x02\u{ea}\u{834}\x03\x02\x02\x02\u{ec}\u{838}\x03\x02\x02\x02\
	\u{ee}\u{846}\x03\x02\x02\x02\u{f0}\u{100}\x05\x08\x05\x02\u{f1}\u{100}\
	\x05\x0a\x06\x02\u{f2}\u{100}\x05\x14\x0b\x02\u{f3}\u{100}\x05\x16\x0c\x02\
	\u{f4}\u{100}\x05\x30\x19\x02\u{f5}\u{100}\x05\x3a\x1e\x02\u{f6}\u{100}\
	\x05\x24\x13\x02\u{f7}\u{100}\x05\x2a\x16\x02\u{f8}\u{100}\x05\x40\x21\x02\
	\u{f9}\u{100}\x05\x5c\x2f\x02\u{fa}\u{100}\x05\x52\x2a\x02\u{fb}\u{100}\
	\x05\x68\x35\x02\u{fc}\u{100}\x05\x64\x33\x02\u{fd}\u{100}\x05\x6c\x37\x02\
	\u{fe}\u{100}\x05\x04\x03\x02\u{ff}\u{f0}\x03\x02\x02\x02\u{ff}\u{f1}\x03\
	\x02\x02\x02\u{ff}\u{f2}\x03\x02\x02\x02\u{ff}\u{f3}\x03\x02\x02\x02\u{ff}\
	\u{f4}\x03\x02\x02\x02\u{ff}\u{f5}\x03\x02\x02\x02\u{ff}\u{f6}\x03\x02\x02\
	\x02\u{ff}\u{f7}\x03\x02\x02\x02\u{ff}\u{f8}\x03\x02\x02\x02\u{ff}\u{f9}\
	\x03\x02\x02\x02\u{ff}\u{fa}\x03\x02\x02\x02\u{ff}\u{fb}\x03\x02\x02\x02\
	\u{ff}\u{fc}\x03\x02\x02\x02\u{ff}\u{fd}\x03\x02\x02\x02\u{ff}\u{fe}\x03\
	\x02\x02\x02\u{100}\u{103}\x03\x02\x02\x02\u{101}\u{ff}\x03\x02\x02\x02\
	\u{101}\u{102}\x03\x02\x02\x02\u{102}\u{104}\x03\x02\x02\x02\u{103}\u{101}\
	\x03\x02\x02\x02\u{104}\u{105}\x07\x02\x02\x03\u{105}\x03\x03\x02\x02\x02\
	\u{106}\u{107}\x09\x02\x02\x02\u{107}\x05\x03\x02\x02\x02\u{108}\u{109}\
	\x09\x03\x02\x02\u{109}\x07\x03\x02\x02\x02\u{10a}\u{10b}\x07\x6d\x02\x02\
	\u{10b}\u{10d}\x05\u{e2}\x72\x02\u{10c}\u{10e}\x05\x04\x03\x02\u{10d}\u{10c}\
	\x03\x02\x02\x02\u{10d}\u{10e}\x03\x02\x02\x02\u{10e}\x09\x03\x02\x02\x02\
	\u{10f}\u{110}\x07\x6e\x02\x02\u{110}\u{111}\x05\x0e\x08\x02\u{111}\x0b\
	\x03\x02\x02\x02\u{112}\u{114}\x07\x5f\x02\x02\u{113}\u{115}\x09\x04\x02\
	\x02\u{114}\u{113}\x03\x02\x02\x02\u{114}\u{115}\x03\x02\x02\x02\u{115}\
	\u{116}\x03\x02\x02\x02\u{116}\u{117}\x05\u{e6}\x74\x02\u{117}\x0d\x03\x02\
	\x02\x02\u{118}\u{140}\x05\x12\x0a\x02\u{119}\u{11a}\x07\x4e\x02\x02\u{11a}\
	\u{11c}\x05\x10\x09\x02\u{11b}\u{11d}\x05\x0c\x07\x02\u{11c}\u{11b}\x03\
	\x02\x02\x02\u{11c}\u{11d}\x03\x02\x02\x02\u{11d}\u{140}\x03\x02\x02\x02\
	\u{11e}\u{11f}\x07\x4e\x02\x02\u{11f}\u{124}\x05\x10\x09\x02\u{120}\u{122}\
	\x09\x05\x02\x02\u{121}\u{120}\x03\x02\x02\x02\u{121}\u{122}\x03\x02\x02\
	\x02\u{122}\u{123}\x03\x02\x02\x02\u{123}\u{125}\x05\x12\x0a\x02\u{124}\
	\u{121}\x03\x02\x02\x02\u{124}\u{125}\x03\x02\x02\x02\u{125}\u{140}\x03\
	\x02\x02\x02\u{126}\u{127}\x07\x4f\x02\x02\u{127}\u{129}\x05\x10\x09\x02\
	\u{128}\u{12a}\x05\x0c\x07\x02\u{129}\u{128}\x03\x02\x02\x02\u{129}\u{12a}\
	\x03\x02\x02\x02\u{12a}\u{140}\x03\x02\x02\x02\u{12b}\u{12c}\x07\x4f\x02\
	\x02\u{12c}\u{131}\x05\x10\x09\x02\u{12d}\u{12f}\x09\x05\x02\x02\u{12e}\
	\u{12d}\x03\x02\x02\x02\u{12e}\u{12f}\x03\x02\x02\x02\u{12f}\u{130}\x03\
	\x02\x02\x02\u{130}\u{132}\x05\x12\x0a\x02\u{131}\u{12e}\x03\x02\x02\x02\
	\u{131}\u{132}\x03\x02\x02\x02\u{132}\u{140}\x03\x02\x02\x02\u{133}\u{135}\
	\x05\x10\x09\x02\u{134}\u{136}\x05\x0c\x07\x02\u{135}\u{134}\x03\x02\x02\
	\x02\u{135}\u{136}\x03\x02\x02\x02\u{136}\u{140}\x03\x02\x02\x02\u{137}\
	\u{13c}\x05\x10\x09\x02\u{138}\u{13a}\x09\x05\x02\x02\u{139}\u{138}\x03\
	\x02\x02\x02\u{139}\u{13a}\x03\x02\x02\x02\u{13a}\u{13b}\x03\x02\x02\x02\
	\u{13b}\u{13d}\x05\x12\x0a\x02\u{13c}\u{139}\x03\x02\x02\x02\u{13c}\u{13d}\
	\x03\x02\x02\x02\u{13d}\u{140}\x03\x02\x02\x02\u{13e}\u{140}\x05\x06\x04\
	\x02\u{13f}\u{118}\x03\x02\x02\x02\u{13f}\u{119}\x03\x02\x02\x02\u{13f}\
	\u{11e}\x03\x02\x02\x02\u{13f}\u{126}\x03\x02\x02\x02\u{13f}\u{12b}\x03\
	\x02\x02\x02\u{13f}\u{133}\x03\x02\x02\x02\u{13f}\u{137}\x03\x02\x02\x02\
	\u{13f}\u{13e}\x03\x02\x02\x02\u{140}\x0f\x03\x02\x02\x02\u{141}\u{146}\
	\x05\u{e6}\x74\x02\u{142}\u{143}\x09\x05\x02\x02\u{143}\u{145}\x05\u{e6}\
	\x74\x02\u{144}\u{142}\x03\x02\x02\x02\u{145}\u{148}\x03\x02\x02\x02\u{146}\
	\u{144}\x03\x02\x02\x02\u{146}\u{147}\x03\x02\x02\x02\u{147}\u{149}\x03\
	\x02\x02\x02\u{148}\u{146}\x03\x02\x02\x02\u{149}\u{14a}\x09\x05\x02\x02\
	\u{14a}\u{14b}\x07\x20\x02\x02\u{14b}\x11\x03\x02\x02\x02\u{14c}\u{14d}\
	\x07\x0e\x02\x02\u{14d}\u{157}\x07\x0f\x02\x02\u{14e}\u{152}\x07\x0e\x02\
	\x02\u{14f}\u{151}\x05\x0e\x08\x02\u{150}\u{14f}\x03\x02\x02\x02\u{151}\
	\u{154}\x03\x02\x02\x02\u{152}\u{150}\x03\x02\x02\x02\u{152}\u{153}\x03\
	\x02\x02\x02\u{153}\u{155}\x03\x02\x02\x02\u{154}\u{152}\x03\x02\x02\x02\
	\u{155}\u{157}\x07\x0f\x02\x02\u{156}\u{14c}\x03\x02\x02\x02\u{156}\u{14e}\
	\x03\x02\x02\x02\u{157}\x13\x03\x02\x02\x02\u{158}\u{159}\x07\x6f\x02\x02\
	\u{159}\x15\x03\x02\x02\x02\u{15a}\u{15c}\x05\u{a4}\x53\x02\u{15b}\u{15a}\
	\x03\x02\x02\x02\u{15b}\u{15c}\x03\x02\x02\x02\u{15c}\u{160}\x03\x02\x02\
	\x02\u{15d}\u{15f}\x05\u{b2}\x5a\x02\u{15e}\u{15d}\x03\x02\x02\x02\u{15f}\
	\u{162}\x03\x02\x02\x02\u{160}\u{15e}\x03\x02\x02\x02\u{160}\u{161}\x03\
	\x02\x02\x02\u{161}\u{163}\x03\x02\x02\x02\u{162}\u{160}\x03\x02\x02\x02\
	\u{163}\u{164}\x05\u{d8}\x6d\x02\u{164}\u{165}\x07\x70\x02\x02\u{165}\u{167}\
	\x05\u{e6}\x74\x02\u{166}\u{168}\x05\u{98}\x4d\x02\u{167}\u{166}\x03\x02\
	\x02\x02\u{167}\u{168}\x03\x02\x02\x02\u{168}\u{16a}\x03\x02\x02\x02\u{169}\
	\u{16b}\x05\x1a\x0e\x02\u{16a}\u{169}\x03\x02\x02\x02\u{16a}\u{16b}\x03\
	\x02\x02\x02\u{16b}\u{16d}\x03\x02\x02\x02\u{16c}\u{16e}\x05\x5e\x30\x02\
	\u{16d}\u{16c}\x03\x02\x02\x02\u{16d}\u{16e}\x03\x02\x02\x02\u{16e}\u{16f}\
	\x03\x02\x02\x02\u{16f}\u{171}\x05\x18\x0d\x02\u{170}\u{172}\x05\x04\x03\
	\x02\u{171}\u{170}\x03\x02\x02\x02\u{171}\u{172}\x03\x02\x02\x02\u{172}\
	\x17\x03\x02\x02\x02\u{173}\u{17a}\x07\x0e\x02\x02\u{174}\u{179}\x05\x22\
	\x12\x02\u{175}\u{179}\x05\x20\x11\x02\u{176}\u{179}\x05\x1e\x10\x02\u{177}\
	\u{179}\x05\x06\x04\x02\u{178}\u{174}\x03\x02\x02\x02\u{178}\u{175}\x03\
	\x02\x02\x02\u{178}\u{176}\x03\x02\x02\x02\u{178}\u{177}\x03\x02\x02\x02\
	\u{179}\u{17c}\x03\x02\x02\x02\u{17a}\u{178}\x03\x02\x02\x02\u{17a}\u{17b}\
	\x03\x02\x02\x02\u{17b}\u{17d}\x03\x02\x02\x02\u{17c}\u{17a}\x03\x02\x02\
	\x02\u{17d}\u{17e}\x07\x0f\x02\x02\u{17e}\x19\x03\x02\x02\x02\u{17f}\u{180}\
	\x07\x0a\x02\x02\u{180}\u{190}\x07\x0b\x02\x02\u{181}\u{182}\x07\x0a\x02\
	\x02\u{182}\u{187}\x05\x1c\x0f\x02\u{183}\u{184}\x07\x05\x02\x02\u{184}\
	\u{186}\x05\x1c\x0f\x02\u{185}\u{183}\x03\x02\x02\x02\u{186}\u{189}\x03\
	\x02\x02\x02\u{187}\u{185}\x03\x02\x02\x02\u{187}\u{188}\x03\x02\x02\x02\
	\u{188}\u{18b}\x03\x02\x02\x02\u{189}\u{187}\x03\x02\x02\x02\u{18a}\u{18c}\
	\x07\x05\x02\x02\u{18b}\u{18a}\x03\x02\x02\x02\u{18b}\u{18c}\x03\x02\x02\
	\x02\u{18c}\u{18d}\x03\x02\x02\x02\u{18d}\u{18e}\x07\x0b\x02\x02\u{18e}\
	\u{190}\x03\x02\x02\x02\u{18f}\u{17f}\x03\x02\x02\x02\u{18f}\u{181}\x03\
	\x02\x02\x02\u{190}\x1b\x03\x02\x02\x02\u{191}\u{192}\x05\u{dc}\x6f\x02\
	\u{192}\x1d\x03\x02\x02\x02\u{193}\u{195}\x05\u{b2}\x5a\x02\u{194}\u{193}\
	\x03\x02\x02\x02\u{195}\u{198}\x03\x02\x02\x02\u{196}\u{194}\x03\x02\x02\
	\x02\u{196}\u{197}\x03\x02\x02\x02\u{197}\u{199}\x03\x02\x02\x02\u{198}\
	\u{196}\x03\x02\x02\x02\u{199}\u{19b}\x05\u{da}\x6e\x02\u{19a}\u{19c}\x05\
	\x5e\x30\x02\u{19b}\u{19a}\x03\x02\x02\x02\u{19b}\u{19c}\x03\x02\x02\x02\
	\u{19c}\u{19e}\x03\x02\x02\x02\u{19d}\u{19f}\x05\x46\x24\x02\u{19e}\u{19d}\
	\x03\x02\x02\x02\u{19e}\u{19f}\x03\x02\x02\x02\u{19f}\x1f\x03\x02\x02\x02\
	\u{1a0}\u{1a2}\x05\u{b2}\x5a\x02\u{1a1}\u{1a0}\x03\x02\x02\x02\u{1a2}\u{1a5}\
	\x03\x02\x02\x02\u{1a3}\u{1a1}\x03\x02\x02\x02\u{1a3}\u{1a4}\x03\x02\x02\
	\x02\u{1a4}\u{1a6}\x03\x02\x02\x02\u{1a5}\u{1a3}\x03\x02\x02\x02\u{1a6}\
	\u{1a8}\x05\u{dc}\x6f\x02\u{1a7}\u{1a9}\x05\u{98}\x4d\x02\u{1a8}\u{1a7}\
	\x03\x02\x02\x02\u{1a8}\u{1a9}\x03\x02\x02\x02\u{1a9}\u{1aa}\x03\x02\x02\
	\x02\u{1aa}\u{1ac}\x05\x42\x22\x02\u{1ab}\u{1ad}\x05\x5e\x30\x02\u{1ac}\
	\u{1ab}\x03\x02\x02\x02\u{1ac}\u{1ad}\x03\x02\x02\x02\u{1ad}\u{1af}\x03\
	\x02\x02\x02\u{1ae}\u{1b0}\x05\x60\x31\x02\u{1af}\u{1ae}\x03\x02\x02\x02\
	\u{1af}\u{1b0}\x03\x02\x02\x02\u{1b0}\u{1b2}\x03\x02\x02\x02\u{1b1}\u{1b3}\
	\x05\x50\x29\x02\u{1b2}\u{1b1}\x03\x02\x02\x02\u{1b2}\u{1b3}\x03\x02\x02\
	\x02\u{1b3}\x21\x03\x02\x02\x02\u{1b4}\u{1b6}\x05\u{b2}\x5a\x02\u{1b5}\u{1b4}\
	\x03\x02\x02\x02\u{1b6}\u{1b9}\x03\x02\x02\x02\u{1b7}\u{1b5}\x03\x02\x02\
	\x02\u{1b7}\u{1b8}\x03\x02\x02\x02\u{1b8}\u{1ba}\x03\x02\x02\x02\u{1b9}\
	\u{1b7}\x03\x02\x02\x02\u{1ba}\u{1bb}\x05\u{da}\x6e\x02\u{1bb}\u{1bc}\x05\
	\x18\x0d\x02\u{1bc}\x23\x03\x02\x02\x02\u{1bd}\u{1bf}\x05\u{a4}\x53\x02\
	\u{1be}\u{1bd}\x03\x02\x02\x02\u{1be}\u{1bf}\x03\x02\x02\x02\u{1bf}\u{1c3}\
	\x03\x02\x02\x02\u{1c0}\u{1c2}\x05\u{b2}\x5a\x02\u{1c1}\u{1c0}\x03\x02\x02\
	\x02\u{1c2}\u{1c5}\x03\x02\x02\x02\u{1c3}\u{1c1}\x03\x02\x02\x02\u{1c3}\
	\u{1c4}\x03\x02\x02\x02\u{1c4}\u{1c6}\x03\x02\x02\x02\u{1c5}\u{1c3}\x03\
	\x02\x02\x02\u{1c6}\u{1c7}\x05\u{d8}\x6d\x02\u{1c7}\u{1c8}\x07\x71\x02\x02\
	\u{1c8}\u{1ca}\x05\u{e6}\x74\x02\u{1c9}\u{1cb}\x05\u{98}\x4d\x02\u{1ca}\
	\u{1c9}\x03\x02\x02\x02\u{1ca}\u{1cb}\x03\x02\x02\x02\u{1cb}\u{1cd}\x03\
	\x02\x02\x02\u{1cc}\u{1ce}\x05\x2e\x18\x02\u{1cd}\u{1cc}\x03\x02\x02\x02\
	\u{1cd}\u{1ce}\x03\x02\x02\x02\u{1ce}\u{1cf}\x03\x02\x02\x02\u{1cf}\u{1d1}\
	\x05\x26\x14\x02\u{1d0}\u{1d2}\x05\x04\x03\x02\u{1d1}\u{1d0}\x03\x02\x02\
	\x02\u{1d1}\u{1d2}\x03\x02\x02\x02\u{1d2}\x25\x03\x02\x02\x02\u{1d3}\u{1da}\
	\x07\x0e\x02\x02\u{1d4}\u{1d9}\x05\x28\x15\x02\u{1d5}\u{1d9}\x05\x20\x11\
	\x02\u{1d6}\u{1d9}\x05\x1e\x10\x02\u{1d7}\u{1d9}\x05\x06\x04\x02\u{1d8}\
	\u{1d4}\x03\x02\x02\x02\u{1d8}\u{1d5}\x03\x02\x02\x02\u{1d8}\u{1d6}\x03\
	\x02\x02\x02\u{1d8}\u{1d7}\x03\x02\x02\x02\u{1d9}\u{1dc}\x03\x02\x02\x02\
	\u{1da}\u{1d8}\x03\x02\x02\x02\u{1da}\u{1db}\x03\x02\x02\x02\u{1db}\u{1dd}\
	\x03\x02\x02\x02\u{1dc}\u{1da}\x03\x02\x02\x02\u{1dd}\u{1de}\x07\x0f\x02\
	\x02\u{1de}\x27\x03\x02\x02\x02\u{1df}\u{1e0}\x07\x74\x02\x02\u{1e0}\u{1e3}\
	\x05\u{e6}\x74\x02\u{1e1}\u{1e2}\x07\x37\x02\x02\u{1e2}\u{1e4}\x05\x72\x3a\
	\x02\u{1e3}\u{1e1}\x03\x02\x02\x02\u{1e3}\u{1e4}\x03\x02\x02\x02\u{1e4}\
	\x29\x03\x02\x02\x02\u{1e5}\u{1e7}\x05\u{a4}\x53\x02\u{1e6}\u{1e5}\x03\x02\
	\x02\x02\u{1e6}\u{1e7}\x03\x02\x02\x02\u{1e7}\u{1eb}\x03\x02\x02\x02\u{1e8}\
	\u{1ea}\x05\u{b2}\x5a\x02\u{1e9}\u{1e8}\x03\x02\x02\x02\u{1ea}\u{1ed}\x03\
	\x02\x02\x02\u{1eb}\u{1e9}\x03\x02\x02\x02\u{1eb}\u{1ec}\x03\x02\x02\x02\
	\u{1ec}\u{1ee}\x03\x02\x02\x02\u{1ed}\u{1eb}\x03\x02\x02\x02\u{1ee}\u{1ef}\
	\x05\u{d8}\x6d\x02\u{1ef}\u{1f0}\x07\x76\x02\x02\u{1f0}\u{1f2}\x05\u{e4}\
	\x73\x02\u{1f1}\u{1f3}\x05\u{98}\x4d\x02\u{1f2}\u{1f1}\x03\x02\x02\x02\u{1f2}\
	\u{1f3}\x03\x02\x02\x02\u{1f3}\u{1f5}\x03\x02\x02\x02\u{1f4}\u{1f6}\x05\
	\x2e\x18\x02\u{1f5}\u{1f4}\x03\x02\x02\x02\u{1f5}\u{1f6}\x03\x02\x02\x02\
	\u{1f6}\u{1f7}\x03\x02\x02\x02\u{1f7}\u{1f8}\x05\x2c\x17\x02\u{1f8}\x2b\
	\x03\x02\x02\x02\u{1f9}\u{1ff}\x07\x0e\x02\x02\u{1fa}\u{1fe}\x05\x28\x15\
	\x02\u{1fb}\u{1fe}\x05\x20\x11\x02\u{1fc}\u{1fe}\x05\x06\x04\x02\u{1fd}\
	\u{1fa}\x03\x02\x02\x02\u{1fd}\u{1fb}\x03\x02\x02\x02\u{1fd}\u{1fc}\x03\
	\x02\x02\x02\u{1fe}\u{201}\x03\x02\x02\x02\u{1ff}\u{1fd}\x03\x02\x02\x02\
	\u{1ff}\u{200}\x03\x02\x02\x02\u{200}\u{202}\x03\x02\x02\x02\u{201}\u{1ff}\
	\x03\x02\x02\x02\u{202}\u{203}\x07\x0f\x02\x02\u{203}\x2d\x03\x02\x02\x02\
	\u{204}\u{205}\x09\x06\x02\x02\u{205}\u{206}\x05\x72\x3a\x02\u{206}\x2f\
	\x03\x02\x02\x02\u{207}\u{209}\x05\u{b2}\x5a\x02\u{208}\u{207}\x03\x02\x02\
	\x02\u{209}\u{20c}\x03\x02\x02\x02\u{20a}\u{208}\x03\x02\x02\x02\u{20a}\
	\u{20b}\x03\x02\x02\x02\u{20b}\u{20d}\x03\x02\x02\x02\u{20c}\u{20a}\x03\
	\x02\x02\x02\u{20d}\u{20e}\x05\u{d8}\x6d\x02\u{20e}\u{20f}\x07\x72\x02\x02\
	\u{20f}\u{211}\x05\u{e6}\x74\x02\u{210}\u{212}\x05\x32\x1a\x02\u{211}\u{210}\
	\x03\x02\x02\x02\u{211}\u{212}\x03\x02\x02\x02\u{212}\u{214}\x03\x02\x02\
	\x02\u{213}\u{215}\x05\x5e\x30\x02\u{214}\u{213}\x03\x02\x02\x02\u{214}\
	\u{215}\x03\x02\x02\x02\u{215}\u{216}\x03\x02\x02\x02\u{216}\u{217}\x05\
	\x34\x1b\x02\u{217}\x31\x03\x02\x02\x02\u{218}\u{21a}\x07\x0a\x02\x02\u{219}\
	\u{21b}\x05\x72\x3a\x02\u{21a}\u{219}\x03\x02\x02\x02\u{21a}\u{21b}\x03\
	\x02\x02\x02\u{21b}\u{21c}\x03\x02\x02\x02\u{21c}\u{21d}\x07\x0b\x02\x02\
	\u{21d}\x33\x03\x02\x02\x02\u{21e}\u{224}\x07\x0e\x02\x02\u{21f}\u{223}\
	\x05\x20\x11\x02\u{220}\u{223}\x05\x36\x1c\x02\u{221}\u{223}\x05\x06\x04\
	\x02\u{222}\u{21f}\x03\x02\x02\x02\u{222}\u{220}\x03\x02\x02\x02\u{222}\
	\u{221}\x03\x02\x02\x02\u{223}\u{226}\x03\x02\x02\x02\u{224}\u{222}\x03\
	\x02\x02\x02\u{224}\u{225}\x03\x02\x02\x02\u{225}\u{227}\x03\x02\x02\x02\
	\u{226}\u{224}\x03\x02\x02\x02\u{227}\u{228}\x07\x0f\x02\x02\u{228}\x35\
	\x03\x02\x02\x02\u{229}\u{22b}\x05\u{e6}\x74\x02\u{22a}\u{22c}\x05\x38\x1d\
	\x02\u{22b}\u{22a}\x03\x02\x02\x02\u{22b}\u{22c}\x03\x02\x02\x02\u{22c}\
	\x37\x03\x02\x02\x02\u{22d}\u{232}\x07\x0e\x02\x02\u{22e}\u{231}\x05\x1e\
	\x10\x02\u{22f}\u{231}\x05\x06\x04\x02\u{230}\u{22e}\x03\x02\x02\x02\u{230}\
	\u{22f}\x03\x02\x02\x02\u{231}\u{234}\x03\x02\x02\x02\u{232}\u{230}\x03\
	\x02\x02\x02\u{232}\u{233}\x03\x02\x02\x02\u{233}\u{235}\x03\x02\x02\x02\
	\u{234}\u{232}\x03\x02\x02\x02\u{235}\u{236}\x07\x0f\x02\x02\u{236}\x39\
	\x03\x02\x02\x02\u{237}\u{239}\x05\u{b2}\x5a\x02\u{238}\u{237}\x03\x02\x02\
	\x02\u{239}\u{23c}\x03\x02\x02\x02\u{23a}\u{238}\x03\x02\x02\x02\u{23a}\
	\u{23b}\x03\x02\x02\x02\u{23b}\u{23d}\x03\x02\x02\x02\u{23c}\u{23a}\x03\
	\x02\x02\x02\u{23d}\u{23e}\x05\u{d8}\x6d\x02\u{23e}\u{23f}\x07\x73\x02\x02\
	\u{23f}\u{241}\x05\u{e6}\x74\x02\u{240}\u{242}\x05\x32\x1a\x02\u{241}\u{240}\
	\x03\x02\x02\x02\u{241}\u{242}\x03\x02\x02\x02\u{242}\u{244}\x03\x02\x02\
	\x02\u{243}\u{245}\x05\x5e\x30\x02\u{244}\u{243}\x03\x02\x02\x02\u{244}\
	\u{245}\x03\x02\x02\x02\u{245}\u{246}\x03\x02\x02\x02\u{246}\u{247}\x05\
	\x3c\x1f\x02\u{247}\x3b\x03\x02\x02\x02\u{248}\u{24e}\x07\x0e\x02\x02\u{249}\
	\u{24d}\x05\x20\x11\x02\u{24a}\u{24d}\x05\x3e\x20\x02\u{24b}\u{24d}\x05\
	\x06\x04\x02\u{24c}\u{249}\x03\x02\x02\x02\u{24c}\u{24a}\x03\x02\x02\x02\
	\u{24c}\u{24b}\x03\x02\x02\x02\u{24d}\u{250}\x03\x02\x02\x02\u{24e}\u{24c}\
	\x03\x02\x02\x02\u{24e}\u{24f}\x03\x02\x02\x02\u{24f}\u{251}\x03\x02\x02\
	\x02\u{250}\u{24e}\x03\x02\x02\x02\u{251}\u{252}\x07\x0f\x02\x02\u{252}\
	\x3d\x03\x02\x02\x02\u{253}\u{255}\x05\u{b2}\x5a\x02\u{254}\u{253}\x03\x02\
	\x02\x02\u{255}\u{258}\x03\x02\x02\x02\u{256}\u{254}\x03\x02\x02\x02\u{256}\
	\u{257}\x03\x02\x02\x02\u{257}\u{259}\x03\x02\x02\x02\u{258}\u{256}\x03\
	\x02\x02\x02\u{259}\u{25c}\x05\u{e6}\x74\x02\u{25a}\u{25b}\x07\x37\x02\x02\
	\u{25b}\u{25d}\x05\x6e\x38\x02\u{25c}\u{25a}\x03\x02\x02\x02\u{25c}\u{25d}\
	\x03\x02\x02\x02\u{25d}\x3f\x03\x02\x02\x02\u{25e}\u{260}\x05\u{a4}\x53\
	\x02\u{25f}\u{25e}\x03\x02\x02\x02\u{25f}\u{260}\x03\x02\x02\x02\u{260}\
	\u{264}\x03\x02\x02\x02\u{261}\u{263}\x05\u{b2}\x5a\x02\u{262}\u{261}\x03\
	\x02\x02\x02\u{263}\u{266}\x03\x02\x02\x02\u{264}\u{262}\x03\x02\x02\x02\
	\u{264}\u{265}\x03\x02\x02\x02\u{265}\u{267}\x03\x02\x02\x02\u{266}\u{264}\
	\x03\x02\x02\x02\u{267}\u{268}\x05\u{d8}\x6d\x02\u{268}\u{269}\x07\x7f\x02\
	\x02\u{269}\u{26b}\x05\u{e4}\x73\x02\u{26a}\u{26c}\x05\u{98}\x4d\x02\u{26b}\
	\u{26a}\x03\x02\x02\x02\u{26b}\u{26c}\x03\x02\x02\x02\u{26c}\u{26d}\x03\
	\x02\x02\x02\u{26d}\u{26f}\x05\x42\x22\x02\u{26e}\u{270}\x05\x5e\x30\x02\
	\u{26f}\u{26e}\x03\x02\x02\x02\u{26f}\u{270}\x03\x02\x02\x02\u{270}\u{272}\
	\x03\x02\x02\x02\u{271}\u{273}\x05\x60\x31\x02\u{272}\u{271}\x03\x02\x02\
	\x02\u{272}\u{273}\x03\x02\x02\x02\u{273}\u{274}\x03\x02\x02\x02\u{274}\
	\u{275}\x05\x50\x29\x02\u{275}\x41\x03\x02\x02\x02\u{276}\u{277}\x07\x0a\
	\x02\x02\u{277}\u{284}\x07\x0b\x02\x02\u{278}\u{279}\x07\x0a\x02\x02\u{279}\
	\u{27e}\x05\x44\x23\x02\u{27a}\u{27b}\x07\x05\x02\x02\u{27b}\u{27d}\x05\
	\x44\x23\x02\u{27c}\u{27a}\x03\x02\x02\x02\u{27d}\u{280}\x03\x02\x02\x02\
	\u{27e}\u{27c}\x03\x02\x02\x02\u{27e}\u{27f}\x03\x02\x02\x02\u{27f}\u{281}\
	\x03\x02\x02\x02\u{280}\u{27e}\x03\x02\x02\x02\u{281}\u{282}\x07\x0b\x02\
	\x02\u{282}\u{284}\x03\x02\x02\x02\u{283}\u{276}\x03\x02\x02\x02\u{283}\
	\u{278}\x03\x02\x02\x02\u{284}\x43\x03\x02\x02\x02\u{285}\u{287}\x05\u{b2}\
	\x5a\x02\u{286}\u{285}\x03\x02\x02\x02\u{287}\u{28a}\x03\x02\x02\x02\u{288}\
	\u{286}\x03\x02\x02\x02\u{288}\u{289}\x03\x02\x02\x02\u{289}\u{28e}\x03\
	\x02\x02\x02\u{28a}\u{288}\x03\x02\x02\x02\u{28b}\u{28d}\x05\u{e6}\x74\x02\
	\u{28c}\u{28b}\x03\x02\x02\x02\u{28d}\u{290}\x03\x02\x02\x02\u{28e}\u{28c}\
	\x03\x02\x02\x02\u{28e}\u{28f}\x03\x02\x02\x02\u{28f}\u{291}\x03\x02\x02\
	\x02\u{290}\u{28e}\x03\x02\x02\x02\u{291}\u{293}\x07\x60\x02\x02\u{292}\
	\u{294}\x05\u{e6}\x74\x02\u{293}\u{292}\x03\x02\x02\x02\u{293}\u{294}\x03\
	\x02\x02\x02\u{294}\u{296}\x03\x02\x02\x02\u{295}\u{297}\x05\x5e\x30\x02\
	\u{296}\u{295}\x03\x02\x02\x02\u{296}\u{297}\x03\x02\x02\x02\u{297}\u{299}\
	\x03\x02\x02\x02\u{298}\u{29a}\x05\x46\x24\x02\u{299}\u{298}\x03\x02\x02\
	\x02\u{299}\u{29a}\x03\x02\x02\x02\u{29a}\u{2c7}\x03\x02\x02\x02\u{29b}\
	\u{29d}\x05\u{b2}\x5a\x02\u{29c}\u{29b}\x03\x02\x02\x02\u{29d}\u{2a0}\x03\
	\x02\x02\x02\u{29e}\u{29c}\x03\x02\x02\x02\u{29e}\u{29f}\x03\x02\x02\x02\
	\u{29f}\u{2a4}\x03\x02\x02\x02\u{2a0}\u{29e}\x03\x02\x02\x02\u{2a1}\u{2a3}\
	\x05\u{e6}\x74\x02\u{2a2}\u{2a1}\x03\x02\x02\x02\u{2a3}\u{2a6}\x03\x02\x02\
	\x02\u{2a4}\u{2a2}\x03\x02\x02\x02\u{2a4}\u{2a5}\x03\x02\x02\x02\u{2a5}\
	\u{2a7}\x03\x02\x02\x02\u{2a6}\u{2a4}\x03\x02\x02\x02\u{2a7}\u{2a9}\x07\
	\x61\x02\x02\u{2a8}\u{2aa}\x05\u{e6}\x74\x02\u{2a9}\u{2a8}\x03\x02\x02\x02\
	\u{2a9}\u{2aa}\x03\x02\x02\x02\u{2aa}\u{2ac}\x03\x02\x02\x02\u{2ab}\u{2ad}\
	\x05\x5e\x30\x02\u{2ac}\u{2ab}\x03\x02\x02\x02\u{2ac}\u{2ad}\x03\x02\x02\
	\x02\u{2ad}\u{2af}\x03\x02\x02\x02\u{2ae}\u{2b0}\x05\x46\x24\x02\u{2af}\
	\u{2ae}\x03\x02\x02\x02\u{2af}\u{2b0}\x03\x02\x02\x02\u{2b0}\u{2c7}\x03\
	\x02\x02\x02\u{2b1}\u{2b3}\x05\u{b2}\x5a\x02\u{2b2}\u{2b1}\x03\x02\x02\x02\
	\u{2b3}\u{2b6}\x03\x02\x02\x02\u{2b4}\u{2b2}\x03\x02\x02\x02\u{2b4}\u{2b5}\
	\x03\x02\x02\x02\u{2b5}\u{2ba}\x03\x02\x02\x02\u{2b6}\u{2b4}\x03\x02\x02\
	\x02\u{2b7}\u{2b9}\x05\u{e6}\x74\x02\u{2b8}\u{2b7}\x03\x02\x02\x02\u{2b9}\
	\u{2bc}\x03\x02\x02\x02\u{2ba}\u{2b8}\x03\x02\x02\x02\u{2ba}\u{2bb}\x03\
	\x02\x02\x02\u{2bb}\u{2bd}\x03\x02\x02\x02\u{2bc}\u{2ba}\x03\x02\x02\x02\
	\u{2bd}\u{2bf}\x05\u{e6}\x74\x02\u{2be}\u{2c0}\x05\x5e\x30\x02\u{2bf}\u{2be}\
	\x03\x02\x02\x02\u{2bf}\u{2c0}\x03\x02\x02\x02\u{2c0}\u{2c2}\x03\x02\x02\
	\x02\u{2c1}\u{2c3}\x05\x46\x24\x02\u{2c2}\u{2c1}\x03\x02\x02\x02\u{2c2}\
	\u{2c3}\x03\x02\x02\x02\u{2c3}\u{2c7}\x03\x02\x02\x02\u{2c4}\u{2c7}\x07\
	\x2d\x02\x02\u{2c5}\u{2c7}\x07\x32\x02\x02\u{2c6}\u{288}\x03\x02\x02\x02\
	\u{2c6}\u{29e}\x03\x02\x02\x02\u{2c6}\u{2b4}\x03\x02\x02\x02\u{2c6}\u{2c4}\
	\x03\x02\x02\x02\u{2c6}\u{2c5}\x03\x02\x02\x02\u{2c7}\x45\x03\x02\x02\x02\
	\u{2c8}\u{2c9}\x07\x37\x02\x02\u{2c9}\u{2ca}\x05\x6e\x38\x02\u{2ca}\x47\
	\x03\x02\x02\x02\u{2cb}\u{2cd}\x07\x55\x02\x02\u{2cc}\u{2cb}\x03\x02\x02\
	\x02\u{2cc}\u{2cd}\x03\x02\x02\x02\u{2cd}\u{2ce}\x03\x02\x02\x02\u{2ce}\
	\u{2e3}\x05\x4a\x26\x02\u{2cf}\u{2d1}\x07\x55\x02\x02\u{2d0}\u{2cf}\x03\
	\x02\x02\x02\u{2d0}\u{2d1}\x03\x02\x02\x02\u{2d1}\u{2d2}\x03\x02\x02\x02\
	\u{2d2}\u{2d3}\x07\x04\x02\x02\u{2d3}\u{2d5}\x07\u{86}\x02\x02\u{2d4}\u{2d6}\
	\x05\x4a\x26\x02\u{2d5}\u{2d4}\x03\x02\x02\x02\u{2d5}\u{2d6}\x03\x02\x02\
	\x02\u{2d6}\u{2e3}\x03\x02\x02\x02\u{2d7}\u{2d9}\x07\x55\x02\x02\u{2d8}\
	\u{2d7}\x03\x02\x02\x02\u{2d8}\u{2d9}\x03\x02\x02\x02\u{2d9}\u{2da}\x03\
	\x02\x02\x02\u{2da}\u{2dc}\x07\x04\x02\x02\u{2db}\u{2dd}\x07\x4e\x02\x02\
	\u{2dc}\u{2db}\x03\x02\x02\x02\u{2dc}\u{2dd}\x03\x02\x02\x02\u{2dd}\u{2de}\
	\x03\x02\x02\x02\u{2de}\u{2e0}\x05\u{e4}\x73\x02\u{2df}\u{2e1}\x05\x4a\x26\
	\x02\u{2e0}\u{2df}\x03\x02\x02\x02\u{2e0}\u{2e1}\x03\x02\x02\x02\u{2e1}\
	\u{2e3}\x03\x02\x02\x02\u{2e2}\u{2cc}\x03\x02\x02\x02\u{2e2}\u{2d0}\x03\
	\x02\x02\x02\u{2e2}\u{2d8}\x03\x02\x02\x02\u{2e3}\x49\x03\x02\x02\x02\u{2e4}\
	\u{2e5}\x07\x0a\x02\x02\u{2e5}\u{2f5}\x07\x0b\x02\x02\u{2e6}\u{2e7}\x07\
	\x0a\x02\x02\u{2e7}\u{2ec}\x05\x4c\x27\x02\u{2e8}\u{2e9}\x07\x05\x02\x02\
	\u{2e9}\u{2eb}\x05\x4c\x27\x02\u{2ea}\u{2e8}\x03\x02\x02\x02\u{2eb}\u{2ee}\
	\x03\x02\x02\x02\u{2ec}\u{2ea}\x03\x02\x02\x02\u{2ec}\u{2ed}\x03\x02\x02\
	\x02\u{2ed}\u{2f0}\x03\x02\x02\x02\u{2ee}\u{2ec}\x03\x02\x02\x02\u{2ef}\
	\u{2f1}\x07\x05\x02\x02\u{2f0}\u{2ef}\x03\x02\x02\x02\u{2f0}\u{2f1}\x03\
	\x02\x02\x02\u{2f1}\u{2f2}\x03\x02\x02\x02\u{2f2}\u{2f3}\x07\x0b\x02\x02\
	\u{2f3}\u{2f5}\x03\x02\x02\x02\u{2f4}\u{2e4}\x03\x02\x02\x02\u{2f4}\u{2e6}\
	\x03\x02\x02\x02\u{2f5}\x4b\x03\x02\x02\x02\u{2f6}\u{2f7}\x05\u{e6}\x74\
	\x02\u{2f7}\u{2f8}\x07\x09\x02\x02\u{2f8}\u{2f9}\x05\x6e\x38\x02\u{2f9}\
	\u{2fc}\x03\x02\x02\x02\u{2fa}\u{2fc}\x05\x6e\x38\x02\u{2fb}\u{2f6}\x03\
	\x02\x02\x02\u{2fb}\u{2fa}\x03\x02\x02\x02\u{2fc}\x4d\x03\x02\x02\x02\u{2fd}\
	\u{2ff}\x05\u{b2}\x5a\x02\u{2fe}\u{2fd}\x03\x02\x02\x02\u{2ff}\u{302}\x03\
	\x02\x02\x02\u{300}\u{2fe}\x03\x02\x02\x02\u{300}\u{301}\x03\x02\x02\x02\
	\u{301}\u{303}\x03\x02\x02\x02\u{302}\u{300}\x03\x02\x02\x02\u{303}\u{304}\
	\x07\x7e\x02\x02\u{304}\u{306}\x05\x42\x22\x02\u{305}\u{307}\x05\x5e\x30\
	\x02\u{306}\u{305}\x03\x02\x02\x02\u{306}\u{307}\x03\x02\x02\x02\u{307}\
	\u{308}\x03\x02\x02\x02\u{308}\u{309}\x05\x50\x29\x02\u{309}\x4f\x03\x02\
	\x02\x02\u{30a}\u{313}\x07\x0e\x02\x02\u{30b}\u{312}\x05\x5c\x2f\x02\u{30c}\
	\u{312}\x05\x52\x2a\x02\u{30d}\u{312}\x05\x68\x35\x02\u{30e}\u{312}\x05\
	\x64\x33\x02\u{30f}\u{312}\x05\x6c\x37\x02\u{310}\u{312}\x05\x04\x03\x02\
	\u{311}\u{30b}\x03\x02\x02\x02\u{311}\u{30c}\x03\x02\x02\x02\u{311}\u{30d}\
	\x03\x02\x02\x02\u{311}\u{30e}\x03\x02\x02\x02\u{311}\u{30f}\x03\x02\x02\
	\x02\u{311}\u{310}\x03\x02\x02\x02\u{312}\u{315}\x03\x02\x02\x02\u{313}\
	\u{311}\x03\x02\x02\x02\u{313}\u{314}\x03\x02\x02\x02\u{314}\u{316}\x03\
	\x02\x02\x02\u{315}\u{313}\x03\x02\x02\x02\u{316}\u{317}\x07\x0f\x02\x02\
	\u{317}\x51\x03\x02\x02\x02\u{318}\u{31a}\x05\u{b2}\x5a\x02\u{319}\u{318}\
	\x03\x02\x02\x02\u{31a}\u{31d}\x03\x02\x02\x02\u{31b}\u{319}\x03\x02\x02\
	\x02\u{31b}\u{31c}\x03\x02\x02\x02\u{31c}\u{31e}\x03\x02\x02\x02\u{31d}\
	\u{31b}\x03\x02\x02\x02\u{31e}\u{31f}\x07\x7a\x02\x02\u{31f}\u{321}\x05\
	\x54\x2b\x02\u{320}\u{322}\x05\x5e\x30\x02\u{321}\u{320}\x03\x02\x02\x02\
	\u{321}\u{322}\x03\x02\x02\x02\u{322}\u{325}\x03\x02\x02\x02\u{323}\u{324}\
	\x07\x37\x02\x02\u{324}\u{326}\x05\x6c\x37\x02\u{325}\u{323}\x03\x02\x02\
	\x02\u{325}\u{326}\x03\x02\x02\x02\u{326}\x53\x03\x02\x02\x02\u{327}\u{32a}\
	\x05\x58\x2d\x02\u{328}\u{32a}\x05\x56\x2c\x02\u{329}\u{327}\x03\x02\x02\
	\x02\u{329}\u{328}\x03\x02\x02\x02\u{32a}\x55\x03\x02\x02\x02\u{32b}\u{330}\
	\x05\u{da}\x6e\x02\u{32c}\u{32d}\x07\x05\x02\x02\u{32d}\u{32f}\x05\u{da}\
	\x6e\x02\u{32e}\u{32c}\x03\x02\x02\x02\u{32f}\u{332}\x03\x02\x02\x02\u{330}\
	\u{32e}\x03\x02\x02\x02\u{330}\u{331}\x03\x02\x02\x02\u{331}\u{334}\x03\
	\x02\x02\x02\u{332}\u{330}\x03\x02\x02\x02\u{333}\u{335}\x07\x05\x02\x02\
	\u{334}\u{333}\x03\x02\x02\x02\u{334}\u{335}\x03\x02\x02\x02\u{335}\x57\
	\x03\x02\x02\x02\u{336}\u{344}\x07\x0a\x02\x02\u{337}\u{338}\x05\x5a\x2e\
	\x02\u{338}\u{339}\x07\x05\x02\x02\u{339}\u{345}\x03\x02\x02\x02\u{33a}\
	\u{33d}\x05\x5a\x2e\x02\u{33b}\u{33c}\x07\x05\x02\x02\u{33c}\u{33e}\x05\
	\x5a\x2e\x02\u{33d}\u{33b}\x03\x02\x02\x02\u{33e}\u{33f}\x03\x02\x02\x02\
	\u{33f}\u{33d}\x03\x02\x02\x02\u{33f}\u{340}\x03\x02\x02\x02\u{340}\u{342}\
	\x03\x02\x02\x02\u{341}\u{343}\x07\x05\x02\x02\u{342}\u{341}\x03\x02\x02\
	\x02\u{342}\u{343}\x03\x02\x02\x02\u{343}\u{345}\x03\x02\x02\x02\u{344}\
	\u{337}\x03\x02\x02\x02\u{344}\u{33a}\x03\x02\x02\x02\u{344}\u{345}\x03\
	\x02\x02\x02\u{345}\u{346}\x03\x02\x02\x02\u{346}\u{37d}\x07\x0b\x02\x02\
	\u{347}\u{348}\x05\u{e4}\x73\x02\u{348}\u{354}\x07\x0a\x02\x02\u{349}\u{34e}\
	\x05\x5a\x2e\x02\u{34a}\u{34b}\x07\x05\x02\x02\u{34b}\u{34d}\x05\x5a\x2e\
	\x02\u{34c}\u{34a}\x03\x02\x02\x02\u{34d}\u{350}\x03\x02\x02\x02\u{34e}\
	\u{34c}\x03\x02\x02\x02\u{34e}\u{34f}\x03\x02\x02\x02\u{34f}\u{352}\x03\
	\x02\x02\x02\u{350}\u{34e}\x03\x02\x02\x02\u{351}\u{353}\x07\x05\x02\x02\
	\u{352}\u{351}\x03\x02\x02\x02\u{352}\u{353}\x03\x02\x02\x02\u{353}\u{355}\
	\x03\x02\x02\x02\u{354}\u{349}\x03\x02\x02\x02\u{354}\u{355}\x03\x02\x02\
	\x02\u{355}\u{356}\x03\x02\x02\x02\u{356}\u{357}\x07\x0b\x02\x02\u{357}\
	\u{37d}\x03\x02\x02\x02\u{358}\u{35a}\x05\u{e4}\x73\x02\u{359}\u{358}\x03\
	\x02\x02\x02\u{359}\u{35a}\x03\x02\x02\x02\u{35a}\u{35b}\x03\x02\x02\x02\
	\u{35b}\u{367}\x07\x0c\x02\x02\u{35c}\u{361}\x05\x5a\x2e\x02\u{35d}\u{35e}\
	\x07\x05\x02\x02\u{35e}\u{360}\x05\x5a\x2e\x02\u{35f}\u{35d}\x03\x02\x02\
	\x02\u{360}\u{363}\x03\x02\x02\x02\u{361}\u{35f}\x03\x02\x02\x02\u{361}\
	\u{362}\x03\x02\x02\x02\u{362}\u{365}\x03\x02\x02\x02\u{363}\u{361}\x03\
	\x02\x02\x02\u{364}\u{366}\x07\x05\x02\x02\u{365}\u{364}\x03\x02\x02\x02\
	\u{365}\u{366}\x03\x02\x02\x02\u{366}\u{368}\x03\x02\x02\x02\u{367}\u{35c}\
	\x03\x02\x02\x02\u{367}\u{368}\x03\x02\x02\x02\u{368}\u{369}\x03\x02\x02\
	\x02\u{369}\u{37d}\x07\x0d\x02\x02\u{36a}\u{36c}\x05\u{e4}\x73\x02\u{36b}\
	\u{36a}\x03\x02\x02\x02\u{36b}\u{36c}\x03\x02\x02\x02\u{36c}\u{36d}\x03\
	\x02\x02\x02\u{36d}\u{379}\x07\x0e\x02\x02\u{36e}\u{373}\x05\x5a\x2e\x02\
	\u{36f}\u{370}\x07\x05\x02\x02\u{370}\u{372}\x05\x5a\x2e\x02\u{371}\u{36f}\
	\x03\x02\x02\x02\u{372}\u{375}\x03\x02\x02\x02\u{373}\u{371}\x03\x02\x02\
	\x02\u{373}\u{374}\x03\x02\x02\x02\u{374}\u{377}\x03\x02\x02\x02\u{375}\
	\u{373}\x03\x02\x02\x02\u{376}\u{378}\x07\x05\x02\x02\u{377}\u{376}\x03\
	\x02\x02\x02\u{377}\u{378}\x03\x02\x02\x02\u{378}\u{37a}\x03\x02\x02\x02\
	\u{379}\u{36e}\x03\x02\x02\x02\u{379}\u{37a}\x03\x02\x02\x02\u{37a}\u{37b}\
	\x03\x02\x02\x02\u{37b}\u{37d}\x07\x0f\x02\x02\u{37c}\u{336}\x03\x02\x02\
	\x02\u{37c}\u{347}\x03\x02\x02\x02\u{37c}\u{359}\x03\x02\x02\x02\u{37c}\
	\u{36b}\x03\x02\x02\x02\u{37d}\x59\x03\x02\x02\x02\u{37e}\u{37f}\x05\u{da}\
	\x6e\x02\u{37f}\u{380}\x07\x09\x02\x02\u{380}\u{382}\x03\x02\x02\x02\u{381}\
	\u{37e}\x03\x02\x02\x02\u{381}\u{382}\x03\x02\x02\x02\u{382}\u{386}\x03\
	\x02\x02\x02\u{383}\u{384}\x05\u{e6}\x74\x02\u{384}\u{385}\x07\x38\x02\x02\
	\u{385}\u{387}\x03\x02\x02\x02\u{386}\u{383}\x03\x02\x02\x02\u{386}\u{387}\
	\x03\x02\x02\x02\u{387}\u{388}\x03\x02\x02\x02\u{388}\u{39d}\x05\x58\x2d\
	\x02\u{389}\u{38a}\x05\u{da}\x6e\x02\u{38a}\u{38b}\x07\x09\x02\x02\u{38b}\
	\u{38d}\x03\x02\x02\x02\u{38c}\u{389}\x03\x02\x02\x02\u{38c}\u{38d}\x03\
	\x02\x02\x02\u{38d}\u{391}\x03\x02\x02\x02\u{38e}\u{38f}\x05\u{e6}\x74\x02\
	\u{38f}\u{390}\x07\x38\x02\x02\u{390}\u{392}\x03\x02\x02\x02\u{391}\u{38e}\
	\x03\x02\x02\x02\u{391}\u{392}\x03\x02\x02\x02\u{392}\u{393}\x03\x02\x02\
	\x02\u{393}\u{39d}\x05\u{e6}\x74\x02\u{394}\u{396}\x05\u{da}\x6e\x02\u{395}\
	\u{394}\x03\x02\x02\x02\u{395}\u{396}\x03\x02\x02\x02\u{396}\u{397}\x03\
	\x02\x02\x02\u{397}\u{399}\x07\x61\x02\x02\u{398}\u{39a}\x05\u{e6}\x74\x02\
	\u{399}\u{398}\x03\x02\x02\x02\u{399}\u{39a}\x03\x02\x02\x02\u{39a}\u{39d}\
	\x03\x02\x02\x02\u{39b}\u{39d}\x05\u{da}\x6e\x02\u{39c}\u{381}\x03\x02\x02\
	\x02\u{39c}\u{38c}\x03\x02\x02\x02\u{39c}\u{395}\x03\x02\x02\x02\u{39c}\
	\u{39b}\x03\x02\x02\x02\u{39d}\x5b\x03\x02\x02\x02\u{39e}\u{3a0}\x05\u{b2}\
	\x5a\x02\u{39f}\u{39e}\x03\x02\x02\x02\u{3a0}\u{3a3}\x03\x02\x02\x02\u{3a1}\
	\u{39f}\x03\x02\x02\x02\u{3a1}\u{3a2}\x03\x02\x02\x02\u{3a2}\u{3a4}\x03\
	\x02\x02\x02\u{3a3}\u{3a1}\x03\x02\x02\x02\u{3a4}\u{3a5}\x05\u{d8}\x6d\x02\
	\u{3a5}\u{3a6}\x07\x74\x02\x02\u{3a6}\u{3a8}\x05\u{e6}\x74\x02\u{3a7}\u{3a9}\
	\x05\u{98}\x4d\x02\u{3a8}\u{3a7}\x03\x02\x02\x02\u{3a8}\u{3a9}\x03\x02\x02\
	\x02\u{3a9}\u{3aa}\x03\x02\x02\x02\u{3aa}\u{3ab}\x07\x37\x02\x02\u{3ab}\
	\u{3ac}\x05\x72\x3a\x02\u{3ac}\u{3bc}\x03\x02\x02\x02\u{3ad}\u{3af}\x05\
	\u{b2}\x5a\x02\u{3ae}\u{3ad}\x03\x02\x02\x02\u{3af}\u{3b2}\x03\x02\x02\x02\
	\u{3b0}\u{3ae}\x03\x02\x02\x02\u{3b0}\u{3b1}\x03\x02\x02\x02\u{3b1}\u{3b3}\
	\x03\x02\x02\x02\u{3b2}\u{3b0}\x03\x02\x02\x02\u{3b3}\u{3b4}\x05\u{d8}\x6d\
	\x02\u{3b4}\u{3b5}\x07\x74\x02\x02\u{3b5}\u{3b7}\x05\u{e6}\x74\x02\u{3b6}\
	\u{3b8}\x05\u{98}\x4d\x02\u{3b7}\u{3b6}\x03\x02\x02\x02\u{3b7}\u{3b8}\x03\
	\x02\x02\x02\u{3b8}\u{3b9}\x03\x02\x02\x02\u{3b9}\u{3ba}\x05\u{a6}\x54\x02\
	\u{3ba}\u{3bc}\x03\x02\x02\x02\u{3bb}\u{3a1}\x03\x02\x02\x02\u{3bb}\u{3b0}\
	\x03\x02\x02\x02\u{3bc}\x5d\x03\x02\x02\x02\u{3bd}\u{3be}\x09\x07\x02\x02\
	\u{3be}\u{3bf}\x05\x72\x3a\x02\u{3bf}\x5f\x03\x02\x02\x02\u{3c0}\u{3c1}\
	\x07\x21\x02\x02\u{3c1}\u{3c2}\x05\x72\x3a\x02\u{3c2}\x61\x03\x02\x02\x02\
	\u{3c3}\u{3c5}\x05\u{b2}\x5a\x02\u{3c4}\u{3c3}\x03\x02\x02\x02\u{3c5}\u{3c8}\
	\x03\x02\x02\x02\u{3c6}\u{3c4}\x03\x02\x02\x02\u{3c6}\u{3c7}\x03\x02\x02\
	\x02\u{3c7}\u{3c9}\x03\x02\x02\x02\u{3c8}\u{3c6}\x03\x02\x02\x02\u{3c9}\
	\u{3ca}\x07\u{8b}\x02\x02\u{3ca}\u{3cb}\x05\x70\x39\x02\u{3cb}\u{3cf}\x05\
	\x50\x29\x02\u{3cc}\u{3ce}\x05\x66\x34\x02\u{3cd}\u{3cc}\x03\x02\x02\x02\
	\u{3ce}\u{3d1}\x03\x02\x02\x02\u{3cf}\u{3cd}\x03\x02\x02\x02\u{3cf}\u{3d0}\
	\x03\x02\x02\x02\u{3d0}\u{3d4}\x03\x02\x02\x02\u{3d1}\u{3cf}\x03\x02\x02\
	\x02\u{3d2}\u{3d3}\x07\u{8c}\x02\x02\u{3d3}\u{3d5}\x05\x50\x29\x02\u{3d4}\
	\u{3d2}\x03\x02\x02\x02\u{3d4}\u{3d5}\x03\x02\x02\x02\u{3d5}\x63\x03\x02\
	\x02\x02\u{3d6}\u{3d8}\x05\u{b2}\x5a\x02\u{3d7}\u{3d6}\x03\x02\x02\x02\u{3d8}\
	\u{3db}\x03\x02\x02\x02\u{3d9}\u{3d7}\x03\x02\x02\x02\u{3d9}\u{3da}\x03\
	\x02\x02\x02\u{3da}\u{3dc}\x03\x02\x02\x02\u{3db}\u{3d9}\x03\x02\x02\x02\
	\u{3dc}\u{3dd}\x07\u{8b}\x02\x02\u{3dd}\u{3e1}\x09\x08\x02\x02\u{3de}\u{3e2}\
	\x05\x58\x2d\x02\u{3df}\u{3e2}\x05\u{e6}\x74\x02\u{3e0}\u{3e2}\x07\u{94}\
	\x02\x02\u{3e1}\u{3de}\x03\x02\x02\x02\u{3e1}\u{3df}\x03\x02\x02\x02\u{3e1}\
	\u{3e0}\x03\x02\x02\x02\u{3e2}\u{3e3}\x03\x02\x02\x02\u{3e3}\u{3e4}\x07\
	\x37\x02\x02\u{3e4}\u{3e5}\x05\x70\x39\x02\u{3e5}\u{3e6}\x05\x50\x29\x02\
	\u{3e6}\u{3f3}\x03\x02\x02\x02\u{3e7}\u{3e9}\x05\u{b2}\x5a\x02\u{3e8}\u{3e7}\
	\x03\x02\x02\x02\u{3e9}\u{3ec}\x03\x02\x02\x02\u{3ea}\u{3e8}\x03\x02\x02\
	\x02\u{3ea}\u{3eb}\x03\x02\x02\x02\u{3eb}\u{3ed}\x03\x02\x02\x02\u{3ec}\
	\u{3ea}\x03\x02\x02\x02\u{3ed}\u{3ee}\x07\u{8b}\x02\x02\u{3ee}\u{3ef}\x09\
	\x08\x02\x02\u{3ef}\u{3f0}\x05\x70\x39\x02\u{3f0}\u{3f1}\x05\x50\x29\x02\
	\u{3f1}\u{3f3}\x03\x02\x02\x02\u{3f2}\u{3d9}\x03\x02\x02\x02\u{3f2}\u{3ea}\
	\x03\x02\x02\x02\u{3f3}\x65\x03\x02\x02\x02\u{3f4}\u{3f5}\x07\u{8c}\x02\
	\x02\u{3f5}\u{3f6}\x07\u{8b}\x02\x02\u{3f6}\u{3f7}\x05\x70\x39\x02\u{3f7}\
	\u{3f8}\x05\x50\x29\x02\u{3f8}\x67\x03\x02\x02\x02\u{3f9}\u{3fb}\x05\u{b2}\
	\x5a\x02\u{3fa}\u{3f9}\x03\x02\x02\x02\u{3fb}\u{3fe}\x03\x02\x02\x02\u{3fc}\
	\u{3fa}\x03\x02\x02\x02\u{3fc}\u{3fd}\x03\x02\x02\x02\u{3fd}\u{3ff}\x03\
	\x02\x02\x02\u{3fe}\u{3fc}\x03\x02\x02\x02\u{3ff}\u{400}\x07\x78\x02\x02\
	\u{400}\u{401}\x05\x70\x39\x02\u{401}\u{402}\x05\x50\x29\x02\u{402}\u{421}\
	\x03\x02\x02\x02\u{403}\u{405}\x05\u{b2}\x5a\x02\u{404}\u{403}\x03\x02\x02\
	\x02\u{405}\u{408}\x03\x02\x02\x02\u{406}\u{404}\x03\x02\x02\x02\u{406}\
	\u{407}\x03\x02\x02\x02\u{407}\u{409}\x03\x02\x02\x02\u{408}\u{406}\x03\
	\x02\x02\x02\u{409}\u{40a}\x07\x78\x02\x02\u{40a}\u{40b}\x07\x7a\x02\x02\
	\u{40b}\u{40c}\x05\x54\x2b\x02\u{40c}\u{40d}\x07\x37\x02\x02\u{40d}\u{40e}\
	\x05\x70\x39\x02\u{40e}\u{40f}\x05\x50\x29\x02\u{40f}\u{421}\x03\x02\x02\
	\x02\u{410}\u{412}\x05\u{b2}\x5a\x02\u{411}\u{410}\x03\x02\x02\x02\u{412}\
	\u{415}\x03\x02\x02\x02\u{413}\u{411}\x03\x02\x02\x02\u{413}\u{414}\x03\
	\x02\x02\x02\u{414}\u{416}\x03\x02\x02\x02\u{415}\u{413}\x03\x02\x02\x02\
	\u{416}\u{417}\x07\x79\x02\x02\u{417}\u{418}\x05\x54\x2b\x02\u{418}\u{419}\
	\x05\u{96}\x4c\x02\u{419}\u{41c}\x05\x70\x39\x02\u{41a}\u{41b}\x07\u{8b}\
	\x02\x02\u{41b}\u{41d}\x05\x70\x39\x02\u{41c}\u{41a}\x03\x02\x02\x02\u{41c}\
	\u{41d}\x03\x02\x02\x02\u{41d}\u{41e}\x03\x02\x02\x02\u{41e}\u{41f}\x05\
	\x50\x29\x02\u{41f}\u{421}\x03\x02\x02\x02\u{420}\u{3fc}\x03\x02\x02\x02\
	\u{420}\u{406}\x03\x02\x02\x02\u{420}\u{413}\x03\x02\x02\x02\u{421}\x69\
	\x03\x02\x02\x02\u{422}\u{423}\x07\u{8b}\x02\x02\u{423}\u{424}\x05\x70\x39\
	\x02\u{424}\x6b\x03\x02\x02\x02\u{425}\u{427}\x05\u{b2}\x5a\x02\u{426}\u{425}\
	\x03\x02\x02\x02\u{427}\u{42a}\x03\x02\x02\x02\u{428}\u{426}\x03\x02\x02\
	\x02\u{428}\u{429}\x03\x02\x02\x02\u{429}\u{42b}\x03\x02\x02\x02\u{42a}\
	\u{428}\x03\x02\x02\x02\u{42b}\u{42d}\x05\x6e\x38\x02\u{42c}\u{42e}\x07\
	\x55\x02\x02\u{42d}\u{42c}\x03\x02\x02\x02\u{42d}\u{42e}\x03\x02\x02\x02\
	\u{42e}\u{430}\x03\x02\x02\x02\u{42f}\u{431}\x05\x04\x03\x02\u{430}\u{42f}\
	\x03\x02\x02\x02\u{430}\u{431}\x03\x02\x02\x02\u{431}\x6d\x03\x02\x02\x02\
	\u{432}\u{433}\x08\x38\x01\x02\u{433}\u{434}\x05\x78\x3d\x02\u{434}\u{435}\
	\x05\x6e\x38\x20\u{435}\u{450}\x03\x02\x02\x02\u{436}\u{437}\x07\x0a\x02\
	\x02\u{437}\u{438}\x05\x6e\x38\x02\u{438}\u{439}\x07\x0b\x02\x02\u{439}\
	\u{450}\x03\x02\x02\x02\u{43a}\u{43b}\x07\x18\x02\x02\u{43b}\u{43c}\x05\
	\x6e\x38\x02\u{43c}\u{43d}\x07\x19\x02\x02\u{43d}\u{450}\x03\x02\x02\x02\
	\u{43e}\u{43f}\x07\x16\x02\x02\u{43f}\u{440}\x05\x6e\x38\x02\u{440}\u{441}\
	\x07\x17\x02\x02\u{441}\u{450}\x03\x02\x02\x02\u{442}\u{450}\x05\x76\x3c\
	\x02\u{443}\u{450}\x05\x62\x32\x02\u{444}\u{450}\x05\u{c8}\x65\x02\u{445}\
	\u{450}\x05\u{b6}\x5c\x02\u{446}\u{450}\x05\u{b8}\x5d\x02\u{447}\u{450}\
	\x05\u{c6}\x64\x02\u{448}\u{450}\x05\u{b0}\x59\x02\u{449}\u{450}\x05\x4e\
	\x28\x02\u{44a}\u{450}\x05\x50\x29\x02\u{44b}\u{450}\x05\u{a2}\x52\x02\u{44c}\
	\u{450}\x05\u{ce}\x68\x02\u{44d}\u{450}\x05\u{d4}\x6b\x02\u{44e}\u{450}\
	\x05\x74\x3b\x02\u{44f}\u{432}\x03\x02\x02\x02\u{44f}\u{436}\x03\x02\x02\
	\x02\u{44f}\u{43a}\x03\x02\x02\x02\u{44f}\u{43e}\x03\x02\x02\x02\u{44f}\
	\u{442}\x03\x02\x02\x02\u{44f}\u{443}\x03\x02\x02\x02\u{44f}\u{444}\x03\
	\x02\x02\x02\u{44f}\u{445}\x03\x02\x02\x02\u{44f}\u{446}\x03\x02\x02\x02\
	\u{44f}\u{447}\x03\x02\x02\x02\u{44f}\u{448}\x03\x02\x02\x02\u{44f}\u{449}\
	\x03\x02\x02\x02\u{44f}\u{44a}\x03\x02\x02\x02\u{44f}\u{44b}\x03\x02\x02\
	\x02\u{44f}\u{44c}\x03\x02\x02\x02\u{44f}\u{44d}\x03\x02\x02\x02\u{44f}\
	\u{44e}\x03\x02\x02\x02\u{450}\u{4a4}\x03\x02\x02\x02\u{451}\u{452}\x0c\
	\x1f\x02\x02\u{452}\u{453}\x05\u{82}\x42\x02\u{453}\u{454}\x05\x6e\x38\x1f\
	\u{454}\u{4a3}\x03\x02\x02\x02\u{455}\u{456}\x0c\x1e\x02\x02\u{456}\u{457}\
	\x05\u{88}\x45\x02\u{457}\u{458}\x05\x6e\x38\x1f\u{458}\u{4a3}\x03\x02\x02\
	\x02\u{459}\u{45a}\x0c\x1d\x02\x02\u{45a}\u{45b}\x05\u{8a}\x46\x02\u{45b}\
	\u{45c}\x05\x6e\x38\x1e\u{45c}\u{4a3}\x03\x02\x02\x02\u{45d}\u{45e}\x0c\
	\x1c\x02\x02\u{45e}\u{45f}\x05\u{8c}\x47\x02\u{45f}\u{460}\x05\x6e\x38\x1d\
	\u{460}\u{4a3}\x03\x02\x02\x02\u{461}\u{462}\x0c\x1b\x02\x02\u{462}\u{463}\
	\x05\x7c\x3f\x02\u{463}\u{464}\x05\x6e\x38\x1c\u{464}\u{4a3}\x03\x02\x02\
	\x02\u{465}\u{466}\x0c\x1a\x02\x02\u{466}\u{467}\x05\u{84}\x43\x02\u{467}\
	\u{468}\x05\x6e\x38\x1b\u{468}\u{4a3}\x03\x02\x02\x02\u{469}\u{46a}\x0c\
	\x19\x02\x02\u{46a}\u{46b}\x05\u{80}\x41\x02\u{46b}\u{46c}\x05\x6e\x38\x1a\
	\u{46c}\u{4a3}\x03\x02\x02\x02\u{46d}\u{46e}\x0c\x16\x02\x02\u{46e}\u{46f}\
	\x05\u{96}\x4c\x02\u{46f}\u{470}\x05\x6e\x38\x17\u{470}\u{4a3}\x03\x02\x02\
	\x02\u{471}\u{472}\x0c\x14\x02\x02\u{472}\u{473}\x05\u{8e}\x48\x02\u{473}\
	\u{474}\x05\x6e\x38\x15\u{474}\u{4a3}\x03\x02\x02\x02\u{475}\u{476}\x0c\
	\x13\x02\x02\u{476}\u{477}\x05\u{90}\x49\x02\u{477}\u{478}\x05\x6e\x38\x14\
	\u{478}\u{4a3}\x03\x02\x02\x02\u{479}\u{47a}\x0c\x26\x02\x02\u{47a}\u{4a3}\
	\x05\x7a\x3e\x02\u{47b}\u{47c}\x0c\x25\x02\x02\u{47c}\u{4a3}\x05\u{d2}\x6a\
	\x02\u{47d}\u{47e}\x0c\x24\x02\x02\u{47e}\u{4a3}\x05\u{9c}\x4f\x02\u{47f}\
	\u{480}\x0c\x23\x02\x02\u{480}\u{4a3}\x05\x48\x25\x02\u{481}\u{483}\x0c\
	\x22\x02\x02\u{482}\u{484}\x07\x55\x02\x02\u{483}\u{482}\x03\x02\x02\x02\
	\u{483}\u{484}\x03\x02\x02\x02\u{484}\u{486}\x03\x02\x02\x02\u{485}\u{487}\
	\x07\x04\x02\x02\u{486}\u{485}\x03\x02\x02\x02\u{486}\u{487}\x03\x02\x02\
	\x02\u{487}\u{488}\x03\x02\x02\x02\u{488}\u{4a3}\x05\x50\x29\x02\u{489}\
	\u{48b}\x0c\x21\x02\x02\u{48a}\u{48c}\x07\x55\x02\x02\u{48b}\u{48a}\x03\
	\x02\x02\x02\u{48b}\u{48c}\x03\x02\x02\x02\u{48c}\u{48d}\x03\x02\x02\x02\
	\u{48d}\u{48e}\x07\x04\x02\x02\u{48e}\u{494}\x09\x09\x02\x02\u{48f}\u{490}\
	\x07\x5f\x02\x02\u{490}\u{492}\x05\u{e6}\x74\x02\u{491}\u{493}\x05\x5e\x30\
	\x02\u{492}\u{491}\x03\x02\x02\x02\u{492}\u{493}\x03\x02\x02\x02\u{493}\
	\u{495}\x03\x02\x02\x02\u{494}\u{48f}\x03\x02\x02\x02\u{494}\u{495}\x03\
	\x02\x02\x02\u{495}\u{496}\x03\x02\x02\x02\u{496}\u{4a3}\x05\u{ba}\x5e\x02\
	\u{497}\u{498}\x0c\x18\x02\x02\u{498}\u{499}\x05\u{92}\x4a\x02\u{499}\u{49a}\
	\x05\x72\x3a\x02\u{49a}\u{4a3}\x03\x02\x02\x02\u{49b}\u{49c}\x0c\x17\x02\
	\x02\u{49c}\u{49d}\x05\u{94}\x4b\x02\u{49d}\u{49e}\x05\x72\x3a\x02\u{49e}\
	\u{4a3}\x03\x02\x02\x02\u{49f}\u{4a0}\x0c\x15\x02\x02\u{4a0}\u{4a1}\x07\
	\x54\x02\x02\u{4a1}\u{4a3}\x05\u{90}\x49\x02\u{4a2}\u{451}\x03\x02\x02\x02\
	\u{4a2}\u{455}\x03\x02\x02\x02\u{4a2}\u{459}\x03\x02\x02\x02\u{4a2}\u{45d}\
	\x03\x02\x02\x02\u{4a2}\u{461}\x03\x02\x02\x02\u{4a2}\u{465}\x03\x02\x02\
	\x02\u{4a2}\u{469}\x03\x02\x02\x02\u{4a2}\u{46d}\x03\x02\x02\x02\u{4a2}\
	\u{471}\x03\x02\x02\x02\u{4a2}\u{475}\x03\x02\x02\x02\u{4a2}\u{479}\x03\
	\x02\x02\x02\u{4a2}\u{47b}\x03\x02\x02\x02\u{4a2}\u{47d}\x03\x02\x02\x02\
	\u{4a2}\u{47f}\x03\x02\x02\x02\u{4a2}\u{481}\x03\x02\x02\x02\u{4a2}\u{489}\
	\x03\x02\x02\x02\u{4a2}\u{497}\x03\x02\x02\x02\u{4a2}\u{49b}\x03\x02\x02\
	\x02\u{4a2}\u{49f}\x03\x02\x02\x02\u{4a3}\u{4a6}\x03\x02\x02\x02\u{4a4}\
	\u{4a2}\x03\x02\x02\x02\u{4a4}\u{4a5}\x03\x02\x02\x02\u{4a5}\x6f\x03\x02\
	\x02\x02\u{4a6}\u{4a4}\x03\x02\x02\x02\u{4a7}\u{4a8}\x08\x39\x01\x02\u{4a8}\
	\u{4a9}\x05\x78\x3d\x02\u{4a9}\u{4aa}\x05\x70\x39\x14\u{4aa}\u{4bb}\x03\
	\x02\x02\x02\u{4ab}\u{4ac}\x07\x0a\x02\x02\u{4ac}\u{4ad}\x05\x6e\x38\x02\
	\u{4ad}\u{4ae}\x07\x0b\x02\x02\u{4ae}\u{4bb}\x03\x02\x02\x02\u{4af}\u{4b0}\
	\x07\x18\x02\x02\u{4b0}\u{4b1}\x05\x6e\x38\x02\u{4b1}\u{4b2}\x07\x19\x02\
	\x02\u{4b2}\u{4bb}\x03\x02\x02\x02\u{4b3}\u{4b4}\x07\x16\x02\x02\u{4b4}\
	\u{4b5}\x05\x6e\x38\x02\u{4b5}\u{4b6}\x07\x17\x02\x02\u{4b6}\u{4bb}\x03\
	\x02\x02\x02\u{4b7}\u{4bb}\x05\u{ce}\x68\x02\u{4b8}\u{4bb}\x05\u{d4}\x6b\
	\x02\u{4b9}\u{4bb}\x05\x74\x3b\x02\u{4ba}\u{4a7}\x03\x02\x02\x02\u{4ba}\
	\u{4ab}\x03\x02\x02\x02\u{4ba}\u{4af}\x03\x02\x02\x02\u{4ba}\u{4b3}\x03\
	\x02\x02\x02\u{4ba}\u{4b7}\x03\x02\x02\x02\u{4ba}\u{4b8}\x03\x02\x02\x02\
	\u{4ba}\u{4b9}\x03\x02\x02\x02\u{4bb}\u{4e4}\x03\x02\x02\x02\u{4bc}\u{4bd}\
	\x0c\x10\x02\x02\u{4bd}\u{4be}\x05\u{88}\x45\x02\u{4be}\u{4bf}\x05\x70\x39\
	\x11\u{4bf}\u{4e3}\x03\x02\x02\x02\u{4c0}\u{4c1}\x0c\x0f\x02\x02\u{4c1}\
	\u{4c2}\x05\u{8a}\x46\x02\u{4c2}\u{4c3}\x05\x70\x39\x10\u{4c3}\u{4e3}\x03\
	\x02\x02\x02\u{4c4}\u{4c5}\x0c\x0e\x02\x02\u{4c5}\u{4c6}\x05\u{8c}\x47\x02\
	\u{4c6}\u{4c7}\x05\x70\x39\x0f\u{4c7}\u{4e3}\x03\x02\x02\x02\u{4c8}\u{4c9}\
	\x0c\x0d\x02\x02\u{4c9}\u{4ca}\x05\u{80}\x41\x02\u{4ca}\u{4cb}\x05\x70\x39\
	\x0e\u{4cb}\u{4e3}\x03\x02\x02\x02\u{4cc}\u{4cd}\x0c\x0c\x02\x02\u{4cd}\
	\u{4ce}\x05\x7c\x3f\x02\u{4ce}\u{4cf}\x05\x70\x39\x0d\u{4cf}\u{4e3}\x03\
	\x02\x02\x02\u{4d0}\u{4d1}\x0c\x09\x02\x02\u{4d1}\u{4d2}\x05\u{84}\x43\x02\
	\u{4d2}\u{4d3}\x05\x70\x39\x0a\u{4d3}\u{4e3}\x03\x02\x02\x02\u{4d4}\u{4d5}\
	\x0c\x13\x02\x02\u{4d5}\u{4e3}\x05\x48\x25\x02\u{4d6}\u{4d7}\x0c\x12\x02\
	\x02\u{4d7}\u{4e3}\x05\u{9c}\x4f\x02\u{4d8}\u{4d9}\x0c\x11\x02\x02\u{4d9}\
	\u{4e3}\x05\u{d2}\x6a\x02\u{4da}\u{4db}\x0c\x0b\x02\x02\u{4db}\u{4dc}\x05\
	\u{92}\x4a\x02\u{4dc}\u{4dd}\x05\x72\x3a\x02\u{4dd}\u{4e3}\x03\x02\x02\x02\
	\u{4de}\u{4df}\x0c\x0a\x02\x02\u{4df}\u{4e0}\x05\u{94}\x4b\x02\u{4e0}\u{4e1}\
	\x05\x72\x3a\x02\u{4e1}\u{4e3}\x03\x02\x02\x02\u{4e2}\u{4bc}\x03\x02\x02\
	\x02\u{4e2}\u{4c0}\x03\x02\x02\x02\u{4e2}\u{4c4}\x03\x02\x02\x02\u{4e2}\
	\u{4c8}\x03\x02\x02\x02\u{4e2}\u{4cc}\x03\x02\x02\x02\u{4e2}\u{4d0}\x03\
	\x02\x02\x02\u{4e2}\u{4d4}\x03\x02\x02\x02\u{4e2}\u{4d6}\x03\x02\x02\x02\
	\u{4e2}\u{4d8}\x03\x02\x02\x02\u{4e2}\u{4da}\x03\x02\x02\x02\u{4e2}\u{4de}\
	\x03\x02\x02\x02\u{4e3}\u{4e6}\x03\x02\x02\x02\u{4e4}\u{4e2}\x03\x02\x02\
	\x02\u{4e4}\u{4e5}\x03\x02\x02\x02\u{4e5}\x71\x03\x02\x02\x02\u{4e6}\u{4e4}\
	\x03\x02\x02\x02\u{4e7}\u{4e8}\x08\x3a\x01\x02\u{4e8}\u{4e9}\x05\x78\x3d\
	\x02\u{4e9}\u{4ea}\x05\x72\x3a\x0a\u{4ea}\u{4fe}\x03\x02\x02\x02\u{4eb}\
	\u{4f9}\x07\x0a\x02\x02\u{4ec}\u{4ed}\x05\x72\x3a\x02\u{4ed}\u{4ee}\x07\
	\x05\x02\x02\u{4ee}\u{4fa}\x03\x02\x02\x02\u{4ef}\u{4f2}\x05\x72\x3a\x02\
	\u{4f0}\u{4f1}\x07\x05\x02\x02\u{4f1}\u{4f3}\x05\x72\x3a\x02\u{4f2}\u{4f0}\
	\x03\x02\x02\x02\u{4f3}\u{4f4}\x03\x02\x02\x02\u{4f4}\u{4f2}\x03\x02\x02\
	\x02\u{4f4}\u{4f5}\x03\x02\x02\x02\u{4f5}\u{4f7}\x03\x02\x02\x02\u{4f6}\
	\u{4f8}\x07\x05\x02\x02\u{4f7}\u{4f6}\x03\x02\x02\x02\u{4f7}\u{4f8}\x03\
	\x02\x02\x02\u{4f8}\u{4fa}\x03\x02\x02\x02\u{4f9}\u{4ec}\x03\x02\x02\x02\
	\u{4f9}\u{4ef}\x03\x02\x02\x02\u{4f9}\u{4fa}\x03\x02\x02\x02\u{4fa}\u{4fb}\
	\x03\x02\x02\x02\u{4fb}\u{4fe}\x07\x0b\x02\x02\u{4fc}\u{4fe}\x05\x74\x3b\
	\x02\u{4fd}\u{4e7}\x03\x02\x02\x02\u{4fd}\u{4eb}\x03\x02\x02\x02\u{4fd}\
	\u{4fc}\x03\x02\x02\x02\u{4fe}\u{510}\x03\x02\x02\x02\u{4ff}\u{500}\x0c\
	\x08\x02\x02\u{500}\u{501}\x05\x7e\x40\x02\u{501}\u{502}\x05\x72\x3a\x09\
	\u{502}\u{50f}\x03\x02\x02\x02\u{503}\u{504}\x0c\x07\x02\x02\u{504}\u{505}\
	\x05\u{86}\x44\x02\u{505}\u{506}\x05\x72\x3a\x08\u{506}\u{50f}\x03\x02\x02\
	\x02\u{507}\u{508}\x0c\x06\x02\x02\u{508}\u{509}\x07\x1c\x02\x02\u{509}\
	\u{50f}\x05\x72\x3a\x07\u{50a}\u{50b}\x0c\x09\x02\x02\u{50b}\u{50f}\x05\
	\u{9e}\x50\x02\u{50c}\u{50d}\x0c\x05\x02\x02\u{50d}\u{50f}\x05\u{9e}\x50\
	\x02\u{50e}\u{4ff}\x03\x02\x02\x02\u{50e}\u{503}\x03\x02\x02\x02\u{50e}\
	\u{507}\x03\x02\x02\x02\u{50e}\u{50a}\x03\x02\x02\x02\u{50e}\u{50c}\x03\
	\x02\x02\x02\u{50f}\u{512}\x03\x02\x02\x02\u{510}\u{50e}\x03\x02\x02\x02\
	\u{510}\u{511}\x03\x02\x02\x02\u{511}\x73\x03\x02\x02\x02\u{512}\u{510}\
	\x03\x02\x02\x02\u{513}\u{51a}\x05\u{ee}\x78\x02\u{514}\u{51a}\x05\u{ea}\
	\x76\x02\u{515}\u{51a}\x05\u{de}\x70\x02\u{516}\u{51a}\x05\u{e0}\x71\x02\
	\u{517}\u{51a}\x05\u{e4}\x73\x02\u{518}\u{51a}\x07\u{94}\x02\x02\u{519}\
	\u{513}\x03\x02\x02\x02\u{519}\u{514}\x03\x02\x02\x02\u{519}\u{515}\x03\
	\x02\x02\x02\u{519}\u{516}\x03\x02\x02\x02\u{519}\u{517}\x03\x02\x02\x02\
	\u{519}\u{518}\x03\x02\x02\x02\u{51a}\x75\x03\x02\x02\x02\u{51b}\u{521}\
	\x07\u{8e}\x02\x02\u{51c}\u{51e}\x07\u{8f}\x02\x02\u{51d}\u{51f}\x05\x6e\
	\x38\x02\u{51e}\u{51d}\x03\x02\x02\x02\u{51e}\u{51f}\x03\x02\x02\x02\u{51f}\
	\u{521}\x03\x02\x02\x02\u{520}\u{51b}\x03\x02\x02\x02\u{520}\u{51c}\x03\
	\x02\x02\x02\u{521}\u{53c}\x03\x02\x02\x02\u{522}\u{525}\x07\u{91}\x02\x02\
	\u{523}\u{524}\x07\x6c\x02\x02\u{524}\u{526}\x05\u{e6}\x74\x02\u{525}\u{523}\
	\x03\x02\x02\x02\u{525}\u{526}\x03\x02\x02\x02\u{526}\u{53c}\x03\x02\x02\
	\x02\u{527}\u{52a}\x07\u{92}\x02\x02\u{528}\u{529}\x07\x6c\x02\x02\u{529}\
	\u{52b}\x05\u{e6}\x74\x02\u{52a}\u{528}\x03\x02\x02\x02\u{52a}\u{52b}\x03\
	\x02\x02\x02\u{52b}\u{53c}\x03\x02\x02\x02\u{52c}\u{52d}\x07\u{93}\x02\x02\
	\u{52d}\u{53c}\x05\x6e\x38\x02\u{52e}\u{531}\x07\u{90}\x02\x02\u{52f}\u{530}\
	\x07\x6c\x02\x02\u{530}\u{532}\x05\u{e6}\x74\x02\u{531}\u{52f}\x03\x02\x02\
	\x02\u{531}\u{532}\x03\x02\x02\x02\u{532}\u{534}\x03\x02\x02\x02\u{533}\
	\u{535}\x05\x6e\x38\x02\u{534}\u{533}\x03\x02\x02\x02\u{534}\u{535}\x03\
	\x02\x02\x02\u{535}\u{53c}\x03\x02\x02\x02\u{536}\u{537}\x07\u{90}\x02\x02\
	\u{537}\u{53c}\x07\u{91}\x02\x02\u{538}\u{539}\x07\u{90}\x02\x02\u{539}\
	\u{53a}\x07\u{83}\x02\x02\u{53a}\u{53c}\x05\x6e\x38\x02\u{53b}\u{520}\x03\
	\x02\x02\x02\u{53b}\u{522}\x03\x02\x02\x02\u{53b}\u{527}\x03\x02\x02\x02\
	\u{53b}\u{52c}\x03\x02\x02\x02\u{53b}\u{52e}\x03\x02\x02\x02\u{53b}\u{536}\
	\x03\x02\x02\x02\u{53b}\u{538}\x03\x02\x02\x02\u{53c}\x77\x03\x02\x02\x02\
	\u{53d}\u{53e}\x09\x0a\x02\x02\u{53e}\x79\x03\x02\x02\x02\u{53f}\u{540}\
	\x09\x0b\x02\x02\u{540}\x7b\x03\x02\x02\x02\u{541}\u{542}\x09\x0c\x02\x02\
	\u{542}\x7d\x03\x02\x02\x02\u{543}\u{544}\x09\x0d\x02\x02\u{544}\x7f\x03\
	\x02\x02\x02\u{545}\u{546}\x09\x0e\x02\x02\u{546}\u{81}\x03\x02\x02\x02\
	\u{547}\u{548}\x09\x0f\x02\x02\u{548}\u{83}\x03\x02\x02\x02\u{549}\u{54a}\
	\x07\x62\x02\x02\u{54a}\u{85}\x03\x02\x02\x02\u{54b}\u{54c}\x09\x10\x02\
	\x02\u{54c}\u{87}\x03\x02\x02\x02\u{54d}\u{54e}\x09\x11\x02\x02\u{54e}\u{89}\
	\x03\x02\x02\x02\u{54f}\u{550}\x09\x12\x02\x02\u{550}\u{8b}\x03\x02\x02\
	\x02\u{551}\u{552}\x09\x13\x02\x02\u{552}\u{8d}\x03\x02\x02\x02\u{553}\u{554}\
	\x09\x14\x02\x02\u{554}\u{8f}\x03\x02\x02\x02\u{555}\u{556}\x09\x15\x02\
	\x02\u{556}\u{91}\x03\x02\x02\x02\u{557}\u{55e}\x07\x5c\x02\x02\u{558}\u{559}\
	\x07\x5c\x02\x02\u{559}\u{55e}\x07\x57\x02\x02\u{55a}\u{55e}\x07\x5d\x02\
	\x02\u{55b}\u{55e}\x07\x5e\x02\x02\u{55c}\u{55e}\x07\x5b\x02\x02\u{55d}\
	\u{557}\x03\x02\x02\x02\u{55d}\u{558}\x03\x02\x02\x02\u{55d}\u{55a}\x03\
	\x02\x02\x02\u{55d}\u{55b}\x03\x02\x02\x02\u{55d}\u{55c}\x03\x02\x02\x02\
	\u{55e}\u{93}\x03\x02\x02\x02\u{55f}\u{560}\x07\x5f\x02\x02\u{560}\u{95}\
	\x03\x02\x02\x02\u{561}\u{567}\x07\x59\x02\x02\u{562}\u{563}\x07\x57\x02\
	\x02\u{563}\u{567}\x07\x59\x02\x02\u{564}\u{567}\x07\x58\x02\x02\u{565}\
	\u{567}\x07\x5a\x02\x02\u{566}\u{561}\x03\x02\x02\x02\u{566}\u{562}\x03\
	\x02\x02\x02\u{566}\u{564}\x03\x02\x02\x02\u{566}\u{565}\x03\x02\x02\x02\
	\u{567}\u{97}\x03\x02\x02\x02\u{568}\u{569}\x07\x10\x02\x02\u{569}\u{58f}\
	\x07\x11\x02\x02\u{56a}\u{56b}\x07\x10\x02\x02\u{56b}\u{570}\x05\u{9a}\x4e\
	\x02\u{56c}\u{56d}\x07\x05\x02\x02\u{56d}\u{56f}\x05\u{9a}\x4e\x02\u{56e}\
	\u{56c}\x03\x02\x02\x02\u{56f}\u{572}\x03\x02\x02\x02\u{570}\u{56e}\x03\
	\x02\x02\x02\u{570}\u{571}\x03\x02\x02\x02\u{571}\u{574}\x03\x02\x02\x02\
	\u{572}\u{570}\x03\x02\x02\x02\u{573}\u{575}\x07\x05\x02\x02\u{574}\u{573}\
	\x03\x02\x02\x02\u{574}\u{575}\x03\x02\x02\x02\u{575}\u{576}\x03\x02\x02\
	\x02\u{576}\u{577}\x07\x11\x02\x02\u{577}\u{58f}\x03\x02\x02\x02\u{578}\
	\u{57a}\x07\x08\x02\x02\u{579}\u{578}\x03\x02\x02\x02\u{579}\u{57a}\x03\
	\x02\x02\x02\u{57a}\u{57b}\x03\x02\x02\x02\u{57b}\u{57c}\x07\x2d\x02\x02\
	\u{57c}\u{58f}\x07\x32\x02\x02\u{57d}\u{57f}\x07\x08\x02\x02\u{57e}\u{57d}\
	\x03\x02\x02\x02\u{57e}\u{57f}\x03\x02\x02\x02\u{57f}\u{580}\x03\x02\x02\
	\x02\u{580}\u{581}\x07\x2d\x02\x02\u{581}\u{586}\x05\u{9a}\x4e\x02\u{582}\
	\u{583}\x07\x05\x02\x02\u{583}\u{585}\x05\u{9a}\x4e\x02\u{584}\u{582}\x03\
	\x02\x02\x02\u{585}\u{588}\x03\x02\x02\x02\u{586}\u{584}\x03\x02\x02\x02\
	\u{586}\u{587}\x03\x02\x02\x02\u{587}\u{58a}\x03\x02\x02\x02\u{588}\u{586}\
	\x03\x02\x02\x02\u{589}\u{58b}\x07\x05\x02\x02\u{58a}\u{589}\x03\x02\x02\
	\x02\u{58a}\u{58b}\x03\x02\x02\x02\u{58b}\u{58c}\x03\x02\x02\x02\u{58c}\
	\u{58d}\x07\x32\x02\x02\u{58d}\u{58f}\x03\x02\x02\x02\u{58e}\u{568}\x03\
	\x02\x02\x02\u{58e}\u{56a}\x03\x02\x02\x02\u{58e}\u{579}\x03\x02\x02\x02\
	\u{58e}\u{57e}\x03\x02\x02\x02\u{58f}\u{99}\x03\x02\x02\x02\u{590}\u{591}\
	\x05\u{e6}\x74\x02\u{591}\u{592}\x07\x09\x02\x02\u{592}\u{594}\x03\x02\x02\
	\x02\u{593}\u{590}\x03\x02\x02\x02\u{593}\u{594}\x03\x02\x02\x02\u{594}\
	\u{595}\x03\x02\x02\x02\u{595}\u{596}\x05\x72\x3a\x02\u{596}\u{9b}\x03\x02\
	\x02\x02\u{597}\u{598}\x07\x08\x02\x02\u{598}\u{599}\x07\x2d\x02\x02\u{599}\
	\u{5ba}\x07\x32\x02\x02\u{59a}\u{59b}\x07\x08\x02\x02\u{59b}\u{59c}\x07\
	\x2d\x02\x02\u{59c}\u{5a1}\x05\u{a0}\x51\x02\u{59d}\u{59e}\x07\x05\x02\x02\
	\u{59e}\u{5a0}\x05\u{a0}\x51\x02\u{59f}\u{59d}\x03\x02\x02\x02\u{5a0}\u{5a3}\
	\x03\x02\x02\x02\u{5a1}\u{59f}\x03\x02\x02\x02\u{5a1}\u{5a2}\x03\x02\x02\
	\x02\u{5a2}\u{5a5}\x03\x02\x02\x02\u{5a3}\u{5a1}\x03\x02\x02\x02\u{5a4}\
	\u{5a6}\x07\x05\x02\x02\u{5a5}\u{5a4}\x03\x02\x02\x02\u{5a5}\u{5a6}\x03\
	\x02\x02\x02\u{5a6}\u{5a7}\x03\x02\x02\x02\u{5a7}\u{5a8}\x07\x32\x02\x02\
	\u{5a8}\u{5ba}\x03\x02\x02\x02\u{5a9}\u{5aa}\x07\x10\x02\x02\u{5aa}\u{5ba}\
	\x07\x11\x02\x02\u{5ab}\u{5ac}\x07\x10\x02\x02\u{5ac}\u{5b1}\x05\u{a0}\x51\
	\x02\u{5ad}\u{5ae}\x07\x05\x02\x02\u{5ae}\u{5b0}\x05\u{a0}\x51\x02\u{5af}\
	\u{5ad}\x03\x02\x02\x02\u{5b0}\u{5b3}\x03\x02\x02\x02\u{5b1}\u{5af}\x03\
	\x02\x02\x02\u{5b1}\u{5b2}\x03\x02\x02\x02\u{5b2}\u{5b5}\x03\x02\x02\x02\
	\u{5b3}\u{5b1}\x03\x02\x02\x02\u{5b4}\u{5b6}\x07\x05\x02\x02\u{5b5}\u{5b4}\
	\x03\x02\x02\x02\u{5b5}\u{5b6}\x03\x02\x02\x02\u{5b6}\u{5b7}\x03\x02\x02\
	\x02\u{5b7}\u{5b8}\x07\x11\x02\x02\u{5b8}\u{5ba}\x03\x02\x02\x02\u{5b9}\
	\u{597}\x03\x02\x02\x02\u{5b9}\u{59a}\x03\x02\x02\x02\u{5b9}\u{5a9}\x03\
	\x02\x02\x02\u{5b9}\u{5ab}\x03\x02\x02\x02\u{5ba}\u{9d}\x03\x02\x02\x02\
	\u{5bb}\u{5bd}\x07\x08\x02\x02\u{5bc}\u{5bb}\x03\x02\x02\x02\u{5bc}\u{5bd}\
	\x03\x02\x02\x02\u{5bd}\u{5be}\x03\x02\x02\x02\u{5be}\u{5bf}\x07\x2d\x02\
	\x02\u{5bf}\u{5c4}\x05\u{a0}\x51\x02\u{5c0}\u{5c1}\x07\x05\x02\x02\u{5c1}\
	\u{5c3}\x05\u{a0}\x51\x02\u{5c2}\u{5c0}\x03\x02\x02\x02\u{5c3}\u{5c6}\x03\
	\x02\x02\x02\u{5c4}\u{5c2}\x03\x02\x02\x02\u{5c4}\u{5c5}\x03\x02\x02\x02\
	\u{5c5}\u{5c7}\x03\x02\x02\x02\u{5c6}\u{5c4}\x03\x02\x02\x02\u{5c7}\u{5c8}\
	\x07\x32\x02\x02\u{5c8}\u{5d5}\x03\x02\x02\x02\u{5c9}\u{5ca}\x07\x10\x02\
	\x02\u{5ca}\u{5cf}\x05\u{a0}\x51\x02\u{5cb}\u{5cc}\x07\x05\x02\x02\u{5cc}\
	\u{5ce}\x05\u{a0}\x51\x02\u{5cd}\u{5cb}\x03\x02\x02\x02\u{5ce}\u{5d1}\x03\
	\x02\x02\x02\u{5cf}\u{5cd}\x03\x02\x02\x02\u{5cf}\u{5d0}\x03\x02\x02\x02\
	\u{5d0}\u{5d2}\x03\x02\x02\x02\u{5d1}\u{5cf}\x03\x02\x02\x02\u{5d2}\u{5d3}\
	\x07\x11\x02\x02\u{5d3}\u{5d5}\x03\x02\x02\x02\u{5d4}\u{5bc}\x03\x02\x02\
	\x02\u{5d4}\u{5c9}\x03\x02\x02\x02\u{5d5}\u{9f}\x03\x02\x02\x02\u{5d6}\u{5d7}\
	\x05\u{e6}\x74\x02\u{5d7}\u{5d8}\x07\x09\x02\x02\u{5d8}\u{5da}\x03\x02\x02\
	\x02\u{5d9}\u{5d6}\x03\x02\x02\x02\u{5d9}\u{5da}\x03\x02\x02\x02\u{5da}\
	\u{5db}\x03\x02\x02\x02\u{5db}\u{5dc}\x05\x72\x3a\x02\u{5dc}\u{a1}\x03\x02\
	\x02\x02\u{5dd}\u{5de}\x07\x6c\x02\x02\u{5de}\u{5df}\x05\u{e6}\x74\x02\u{5df}\
	\u{a3}\x03\x02\x02\x02\u{5e0}\u{5e2}\x05\u{b2}\x5a\x02\u{5e1}\u{5e0}\x03\
	\x02\x02\x02\u{5e2}\u{5e5}\x03\x02\x02\x02\u{5e3}\u{5e1}\x03\x02\x02\x02\
	\u{5e3}\u{5e4}\x03\x02\x02\x02\u{5e4}\u{5e6}\x03\x02\x02\x02\u{5e5}\u{5e3}\
	\x03\x02\x02\x02\u{5e6}\u{5e7}\x05\u{d8}\x6d\x02\u{5e7}\u{5e8}\x07\x75\x02\
	\x02\u{5e8}\u{5e9}\x05\u{a6}\x54\x02\u{5e9}\u{600}\x03\x02\x02\x02\u{5ea}\
	\u{5ec}\x05\u{b2}\x5a\x02\u{5eb}\u{5ea}\x03\x02\x02\x02\u{5ec}\u{5ef}\x03\
	\x02\x02\x02\u{5ed}\u{5eb}\x03\x02\x02\x02\u{5ed}\u{5ee}\x03\x02\x02\x02\
	\u{5ee}\u{5f0}\x03\x02\x02\x02\u{5ef}\u{5ed}\x03\x02\x02\x02\u{5f0}\u{5f1}\
	\x05\u{d8}\x6d\x02\u{5f1}\u{5f2}\x07\x75\x02\x02\u{5f2}\u{5f7}\x05\u{e6}\
	\x74\x02\u{5f3}\u{5f4}\x07\x05\x02\x02\u{5f4}\u{5f6}\x05\u{e6}\x74\x02\u{5f5}\
	\u{5f3}\x03\x02\x02\x02\u{5f6}\u{5f9}\x03\x02\x02\x02\u{5f7}\u{5f5}\x03\
	\x02\x02\x02\u{5f7}\u{5f8}\x03\x02\x02\x02\u{5f8}\u{5fb}\x03\x02\x02\x02\
	\u{5f9}\u{5f7}\x03\x02\x02\x02\u{5fa}\u{5fc}\x07\x05\x02\x02\u{5fb}\u{5fa}\
	\x03\x02\x02\x02\u{5fb}\u{5fc}\x03\x02\x02\x02\u{5fc}\u{5fd}\x03\x02\x02\
	\x02\u{5fd}\u{5fe}\x05\u{a6}\x54\x02\u{5fe}\u{600}\x03\x02\x02\x02\u{5ff}\
	\u{5e3}\x03\x02\x02\x02\u{5ff}\u{5ed}\x03\x02\x02\x02\u{600}\u{a5}\x03\x02\
	\x02\x02\u{601}\u{606}\x07\x0e\x02\x02\u{602}\u{605}\x05\u{a8}\x55\x02\u{603}\
	\u{605}\x05\x06\x04\x02\u{604}\u{602}\x03\x02\x02\x02\u{604}\u{603}\x03\
	\x02\x02\x02\u{605}\u{608}\x03\x02\x02\x02\u{606}\u{604}\x03\x02\x02\x02\
	\u{606}\u{607}\x03\x02\x02\x02\u{607}\u{609}\x03\x02\x02\x02\u{608}\u{606}\
	\x03\x02\x02\x02\u{609}\u{60a}\x07\x0f\x02\x02\u{60a}\u{a7}\x03\x02\x02\
	\x02\u{60b}\u{60c}\x07\x03\x02\x02\u{60c}\u{613}\x05\u{aa}\x56\x02\u{60d}\
	\u{60e}\x07\u{8e}\x02\x02\u{60e}\u{613}\x05\x72\x3a\x02\u{60f}\u{610}\x05\
	\u{e6}\x74\x02\u{610}\u{611}\x05\u{ae}\x58\x02\u{611}\u{613}\x03\x02\x02\
	\x02\u{612}\u{60b}\x03\x02\x02\x02\u{612}\u{60d}\x03\x02\x02\x02\u{612}\
	\u{60f}\x03\x02\x02\x02\u{613}\u{a9}\x03\x02\x02\x02\u{614}\u{618}\x07\x0e\
	\x02\x02\u{615}\u{617}\x05\u{ac}\x57\x02\u{616}\u{615}\x03\x02\x02\x02\u{617}\
	\u{61a}\x03\x02\x02\x02\u{618}\u{616}\x03\x02\x02\x02\u{618}\u{619}\x03\
	\x02\x02\x02\u{619}\u{61b}\x03\x02\x02\x02\u{61a}\u{618}\x03\x02\x02\x02\
	\u{61b}\u{61c}\x07\x0f\x02\x02\u{61c}\u{ab}\x03\x02\x02\x02\u{61d}\u{61e}\
	\x05\u{e6}\x74\x02\u{61e}\u{61f}\x07\x09\x02\x02\u{61f}\u{620}\x05\x72\x3a\
	\x02\u{620}\u{623}\x03\x02\x02\x02\u{621}\u{623}\x05\x06\x04\x02\u{622}\
	\u{61d}\x03\x02\x02\x02\u{622}\u{621}\x03\x02\x02\x02\u{623}\u{ad}\x03\x02\
	\x02\x02\u{624}\u{629}\x07\x0e\x02\x02\u{625}\u{628}\x05\x6c\x37\x02\u{626}\
	\u{628}\x05\x06\x04\x02\u{627}\u{625}\x03\x02\x02\x02\u{627}\u{626}\x03\
	\x02\x02\x02\u{628}\u{62b}\x03\x02\x02\x02\u{629}\u{627}\x03\x02\x02\x02\
	\u{629}\u{62a}\x03\x02\x02\x02\u{62a}\u{62c}\x03\x02\x02\x02\u{62b}\u{629}\
	\x03\x02\x02\x02\u{62c}\u{62d}\x07\x0f\x02\x02\u{62d}\u{af}\x03\x02\x02\
	\x02\u{62e}\u{62f}\x07\x4e\x02\x02\u{62f}\u{631}\x05\u{b4}\x5b\x02\u{630}\
	\u{632}\x05\x18\x0d\x02\u{631}\u{630}\x03\x02\x02\x02\u{631}\u{632}\x03\
	\x02\x02\x02\u{632}\u{642}\x03\x02\x02\x02\u{633}\u{634}\x07\x4e\x02\x02\
	\u{634}\u{635}\x07\x0c\x02\x02\u{635}\u{63a}\x05\u{b4}\x5b\x02\u{636}\u{637}\
	\x07\x05\x02\x02\u{637}\u{639}\x05\u{b4}\x5b\x02\u{638}\u{636}\x03\x02\x02\
	\x02\u{639}\u{63c}\x03\x02\x02\x02\u{63a}\u{638}\x03\x02\x02\x02\u{63a}\
	\u{63b}\x03\x02\x02\x02\u{63b}\u{63d}\x03\x02\x02\x02\u{63c}\u{63a}\x03\
	\x02\x02\x02\u{63d}\u{63f}\x07\x0d\x02\x02\u{63e}\u{640}\x05\x18\x0d\x02\
	\u{63f}\u{63e}\x03\x02\x02\x02\u{63f}\u{640}\x03\x02\x02\x02\u{640}\u{642}\
	\x03\x02\x02\x02\u{641}\u{62e}\x03\x02\x02\x02\u{641}\u{633}\x03\x02\x02\
	\x02\u{642}\u{b1}\x03\x02\x02\x02\u{643}\u{644}\x07\x4f\x02\x02\u{644}\u{646}\
	\x05\u{b4}\x5b\x02\u{645}\u{647}\x05\x18\x0d\x02\u{646}\u{645}\x03\x02\x02\
	\x02\u{646}\u{647}\x03\x02\x02\x02\u{647}\u{657}\x03\x02\x02\x02\u{648}\
	\u{649}\x07\x4f\x02\x02\u{649}\u{64a}\x07\x0c\x02\x02\u{64a}\u{64f}\x05\
	\u{b4}\x5b\x02\u{64b}\u{64c}\x07\x05\x02\x02\u{64c}\u{64e}\x05\u{b4}\x5b\
	\x02\u{64d}\u{64b}\x03\x02\x02\x02\u{64e}\u{651}\x03\x02\x02\x02\u{64f}\
	\u{64d}\x03\x02\x02\x02\u{64f}\u{650}\x03\x02\x02\x02\u{650}\u{652}\x03\
	\x02\x02\x02\u{651}\u{64f}\x03\x02\x02\x02\u{652}\u{654}\x07\x0d\x02\x02\
	\u{653}\u{655}\x05\x18\x0d\x02\u{654}\u{653}\x03\x02\x02\x02\u{654}\u{655}\
	\x03\x02\x02\x02\u{655}\u{657}\x03\x02\x02\x02\u{656}\u{643}\x03\x02\x02\
	\x02\u{656}\u{648}\x03\x02\x02\x02\u{657}\u{b3}\x03\x02\x02\x02\u{658}\u{65a}\
	\x05\u{e4}\x73\x02\u{659}\u{65b}\x05\x4a\x26\x02\u{65a}\u{659}\x03\x02\x02\
	\x02\u{65a}\u{65b}\x03\x02\x02\x02\u{65b}\u{65d}\x03\x02\x02\x02\u{65c}\
	\u{65e}\x05\x18\x0d\x02\u{65d}\u{65c}\x03\x02\x02\x02\u{65d}\u{65e}\x03\
	\x02\x02\x02\u{65e}\u{b5}\x03\x02\x02\x02\u{65f}\u{661}\x05\u{b2}\x5a\x02\
	\u{660}\u{65f}\x03\x02\x02\x02\u{661}\u{664}\x03\x02\x02\x02\u{662}\u{660}\
	\x03\x02\x02\x02\u{662}\u{663}\x03\x02\x02\x02\u{663}\u{665}\x03\x02\x02\
	\x02\u{664}\u{662}\x03\x02\x02\x02\u{665}\u{667}\x07\u{80}\x02\x02\u{666}\
	\u{668}\x05\x72\x3a\x02\u{667}\u{666}\x03\x02\x02\x02\u{667}\u{668}\x03\
	\x02\x02\x02\u{668}\u{669}\x03\x02\x02\x02\u{669}\u{66a}\x05\x50\x29\x02\
	\u{66a}\u{b7}\x03\x02\x02\x02\u{66b}\u{66d}\x05\u{b2}\x5a\x02\u{66c}\u{66b}\
	\x03\x02\x02\x02\u{66d}\u{670}\x03\x02\x02\x02\u{66e}\u{66c}\x03\x02\x02\
	\x02\u{66e}\u{66f}\x03\x02\x02\x02\u{66f}\u{671}\x03\x02\x02\x02\u{670}\
	\u{66e}\x03\x02\x02\x02\u{671}\u{675}\x09\x09\x02\x02\u{672}\u{673}\x05\
	\u{e6}\x74\x02\u{673}\u{674}\x07\x38\x02\x02\u{674}\u{676}\x03\x02\x02\x02\
	\u{675}\u{672}\x03\x02\x02\x02\u{675}\u{676}\x03\x02\x02\x02\u{676}\u{677}\
	\x03\x02\x02\x02\u{677}\u{678}\x05\x70\x39\x02\u{678}\u{679}\x05\u{ba}\x5e\
	\x02\u{679}\u{b9}\x03\x02\x02\x02\u{67a}\u{67f}\x07\x0e\x02\x02\u{67b}\u{67e}\
	\x05\u{bc}\x5f\x02\u{67c}\u{67e}\x05\x06\x04\x02\u{67d}\u{67b}\x03\x02\x02\
	\x02\u{67d}\u{67c}\x03\x02\x02\x02\u{67e}\u{681}\x03\x02\x02\x02\u{67f}\
	\u{67d}\x03\x02\x02\x02\u{67f}\u{680}\x03\x02\x02\x02\u{680}\u{682}\x03\
	\x02\x02\x02\u{681}\u{67f}\x03\x02\x02\x02\u{682}\u{683}\x07\x0f\x02\x02\
	\u{683}\u{bb}\x03\x02\x02\x02\u{684}\u{686}\x05\u{b2}\x5a\x02\u{685}\u{684}\
	\x03\x02\x02\x02\u{686}\u{689}\x03\x02\x02\x02\u{687}\u{685}\x03\x02\x02\
	\x02\u{687}\u{688}\x03\x02\x02\x02\u{688}\u{68a}\x03\x02\x02\x02\u{689}\
	\u{687}\x03\x02\x02\x02\u{68a}\u{68b}\x07\u{83}\x02\x02\u{68b}\u{6d1}\x05\
	\u{e6}\x74\x02\u{68c}\u{68e}\x05\u{b2}\x5a\x02\u{68d}\u{68c}\x03\x02\x02\
	\x02\u{68e}\u{691}\x03\x02\x02\x02\u{68f}\u{68d}\x03\x02\x02\x02\u{68f}\
	\u{690}\x03\x02\x02\x02\u{690}\u{692}\x03\x02\x02\x02\u{691}\u{68f}\x03\
	\x02\x02\x02\u{692}\u{693}\x07\u{83}\x02\x02\u{693}\u{69f}\x07\x0c\x02\x02\
	\u{694}\u{699}\x05\u{e6}\x74\x02\u{695}\u{696}\x07\x05\x02\x02\u{696}\u{698}\
	\x05\u{e6}\x74\x02\u{697}\u{695}\x03\x02\x02\x02\u{698}\u{69b}\x03\x02\x02\
	\x02\u{699}\u{697}\x03\x02\x02\x02\u{699}\u{69a}\x03\x02\x02\x02\u{69a}\
	\u{69d}\x03\x02\x02\x02\u{69b}\u{699}\x03\x02\x02\x02\u{69c}\u{69e}\x07\
	\x05\x02\x02\u{69d}\u{69c}\x03\x02\x02\x02\u{69d}\u{69e}\x03\x02\x02\x02\
	\u{69e}\u{6a0}\x03\x02\x02\x02\u{69f}\u{694}\x03\x02\x02\x02\u{69f}\u{6a0}\
	\x03\x02\x02\x02\u{6a0}\u{6a1}\x03\x02\x02\x02\u{6a1}\u{6d1}\x07\x0d\x02\
	\x02\u{6a2}\u{6a4}\x05\u{b2}\x5a\x02\u{6a3}\u{6a2}\x03\x02\x02\x02\u{6a4}\
	\u{6a7}\x03\x02\x02\x02\u{6a5}\u{6a3}\x03\x02\x02\x02\u{6a5}\u{6a6}\x03\
	\x02\x02\x02\u{6a6}\u{6a8}\x03\x02\x02\x02\u{6a7}\u{6a5}\x03\x02\x02\x02\
	\u{6a8}\u{6a9}\x07\x74\x02\x02\u{6a9}\u{6ac}\x05\x72\x3a\x02\u{6aa}\u{6ab}\
	\x07\u{8b}\x02\x02\u{6ab}\u{6ad}\x05\x70\x39\x02\u{6ac}\u{6aa}\x03\x02\x02\
	\x02\u{6ac}\u{6ad}\x03\x02\x02\x02\u{6ad}\u{6ae}\x03\x02\x02\x02\u{6ae}\
	\u{6af}\x05\u{be}\x60\x02\u{6af}\u{6d1}\x03\x02\x02\x02\u{6b0}\u{6b2}\x05\
	\u{b2}\x5a\x02\u{6b1}\u{6b0}\x03\x02\x02\x02\u{6b2}\u{6b5}\x03\x02\x02\x02\
	\u{6b3}\u{6b1}\x03\x02\x02\x02\u{6b3}\u{6b4}\x03\x02\x02\x02\u{6b4}\u{6b6}\
	\x03\x02\x02\x02\u{6b5}\u{6b3}\x03\x02\x02\x02\u{6b6}\u{6b7}\x07\u{85}\x02\
	\x02\u{6b7}\u{6b8}\x05\x70\x39\x02\u{6b8}\u{6b9}\x05\u{be}\x60\x02\u{6b9}\
	\u{6d1}\x03\x02\x02\x02\u{6ba}\u{6bc}\x05\u{b2}\x5a\x02\u{6bb}\u{6ba}\x03\
	\x02\x02\x02\u{6bc}\u{6bf}\x03\x02\x02\x02\u{6bd}\u{6bb}\x03\x02\x02\x02\
	\u{6bd}\u{6be}\x03\x02\x02\x02\u{6be}\u{6c0}\x03\x02\x02\x02\u{6bf}\u{6bd}\
	\x03\x02\x02\x02\u{6c0}\u{6c1}\x07\u{8c}\x02\x02\u{6c1}\u{6d1}\x05\u{be}\
	\x60\x02\u{6c2}\u{6c4}\x05\u{b2}\x5a\x02\u{6c3}\u{6c2}\x03\x02\x02\x02\u{6c4}\
	\u{6c7}\x03\x02\x02\x02\u{6c5}\u{6c3}\x03\x02\x02\x02\u{6c5}\u{6c6}\x03\
	\x02\x02\x02\u{6c6}\u{6c8}\x03\x02\x02\x02\u{6c7}\u{6c5}\x03\x02\x02\x02\
	\u{6c8}\u{6c9}\x07\u{84}\x02\x02\u{6c9}\u{6cc}\x05\u{c0}\x61\x02\u{6ca}\
	\u{6cb}\x07\u{8b}\x02\x02\u{6cb}\u{6cd}\x05\x70\x39\x02\u{6cc}\u{6ca}\x03\
	\x02\x02\x02\u{6cc}\u{6cd}\x03\x02\x02\x02\u{6cd}\u{6ce}\x03\x02\x02\x02\
	\u{6ce}\u{6cf}\x05\u{be}\x60\x02\u{6cf}\u{6d1}\x03\x02\x02\x02\u{6d0}\u{687}\
	\x03\x02\x02\x02\u{6d0}\u{68f}\x03\x02\x02\x02\u{6d0}\u{6a5}\x03\x02\x02\
	\x02\u{6d0}\u{6b3}\x03\x02\x02\x02\u{6d0}\u{6bd}\x03\x02\x02\x02\u{6d0}\
	\u{6c5}\x03\x02\x02\x02\u{6d1}\u{bd}\x03\x02\x02\x02\u{6d2}\u{6d6}\x07\x09\
	\x02\x02\u{6d3}\u{6d5}\x05\x6e\x38\x02\u{6d4}\u{6d3}\x03\x02\x02\x02\u{6d5}\
	\u{6d8}\x03\x02\x02\x02\u{6d6}\u{6d4}\x03\x02\x02\x02\u{6d6}\u{6d7}\x03\
	\x02\x02\x02\u{6d7}\u{bf}\x03\x02\x02\x02\u{6d8}\u{6d6}\x03\x02\x02\x02\
	\u{6d9}\u{6da}\x08\x61\x01\x02\u{6da}\u{6db}\x05\u{c2}\x62\x02\u{6db}\u{6e4}\
	\x03\x02\x02\x02\u{6dc}\u{6dd}\x0c\x05\x02\x02\u{6dd}\u{6de}\x09\x16\x02\
	\x02\u{6de}\u{6e3}\x05\u{c0}\x61\x06\u{6df}\u{6e0}\x0c\x04\x02\x02\u{6e0}\
	\u{6e1}\x07\x62\x02\x02\u{6e1}\u{6e3}\x05\u{c0}\x61\x05\u{6e2}\u{6dc}\x03\
	\x02\x02\x02\u{6e2}\u{6df}\x03\x02\x02\x02\u{6e3}\u{6e6}\x03\x02\x02\x02\
	\u{6e4}\u{6e2}\x03\x02\x02\x02\u{6e4}\u{6e5}\x03\x02\x02\x02\u{6e5}\u{c1}\
	\x03\x02\x02\x02\u{6e6}\u{6e4}\x03\x02\x02\x02\u{6e7}\u{6fb}\x05\u{c4}\x63\
	\x02\u{6e8}\u{6e9}\x05\u{e6}\x74\x02\u{6e9}\u{6ea}\x07\x38\x02\x02\u{6ea}\
	\u{6eb}\x05\u{c2}\x62\x02\u{6eb}\u{6fb}\x03\x02\x02\x02\u{6ec}\u{6ed}\x05\
	\u{da}\x6e\x02\u{6ed}\u{6f1}\x07\x09\x02\x02\u{6ee}\u{6ef}\x05\u{e6}\x74\
	\x02\u{6ef}\u{6f0}\x07\x38\x02\x02\u{6f0}\u{6f2}\x03\x02\x02\x02\u{6f1}\
	\u{6ee}\x03\x02\x02\x02\u{6f1}\u{6f2}\x03\x02\x02\x02\u{6f2}\u{6f3}\x03\
	\x02\x02\x02\u{6f3}\u{6f4}\x05\u{c2}\x62\x02\u{6f4}\u{6fb}\x03\x02\x02\x02\
	\u{6f5}\u{6fb}\x05\u{da}\x6e\x02\u{6f6}\u{6fb}\x05\u{e4}\x73\x02\u{6f7}\
	\u{6fb}\x05\u{ea}\x76\x02\u{6f8}\u{6fb}\x05\u{ee}\x78\x02\u{6f9}\u{6fb}\
	\x07\u{94}\x02\x02\u{6fa}\u{6e7}\x03\x02\x02\x02\u{6fa}\u{6e8}\x03\x02\x02\
	\x02\u{6fa}\u{6ec}\x03\x02\x02\x02\u{6fa}\u{6f5}\x03\x02\x02\x02\u{6fa}\
	\u{6f6}\x03\x02\x02\x02\u{6fa}\u{6f7}\x03\x02\x02\x02\u{6fa}\u{6f8}\x03\
	\x02\x02\x02\u{6fa}\u{6f9}\x03\x02\x02\x02\u{6fb}\u{c3}\x03\x02\x02\x02\
	\u{6fc}\u{6fe}\x05\u{e4}\x73\x02\u{6fd}\u{6fc}\x03\x02\x02\x02\u{6fd}\u{6fe}\
	\x03\x02\x02\x02\u{6fe}\u{6ff}\x03\x02\x02\x02\u{6ff}\u{700}\x07\x0a\x02\
	\x02\u{700}\u{74f}\x07\x0b\x02\x02\u{701}\u{703}\x05\u{e4}\x73\x02\u{702}\
	\u{701}\x03\x02\x02\x02\u{702}\u{703}\x03\x02\x02\x02\u{703}\u{704}\x03\
	\x02\x02\x02\u{704}\u{705}\x07\x0c\x02\x02\u{705}\u{74f}\x07\x0d\x02\x02\
	\u{706}\u{708}\x05\u{e4}\x73\x02\u{707}\u{706}\x03\x02\x02\x02\u{707}\u{708}\
	\x03\x02\x02\x02\u{708}\u{709}\x03\x02\x02\x02\u{709}\u{70a}\x07\x0e\x02\
	\x02\u{70a}\u{74f}\x07\x0f\x02\x02\u{70b}\u{70c}\x07\x0a\x02\x02\u{70c}\
	\u{70d}\x05\u{c2}\x62\x02\u{70d}\u{70e}\x07\x05\x02\x02\u{70e}\u{70f}\x07\
	\x0b\x02\x02\u{70f}\u{74f}\x03\x02\x02\x02\u{710}\u{711}\x07\x0a\x02\x02\
	\u{711}\u{714}\x05\u{c2}\x62\x02\u{712}\u{713}\x07\x05\x02\x02\u{713}\u{715}\
	\x05\u{c2}\x62\x02\u{714}\u{712}\x03\x02\x02\x02\u{715}\u{716}\x03\x02\x02\
	\x02\u{716}\u{714}\x03\x02\x02\x02\u{716}\u{717}\x03\x02\x02\x02\u{717}\
	\u{719}\x03\x02\x02\x02\u{718}\u{71a}\x07\x05\x02\x02\u{719}\u{718}\x03\
	\x02\x02\x02\u{719}\u{71a}\x03\x02\x02\x02\u{71a}\u{71b}\x03\x02\x02\x02\
	\u{71b}\u{71c}\x07\x0b\x02\x02\u{71c}\u{74f}\x03\x02\x02\x02\u{71d}\u{71e}\
	\x05\u{e4}\x73\x02\u{71e}\u{71f}\x07\x0a\x02\x02\u{71f}\u{724}\x05\u{c2}\
	\x62\x02\u{720}\u{721}\x07\x05\x02\x02\u{721}\u{723}\x05\u{c2}\x62\x02\u{722}\
	\u{720}\x03\x02\x02\x02\u{723}\u{726}\x03\x02\x02\x02\u{724}\u{722}\x03\
	\x02\x02\x02\u{724}\u{725}\x03\x02\x02\x02\u{725}\u{728}\x03\x02\x02\x02\
	\u{726}\u{724}\x03\x02\x02\x02\u{727}\u{729}\x07\x05\x02\x02\u{728}\u{727}\
	\x03\x02\x02\x02\u{728}\u{729}\x03\x02\x02\x02\u{729}\u{72a}\x03\x02\x02\
	\x02\u{72a}\u{72b}\x07\x0b\x02\x02\u{72b}\u{74f}\x03\x02\x02\x02\u{72c}\
	\u{72e}\x05\u{e4}\x73\x02\u{72d}\u{72c}\x03\x02\x02\x02\u{72d}\u{72e}\x03\
	\x02\x02\x02\u{72e}\u{72f}\x03\x02\x02\x02\u{72f}\u{730}\x07\x0c\x02\x02\
	\u{730}\u{735}\x05\u{c2}\x62\x02\u{731}\u{732}\x07\x05\x02\x02\u{732}\u{734}\
	\x05\u{c2}\x62\x02\u{733}\u{731}\x03\x02\x02\x02\u{734}\u{737}\x03\x02\x02\
	\x02\u{735}\u{733}\x03\x02\x02\x02\u{735}\u{736}\x03\x02\x02\x02\u{736}\
	\u{739}\x03\x02\x02\x02\u{737}\u{735}\x03\x02\x02\x02\u{738}\u{73a}\x07\
	\x05\x02\x02\u{739}\u{738}\x03\x02\x02\x02\u{739}\u{73a}\x03\x02\x02\x02\
	\u{73a}\u{73b}\x03\x02\x02\x02\u{73b}\u{73c}\x07\x0d\x02\x02\u{73c}\u{74f}\
	\x03\x02\x02\x02\u{73d}\u{73f}\x05\u{e4}\x73\x02\u{73e}\u{73d}\x03\x02\x02\
	\x02\u{73e}\u{73f}\x03\x02\x02\x02\u{73f}\u{740}\x03\x02\x02\x02\u{740}\
	\u{741}\x07\x0e\x02\x02\u{741}\u{746}\x05\u{c2}\x62\x02\u{742}\u{743}\x07\
	\x05\x02\x02\u{743}\u{745}\x05\u{c2}\x62\x02\u{744}\u{742}\x03\x02\x02\x02\
	\u{745}\u{748}\x03\x02\x02\x02\u{746}\u{744}\x03\x02\x02\x02\u{746}\u{747}\
	\x03\x02\x02\x02\u{747}\u{74a}\x03\x02\x02\x02\u{748}\u{746}\x03\x02\x02\
	\x02\u{749}\u{74b}\x07\x05\x02\x02\u{74a}\u{749}\x03\x02\x02\x02\u{74a}\
	\u{74b}\x03\x02\x02\x02\u{74b}\u{74c}\x03\x02\x02\x02\u{74c}\u{74d}\x07\
	\x0f\x02\x02\u{74d}\u{74f}\x03\x02\x02\x02\u{74e}\u{6fd}\x03\x02\x02\x02\
	\u{74e}\u{702}\x03\x02\x02\x02\u{74e}\u{707}\x03\x02\x02\x02\u{74e}\u{70b}\
	\x03\x02\x02\x02\u{74e}\u{710}\x03\x02\x02\x02\u{74e}\u{71d}\x03\x02\x02\
	\x02\u{74e}\u{72d}\x03\x02\x02\x02\u{74e}\u{73e}\x03\x02\x02\x02\u{74f}\
	\u{c5}\x03\x02\x02\x02\u{750}\u{752}\x07\x7d\x02\x02\u{751}\u{753}\x05\u{98}\
	\x4d\x02\u{752}\u{751}\x03\x02\x02\x02\u{752}\u{753}\x03\x02\x02\x02\u{753}\
	\u{755}\x03\x02\x02\x02\u{754}\u{756}\x05\x1a\x0e\x02\u{755}\u{754}\x03\
	\x02\x02\x02\u{755}\u{756}\x03\x02\x02\x02\u{756}\u{758}\x03\x02\x02\x02\
	\u{757}\u{759}\x05\x5e\x30\x02\u{758}\u{757}\x03\x02\x02\x02\u{758}\u{759}\
	\x03\x02\x02\x02\u{759}\u{75a}\x03\x02\x02\x02\u{75a}\u{75b}\x05\x18\x0d\
	\x02\u{75b}\u{c7}\x03\x02\x02\x02\u{75c}\u{75d}\x07\x7c\x02\x02\u{75d}\u{75f}\
	\x05\u{dc}\x6f\x02\u{75e}\u{760}\x05\u{9e}\x50\x02\u{75f}\u{75e}\x03\x02\
	\x02\x02\u{75f}\u{760}\x03\x02\x02\x02\u{760}\u{762}\x03\x02\x02\x02\u{761}\
	\u{763}\x05\x4a\x26\x02\u{762}\u{761}\x03\x02\x02\x02\u{762}\u{763}\x03\
	\x02\x02\x02\u{763}\u{764}\x03\x02\x02\x02\u{764}\u{765}\x05\u{cc}\x67\x02\
	\u{765}\u{76e}\x03\x02\x02\x02\u{766}\u{767}\x07\x7c\x02\x02\u{767}\u{769}\
	\x05\u{dc}\x6f\x02\u{768}\u{76a}\x05\u{9e}\x50\x02\u{769}\u{768}\x03\x02\
	\x02\x02\u{769}\u{76a}\x03\x02\x02\x02\u{76a}\u{76b}\x03\x02\x02\x02\u{76b}\
	\u{76c}\x05\x4a\x26\x02\u{76c}\u{76e}\x03\x02\x02\x02\u{76d}\u{75c}\x03\
	\x02\x02\x02\u{76d}\u{766}\x03\x02\x02\x02\u{76e}\u{c9}\x03\x02\x02\x02\
	\u{76f}\u{771}\x05\x4a\x26\x02\u{770}\u{76f}\x03\x02\x02\x02\u{770}\u{771}\
	\x03\x02\x02\x02\u{771}\u{772}\x03\x02\x02\x02\u{772}\u{775}\x05\u{cc}\x67\
	\x02\u{773}\u{775}\x05\x4a\x26\x02\u{774}\u{770}\x03\x02\x02\x02\u{774}\
	\u{773}\x03\x02\x02\x02\u{775}\u{cb}\x03\x02\x02\x02\u{776}\u{77b}\x07\x0e\
	\x02\x02\u{777}\u{77a}\x05\x4c\x27\x02\u{778}\u{77a}\x05\x06\x04\x02\u{779}\
	\u{777}\x03\x02\x02\x02\u{779}\u{778}\x03\x02\x02\x02\u{77a}\u{77d}\x03\
	\x02\x02\x02\u{77b}\u{779}\x03\x02\x02\x02\u{77b}\u{77c}\x03\x02\x02\x02\
	\u{77c}\u{77e}\x03\x02\x02\x02\u{77d}\u{77b}\x03\x02\x02\x02\u{77e}\u{77f}\
	\x07\x0f\x02\x02\u{77f}\u{cd}\x03\x02\x02\x02\u{780}\u{781}\x07\x0a\x02\
	\x02\u{781}\u{795}\x07\x0b\x02\x02\u{782}\u{783}\x07\x0a\x02\x02\u{783}\
	\u{786}\x05\u{d0}\x69\x02\u{784}\u{785}\x07\x05\x02\x02\u{785}\u{787}\x05\
	\u{d0}\x69\x02\u{786}\u{784}\x03\x02\x02\x02\u{787}\u{788}\x03\x02\x02\x02\
	\u{788}\u{786}\x03\x02\x02\x02\u{788}\u{789}\x03\x02\x02\x02\u{789}\u{78b}\
	\x03\x02\x02\x02\u{78a}\u{78c}\x07\x05\x02\x02\u{78b}\u{78a}\x03\x02\x02\
	\x02\u{78b}\u{78c}\x03\x02\x02\x02\u{78c}\u{78d}\x03\x02\x02\x02\u{78d}\
	\u{78e}\x07\x0b\x02\x02\u{78e}\u{795}\x03\x02\x02\x02\u{78f}\u{790}\x07\
	\x0a\x02\x02\u{790}\u{791}\x05\u{d0}\x69\x02\u{791}\u{792}\x07\x05\x02\x02\
	\u{792}\u{793}\x07\x0b\x02\x02\u{793}\u{795}\x03\x02\x02\x02\u{794}\u{780}\
	\x03\x02\x02\x02\u{794}\u{782}\x03\x02\x02\x02\u{794}\u{78f}\x03\x02\x02\
	\x02\u{795}\u{cf}\x03\x02\x02\x02\u{796}\u{797}\x05\u{e6}\x74\x02\u{797}\
	\u{798}\x07\x09\x02\x02\u{798}\u{79a}\x03\x02\x02\x02\u{799}\u{796}\x03\
	\x02\x02\x02\u{799}\u{79a}\x03\x02\x02\x02\u{79a}\u{79b}\x03\x02\x02\x02\
	\u{79b}\u{79c}\x05\x6e\x38\x02\u{79c}\u{d1}\x03\x02\x02\x02\u{79d}\u{79f}\
	\x07\x55\x02\x02\u{79e}\u{79d}\x03\x02\x02\x02\u{79e}\u{79f}\x03\x02\x02\
	\x02\u{79f}\u{7a0}\x03\x02\x02\x02\u{7a0}\u{7a1}\x05\u{d4}\x6b\x02\u{7a1}\
	\u{d3}\x03\x02\x02\x02\u{7a2}\u{7ae}\x07\x0c\x02\x02\u{7a3}\u{7a8}\x05\u{d6}\
	\x6c\x02\u{7a4}\u{7a5}\x07\x05\x02\x02\u{7a5}\u{7a7}\x05\u{d6}\x6c\x02\u{7a6}\
	\u{7a4}\x03\x02\x02\x02\u{7a7}\u{7aa}\x03\x02\x02\x02\u{7a8}\u{7a6}\x03\
	\x02\x02\x02\u{7a8}\u{7a9}\x03\x02\x02\x02\u{7a9}\u{7ac}\x03\x02\x02\x02\
	\u{7aa}\u{7a8}\x03\x02\x02\x02\u{7ab}\u{7ad}\x07\x05\x02\x02\u{7ac}\u{7ab}\
	\x03\x02\x02\x02\u{7ac}\u{7ad}\x03\x02\x02\x02\u{7ad}\u{7af}\x03\x02\x02\
	\x02\u{7ae}\u{7a3}\x03\x02\x02\x02\u{7ae}\u{7af}\x03\x02\x02\x02\u{7af}\
	\u{7b0}\x03\x02\x02\x02\u{7b0}\u{7c1}\x07\x0d\x02\x02\u{7b1}\u{7bd}\x07\
	\x12\x02\x02\u{7b2}\u{7b7}\x05\u{d6}\x6c\x02\u{7b3}\u{7b4}\x07\x05\x02\x02\
	\u{7b4}\u{7b6}\x05\u{d6}\x6c\x02\u{7b5}\u{7b3}\x03\x02\x02\x02\u{7b6}\u{7b9}\
	\x03\x02\x02\x02\u{7b7}\u{7b5}\x03\x02\x02\x02\u{7b7}\u{7b8}\x03\x02\x02\
	\x02\u{7b8}\u{7bb}\x03\x02\x02\x02\u{7b9}\u{7b7}\x03\x02\x02\x02\u{7ba}\
	\u{7bc}\x07\x05\x02\x02\u{7bb}\u{7ba}\x03\x02\x02\x02\u{7bb}\u{7bc}\x03\
	\x02\x02\x02\u{7bc}\u{7be}\x03\x02\x02\x02\u{7bd}\u{7b2}\x03\x02\x02\x02\
	\u{7bd}\u{7be}\x03\x02\x02\x02\u{7be}\u{7bf}\x03\x02\x02\x02\u{7bf}\u{7c1}\
	\x07\x13\x02\x02\u{7c0}\u{7a2}\x03\x02\x02\x02\u{7c0}\u{7b1}\x03\x02\x02\
	\x02\u{7c1}\u{d5}\x03\x02\x02\x02\u{7c2}\u{7fb}\x07\x09\x02\x02\u{7c3}\u{7fb}\
	\x05\x6e\x38\x02\u{7c4}\u{7c5}\x05\x6e\x38\x02\u{7c5}\u{7c6}\x07\x09\x02\
	\x02\u{7c6}\u{7fb}\x03\x02\x02\x02\u{7c7}\u{7c8}\x07\x09\x02\x02\u{7c8}\
	\u{7fb}\x05\x6e\x38\x02\u{7c9}\u{7ca}\x05\x6e\x38\x02\u{7ca}\u{7cb}\x07\
	\x09\x02\x02\u{7cb}\u{7cc}\x05\x6e\x38\x02\u{7cc}\u{7fb}\x03\x02\x02\x02\
	\u{7cd}\u{7d1}\x07\x08\x02\x02\u{7ce}\u{7cf}\x07\x09\x02\x02\u{7cf}\u{7d1}\
	\x07\x09\x02\x02\u{7d0}\u{7cd}\x03\x02\x02\x02\u{7d0}\u{7ce}\x03\x02\x02\
	\x02\u{7d1}\u{7fb}\x03\x02\x02\x02\u{7d2}\u{7d6}\x05\x6e\x38\x02\u{7d3}\
	\u{7d7}\x07\x08\x02\x02\u{7d4}\u{7d5}\x07\x09\x02\x02\u{7d5}\u{7d7}\x07\
	\x09\x02\x02\u{7d6}\u{7d3}\x03\x02\x02\x02\u{7d6}\u{7d4}\x03\x02\x02\x02\
	\u{7d7}\u{7fb}\x03\x02\x02\x02\u{7d8}\u{7d9}\x07\x09\x02\x02\u{7d9}\u{7da}\
	\x05\x6e\x38\x02\u{7da}\u{7db}\x07\x09\x02\x02\u{7db}\u{7fb}\x03\x02\x02\
	\x02\u{7dc}\u{7e0}\x07\x08\x02\x02\u{7dd}\u{7de}\x07\x09\x02\x02\u{7de}\
	\u{7e0}\x07\x09\x02\x02\u{7df}\u{7dc}\x03\x02\x02\x02\u{7df}\u{7dd}\x03\
	\x02\x02\x02\u{7e0}\u{7e1}\x03\x02\x02\x02\u{7e1}\u{7fb}\x05\x6e\x38\x02\
	\u{7e2}\u{7e3}\x05\x6e\x38\x02\u{7e3}\u{7e4}\x07\x09\x02\x02\u{7e4}\u{7e5}\
	\x05\x6e\x38\x02\u{7e5}\u{7e6}\x07\x09\x02\x02\u{7e6}\u{7fb}\x03\x02\x02\
	\x02\u{7e7}\u{7e8}\x07\x09\x02\x02\u{7e8}\u{7e9}\x05\x6e\x38\x02\u{7e9}\
	\u{7ea}\x07\x09\x02\x02\u{7ea}\u{7eb}\x05\x6e\x38\x02\u{7eb}\u{7fb}\x03\
	\x02\x02\x02\u{7ec}\u{7f0}\x05\x6e\x38\x02\u{7ed}\u{7f1}\x07\x08\x02\x02\
	\u{7ee}\u{7ef}\x07\x09\x02\x02\u{7ef}\u{7f1}\x07\x09\x02\x02\u{7f0}\u{7ed}\
	\x03\x02\x02\x02\u{7f0}\u{7ee}\x03\x02\x02\x02\u{7f1}\u{7f2}\x03\x02\x02\
	\x02\u{7f2}\u{7f3}\x05\x6e\x38\x02\u{7f3}\u{7fb}\x03\x02\x02\x02\u{7f4}\
	\u{7f5}\x05\x6e\x38\x02\u{7f5}\u{7f6}\x07\x09\x02\x02\u{7f6}\u{7f7}\x05\
	\x6e\x38\x02\u{7f7}\u{7f8}\x07\x09\x02\x02\u{7f8}\u{7f9}\x05\x6e\x38\x02\
	\u{7f9}\u{7fb}\x03\x02\x02\x02\u{7fa}\u{7c2}\x03\x02\x02\x02\u{7fa}\u{7c3}\
	\x03\x02\x02\x02\u{7fa}\u{7c4}\x03\x02\x02\x02\u{7fa}\u{7c7}\x03\x02\x02\
	\x02\u{7fa}\u{7c9}\x03\x02\x02\x02\u{7fa}\u{7d0}\x03\x02\x02\x02\u{7fa}\
	\u{7d2}\x03\x02\x02\x02\u{7fa}\u{7d8}\x03\x02\x02\x02\u{7fa}\u{7df}\x03\
	\x02\x02\x02\u{7fa}\u{7e2}\x03\x02\x02\x02\u{7fa}\u{7e7}\x03\x02\x02\x02\
	\u{7fa}\u{7ec}\x03\x02\x02\x02\u{7fa}\u{7f4}\x03\x02\x02\x02\u{7fb}\u{d7}\
	\x03\x02\x02\x02\u{7fc}\u{7fe}\x05\u{e6}\x74\x02\u{7fd}\u{7fc}\x03\x02\x02\
	\x02\u{7fe}\u{801}\x03\x02\x02\x02\u{7ff}\u{7fd}\x03\x02\x02\x02\u{7ff}\
	\u{800}\x03\x02\x02\x02\u{800}\u{d9}\x03\x02\x02\x02\u{801}\u{7ff}\x03\x02\
	\x02\x02\u{802}\u{804}\x05\u{e6}\x74\x02\u{803}\u{802}\x03\x02\x02\x02\u{804}\
	\u{807}\x03\x02\x02\x02\u{805}\u{803}\x03\x02\x02\x02\u{805}\u{806}\x03\
	\x02\x02\x02\u{806}\u{808}\x03\x02\x02\x02\u{807}\u{805}\x03\x02\x02\x02\
	\u{808}\u{809}\x05\u{e6}\x74\x02\u{809}\u{db}\x03\x02\x02\x02\u{80a}\u{80c}\
	\x05\u{e6}\x74\x02\u{80b}\u{80a}\x03\x02\x02\x02\u{80c}\u{80f}\x03\x02\x02\
	\x02\u{80d}\u{80b}\x03\x02\x02\x02\u{80d}\u{80e}\x03\x02\x02\x02\u{80e}\
	\u{810}\x03\x02\x02\x02\u{80f}\u{80d}\x03\x02\x02\x02\u{810}\u{815}\x05\
	\u{e6}\x74\x02\u{811}\u{812}\x07\x08\x02\x02\u{812}\u{814}\x05\u{e6}\x74\
	\x02\u{813}\u{811}\x03\x02\x02\x02\u{814}\u{817}\x03\x02\x02\x02\u{815}\
	\u{813}\x03\x02\x02\x02\u{815}\u{816}\x03\x02\x02\x02\u{816}\u{dd}\x03\x02\
	\x02\x02\u{817}\u{815}\x03\x02\x02\x02\u{818}\u{81b}\x07\x50\x02\x02\u{819}\
	\u{81c}\x05\u{e6}\x74\x02\u{81a}\u{81c}\x05\u{e8}\x75\x02\u{81b}\u{819}\
	\x03\x02\x02\x02\u{81b}\u{81a}\x03\x02\x02\x02\u{81b}\u{81c}\x03\x02\x02\
	\x02\u{81c}\u{df}\x03\x02\x02\x02\u{81d}\u{81e}\x09\x17\x02\x02\u{81e}\u{81f}\
	\x07\u{86}\x02\x02\u{81f}\u{e1}\x03\x02\x02\x02\u{820}\u{825}\x05\u{e6}\
	\x74\x02\u{821}\u{822}\x09\x05\x02\x02\u{822}\u{824}\x05\u{e6}\x74\x02\u{823}\
	\u{821}\x03\x02\x02\x02\u{824}\u{827}\x03\x02\x02\x02\u{825}\u{823}\x03\
	\x02\x02\x02\u{825}\u{826}\x03\x02\x02\x02\u{826}\u{e3}\x03\x02\x02\x02\
	\u{827}\u{825}\x03\x02\x02\x02\u{828}\u{82d}\x05\u{e6}\x74\x02\u{829}\u{82a}\
	\x07\x08\x02\x02\u{82a}\u{82c}\x05\u{e6}\x74\x02\u{82b}\u{829}\x03\x02\x02\
	\x02\u{82c}\u{82f}\x03\x02\x02\x02\u{82d}\u{82b}\x03\x02\x02\x02\u{82d}\
	\u{82e}\x03\x02\x02\x02\u{82e}\u{e5}\x03\x02\x02\x02\u{82f}\u{82d}\x03\x02\
	\x02\x02\u{830}\u{831}\x09\x18\x02\x02\u{831}\u{e7}\x03\x02\x02\x02\u{832}\
	\u{833}\x09\x19\x02\x02\u{833}\u{e9}\x03\x02\x02\x02\u{834}\u{836}\x05\u{e8}\
	\x75\x02\u{835}\u{837}\x05\u{e6}\x74\x02\u{836}\u{835}\x03\x02\x02\x02\u{836}\
	\u{837}\x03\x02\x02\x02\u{837}\u{eb}\x03\x02\x02\x02\u{838}\u{839}\x09\x1a\
	\x02\x02\u{839}\u{ed}\x03\x02\x02\x02\u{83a}\u{83c}\x05\u{e6}\x74\x02\u{83b}\
	\u{83a}\x03\x02\x02\x02\u{83b}\u{83c}\x03\x02\x02\x02\u{83c}\u{83d}\x03\
	\x02\x02\x02\u{83d}\u{847}\x07\u{88}\x02\x02\u{83e}\u{840}\x05\u{e6}\x74\
	\x02\u{83f}\u{83e}\x03\x02\x02\x02\u{83f}\u{840}\x03\x02\x02\x02\u{840}\
	\u{841}\x03\x02\x02\x02\u{841}\u{847}\x07\u{89}\x02\x02\u{842}\u{844}\x05\
	\u{e6}\x74\x02\u{843}\u{842}\x03\x02\x02\x02\u{843}\u{844}\x03\x02\x02\x02\
	\u{844}\u{845}\x03\x02\x02\x02\u{845}\u{847}\x07\u{8a}\x02\x02\u{846}\u{83b}\
	\x03\x02\x02\x02\u{846}\u{83f}\x03\x02\x02\x02\u{846}\u{843}\x03\x02\x02\
	\x02\u{847}\u{ef}\x03\x02\x02\x02\u{12a}\u{ff}\u{101}\u{10d}\u{114}\u{11c}\
	\u{121}\u{124}\u{129}\u{12e}\u{131}\u{135}\u{139}\u{13c}\u{13f}\u{146}\u{152}\
	\u{156}\u{15b}\u{160}\u{167}\u{16a}\u{16d}\u{171}\u{178}\u{17a}\u{187}\u{18b}\
	\u{18f}\u{196}\u{19b}\u{19e}\u{1a3}\u{1a8}\u{1ac}\u{1af}\u{1b2}\u{1b7}\u{1be}\
	\u{1c3}\u{1ca}\u{1cd}\u{1d1}\u{1d8}\u{1da}\u{1e3}\u{1e6}\u{1eb}\u{1f2}\u{1f5}\
	\u{1fd}\u{1ff}\u{20a}\u{211}\u{214}\u{21a}\u{222}\u{224}\u{22b}\u{230}\u{232}\
	\u{23a}\u{241}\u{244}\u{24c}\u{24e}\u{256}\u{25c}\u{25f}\u{264}\u{26b}\u{26f}\
	\u{272}\u{27e}\u{283}\u{288}\u{28e}\u{293}\u{296}\u{299}\u{29e}\u{2a4}\u{2a9}\
	\u{2ac}\u{2af}\u{2b4}\u{2ba}\u{2bf}\u{2c2}\u{2c6}\u{2cc}\u{2d0}\u{2d5}\u{2d8}\
	\u{2dc}\u{2e0}\u{2e2}\u{2ec}\u{2f0}\u{2f4}\u{2fb}\u{300}\u{306}\u{311}\u{313}\
	\u{31b}\u{321}\u{325}\u{329}\u{330}\u{334}\u{33f}\u{342}\u{344}\u{34e}\u{352}\
	\u{354}\u{359}\u{361}\u{365}\u{367}\u{36b}\u{373}\u{377}\u{379}\u{37c}\u{381}\
	\u{386}\u{38c}\u{391}\u{395}\u{399}\u{39c}\u{3a1}\u{3a8}\u{3b0}\u{3b7}\u{3bb}\
	\u{3c6}\u{3cf}\u{3d4}\u{3d9}\u{3e1}\u{3ea}\u{3f2}\u{3fc}\u{406}\u{413}\u{41c}\
	\u{420}\u{428}\u{42d}\u{430}\u{44f}\u{483}\u{486}\u{48b}\u{492}\u{494}\u{4a2}\
	\u{4a4}\u{4ba}\u{4e2}\u{4e4}\u{4f4}\u{4f7}\u{4f9}\u{4fd}\u{50e}\u{510}\u{519}\
	\u{51e}\u{520}\u{525}\u{52a}\u{531}\u{534}\u{53b}\u{55d}\u{566}\u{570}\u{574}\
	\u{579}\u{57e}\u{586}\u{58a}\u{58e}\u{593}\u{5a1}\u{5a5}\u{5b1}\u{5b5}\u{5b9}\
	\u{5bc}\u{5c4}\u{5cf}\u{5d4}\u{5d9}\u{5e3}\u{5ed}\u{5f7}\u{5fb}\u{5ff}\u{604}\
	\u{606}\u{612}\u{618}\u{622}\u{627}\u{629}\u{631}\u{63a}\u{63f}\u{641}\u{646}\
	\u{64f}\u{654}\u{656}\u{65a}\u{65d}\u{662}\u{667}\u{66e}\u{675}\u{67d}\u{67f}\
	\u{687}\u{68f}\u{699}\u{69d}\u{69f}\u{6a5}\u{6ac}\u{6b3}\u{6bd}\u{6c5}\u{6cc}\
	\u{6d0}\u{6d6}\u{6e2}\u{6e4}\u{6f1}\u{6fa}\u{6fd}\u{702}\u{707}\u{716}\u{719}\
	\u{724}\u{728}\u{72d}\u{735}\u{739}\u{73e}\u{746}\u{74a}\u{74e}\u{752}\u{755}\
	\u{758}\u{75f}\u{762}\u{769}\u{76d}\u{770}\u{774}\u{779}\u{77b}\u{788}\u{78b}\
	\u{794}\u{799}\u{79e}\u{7a8}\u{7ac}\u{7ae}\u{7b7}\u{7bb}\u{7bd}\u{7c0}\u{7d0}\
	\u{7d6}\u{7df}\u{7f0}\u{7fa}\u{7ff}\u{805}\u{80d}\u{815}\u{81b}\u{825}\u{82d}\
	\u{836}\u{83b}\u{83f}\u{843}\u{846}";
