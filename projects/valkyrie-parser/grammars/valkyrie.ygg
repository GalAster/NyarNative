grammar Valkyrie {

}

// === statements === -----------------------------------------------------------------
entry class Program {
    Statement* EOI
}
// === statements === -----------------------------------------------------------------
union Statement {
    | DefineNamespace
    | DefineImport
    | DefineClass
    | DefineUnion
    | DefineEnumerate
    | DefineTrait
    | DefineFunction
    | MainStatement
}
/// Used to isolate expressions and control whether to output the expression
union EOS ^ {
    | [;；]   #Omit
    | /⁏|;;/  #Show
}
/// Used to isolate expressions, has no practical meaning
class EOS_FREE {
    [,，;；⁏]
}
// === namespace === -----------------------------------------------------------------
class DefineNamespace {
    ^KW_NAMESPACE OP_NAMESPACE? NamepathFree ^EOS?
}

@style(keyword)
union OP_NAMESPACE {
    | '!' #Main
    | '?' #Test
    | '*' #Hide
}
// === import === -----------------------------------------------------------------
atomic class DefineImport {
    | ^KW_IMPORT ~ ImportTerm? ~ ^EOS?
    | ^KW_IMPORT ~ '{' (HIDE (ImportTerm|^EOS_FREE))* ~ '}' ~ ^EOS?
}
union ImportTerm {
    | ImportAs
    | ImportAll
    | ImportMacro
    | ImportBlock
    | NamepathFree
}
/// `import package∷module∷item as alias`
class ImportAs { NamepathFree ^KW_AS alias:Identifier }
/// `import package∷module∷*`
class ImportAll { NamepathFree /[.∷]|::/ OP_IMPORT_ALL }
/// `import package∷module { ... }`
atomic class ImportBlock  {
    NamepathFree ~ /[.∷]|::/? ~ '{' (HIDE (ImportTerm|^EOS_FREE))* ~ '}'
}
/// `import package::module::#macro as @macro`
class ImportMacro  {
    NamepathFree /[.∷]|::/ ImportMacroItem ^KW_AS alias:ImportMacroItem
}
atomic union ImportMacroItem {
    | '#' Identifier #Capture
    | '@' Identifier #Instant
}
// === template === ----------------------------------------------------------------------------------------------------
class DefineTemplate {
    AttributeCall* ModifierCall*
    KW_TEMPLATE TemplateParameters? TemplateBlock
}
class TemplateParameters {
    | Identifier (^COMMA Identifier)* ^COMMA?
    | '<' Identifier (^COMMA Identifier)* ^COMMA? '>'
    | '⟨' Identifier (^COMMA Identifier)* ^COMMA? '⟩'
}
class TemplateBlock {
    '{' (TemplateStatement | TemplateImplements | EOS_FREE)* '}'
}
class TemplateStatement {
    WhereBlock
    //  | KW_RETURN TypeExpression
    //  | Identifier RequireBlock
}
class TemplateImplements {
      KW_IMPLEMENTS // TypeExpression
}
class WhereBlock {
    KW_WHERE '{' WhereBound* '}'
}
class WhereBound {
    //    | Identifier COLON TypeExpression
    | EOS_FREE
}
//class RequireBlock {
//    '{' (ExpressionRoot | EOS_FREE)* '}'
//}
// === classes === -----------------------------------------------------------------------------------------------------
class DefineClass {
    DefineTemplate? AttributeCall* ModifierCall*
    KW_CLASS Identifier ClassInherit? ClassBlock ^EOS?
}
class ClassBlock {
    '{' ClassBlockItem* '}'
}
union ClassBlockItem {
    | ClassDomain
    | ClassMethod
    | ClassField
    | EOS_FREE
}
class ClassInherit {
    '(' (ClassInheritItem (',' ClassInheritItem)* ','?)? ')'
}
class ClassInheritItem {
    Namepath
}
class ClassField {
    AttributeCall* field_modifier*
    Identifier TypeHint? ParameterDefault?
}
atomic inline class field_modifier {
    !(^Namepath ~ [:=};]) ModifierCall
}
class ParameterDefault {
    '=' MainExpression
}
class ClassMethod {
    AttributeCall* method_modifier* Namepath
    '(' ')'
    // DefineGeneric? FunctionParameters ReturnType? FunctionBlock?
}
atomic inline class method_modifier {
    !(^Namepath ~ [(<:}]) ModifierCall
}
class ClassDomain {
    AttributeCall* field_modifier*
    Identifier ClassBlock
}
@style(keyword)
union KW_CLASS {
    | 'class'     #Class
    | 'structure' #Structure
}
// === object statement === --------------------------------------------------------------------------------------------
class ObjectStatement {
    KW_Object ClassInherit? ClassBlock ^EOS?
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineUnion {
    AttributeCall* KW_UNION Identifier
}
@style(keyword)
class KW_UNION {
    'union'
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineEnumerate {
    AttributeCall* KW_FLAGS Identifier
}
@style(keyword)
@railway(false)
union KW_FLAGS {
    | 'enumerate' #Enum
    | 'flags'     #Flags
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineTrait {
    KW_TRAIT
}
@style(keyword)
union KW_TRAIT {
    | 'trait'     #Trait
    | 'interface' #Interface
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineFunction {
    KW_FUNCTION Namepath
}
@style(keyword)
union KW_FUNCTION {
    | /micro|function/ #Micro
    | 'macro'          #Macro
}
class Continuation {
    '{' MainStatement* '}'
}
// === while loop === --------------------------------------------------------------------------------------------------
class WhileStatement {
    KW_WHILE InlineExpression? Continuation ^EOS?
}
@style(keyword)
union KW_WHILE {
    | 'while' #While
    | 'until' #Until
}
// === for loop === ----------------------------------------------------------------------------------------------------
class ForStatement {
    KW_FOR Identifier KW_IN InlineExpression? Continuation ^EOS?
}
// === expression === --------------------------------------------------------------------------------------------------
atomic union MainStatement {
    | WhileStatement
    | ForStatement
    | ExpressionStatement
}
class ExpressionStatement {
    MainExpression EOS?
}


// === expression === --------------------------------------------------------------------------------------------------
atomic class MainExpression {
    MainTerm (HIDE MainInfix ~ MainTerm)*
}
atomic class MainTerm {
    (MainPrefix HIDE)* MainFactor MainSuffix*
}

union MainFactor {
    | TryStatement
    | NewStatement
    | ObjectStatement
    | GroupFactor
    | Leading
}
atomic class GroupFactor {
    '(' ~ MainExpression ~ ')'
}

union Leading {
    | ProceduralCall
    | TupleLiteralStrict
    | RangeLiteral
    | TextLiteral
    | Namepath
    | Integer
    | Special
}

@railway(false)
@style(operator)
text class MainInfix ^ {
    / [+\\-*\/%]=?
    | [√^]
    # start with ?, !, =
    | [?]=
    | !==|=!=|===|==|!=|=|[!≢≠≡]
    # start with `<, >`
    | <<<|<<=|<<|<=|[⋘≪⩽≤<]
    | >>>|>>=|>>|>=|[⋙≫⩾≥>]
    # start with &, |
    | [&|]{1,3}
    | [∧⊼⩟∨⊽⊻]
    # range, contains
    | [.]{1,2}[<=]
    | [∈∊∉∋∍∌]
    | (not\s+)?in
    | is(\s+not)?
    # map, apply
    | \/@ | [⇴⨵⊕⟴] | @{2,3}
    /
}
@railway(false)
text class MainPrefix {
    / [¬!+]
    | [-]
    | [.]{2,3}
    | [⅟]
    | [√∛∜]
    | [&*]
    /
}
@railway(false)
atomic union MainSuffix {
    | InlineSuffix
}
// === inline expression === --------------------------------------------------------------------------------------------------
atomic class InlineExpression {
    InlineTerm (HIDE MainInfix ~ InlineTerm)*
}
atomic class InlineTerm {
    (MainPrefix HIDE)* MainFactor InlineSuffix*
}
atomic union InlineSuffix {
    | HIDE SuffixOperator
    | DotCall
    | TupleCall
    | RangeCall
    | GenericCall
}
@railway(false)
text class SuffixOperator {
    / [!]
    | [%‰‱]
    | [′″‴⁗]
    | [℃℉]
    /
}
// === identifier === --------------------------------------------------------------------------------------------------
class TypeHint {
    COLON TypeExpression
}
atomic class TypeExpression {
    TypeTerm (HIDE TypeInfix ~ TypeTerm)*
}
atomic class TypeTerm {
    (TypePrefix HIDE)* MainFactor TypeSuffix*
}
atomic union TypeFactor {
    | '(' ~ TypeExpression ~ ')'
    | Leading
}
@style(operator)
text class TypeInfix {
    / [|&]
    /
}
text class TypePrefix {
    / [+]
    | [-]
    /
}
atomic union TypeSuffix {
    | GenericHide
    | '?' #Option
}
// === try statement === -----------------------------------------------------------------------------------------------
class TryStatement {
    KW_TRY TypeExpression? Continuation
}
// === new statement === -----------------------------------------------------------------------------------------------
class NewStatement {
    KW_NEW NewModifiers* Namepath GenericHide? TupleLiteral? NewBlock? ^EOS?
}
atomic class NewModifiers ^ {
    !NEW_MODIFIER_STOP ^Identifier
}
class NewBlock {
    '{' (NewPair (EOS_FREE NewPair)* EOS_FREE?)? '}'
}
atomic class NEW_MODIFIER_STOP {
    Identifier HIDE [\[({<⟨:∷;]
}
atomic class NewPair {
    (NewPairKey ~ Colon HIDE)? MainExpression
}
union NewPairKey {
    | Identifier
    | TextRaw
    | RangeLiteral
}
// === dot === ---------------------------------------------------------------------------------------------------------
class DotCall {
    OP_AND_THEN? ^DOT DotCallItem
}
union DotCallItem {
    | Namepath
    | Integer
}
// === tuple === -------------------------------------------------------------------------------------------------------
atomic class TupleCall {
     ^WhiteSpace? OP_AND_THEN? ^WhiteSpace? (
        | TupleLiteral (^WhiteSpace? Continuation)?
        | Continuation
     )
}
class TupleLiteral {
    '(' TupleTerms ')'
}
atomic class TupleLiteralStrict {
    | '(' ~ ')'
    | '(' ~ TuplePair ~ ^COMMA ~ ')'
    | '(' ~ TuplePair (HIDE ^COMMA ~ TuplePair)* (HIDE ^COMMA)? ~ ')'
}
atomic class TupleTerms {
    (TuplePair (HIDE ^COMMA ~ TuplePair)* (HIDE ^COMMA)?)?
}
class TuplePair {
    (TupleKey Colon)? MainExpression
}
union TupleKey {
    | Identifier
    | TextRaw
}
// === range === -------------------------------------------------------------------------------------------------------
atomic class RangeCall {
    ^WhiteSpace? OP_AND_THEN? ^WhiteSpace? RangeLiteral
}
atomic class RangeLiteral {
    | '[' ~ (SubscriptAxis (HIDE ^COMMA ~ SubscriptAxis)* ~ ^COMMA?)? ~ ']'
    | '⁅' ~ (SubscriptAxis (HIDE ^COMMA ~ SubscriptAxis)* ~ ^COMMA?)? ~ '⁆'
}
union SubscriptAxis {
    | SubscriptRange
    | SubscriptOnly
}
class SubscriptOnly {
    index:MainExpression
}
atomic class SubscriptRange ^ {
    (head:MainExpression HIDE)? (
        | RangeOmit (HIDE step:MainExpression)?
        | COLON (HIDE tail:MainExpression (HIDE COLON (HIDE step:MainExpression)?)?)?
    )
}
atomic inline class RangeOmit {
    PROPORTION | COLON ~ COLON
}
// === generic call === ------------------------------------------------------------------------------------------------
class GenericCall {
    OP_AND_THEN? (
        | PROPORTION '<' GenericTerms '>'
        | '⟨' GenericTerms '⟩'
    )
    (PROPORTION Namepath)?
}
class GenericHide {
    | PROPORTION? '<' GenericTerms '>'
    | '⟨' GenericTerms '⟩'
}
atomic class GenericTerms {
    (GenericPair (HIDE ^COMMA ~ GenericPair)* (HIDE ^COMMA)?)?
}
class GenericPair {
    (Identifier Colon)? TypeExpression
}
// === annotation === --------------------------------------------------------------------------------------------------
class AttributeCall {
    // #call(...)
    AttributePath TupleLiteral?
}
class ProceduralCall {
    // @call(...)
    ProceduralPath TupleLiteral?
}
// === text === ------------------------------------------------------------------------------------------------------
atomic class TextLiteral {
    Identifier? TextRaw
}
atomic class TextRaw {
    | '""""' TEXT_CONTENT5 '""""'
    | "''''" TEXT_CONTENT6 "''''"
    | '"""' TEXT_CONTENT3 '"""'
    | "'''" TEXT_CONTENT4 "'''"
    | '"' TEXT_CONTENT1 '"'
    | "'" TEXT_CONTENT2 "'"
}
text atomic class TEXT_CONTENT1 { [^"]* }
text atomic class TEXT_CONTENT2 { [^']* }
text atomic class TEXT_CONTENT3 { (!'"""' ANY)+ }
text atomic class TEXT_CONTENT4 { (!"'''" ANY)+ }
text atomic class TEXT_CONTENT5 { (!'""""' ANY)+ }
text atomic class TEXT_CONTENT6 { (!"''''" ANY)+ }
// === identifier === --------------------------------------------------------------------------------------------------
atomic class ModifierCall ^ {
    !(KW_CLASS | KW_UNION | KW_TRAIT) ^Identifier
}
atomic class AttributePath {
    '#' Namepath
}
atomic class ProceduralPath {
    '@' Namepath
}
atomic class NamepathFree  {
    Identifier (HIDE ^PROPORTION2 ~ Identifier)*
}
atomic class Namepath {
    Identifier (HIDE ^PROPORTION ~ Identifier)*
}
atomic union Identifier {
    | IdentifierBare
    | IdentifierRaw
}
text class IdentifierBare {
    /[_\p{XID_start}]\p{XID_continue}*/
}
atomic class IdentifierRaw {
    '`' IdentifierRawText '`'
}
text class IdentifierRawText {
    [^`]+
}
text class Special {
    /[∅∞]|true|false/
}
// === number === ------------------------------------------------------------------------------------------------------
text class Integer {
    /0|[1-9][0-9]*/
}
// === keywords === ----------------------------------------------------------------------------------------------------
@railway(false)
token {
    PROPORTION: /∷|::/
    COLON: [:：]
    COMMA: [,，]
    DOT:   [.．]
    OFFSET_L: '⁅'
    OFFSET_R: '⁆'
}
class PROPORTION2 -> PROPORTION {
    /[.．∷]|::/
}
@railway(false)
@style(keyword)
token {
    OP_IMPORT_ALL: '*'
    OP_AND_THEN: '?'
    OP_BIND: /≔|:=/
}
@railway(false)
@style(keyword)
token {
    KW_NAMESPACE: /namespace/
    KW_IMPORT: /using/
    KW_TEMPLATE: /template|generic/
    KW_WHERE: /where/
    KW_TRAIT: /trait|interface/
    KW_IMPLEMENTS: /implements?/
    KW_EXTENDS: /extends?/
    KW_INHERITS: /inherits?/
    // control
    KW_IF: /if/
    KW_ELSE: /else/
    KW_FOR: /for/
    KW_RETURN: /return/
    KW_BREAK: /break/
    KW_CONTINUE: /continue/
    KW_TRY: /try/
    KW_NEW: /new/
    KW_OBJECT: /object/
    // === operators === -----------------------------------------------------------------------------------------------
    KW_NOT: 'not'
    KW_IN: 'in'
    KW_IS: 'is'
    KW_AS: 'as'
}
// === ignores === -----------------------------------------------------------------------------------------------------
@railway(false)
class WhiteSpace {
    /[^\\S\r\n]+/
}
@railway(false)
hide class SkipSpace {
    /\p{White_Space}+/
}
@style(comment)
@railway(false)
hide class Comment {
    | '//' /[^\n\r]*/
    | '/*'  '*/'
}
