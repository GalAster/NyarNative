grammar Valkyrie {
    patterns: ["*.vk", "*.valkyrie"]
}

// === statements === -----------------------------------------------------------------
entry class Program {
    Statement* EOI
}
// === statements === -----------------------------------------------------------------
union Statement {
    | DefineNamespace
    | DefineImport
    | DefineClass
    | DefineUnion
    | DefineEnumerate
    | DefineTrait
    | DefineFunction
    | MainStatement
}
/// Used to isolate expressions and control whether to output the expression
union EOS ^ {
    | [;；]   #Omit
    | /⁏|;;/  #Show
}
/// Used to isolate expressions, has no practical meaning
class EOS_FREE {
    [,，;；⁏]
}
// === namespace === -----------------------------------------------------------------
class DefineNamespace {
    ^KW_NAMESPACE OP_NAMESPACE? NamepathFree ^EOS?
}

@style(keyword)
union OP_NAMESPACE {
    | '!' #Main
    | '?' #Test
    | '*' #Hide
}
// === import === -----------------------------------------------------------------
atomic class DefineImport {
    | ^KW_IMPORT ~ ImportTerm? ~ ^EOS?
    | ^KW_IMPORT ~ '{' (HIDE (ImportTerm|^EOS_FREE))* ~ '}' ~ ^EOS?
}
union ImportTerm {
    | ImportAs
    | ImportAll
    | ImportMacro
    | ImportBlock
    | NamepathFree
}
/// `import package∷module∷item as alias`
class ImportAs { NamepathFree ^KW_AS alias:Identifier }
/// `import package∷module∷*`
class ImportAll { NamepathFree /[.∷]|::/ OP_IMPORT_ALL }
/// `import package∷module { ... }`
atomic class ImportBlock  {
    NamepathFree ~ /[.∷]|::/? ~ '{' (HIDE (ImportTerm|^EOS_FREE))* ~ '}'
}
/// `import package::module::#macro as @macro`
class ImportMacro  {
    NamepathFree /[.∷]|::/ ImportMacroItem ^KW_AS alias:ImportMacroItem
}
atomic union ImportMacroItem {
    | '#' Identifier #Capture
    | '@' Identifier #Instant
}
// === template === ----------------------------------------------------------------------------------------------------

// === template === ----------------------------------------------------------------------------------------------------
class DefineTemplate {
    AnnotationHead
    KW_TEMPLATE TemplateParameters? TemplateBlock
}
class TemplateParameters {
    | Identifier (^COMMA Identifier)* ^COMMA?
    | '<' Identifier (^COMMA Identifier)* ^COMMA? '>'
    | '⟨' Identifier (^COMMA Identifier)* ^COMMA? '⟩'
}
class TemplateBlock {
    '{' (TemplateStatement | TemplateImplements | EOS_FREE)* '}'
}
class TemplateStatement {
    WhereBlock
    //  | KW_RETURN TypeExpression
    //  | Identifier RequireBlock
}
class TemplateImplements {
      KW_IMPLEMENTS // TypeExpression
}
class WhereBlock {
    KW_WHERE '{' WhereBound* '}'
}
class WhereBound {
    //    | Identifier COLON TypeExpression
    | EOS_FREE
}
//class RequireBlock {
//    '{' (ExpressionRoot | EOS_FREE)* '}'
//}
// === classes === -----------------------------------------------------------------------------------------------------
class DefineClass {
    DefineTemplate?
    AnnotationHead
    KW_CLASS Identifier GenericDefine? ClassInherit? TypeHint? ClassBlock ^EOS?
}
class ClassBlock {
    '{' ClassTerm* '}'
}
union ClassTerm {
    | ClassDomain
    | DefineMethod
    | ClassField
    | EOS_FREE
}
class ClassInherit {
    '(' (ClassInheritItem (',' ClassInheritItem)* ','?)? ')'
}
class ClassInheritItem {
    Namepath
}
class ClassField {
    AttributeCall* field_modifier*
    Identifier TypeHint? ParameterDefault?
}
atomic inline class field_modifier {
    !(^Namepath ~ [:=};]) ModifierCall
}
class ParameterDefault {
    '=' MainExpression
}
class DefineMethod {
    AttributeCall* method_modifier* Namepath
    '(' ')'
    // DefineGeneric? FunctionParameters ReturnType? FunctionBlock?
}
atomic inline class method_modifier {
    !(^Namepath ~ [(<:}]) ModifierCall
}
class ClassDomain {
    AttributeCall* field_modifier*
    Identifier ClassBlock
}
@style(keyword)
union KW_CLASS {
    | 'class'     #Class
    | 'structure' #Structure
}
// === object statement === --------------------------------------------------------------------------------------------
class ObjectStatement {
    KW_Object ClassInherit? ClassBlock ^EOS?
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineEnumerate {
    AnnotationHead
    KW_FLAGS Identifier '{' FlagTerm* '}'
}
union FlagTerm {
    | FlagField
    | EOS_FREE
}
class FlagField {
    Identifier ('=' MainExpression)?
}
@style(keyword)
@railway(false)
union KW_FLAGS {
    | 'enumerate' #Enum
    | 'flags'     #Flags
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineUnion {
    AnnotationHead
    KW_UNION Identifier ClassInherit? TypeHint? '{' UnionTerm* '}'
}
union UnionTerm {
    | DefineVariant
    | DefineMethod
    | EOS_FREE
}
class DefineVariant {
    AnnotationTerm* Identifier ClassBlock?
}
@style(keyword)
class KW_UNION {
    'union'
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineTrait {
    KW_TRAIT
}
@style(keyword)
union KW_TRAIT {
    | 'trait'     #Trait
    | 'interface' #Interface
}
// === identifier === --------------------------------------------------------------------------------------------------
class DefineFunction {
    AnnotationHead
    KW_FUNCTION Namepath GenericDefine? '(' ParameterTerms ')' TypeReturn? TypeEffect? Continuation?
}
class TypeHint {
    COLON TypeExpression
}
class TypeReturn {
    ARROW1 TypeExpression
}
class TypeEffect {
    '/' TypeExpression
}
atomic class ParameterTerms {
    (ParameterItem (HIDE ^COMMA ~ ParameterItem)* (HIDE ^COMMA)?)?
}
union ParameterItem {
    | '<' #LMark
    | '>' #RMark
    | ParameterPair
}
class ParameterPair {
    ModifierAhead* ParameterHint?
    Identifier TypeHint? ParameterDefault?
}
text class ParameterHint {
    /[.]{2,3}|[~^]/
}
class Continuation {
    '{' MainStatement* '}'
}
@style(keyword)
union KW_FUNCTION {
    | /micro|function/ #Micro
    | /macro/          #Macro
}
// === while loop === --------------------------------------------------------------------------------------------------
class WhileStatement {
    KW_WHILE InlineExpression? Continuation ^EOS?
}
@style(keyword)
union KW_WHILE {
    | 'while' #While
    | 'until' #Until
}
// === for loop === ----------------------------------------------------------------------------------------------------
class ForStatement {
    KW_FOR Identifier KW_IN InlineExpression? Continuation ^EOS?
}
// === expression === --------------------------------------------------------------------------------------------------
union MainStatement {
    | WhileStatement
    | ForStatement
    | ExpressionStatement
}
class ExpressionStatement {
    MainExpression OP_AND_THEN? EOS?
}
// === match/catch/switch === ------------------------------------------------------------------------------------------
class MatchExpression {
    KW_MATCH (
        | (Identifier BIND_L)? InlineExpression
        | InlineExpression (BIND_R Identifier)?
    )
    '{' MatchTerms* '}'
}
class SwitchStatement {
    KW_SWITCH '{' MatchTerms* '}'
}
union MatchTerms {
    | MatchType
    | MatchCase
    | MatchWhen
    | MatchElse
    | COMMA
}
class MatchType {
    KW_TYPE Identifier ^COLON MatchStatement*
}
class MatchCase {
    KW_CASE Identifier ^COLON MatchStatement*
}
class MatchWhen {
    KW_WHEN InlineExpression ^COLON MatchStatement*
}
class MatchElse {
    KW_ELSE ^COLON MatchStatement*
}
atomic class MatchStatement {
    !/type|case|when|else|[,，]/ MainStatement
}
@style(keyword)
union KW_MATCH {
    | 'match' #Match
    | 'catch' #Catch
}
@style(operator)
token {
    BIND_L: /≔|:=/
    BIND_R: /≕|=:/
}
// === match dot call === ----------------------------------------------------------------------------------------------
atomic class DotMatchCall {
    OP_AND_THEN? ~ ^DOT ^WhiteSpace? KW_MATCH (^WhiteSpace? BIND_R ^WhiteSpace? Identifier)? ^WhiteSpace? '{' (HIDE MatchTerms)* ~ '}'
}
// === expression === --------------------------------------------------------------------------------------------------
atomic class MainExpression {
    MainTerm (HIDE MainInfix ~ MainTerm)*
}
atomic class MainTerm {
    (MainPrefix HIDE)* MainFactor MainSuffix*
}

union MainFactor {
    | SwitchStatement
    | TryStatement
    | MatchExpression
    | NewStatement
    | ObjectStatement
    | GroupFactor
    | Leading
}
atomic class GroupFactor {
    '(' ~ MainExpression ~ ')'
}

union Leading {
    | ProceduralCall
    | TupleLiteralStrict
    | RangeLiteral
    | TextLiteral
    | Slot
    | Namepath
    | Number
    | Special
}
@railway(false)
atomic union MainSuffix {
    | HIDE DotMatchCall   #DotMatchCall
    | HIDE DotClosureCall #DotClosureCall
    | TupleCall
    | InlineSuffix
}
// === operators === ---------------------------------------------------------------------------------------------------
@railway(false)
@style(operator)
text class MainInfix ^ {
    / [+\\-*\/%]=?
    | [√^]
    # start with ?, !, =
    | [?]=
    | !==|=!=|===|==|!=|=|[!≢≠≡]
    # start with `<, >`
    | <<<|<<=|<<|<=|[⋘≪⩽≤<]
    | >>>|>>=|>>|>=|[⋙≫⩾≥>]
    # start with &, |
    | [&|]{1,3}
    | [∧⊼⩟∨⊽⊻]
    # range, contains
    | [.]{1,2}[<=]
    | [∈∊∉∋∍∌]
    | (not\s+)?in
    | is(\s+not)?
    # map, apply
    | \/@ | [⇴⨵⊕⟴] | @{2,3}
    /
}
@railway(false)
@style(operator)
text class TypeInfix {
    / [|&+]
    | [-]
    /
}
@railway(false)
@style(operator)
text class MainPrefix {
    / [¬!+]
    | [-]
    | [.]{2,3}
    | [⅟]
    | [√∛∜]
    | [&*]
    /
}
@railway(false)
@style(operator)
text class TypePrefix {
    / [+¬~]
    | [-]
    /
}
@railway(false)
@style(operator)
text class SuffixOperator {
    / [!]
    | [%‰‱]
    | [′″‴⁗]
    | [℃℉]
    /
}
// === inline expression === --------------------------------------------------------------------------------------------------
atomic class InlineExpression {
    InlineTerm (HIDE MainInfix ~ InlineTerm)*
}
atomic class InlineTerm {
    (MainPrefix HIDE)* MainFactor InlineSuffix*
}
union InlineSuffix {
    | HIDE SuffixOperator #SuffixOperator
    | HIDE DotCall #DotCall
    | InlineTupleCall
    | RangeCall
    | GenericCall
}
// === identifier === --------------------------------------------------------------------------------------------------
atomic class TypeExpression {
    TypeTerm (HIDE TypeInfix ~ TypeTerm)*
}
atomic class TypeTerm {
    (TypePrefix HIDE)* MainFactor TypeSuffix*
}
atomic union TypeFactor {
    | '(' ~ TypeExpression ~ ')'
    | Leading
}
atomic union TypeSuffix {
    | GenericHide
    | '?' #Option
}
// === try statement === -----------------------------------------------------------------------------------------------
class TryStatement {
    KW_TRY TypeExpression? Continuation
}
// === new statement === -----------------------------------------------------------------------------------------------
class NewStatement {
    KW_NEW ModifierAhead* Namepath GenericHide? TupleLiteral? NewBlock? ^EOS?
}
class NewBlock {
    '{' (NewPair (EOS_FREE NewPair)* EOS_FREE?)? '}'
}
atomic class NewPair {
    (NewPairKey ~ Colon HIDE)? MainExpression
}
union NewPairKey {
    | Identifier
    | TextRaw
    | RangeLiteral
}
// === dot === ---------------------------------------------------------------------------------------------------------
atomic class DotCall {
    OP_AND_THEN? ~ ^DOT ^WhiteSpace? DotCallItem
}
union DotCallItem {
    | Namepath
    | Integer
}
// === dot === ---------------------------------------------------------------------------------------------------------
atomic class DotClosureCall {
    OP_AND_THEN? ~ ^DOT ^WhiteSpace? Continuation
}
// === tuple === -------------------------------------------------------------------------------------------------------
atomic class InlineTupleCall {
     ^WhiteSpace? OP_AND_THEN? ^WhiteSpace? TupleLiteral
}
atomic class TupleCall {
     ^WhiteSpace? OP_AND_THEN? ^WhiteSpace? (
        | TupleLiteral (^WhiteSpace? Continuation)?
        | Continuation
     )
}
class TupleLiteral {
    '(' TupleTerms ')'
}
atomic class TupleLiteralStrict {
    | '(' ~ ')'
    | '(' ~ TuplePair ~ ^COMMA ~ ')'
    | '(' ~ TuplePair (HIDE ^COMMA ~ TuplePair)* (HIDE ^COMMA)? ~ ')'
}
atomic class TupleTerms {
    (TuplePair (HIDE ^COMMA ~ TuplePair)* (HIDE ^COMMA)?)?
}
class TuplePair {
    (TupleKey Colon)? MainExpression
}
union TupleKey {
    | Identifier
    | TextRaw
}
// === range === -------------------------------------------------------------------------------------------------------
atomic class RangeCall {
    ^WhiteSpace? OP_AND_THEN? ^WhiteSpace? RangeLiteral
}
atomic class RangeLiteral {
    | '[' ~ (SubscriptAxis (HIDE ^COMMA ~ SubscriptAxis)* ~ ^COMMA?)? ~ ']'
    | '⁅' ~ (SubscriptAxis (HIDE ^COMMA ~ SubscriptAxis)* ~ ^COMMA?)? ~ '⁆'
}
union SubscriptAxis {
    | SubscriptRange
    | SubscriptOnly
}
class SubscriptOnly {
    index:MainExpression
}
atomic class SubscriptRange ^ {
    (head:MainExpression HIDE)? (
        | RangeOmit (HIDE step:MainExpression)?
        | COLON (HIDE tail:MainExpression (HIDE COLON (HIDE step:MainExpression)?)?)?
    )
}
atomic inline class RangeOmit {
    PROPORTION | COLON ~ COLON
}
// === generic define === ----------------------------------------------------------------------------------------------
class GenericDefine {
    | PROPORTION? '<' GenericParameter '>'
    | '⟨' GenericParameter '⟩'
}
atomic class GenericParameter {
    (GenericParameterPair (HIDE ^COMMA ~ GenericParameterPair)* (HIDE ^COMMA)?)?
}
class GenericParameterPair {
    Identifier (Colon TypeExpression)? ('=' TypeExpression)?
}
// === generic call === ------------------------------------------------------------------------------------------------
class GenericCall {
    OP_AND_THEN? (
        | PROPORTION '<' GenericTerms '>'
        | '⟨' GenericTerms '⟩'
    )
    (PROPORTION Namepath)?
}
class GenericHide {
    | PROPORTION? '<' GenericTerms '>'
    | '⟨' GenericTerms '⟩'
}
atomic class GenericTerms {
    (GenericPair (HIDE ^COMMA ~ GenericPair)* (HIDE ^COMMA)?)?
}
class GenericPair {
    (Identifier Colon)? TypeExpression
}
// === annotation === --------------------------------------------------------------------------------------------------
class AnnotationHead {
    AnnotationTerm* ModifierCall*
}
class AnnotationMix {
    AnnotationTermMix* ModifierAhead*
}
union AnnotationTerm {
    | AttributeCall
}
union AnnotationTermMix {
    | AttributeCall
    | ProceduralCall
}
atomic class AttributeCall {
    // #call(...) { domain } receiver
    '#' Namepath ~ TupleLiteral? ~ ClassBlock?
}
atomic class ProceduralCall {
    // @call(...) { domain }
    '@' Namepath ~ TupleLiteral? ~ ClassBlock?
}
// === text === ------------------------------------------------------------------------------------------------------
atomic class TextLiteral {
    Identifier? TextRaw
}
atomic class TextRaw {
    | '""""' TEXT_CONTENT5 '""""'
    | "''''" TEXT_CONTENT6 "''''"
    | '"""' TEXT_CONTENT3 '"""'
    | "'''" TEXT_CONTENT4 "'''"
    | '"' TEXT_CONTENT1 '"'
    | "'" TEXT_CONTENT2 "'"
}
text atomic class TEXT_CONTENT1 { [^"]* }
text atomic class TEXT_CONTENT2 { [^']* }
text atomic class TEXT_CONTENT3 { (!'"""' ANY)+ }
text atomic class TEXT_CONTENT4 { (!"'''" ANY)+ }
text atomic class TEXT_CONTENT5 { (!'""""' ANY)+ }
text atomic class TEXT_CONTENT6 { (!"''''" ANY)+ }
// === modifier === --------------------------------------------------------------------------------------------------
atomic class ModifierCall ^ {
    !KEYWORDS_STOP ^Identifier
}
atomic class ModifierAhead ^ {
    !IDENTIFIER_STOP ^Identifier
}
class KEYWORDS_STOP {
    / template | generic
    | class | structure
    | enumerate | flags | union
    | function | micro | macro
    | trait | interface
    /
}
class IDENTIFIER_STOP {
    Identifier [\[(){}<>⟨:∷,;]
}
// === identifier === --------------------------------------------------------------------------------------------------
atomic class Slot {
    OP_SLOT SlotItem?
}
union SlotItem {
    | Integer
    | Identifier
}
atomic class NamepathFree  {
    Identifier (HIDE ^PROPORTION2 ~ Identifier)*
}
atomic class Namepath {
    Identifier (HIDE ^PROPORTION ~ Identifier)*
}
atomic union Identifier {
    | IdentifierBare
    | IdentifierRaw
}
text class IdentifierBare {
    /[_\p{XID_start}]\p{XID_continue}*/
}
atomic class IdentifierRaw {
    '`' IdentifierRawText '`'
}
text class IdentifierRawText {
    [^`]+
}
text class Special {
    /[∅∞]|true|false|[?]{3}/
}
// === number === ------------------------------------------------------------------------------------------------------
union Number {
    | DecimalX
    | Decimal
}
union Sign {
    | '+' #Positive
    | '-' #Netative
}
text class Integer {
    /[0-9](_*[0-9])*/
}
text class DigitsX {
    /[0-9a-zA-Z](_*[0-9a-zA-Z])*/
}
atomic class Decimal ^ {
    (
        | lhs:Integer (dot:DOT (rhs:Integer)?)?
        | dot:DOT rhs:Integer
    )
    (/[⁑]|[*]{2}/ (sign:Sign)? shift:Integer)?
    (/[_]*/ unit:Identifier)?
}
atomic class DecimalX ^ {
    base:Integer /[⁂]|[*]{3}/
    (
        | lhs:DigitsX (dot:DOT (rhs:DigitsX)?)?
        | dot:DOT rhs:DigitsX
    )
    (/[⁑]|[*]{2}/ (
        | (sign:Sign)? shift:Integer (/[_]*/ unit:Identifier)?
        | unit:Identifier
    ))?
}
// === keywords === ----------------------------------------------------------------------------------------------------
@railway(false)
token {
    PROPORTION: /∷|::/
    COLON: [:：]
    ARROW1: /[:：⟶]|->/
    COMMA: [,，]
    DOT:   [.．]
    OFFSET_L: '⁅'
    OFFSET_R: '⁆'
    OP_SLOT: /[$]{1,3}/
}
class PROPORTION2 -> PROPORTION {
    /[.．∷]|::/
}
@railway(false)
@style(keyword)
token {
    OP_IMPORT_ALL: '*'
    OP_AND_THEN: '?'
    OP_BIND: /≔|:=/
}
@railway(false)
@style(keyword)
token {
    KW_NAMESPACE: /namespace/
    KW_IMPORT: /using/
    // === class === ---------------------------------------------------------------------------------------------------
    KW_TEMPLATE: /template|generic/
    KW_WHERE: /where/
    KW_TRAIT: /trait|interface/
    KW_IMPLEMENTS: /implements?/
    KW_EXTENDS: /extends?/
    KW_INHERITS: /inherits?/
    // === looping === -------------------------------------------------------------------------------------------------
    KW_FOR: /for/
    KW_RETURN: /return/
    KW_BREAK: /break/
    KW_CONTINUE: /continue/
    // === constructor === ---------------------------------------------------------------------------------------------
    KW_NEW: /new/
    KW_OBJECT: /object/
    // === if/switch/catch/match === -----------------------------------------------------------------------------------
    KW_IF: /if/
    KW_SWITCH: /switch/
    KW_TRY: /try/
    KW_TYPE: /type/
    KW_CASE: /case/
    KW_WHEN: /when/
    KW_ELSE: /else/
    // === operators === -----------------------------------------------------------------------------------------------
    KW_NOT: 'not'
    KW_IN: 'in'
    KW_IS: 'is'
    KW_AS: 'as'
}
// === ignores === -----------------------------------------------------------------------------------------------------
@railway(false)
class WhiteSpace {
    /[^\\S\r\n]+/
}
@railway(false)
hide class SkipSpace {
    /\p{White_Space}+/
}
@style(comment)
hide class Comment {
    | '//' /[^\n\r]*/
    | '/*' '*/'
}
