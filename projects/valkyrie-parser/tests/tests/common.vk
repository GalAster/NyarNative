namespace test;
let a = 1⁏
let mut ma = 1⁏

function test(
    -- 1
    #[nice(#boat args: what)]
    -- 2
    placeholder mut a: A = 0,
    -- 3
    `b`: `B` = null
) -> ReturnType {
    if err != nil {
        return a
    }
}


extends std::Class {
    functions() {
        for  i, j, k,    in
        {

        }

    }
}



vow {
    ensure positive {
        self > 0
    }
}
refine class Positive(Integer) {
    constructor() {

    }
    constructor() {

    }
    `+`() {}
}

violate {
    y._private_field
}



--- 能被 @derive 的 trait
@derive(Copy, Clone, Debug, PartialEq, Eq, Hash)
@(Copy, Clone , Debug, PartialEq, Eq, Hash)
derived macro A {

}
template F {
    where {
        F: AnyType -> AnyType
    }
}
trait Functor⟨F⟩ {
    domain {

    }

    map<A, B>(self: F<A>, f: (a: A) -> B) -> F<B>
}

--- 隐式宏, 此类宏不需要
implicit macro print {

}

print("a")

a[T]
a⁅T⁆

@document.include("a/b")
--- a
--- a
@derive(Copy, Clone, Debug, PartialEq, Eq, Hash)
@(Copy, Clone , Debug, PartialEq, Eq, Hash)
class A⟬T <: Trait⟭ {
##where {
T <: Trait
}
##ensure {
self > 0
}

a: T
}

extends<T> A<T> {

}
vow {
     require {
         self > 0
     }
    ensure {
        self != infinity
     }
}
function a() {
    @assert -- 断言
    @assume -- 假设
    @refute -- 否定
}


generic T, U {
     forall {f32, f64} -- 前置

     require {

     }
    ensure -- 后置
    where -- 约束
}
class A {

}
