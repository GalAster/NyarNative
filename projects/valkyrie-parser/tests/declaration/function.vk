micro fun1() {

}

macro fun2(): R {

}


function fun3(a, k: T, p: U = 1) -> R {
    print("Hello, world!")
}


micro fun4<G, R>(g: G) -> R {
    1 + 1
    a in b
    print("Hello, world!")
}


macro outer<L>(lhs: L) -> String {
    // let mut count = 0
    lambda<R>(rhs: R) {
        while count < 10 {
            count += 1
            print("{lhs} {rhs}")
        }
    }
    "{count}"
}

public static final micro main(mut args: List<String>) -> int {
    outer("Hello")("world")
    return 0
}

function name() {}


function package::module::`function`
(
    // This parameter cannot be called by name
    position_only,
    <,
    // The parameter's name and value is optional
    free: int = 1,
    >,
    // This parameter must be called by name
    name_only,
    // If this parameter is not passed in,
    // the variable named `name` in the environment will be automatically captured.
    // **Note that this parameter does not participate in position matching**
    context name,
    // Redundant nameless functions will be captured as `list_catch`
    // *Otherwise, passing in extra parameters is a compilation error*
    ..list_catch,
    // Redundant named functions will be caught as `dict_catch`
    // *Otherwise, passing in extra parameters is a compilation error*
    ...dict_catch
)
{
    markdown"*italic*"
}

micro return_self(effect: int) -> Equirecursive {

}

macro progress⟨R, P⟩(): R / P {

}




inline function package::path::range(min: int, max: int, step: int): Range {
    new lazy std::iterator::Range⟨int⟩() {
        from: min,
        till: max,
        step: step,
        _current: min,
    }
}

micro name(a, k: T, p: U = 1) -> R {
    print("Hello, world!")
}


#derive(Default, Debug, Serde)
class TClass {
    fields,
}

extends TClass {
    functions
}


#[derive]
function name(args) {
    block
}


public static void fun main function print⟨P⟩(w: Write, .., ...) {
    #another
    lambda (args, .., ...): T {
        w.write(this)
    }
    .call()
}


#require(safe)
public static void fun main function main(args: List⟨String⟩, a) {
    a ⇴ b ⊕ c ⟴ d ⁒ 2 ÷ 3
}




