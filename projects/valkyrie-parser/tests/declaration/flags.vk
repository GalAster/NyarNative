enumerate Empty {}
flags Empty {}

enumerate OneEnum {
    A
}
flags OneFlag {
    A
}
flags Empty {}

flags OneFlag {
    A,

    get name() {

    }
}

flags TestFlags2(u8): A + B {
    A = 12 + 1,
    Bb = 12 + 2,
    Ccc = 3,
}

flags ManyEnums {
    A = 1,
    B = 2 ^ 5, ,
    C = Base.A && Base.B,
    D = TestFlags2[Self::A] || TestFlags2[Self::B],
}

flags ManyFlags {
    A = 1,
    B = 2 ^ 2,
    C = Base.A && Base.B,
    D = ManyEnums[Self::A] || ManyEnums[Self::B],
}



enumerate ManyEnums {
    A = 1;
    B = 2 >> 0,
    C = Base.A & Base.B,
    D = flip[Self::A] | flip[Self::B];
}
flags ManyFlags {
    A = 1;
    B = 2 >> 0,
    C = Base.A & Base.B,
    D = flip[Self::A] | flip[Self::B];
}

flags Bitflags: Debug + Copy + !Default {
    A = b'01'
    B = o'01'
    C = x'01'
    D = 8
}

public flags Flags {
    A = 1 << 0;
    B = 1 << 1;
    C = 1 << 2;
    bitflag = A || B || C;
    `class` = 1 >> 8;
}

test function test() {
    let e1 = Flags::A || Flags::C;
    let e2 = Flags::B || Flags::C;
    // union
    assert {
        e1 || e2 == Flags::ABC
    }
    // intersection
    assert {
        e1 && e2 == Flags::ABC
    }
    // set difference
    assert((e1 - e2), Flags::A);
    // set complement
    assert(!e2, Flags::A);
    // set all bits to 1
    e1.all();
    // set all bits to 0
    e1.none();
}

extends Bitflags {
    get_bits(self) {

    }
    as_bools(self) {

    }
}

// always public
#infix('|')
oppo function logic_or(self, rhs: Self) -> Self {
    Self::from(self.bits || rhs.bits)
}

